 * Copyright (c) 2011-2012, fortiss GmbH.
 * Licensed under the Apache License, Version 2.0.
 *
 * Use, modification and distribution are subject to the terms specified
 * in the accompanying license file LICENSE.txt located at the root directory
 * of this software distribution. A copy is available at
 * http://chromosome.fortiss.org/.
 *
 * This file is part of CHROMOSOME.
 *
 * $Id$
 */

/**
 * \file
 *         TDMA execution manager.
 *
 * \author
 *         Gang Chen <gachen@fortiss.org>
 */

/*
    tdma execution manager for chromsome 
    author: Gang Chen @ fortiss
    */

    #include "system.h"
    #include "altera_avalon_timer_regs.h"
    #include "sys/alt_irq.h"
    #include "FreeRTOS.h"
    #include "task.h"
    #include "semphr.h"
    #include "exe_tdma.h"
    #include "portmacro.h"
    #include <stdio.h>

    //hardware dependence code for TDMA shedule policy
    static volatile unsigned char xme_index_task=0;
    static void TDMA_CLK_Int_Handler(void *context,alt_u32 id);
    xSemaphoreHandle TimerBinarySemaphore_t=NULL;
    
    void init_tdma_timer(unsigned int xme_slot_len)
    {
        if ( -EINVAL == alt_irq_register( TDMA_CLK_IRQ, 0x0, TDMA_CLK_Int_Handler ) )
        { 
        /* Failed to install the Interrupt Handler. */
        asm( "break" );
        }
        else
        {
        /* Configure SysTick to interrupt at the requested rate. */
        IOWR_ALTERA_AVALON_TIMER_CONTROL( TDMA_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
        IOWR_ALTERA_AVALON_TIMER_PERIODL( TDMA_CLK_BASE, (((unsigned long)xme_slot_len)*configCPU_TDMA_CLOCK_US_devided ) & 0xFFFF );
        IOWR_ALTERA_AVALON_TIMER_PERIODH( TDMA_CLK_BASE, (((unsigned long)xme_slot_len)*configCPU_TDMA_CLOCK_US_devided ) >> 16 );
        IOWR_ALTERA_AVALON_TIMER_CONTROL( TDMA_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );   
        } 

        /* Clear any already pending interrupts generated by the Timer. */
        IOWR_ALTERA_AVALON_TIMER_STATUS( TDMA_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
    }
    //use timer ISR to control the state of the task
    //According to the definition of TDMA, the period of timer is danymic, which equals to the assigned slot of every task
    //so when the ISR is comming at end point of each slot.
    //Making the depth of next task increase and suspend current task , resume the next resum,reset timer
     static void TDMA_CLK_Int_Handler(void *context,alt_u32 id)
    {
        static portBASE_TYPE xISR_Taskwoken;
        xISR_Taskwoken=pdFALSE;
        xSemaphoreGiveFromISR(TimerBinarySemaphore_t,&xISR_Taskwoken);
        portEND_SWITCHING_ISR(xISR_Taskwoken);//context switch
        IOWR_ALTERA_AVALON_TIMER_STATUS( TDMA_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
        //init_tdma_timer(task_Desc[xme_index_task].slot_len);
     }
    void set_TDMA_CLK_Period(unsigned int xme_slot_len)
    {
        IOWR_ALTERA_AVALON_TIMER_CONTROL( TDMA_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
        IOWR_ALTERA_AVALON_TIMER_PERIODL( TDMA_CLK_BASE, (((unsigned long)xme_slot_len)*configCPU_TDMA_CLOCK_US_devided ) & 0xFFFF );
        IOWR_ALTERA_AVALON_TIMER_PERIODH( TDMA_CLK_BASE, (((unsigned long)xme_slot_len)*configCPU_TDMA_CLOCK_US_devided ) >> 16 );
        IOWR_ALTERA_AVALON_TIMER_CONTROL( TDMA_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
        IOWR_ALTERA_AVALON_TIMER_STATUS( TDMA_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
    }
    static void ISR_Task_Handle(void *para)
    {
        static unsigned char led=0x40;
        unsigned char index=0;
        for(;;)
        {
            xSemaphoreTake(TimerBinarySemaphore_t,portMAX_DELAY);
            led=IORD(LED_PIO_BASE,0); 
            led=(led&(~0x40))+((~(led&0x40))&0x40);
            IOWR(LED_PIO_BASE,0,led);
            if(xme_index_task==(xme_task_num-1))
            {
                xme_index_task=0;
            }
            else
            {
                xme_index_task++;
            }
            task_Desc[xme_index_task].task_depth++;
            if(xme_index_task)
                index=xme_index_task-1;
            else
                index=xme_task_num-1;
            vTaskSuspend(task_Desc[index].taskRTOSHandle);//can not be used here
            xTaskResumeFromISR(task_Desc[xme_index_task].taskRTOSHandle);//
            printf("start to run %d\n",xme_index_task);
            set_TDMA_CLK_Period(task_Desc[xme_index_task].slot_len);
        }
    }
    //
    void exe_sched_init()
    {
        unsigned char i;
        portBASE_TYPE res;
        for(i=0;i<xme_task_num;i++)
        {
            vTaskSuspend(task_Desc[i].taskRTOSHandle);
            task_Desc[i].task_depth=0;
        }
        xme_index_task=0;
        task_Desc[xme_index_task].task_depth++;
        vTaskResume(task_Desc[xme_index_task].taskRTOSHandle);
        vSemaphoreCreateBinary(TimerBinarySemaphore_t);
        if(TimerBinarySemaphore_t!=NULL)
        {
            res=xTaskCreate(
                                ISR_Task_Handle,
                                ( signed char * ) "Task",
                                configMINIMAL_STACK_SIZE,
                                NULL,
                                255,
                                NULL
                                );
            if(res != pdPASS)
            {
                printf("erro,fail to create task\n");
                for(;;);
            }
            else
            {
                printf("successful to create semaphorebinary signal\n");
                printf("successful to create tdma context switch task\n");
                init_tdma_timer(task_Desc[xme_index_task].slot_len);
            //to do call vtaskStartScheduler() in freeRTOS
            }
        }
        else
        {
            printf("fail to create semaphorebinary signal\n");
            for(;;);
        } 
    }
    //before implement the callback function of each task
    //should check its running depth
    void exe_sched_taskWrapper(void* param)
    {
        static unsigned char led=0x80;
        unsigned char local_depth;
        exe_task_descriptor_t* task_Desc_local=(exe_task_descriptor_t*) param;
        //printf("run\n");
        while(1)
        {
            taskDISABLE_INTERRUPTS();
            local_depth=task_Desc_local->task_depth;
            taskENABLE_INTERRUPTS();
            if(local_depth>0)
            {
                task_Desc_local->callback(task_Desc_local->userData);
                taskDISABLE_INTERRUPTS();
                (task_Desc_local->task_depth)--;
                taskENABLE_INTERRUPTS();
                //printf("run2\n");
            }
            else
            {
                vTaskSuspend(task_Desc_local->taskRTOSHandle);//
                led=IORD(LED_PIO_BASE,0); ; 
                led=(led&(~0x80))+((~(led&0x80))&0x80);
                IOWR(LED_PIO_BASE,0,led);
                //printf("task %d\n",task_Desc->priority);
            }
        }
    }
    
  
    







