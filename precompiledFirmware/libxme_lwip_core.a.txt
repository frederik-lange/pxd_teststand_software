In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libxme_lwip_core.a:

def.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  22424 Jul 30 19:07 2021 def.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000a8  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000dc  2**0
                  ALLOC
  3 .debug_abbrev 00000076  00000000  00000000  000000dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000111  00000000  00000000  00000152  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000001bb  00000000  00000000  00000263  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00004823  00000000  00000000  0000041e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000000e0  00000000  00000000  00004c41  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000004e  00000000  00000000  00004d21  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000026  00000000  00000000  00004d6f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00004d95  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000000ea  00000000  00000000  00004db5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00004e9f  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00004eca  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000088  00000000  00000000  00004efc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 def.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000030 lwip_htons
00000030 g     F .text	0000001e lwip_ntohs
00000050 g     F .text	0000003c lwip_htonl
0000008c g     F .text	0000001a lwip_ntohl



Disassembly of section .text:

00000000 <lwip_htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
lwip_htons(u16_t n)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	80fb      	strh	r3, [r7, #6]
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
   a:	88fb      	ldrh	r3, [r7, #6]
   c:	ea4f 2303 	mov.w	r3, r3, lsl #8
  10:	b29a      	uxth	r2, r3
  12:	88fb      	ldrh	r3, [r7, #6]
  14:	ea4f 2313 	mov.w	r3, r3, lsr #8
  18:	b29b      	uxth	r3, r3
  1a:	b29b      	uxth	r3, r3
  1c:	ea42 0303 	orr.w	r3, r2, r3
  20:	b29b      	uxth	r3, r3
  22:	b29b      	uxth	r3, r3
}
  24:	4618      	mov	r0, r3
  26:	f107 070c 	add.w	r7, r7, #12
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr

00000030 <lwip_ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
  30:	b580      	push	{r7, lr}
  32:	b082      	sub	sp, #8
  34:	af00      	add	r7, sp, #0
  36:	4603      	mov	r3, r0
  38:	80fb      	strh	r3, [r7, #6]
  return lwip_htons(n);
  3a:	88fb      	ldrh	r3, [r7, #6]
  3c:	4618      	mov	r0, r3
  3e:	f7ff fffe 	bl	0 <lwip_htons>
			3e: R_ARM_THM_CALL	lwip_htons
  42:	4603      	mov	r3, r0
}
  44:	4618      	mov	r0, r3
  46:	f107 0708 	add.w	r7, r7, #8
  4a:	46bd      	mov	sp, r7
  4c:	bd80      	pop	{r7, pc}
  4e:	bf00      	nop

00000050 <lwip_htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  50:	b480      	push	{r7}
  52:	b083      	sub	sp, #12
  54:	af00      	add	r7, sp, #0
  56:	6078      	str	r0, [r7, #4]
  return ((n & 0xff) << 24) |
  58:	687b      	ldr	r3, [r7, #4]
  5a:	ea4f 6203 	mov.w	r2, r3, lsl #24
    ((n & 0xff00) << 8) |
  5e:	687b      	ldr	r3, [r7, #4]
  60:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  64:	ea4f 2303 	mov.w	r3, r3, lsl #8
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  68:	431a      	orrs	r2, r3
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  6a:	687b      	ldr	r3, [r7, #4]
  6c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  70:	ea4f 2313 	mov.w	r3, r3, lsr #8
 */
u32_t
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
  74:	431a      	orrs	r2, r3
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  76:	687b      	ldr	r3, [r7, #4]
  78:	ea4f 6313 	mov.w	r3, r3, lsr #24
 * @return n in network byte order
 */
u32_t
lwip_htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  7c:	ea42 0303 	orr.w	r3, r2, r3
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80:	4618      	mov	r0, r3
  82:	f107 070c 	add.w	r7, r7, #12
  86:	46bd      	mov	sp, r7
  88:	bc80      	pop	{r7}
  8a:	4770      	bx	lr

0000008c <lwip_ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
lwip_ntohl(u32_t n)
{
  8c:	b580      	push	{r7, lr}
  8e:	b082      	sub	sp, #8
  90:	af00      	add	r7, sp, #0
  92:	6078      	str	r0, [r7, #4]
  return lwip_htonl(n);
  94:	6878      	ldr	r0, [r7, #4]
  96:	f7ff fffe 	bl	50 <lwip_htonl>
			96: R_ARM_THM_CALL	lwip_htonl
  9a:	4603      	mov	r3, r0
}
  9c:	4618      	mov	r0, r3
  9e:	f107 0708 	add.w	r7, r7, #8
  a2:	46bd      	mov	sp, r7
  a4:	bd80      	pop	{r7, pc}
  a6:	bf00      	nop

dhcp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 376192 Jul 30 19:07 2021 dhcp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001bd0  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  00000000  00000000  00001c04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  00001c08  2**2
                  ALLOC
  3 .debug_abbrev 00000200  00000000  00000000  00001c08  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00001343  00000000  00000000  00001e08  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000f38  00000000  00000000  0000314b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0005410b  00000000  00000000  00004083  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000774  00000000  00000000  0005818e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000125  00000000  00000000  00058902  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000001a4  00000000  00000000  00058a27  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00058bcb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000008b8  00000000  00000000  00058beb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  000594a3  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  000594ce  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000438  00000000  00000000  00059500  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 dhcp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 xme_core_config
00000000 l     F .text	00000048 dhcp_handle_nak
000010ec l     F .text	00000036 dhcp_set_state
000009d0 l     F .text	0000012c dhcp_discover
00000048 l     F .text	00000070 dhcp_check
000000b8 l     F .text	00000048 dhcp_handle_offer
00000100 l     F .text	00000164 dhcp_select
000018a0 l     F .text	00000282 dhcp_create_msg
00001124 l     F .text	00000052 dhcp_option
000011ac l     F .text	00000058 dhcp_option_short
00001204 l     F .text	000000a0 dhcp_option_long
00001178 l     F .text	00000032 dhcp_option_byte
00001b5c l     F .text	00000072 dhcp_option_trailer
00001b24 l     F .text	00000038 dhcp_delete_msg
0000043c l     F .text	00000034 dhcp_t2_timeout
00000408 l     F .text	00000034 dhcp_t1_timeout
00000340 l     F .text	000000c8 dhcp_timeout
00000afc l     F .text	00000168 dhcp_bind
00000d58 l     F .text	000000f4 dhcp_rebind
00000e4c l     F .text	00000114 dhcp_reboot
00000470 l     F .text	0000010c dhcp_handle_ack
00001748 l     F .text	00000158 dhcp_recv
000008f0 l     F .text	000000e0 dhcp_decline
000012a4 l     F .text	000004a4 dhcp_parse_reply
00000000 l     O .data	00000004 xid.7009
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 xme_core_log_logCallback
00000028       O *COM*	00000004 dhcp_rx_options_val
0000000a       O *COM*	00000004 dhcp_rx_options_given
00000000         *UND*	00000000 netif_set_down
00000000         *UND*	00000000 netif_set_ipaddr
00000000         *UND*	00000000 netif_set_gw
00000000         *UND*	00000000 netif_set_netmask
00000000         *UND*	00000000 ip_addr_any
00000000         *UND*	00000000 etharp_query
00000000         *UND*	00000000 lwip_htonl
00000000         *UND*	00000000 lwip_ntohl
00000000         *UND*	00000000 pbuf_realloc
00000000         *UND*	00000000 udp_sendto_if
00000000         *UND*	00000000 ip_addr_broadcast
00000264 g     F .text	00000074 dhcp_coarse_tmr
00000000         *UND*	00000000 netif_list
000002d8 g     F .text	00000068 dhcp_fine_tmr
00000f60 g     F .text	00000134 dhcp_release
00000c64 g     F .text	000000f4 dhcp_renew
00000000         *UND*	00000000 dns_setserver
0000057c g     F .text	00000026 dhcp_set_struct
00000000         *UND*	00000000 memset
000005a4 g     F .text	0000002a dhcp_cleanup
00000000         *UND*	00000000 mem_free
000005d0 g     F .text	0000013c dhcp_start
00000000         *UND*	00000000 mem_malloc
00000000         *UND*	00000000 udp_remove
00000000         *UND*	00000000 udp_new
00000000         *UND*	00000000 udp_bind
00000000         *UND*	00000000 udp_connect
00000000         *UND*	00000000 udp_recv
00001094 g     F .text	00000058 dhcp_stop
0000070c g     F .text	0000011c dhcp_inform
00000828 g     F .text	00000086 dhcp_network_changed
000008b0 g     F .text	0000003e dhcp_arp_reply
00000000         *UND*	00000000 netif_set_up
00000000         *UND*	00000000 pbuf_copy_partial
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 pbuf_alloc



Disassembly of section .text:

00000000 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
       0:	b580      	push	{r7, lr}
       2:	b084      	sub	sp, #16
       4:	af00      	add	r7, sp, #0
       6:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
       8:	687b      	ldr	r3, [r7, #4]
       a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
       c:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
       e:	6878      	ldr	r0, [r7, #4]
      10:	f7ff fffe 	bl	0 <netif_set_down>
			10: R_ARM_THM_CALL	netif_set_down
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
      14:	6878      	ldr	r0, [r7, #4]
      16:	490b      	ldr	r1, [pc, #44]	; (44 <dhcp_handle_nak+0x44>)
      18:	f7ff fffe 	bl	0 <netif_set_ipaddr>
			18: R_ARM_THM_CALL	netif_set_ipaddr
  netif_set_gw(netif, IP_ADDR_ANY);
      1c:	6878      	ldr	r0, [r7, #4]
      1e:	4909      	ldr	r1, [pc, #36]	; (44 <dhcp_handle_nak+0x44>)
      20:	f7ff fffe 	bl	0 <netif_set_gw>
			20: R_ARM_THM_CALL	netif_set_gw
  netif_set_netmask(netif, IP_ADDR_ANY); 
      24:	6878      	ldr	r0, [r7, #4]
      26:	4907      	ldr	r1, [pc, #28]	; (44 <dhcp_handle_nak+0x44>)
      28:	f7ff fffe 	bl	0 <netif_set_netmask>
			28: R_ARM_THM_CALL	netif_set_netmask
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
      2c:	68f8      	ldr	r0, [r7, #12]
      2e:	f04f 010c 	mov.w	r1, #12
      32:	f001 f85b 	bl	10ec <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
      36:	6878      	ldr	r0, [r7, #4]
      38:	f000 fcca 	bl	9d0 <dhcp_discover>
}
      3c:	f107 0710 	add.w	r7, r7, #16
      40:	46bd      	mov	sp, r7
      42:	bd80      	pop	{r7, pc}
      44:	00000000 	.word	0x00000000
			44: R_ARM_ABS32	ip_addr_any

00000048 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
      48:	b580      	push	{r7, lr}
      4a:	b084      	sub	sp, #16
      4c:	af00      	add	r7, sp, #0
      4e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
      50:	687b      	ldr	r3, [r7, #4]
      52:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      54:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  dhcp_set_state(dhcp, DHCP_CHECKING);
      56:	68f8      	ldr	r0, [r7, #12]
      58:	f04f 0108 	mov.w	r1, #8
      5c:	f001 f846 	bl	10ec <dhcp_set_state>
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
      60:	68fb      	ldr	r3, [r7, #12]
      62:	f103 0324 	add.w	r3, r3, #36	; 0x24
      66:	6878      	ldr	r0, [r7, #4]
      68:	4619      	mov	r1, r3
      6a:	f04f 0200 	mov.w	r2, #0
      6e:	f7ff fffe 	bl	0 <etharp_query>
			6e: R_ARM_THM_CALL	etharp_query
      72:	4603      	mov	r3, r0
      74:	72fb      	strb	r3, [r7, #11]
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
      76:	68fb      	ldr	r3, [r7, #12]
      78:	7b5b      	ldrb	r3, [r3, #13]
      7a:	f103 0301 	add.w	r3, r3, #1
      7e:	b2da      	uxtb	r2, r3
      80:	68fb      	ldr	r3, [r7, #12]
      82:	735a      	strb	r2, [r3, #13]
  msecs = 500;
      84:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
      88:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
      8a:	893b      	ldrh	r3, [r7, #8]
      8c:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
      90:	f103 0303 	add.w	r3, r3, #3
      94:	4a07      	ldr	r2, [pc, #28]	; (b4 <dhcp_check+0x6c>)
      96:	fb82 1203 	smull	r1, r2, r2, r3
      9a:	ea4f 1262 	mov.w	r2, r2, asr #5
      9e:	ea4f 73e3 	mov.w	r3, r3, asr #31
      a2:	1ad3      	subs	r3, r2, r3
      a4:	b29a      	uxth	r2, r3
      a6:	68fb      	ldr	r3, [r7, #12]
      a8:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
}
      aa:	f107 0710 	add.w	r7, r7, #16
      ae:	46bd      	mov	sp, r7
      b0:	bd80      	pop	{r7, pc}
      b2:	bf00      	nop
      b4:	10624dd3 	.word	0x10624dd3

000000b8 <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
      b8:	b580      	push	{r7, lr}
      ba:	b084      	sub	sp, #16
      bc:	af00      	add	r7, sp, #0
      be:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
      c0:	687b      	ldr	r3, [r7, #4]
      c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      c4:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* obtain the server address */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
      c6:	4b0c      	ldr	r3, [pc, #48]	; (f8 <dhcp_handle_offer+0x40>)
      c8:	789b      	ldrb	r3, [r3, #2]
      ca:	2b00      	cmp	r3, #0
      cc:	d00f      	beq.n	ee <dhcp_handle_offer+0x36>
    ip4_addr_set_u32(&dhcp->server_ip_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
      ce:	4b0b      	ldr	r3, [pc, #44]	; (fc <dhcp_handle_offer+0x44>)
      d0:	689b      	ldr	r3, [r3, #8]
      d2:	4618      	mov	r0, r3
      d4:	f7ff fffe 	bl	0 <lwip_htonl>
			d4: R_ARM_THM_CALL	lwip_htonl
      d8:	4602      	mov	r2, r0
      da:	68fb      	ldr	r3, [r7, #12]
      dc:	621a      	str	r2, [r3, #32]
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->server_ip_addr)));
    /* remember offered address */
    ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
      de:	68fb      	ldr	r3, [r7, #12]
      e0:	689b      	ldr	r3, [r3, #8]
      e2:	691a      	ldr	r2, [r3, #16]
      e4:	68fb      	ldr	r3, [r7, #12]
      e6:	625a      	str	r2, [r3, #36]	; 0x24
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
      ip4_addr_get_u32(&dhcp->offered_ip_addr)));

    dhcp_select(netif);
      e8:	6878      	ldr	r0, [r7, #4]
      ea:	f000 f809 	bl	100 <dhcp_select>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void*)netif));
  }
}
      ee:	f107 0710 	add.w	r7, r7, #16
      f2:	46bd      	mov	sp, r7
      f4:	bd80      	pop	{r7, pc}
      f6:	bf00      	nop
	...
			f8: R_ARM_ABS32	dhcp_rx_options_given
			fc: R_ARM_ABS32	dhcp_rx_options_val

00000100 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
     100:	b580      	push	{r7, lr}
     102:	b086      	sub	sp, #24
     104:	af02      	add	r7, sp, #8
     106:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     108:	687b      	ldr	r3, [r7, #4]
     10a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     10c:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  dhcp_set_state(dhcp, DHCP_REQUESTING);
     10e:	68f8      	ldr	r0, [r7, #12]
     110:	f04f 0101 	mov.w	r1, #1
     114:	f000 ffea 	bl	10ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
     118:	6878      	ldr	r0, [r7, #4]
     11a:	68f9      	ldr	r1, [r7, #12]
     11c:	f04f 0203 	mov.w	r2, #3
     120:	f001 fbbe 	bl	18a0 <dhcp_create_msg>
     124:	4603      	mov	r3, r0
     126:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     128:	f997 300b 	ldrsb.w	r3, [r7, #11]
     12c:	2b00      	cmp	r3, #0
     12e:	d167      	bne.n	200 <dhcp_select+0x100>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
     130:	68f8      	ldr	r0, [r7, #12]
     132:	f04f 0139 	mov.w	r1, #57	; 0x39
     136:	f04f 0202 	mov.w	r2, #2
     13a:	f000 fff3 	bl	1124 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
     13e:	687b      	ldr	r3, [r7, #4]
     140:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     142:	68f8      	ldr	r0, [r7, #12]
     144:	4619      	mov	r1, r3
     146:	f001 f831 	bl	11ac <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
     14a:	68f8      	ldr	r0, [r7, #12]
     14c:	f04f 0132 	mov.w	r1, #50	; 0x32
     150:	f04f 0204 	mov.w	r2, #4
     154:	f000 ffe6 	bl	1124 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
     158:	68fb      	ldr	r3, [r7, #12]
     15a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     15c:	4618      	mov	r0, r3
     15e:	f7ff fffe 	bl	0 <lwip_ntohl>
			15e: R_ARM_THM_CALL	lwip_ntohl
     162:	4603      	mov	r3, r0
     164:	68f8      	ldr	r0, [r7, #12]
     166:	4619      	mov	r1, r3
     168:	f001 f84c 	bl	1204 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
     16c:	68f8      	ldr	r0, [r7, #12]
     16e:	f04f 0136 	mov.w	r1, #54	; 0x36
     172:	f04f 0204 	mov.w	r2, #4
     176:	f000 ffd5 	bl	1124 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->server_ip_addr)));
     17a:	68fb      	ldr	r3, [r7, #12]
     17c:	6a1b      	ldr	r3, [r3, #32]
     17e:	4618      	mov	r0, r3
     180:	f7ff fffe 	bl	0 <lwip_ntohl>
			180: R_ARM_THM_CALL	lwip_ntohl
     184:	4603      	mov	r3, r0
     186:	68f8      	ldr	r0, [r7, #12]
     188:	4619      	mov	r1, r3
     18a:	f001 f83b 	bl	1204 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
     18e:	68f8      	ldr	r0, [r7, #12]
     190:	f04f 0137 	mov.w	r1, #55	; 0x37
     194:	f04f 0204 	mov.w	r2, #4
     198:	f000 ffc4 	bl	1124 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
     19c:	68f8      	ldr	r0, [r7, #12]
     19e:	f04f 0101 	mov.w	r1, #1
     1a2:	f000 ffe9 	bl	1178 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
     1a6:	68f8      	ldr	r0, [r7, #12]
     1a8:	f04f 0103 	mov.w	r1, #3
     1ac:	f000 ffe4 	bl	1178 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
     1b0:	68f8      	ldr	r0, [r7, #12]
     1b2:	f04f 011c 	mov.w	r1, #28
     1b6:	f000 ffdf 	bl	1178 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
     1ba:	68f8      	ldr	r0, [r7, #12]
     1bc:	f04f 0106 	mov.w	r1, #6
     1c0:	f000 ffda 	bl	1178 <dhcp_option_byte>

#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
     1c4:	68f8      	ldr	r0, [r7, #12]
     1c6:	f001 fcc9 	bl	1b5c <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     1ca:	68fb      	ldr	r3, [r7, #12]
     1cc:	691a      	ldr	r2, [r3, #16]
     1ce:	68fb      	ldr	r3, [r7, #12]
     1d0:	8b1b      	ldrh	r3, [r3, #24]
     1d2:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     1d6:	b29b      	uxth	r3, r3
     1d8:	4610      	mov	r0, r2
     1da:	4619      	mov	r1, r3
     1dc:	f7ff fffe 	bl	0 <pbuf_realloc>
			1dc: R_ARM_THM_CALL	pbuf_realloc

    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
     1e0:	68fb      	ldr	r3, [r7, #12]
     1e2:	685a      	ldr	r2, [r3, #4]
     1e4:	68fb      	ldr	r3, [r7, #12]
     1e6:	691b      	ldr	r3, [r3, #16]
     1e8:	6879      	ldr	r1, [r7, #4]
     1ea:	9100      	str	r1, [sp, #0]
     1ec:	4610      	mov	r0, r2
     1ee:	4619      	mov	r1, r3
     1f0:	4a1a      	ldr	r2, [pc, #104]	; (25c <dhcp_select+0x15c>)
     1f2:	f04f 0343 	mov.w	r3, #67	; 0x43
     1f6:	f7ff fffe 	bl	0 <udp_sendto_if>
			1f6: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(dhcp);
     1fa:	68f8      	ldr	r0, [r7, #12]
     1fc:	f001 fc92 	bl	1b24 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
     200:	68fb      	ldr	r3, [r7, #12]
     202:	7b5b      	ldrb	r3, [r3, #13]
     204:	f103 0301 	add.w	r3, r3, #1
     208:	b2da      	uxtb	r2, r3
     20a:	68fb      	ldr	r3, [r7, #12]
     20c:	735a      	strb	r2, [r3, #13]
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
     20e:	68fb      	ldr	r3, [r7, #12]
     210:	7b5b      	ldrb	r3, [r3, #13]
     212:	2b05      	cmp	r3, #5
     214:	d807      	bhi.n	226 <dhcp_select+0x126>
     216:	68fb      	ldr	r3, [r7, #12]
     218:	7b5b      	ldrb	r3, [r3, #13]
     21a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     21e:	fa02 f303 	lsl.w	r3, r2, r3
     222:	b29b      	uxth	r3, r3
     224:	e001      	b.n	22a <dhcp_select+0x12a>
     226:	f64e 2360 	movw	r3, #60000	; 0xea60
     22a:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
     22c:	893b      	ldrh	r3, [r7, #8]
     22e:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
     232:	f103 0303 	add.w	r3, r3, #3
     236:	4a0a      	ldr	r2, [pc, #40]	; (260 <dhcp_select+0x160>)
     238:	fb82 1203 	smull	r1, r2, r2, r3
     23c:	ea4f 1262 	mov.w	r2, r2, asr #5
     240:	ea4f 73e3 	mov.w	r3, r3, asr #31
     244:	1ad3      	subs	r3, r2, r3
     246:	b29a      	uxth	r2, r3
     248:	68fb      	ldr	r3, [r7, #12]
     24a:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
     24c:	7afb      	ldrb	r3, [r7, #11]
     24e:	b25b      	sxtb	r3, r3
}
     250:	4618      	mov	r0, r3
     252:	f107 0710 	add.w	r7, r7, #16
     256:	46bd      	mov	sp, r7
     258:	bd80      	pop	{r7, pc}
     25a:	bf00      	nop
     25c:	00000000 	.word	0x00000000
			25c: R_ARM_ABS32	ip_addr_broadcast
     260:	10624dd3 	.word	0x10624dd3

00000264 <dhcp_coarse_tmr>:
/**
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 */
void
dhcp_coarse_tmr()
{
     264:	b580      	push	{r7, lr}
     266:	b082      	sub	sp, #8
     268:	af00      	add	r7, sp, #0
  struct netif *netif = netif_list;
     26a:	4b1a      	ldr	r3, [pc, #104]	; (2d4 <dhcp_coarse_tmr+0x70>)
     26c:	681b      	ldr	r3, [r3, #0]
     26e:	607b      	str	r3, [r7, #4]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
     270:	e029      	b.n	2c6 <dhcp_coarse_tmr+0x62>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
     272:	687b      	ldr	r3, [r7, #4]
     274:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     276:	2b00      	cmp	r3, #0
     278:	d022      	beq.n	2c0 <dhcp_coarse_tmr+0x5c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
     27a:	687b      	ldr	r3, [r7, #4]
     27c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     27e:	8bda      	ldrh	r2, [r3, #30]
     280:	2a01      	cmp	r2, #1
     282:	bf14      	ite	ne
     284:	2100      	movne	r1, #0
     286:	2101      	moveq	r1, #1
     288:	b2c9      	uxtb	r1, r1
     28a:	f102 32ff 	add.w	r2, r2, #4294967295
     28e:	b292      	uxth	r2, r2
     290:	83da      	strh	r2, [r3, #30]
     292:	2900      	cmp	r1, #0
     294:	d003      	beq.n	29e <dhcp_coarse_tmr+0x3a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
     296:	6878      	ldr	r0, [r7, #4]
     298:	f000 f8d0 	bl	43c <dhcp_t2_timeout>
     29c:	e010      	b.n	2c0 <dhcp_coarse_tmr+0x5c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
     29e:	687b      	ldr	r3, [r7, #4]
     2a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     2a2:	8b9a      	ldrh	r2, [r3, #28]
     2a4:	2a01      	cmp	r2, #1
     2a6:	bf14      	ite	ne
     2a8:	2100      	movne	r1, #0
     2aa:	2101      	moveq	r1, #1
     2ac:	b2c9      	uxtb	r1, r1
     2ae:	f102 32ff 	add.w	r2, r2, #4294967295
     2b2:	b292      	uxth	r2, r2
     2b4:	839a      	strh	r2, [r3, #28]
     2b6:	2900      	cmp	r1, #0
     2b8:	d002      	beq.n	2c0 <dhcp_coarse_tmr+0x5c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
     2ba:	6878      	ldr	r0, [r7, #4]
     2bc:	f000 f8a4 	bl	408 <dhcp_t1_timeout>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
     2c0:	687b      	ldr	r3, [r7, #4]
     2c2:	681b      	ldr	r3, [r3, #0]
     2c4:	607b      	str	r3, [r7, #4]
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
     2c6:	687b      	ldr	r3, [r7, #4]
     2c8:	2b00      	cmp	r3, #0
     2ca:	d1d2      	bne.n	272 <dhcp_coarse_tmr+0xe>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
     2cc:	f107 0708 	add.w	r7, r7, #8
     2d0:	46bd      	mov	sp, r7
     2d2:	bd80      	pop	{r7, pc}
     2d4:	00000000 	.word	0x00000000
			2d4: R_ARM_ABS32	netif_list

000002d8 <dhcp_fine_tmr>:
 * A DHCP server is expected to respond within a short period of time.
 * This timer checks whether an outstanding DHCP request is timed out.
 */
void
dhcp_fine_tmr()
{
     2d8:	b580      	push	{r7, lr}
     2da:	b082      	sub	sp, #8
     2dc:	af00      	add	r7, sp, #0
  struct netif *netif = netif_list;
     2de:	4b17      	ldr	r3, [pc, #92]	; (33c <dhcp_fine_tmr+0x64>)
     2e0:	681b      	ldr	r3, [r3, #0]
     2e2:	607b      	str	r3, [r7, #4]
  /* loop through netif's */
  while (netif != NULL) {
     2e4:	e022      	b.n	32c <dhcp_fine_tmr+0x54>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
     2e6:	687b      	ldr	r3, [r7, #4]
     2e8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     2ea:	2b00      	cmp	r3, #0
     2ec:	d01b      	beq.n	326 <dhcp_fine_tmr+0x4e>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
     2ee:	687b      	ldr	r3, [r7, #4]
     2f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     2f2:	8b5b      	ldrh	r3, [r3, #26]
     2f4:	2b01      	cmp	r3, #1
     2f6:	d907      	bls.n	308 <dhcp_fine_tmr+0x30>
        netif->dhcp->request_timeout--;
     2f8:	687b      	ldr	r3, [r7, #4]
     2fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     2fc:	8b5a      	ldrh	r2, [r3, #26]
     2fe:	f102 32ff 	add.w	r2, r2, #4294967295
     302:	b292      	uxth	r2, r2
     304:	835a      	strh	r2, [r3, #26]
     306:	e00e      	b.n	326 <dhcp_fine_tmr+0x4e>
      }
      else if (netif->dhcp->request_timeout == 1) {
     308:	687b      	ldr	r3, [r7, #4]
     30a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     30c:	8b5b      	ldrh	r3, [r3, #26]
     30e:	2b01      	cmp	r3, #1
     310:	d109      	bne.n	326 <dhcp_fine_tmr+0x4e>
        netif->dhcp->request_timeout--;
     312:	687b      	ldr	r3, [r7, #4]
     314:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     316:	8b5a      	ldrh	r2, [r3, #26]
     318:	f102 32ff 	add.w	r2, r2, #4294967295
     31c:	b292      	uxth	r2, r2
     31e:	835a      	strh	r2, [r3, #26]
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this client's request timeout triggered */
        dhcp_timeout(netif);
     320:	6878      	ldr	r0, [r7, #4]
     322:	f000 f80d 	bl	340 <dhcp_timeout>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
     326:	687b      	ldr	r3, [r7, #4]
     328:	681b      	ldr	r3, [r3, #0]
     32a:	607b      	str	r3, [r7, #4]
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
     32c:	687b      	ldr	r3, [r7, #4]
     32e:	2b00      	cmp	r3, #0
     330:	d1d9      	bne.n	2e6 <dhcp_fine_tmr+0xe>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
     332:	f107 0708 	add.w	r7, r7, #8
     336:	46bd      	mov	sp, r7
     338:	bd80      	pop	{r7, pc}
     33a:	bf00      	nop
     33c:	00000000 	.word	0x00000000
			33c: R_ARM_ABS32	netif_list

00000340 <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
     340:	b580      	push	{r7, lr}
     342:	b084      	sub	sp, #16
     344:	af00      	add	r7, sp, #0
     346:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     348:	687b      	ldr	r3, [r7, #4]
     34a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     34c:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
     34e:	68fb      	ldr	r3, [r7, #12]
     350:	7b1b      	ldrb	r3, [r3, #12]
     352:	2b0c      	cmp	r3, #12
     354:	d003      	beq.n	35e <dhcp_timeout+0x1e>
     356:	68fb      	ldr	r3, [r7, #12]
     358:	7b1b      	ldrb	r3, [r3, #12]
     35a:	2b06      	cmp	r3, #6
     35c:	d103      	bne.n	366 <dhcp_timeout+0x26>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
     35e:	6878      	ldr	r0, [r7, #4]
     360:	f000 fb36 	bl	9d0 <dhcp_discover>
     364:	e04c      	b.n	400 <dhcp_timeout+0xc0>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
     366:	68fb      	ldr	r3, [r7, #12]
     368:	7b1b      	ldrb	r3, [r3, #12]
     36a:	2b01      	cmp	r3, #1
     36c:	d10e      	bne.n	38c <dhcp_timeout+0x4c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
     36e:	68fb      	ldr	r3, [r7, #12]
     370:	7b5b      	ldrb	r3, [r3, #13]
     372:	2b05      	cmp	r3, #5
     374:	d803      	bhi.n	37e <dhcp_timeout+0x3e>
      dhcp_select(netif);
     376:	6878      	ldr	r0, [r7, #4]
     378:	f7ff fec2 	bl	100 <dhcp_select>
     37c:	e040      	b.n	400 <dhcp_timeout+0xc0>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
     37e:	6878      	ldr	r0, [r7, #4]
     380:	f7ff fffe 	bl	f60 <dhcp_release>
			380: R_ARM_THM_CALL	dhcp_release
      dhcp_discover(netif);
     384:	6878      	ldr	r0, [r7, #4]
     386:	f000 fb23 	bl	9d0 <dhcp_discover>
     38a:	e039      	b.n	400 <dhcp_timeout+0xc0>
    }
#if DHCP_DOES_ARP_CHECK
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
     38c:	68fb      	ldr	r3, [r7, #12]
     38e:	7b1b      	ldrb	r3, [r3, #12]
     390:	2b08      	cmp	r3, #8
     392:	d10b      	bne.n	3ac <dhcp_timeout+0x6c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
     394:	68fb      	ldr	r3, [r7, #12]
     396:	7b5b      	ldrb	r3, [r3, #13]
     398:	2b01      	cmp	r3, #1
     39a:	d803      	bhi.n	3a4 <dhcp_timeout+0x64>
      dhcp_check(netif);
     39c:	6878      	ldr	r0, [r7, #4]
     39e:	f7ff fe53 	bl	48 <dhcp_check>
     3a2:	e02d      	b.n	400 <dhcp_timeout+0xc0>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
     3a4:	6878      	ldr	r0, [r7, #4]
     3a6:	f000 fba9 	bl	afc <dhcp_bind>
     3aa:	e029      	b.n	400 <dhcp_timeout+0xc0>
    }
#endif /* DHCP_DOES_ARP_CHECK */
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
     3ac:	68fb      	ldr	r3, [r7, #12]
     3ae:	7b1b      	ldrb	r3, [r3, #12]
     3b0:	2b05      	cmp	r3, #5
     3b2:	d103      	bne.n	3bc <dhcp_timeout+0x7c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
     3b4:	6878      	ldr	r0, [r7, #4]
     3b6:	f7ff fffe 	bl	c64 <dhcp_renew>
			3b6: R_ARM_THM_CALL	dhcp_renew
     3ba:	e021      	b.n	400 <dhcp_timeout+0xc0>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
     3bc:	68fb      	ldr	r3, [r7, #12]
     3be:	7b1b      	ldrb	r3, [r3, #12]
     3c0:	2b04      	cmp	r3, #4
     3c2:	d10e      	bne.n	3e2 <dhcp_timeout+0xa2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
     3c4:	68fb      	ldr	r3, [r7, #12]
     3c6:	7b5b      	ldrb	r3, [r3, #13]
     3c8:	2b08      	cmp	r3, #8
     3ca:	d803      	bhi.n	3d4 <dhcp_timeout+0x94>
      dhcp_rebind(netif);
     3cc:	6878      	ldr	r0, [r7, #4]
     3ce:	f000 fcc3 	bl	d58 <dhcp_rebind>
     3d2:	e015      	b.n	400 <dhcp_timeout+0xc0>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
     3d4:	6878      	ldr	r0, [r7, #4]
     3d6:	f7ff fffe 	bl	f60 <dhcp_release>
			3d6: R_ARM_THM_CALL	dhcp_release
      dhcp_discover(netif);
     3da:	6878      	ldr	r0, [r7, #4]
     3dc:	f000 faf8 	bl	9d0 <dhcp_discover>
     3e0:	e00e      	b.n	400 <dhcp_timeout+0xc0>
    }
  } else if (dhcp->state == DHCP_REBOOTING) {
     3e2:	68fb      	ldr	r3, [r7, #12]
     3e4:	7b1b      	ldrb	r3, [r3, #12]
     3e6:	2b03      	cmp	r3, #3
     3e8:	d10a      	bne.n	400 <dhcp_timeout+0xc0>
    if (dhcp->tries < REBOOT_TRIES) {
     3ea:	68fb      	ldr	r3, [r7, #12]
     3ec:	7b5b      	ldrb	r3, [r3, #13]
     3ee:	2b01      	cmp	r3, #1
     3f0:	d803      	bhi.n	3fa <dhcp_timeout+0xba>
      dhcp_reboot(netif);
     3f2:	6878      	ldr	r0, [r7, #4]
     3f4:	f000 fd2a 	bl	e4c <dhcp_reboot>
     3f8:	e002      	b.n	400 <dhcp_timeout+0xc0>
    } else {
      dhcp_discover(netif);
     3fa:	6878      	ldr	r0, [r7, #4]
     3fc:	f000 fae8 	bl	9d0 <dhcp_discover>
    }
  }
}
     400:	f107 0710 	add.w	r7, r7, #16
     404:	46bd      	mov	sp, r7
     406:	bd80      	pop	{r7, pc}

00000408 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
     408:	b580      	push	{r7, lr}
     40a:	b084      	sub	sp, #16
     40c:	af00      	add	r7, sp, #0
     40e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     410:	687b      	ldr	r3, [r7, #4]
     412:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     414:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
     416:	68fb      	ldr	r3, [r7, #12]
     418:	7b1b      	ldrb	r3, [r3, #12]
     41a:	2b01      	cmp	r3, #1
     41c:	d007      	beq.n	42e <dhcp_t1_timeout+0x26>
     41e:	68fb      	ldr	r3, [r7, #12]
     420:	7b1b      	ldrb	r3, [r3, #12]
     422:	2b0a      	cmp	r3, #10
     424:	d003      	beq.n	42e <dhcp_t1_timeout+0x26>
      (dhcp->state == DHCP_RENEWING)) {
     426:	68fb      	ldr	r3, [r7, #12]
     428:	7b1b      	ldrb	r3, [r3, #12]
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
     42a:	2b05      	cmp	r3, #5
     42c:	d102      	bne.n	434 <dhcp_t1_timeout+0x2c>
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t1_timeout(): must renew\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_RENEWING, not DHCP_BOUND */
    dhcp_renew(netif);
     42e:	6878      	ldr	r0, [r7, #4]
     430:	f7ff fffe 	bl	c64 <dhcp_renew>
			430: R_ARM_THM_CALL	dhcp_renew
  }
}
     434:	f107 0710 	add.w	r7, r7, #16
     438:	46bd      	mov	sp, r7
     43a:	bd80      	pop	{r7, pc}

0000043c <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
     43c:	b580      	push	{r7, lr}
     43e:	b084      	sub	sp, #16
     440:	af00      	add	r7, sp, #0
     442:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     444:	687b      	ldr	r3, [r7, #4]
     446:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     448:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
     44a:	68fb      	ldr	r3, [r7, #12]
     44c:	7b1b      	ldrb	r3, [r3, #12]
     44e:	2b01      	cmp	r3, #1
     450:	d007      	beq.n	462 <dhcp_t2_timeout+0x26>
     452:	68fb      	ldr	r3, [r7, #12]
     454:	7b1b      	ldrb	r3, [r3, #12]
     456:	2b0a      	cmp	r3, #10
     458:	d003      	beq.n	462 <dhcp_t2_timeout+0x26>
      (dhcp->state == DHCP_RENEWING)) {
     45a:	68fb      	ldr	r3, [r7, #12]
     45c:	7b1b      	ldrb	r3, [r3, #12]
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) ||
     45e:	2b05      	cmp	r3, #5
     460:	d102      	bne.n	468 <dhcp_t2_timeout+0x2c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
                ("dhcp_t2_timeout(): must rebind\n"));
    /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
       DHCP_REBINDING, not DHCP_BOUND */
    dhcp_rebind(netif);
     462:	6878      	ldr	r0, [r7, #4]
     464:	f000 fc78 	bl	d58 <dhcp_rebind>
  }
}
     468:	f107 0710 	add.w	r7, r7, #16
     46c:	46bd      	mov	sp, r7
     46e:	bd80      	pop	{r7, pc}

00000470 <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
     470:	b580      	push	{r7, lr}
     472:	b086      	sub	sp, #24
     474:	af00      	add	r7, sp, #0
     476:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     478:	687b      	ldr	r3, [r7, #4]
     47a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     47c:	613b      	str	r3, [r7, #16]
#if LWIP_DNS
  u8_t n;
#endif /* LWIP_DNS */

  /* clear options we might not get from the ACK */
  ip_addr_set_zero(&dhcp->offered_sn_mask);
     47e:	693b      	ldr	r3, [r7, #16]
     480:	f04f 0200 	mov.w	r2, #0
     484:	629a      	str	r2, [r3, #40]	; 0x28
  ip_addr_set_zero(&dhcp->offered_gw_addr);
     486:	693b      	ldr	r3, [r7, #16]
     488:	f04f 0200 	mov.w	r2, #0
     48c:	62da      	str	r2, [r3, #44]	; 0x2c
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* lease time given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
     48e:	4b39      	ldr	r3, [pc, #228]	; (574 <dhcp_handle_ack+0x104>)
     490:	78db      	ldrb	r3, [r3, #3]
     492:	2b00      	cmp	r3, #0
     494:	d003      	beq.n	49e <dhcp_handle_ack+0x2e>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
     496:	4b38      	ldr	r3, [pc, #224]	; (578 <dhcp_handle_ack+0x108>)
     498:	68da      	ldr	r2, [r3, #12]
     49a:	693b      	ldr	r3, [r7, #16]
     49c:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
     49e:	4b35      	ldr	r3, [pc, #212]	; (574 <dhcp_handle_ack+0x104>)
     4a0:	791b      	ldrb	r3, [r3, #4]
     4a2:	2b00      	cmp	r3, #0
     4a4:	d004      	beq.n	4b0 <dhcp_handle_ack+0x40>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
     4a6:	4b34      	ldr	r3, [pc, #208]	; (578 <dhcp_handle_ack+0x108>)
     4a8:	691a      	ldr	r2, [r3, #16]
     4aa:	693b      	ldr	r3, [r7, #16]
     4ac:	635a      	str	r2, [r3, #52]	; 0x34
     4ae:	e005      	b.n	4bc <dhcp_handle_ack+0x4c>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
     4b0:	693b      	ldr	r3, [r7, #16]
     4b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     4b4:	ea4f 0253 	mov.w	r2, r3, lsr #1
     4b8:	693b      	ldr	r3, [r7, #16]
     4ba:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* renewal period given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
     4bc:	4b2d      	ldr	r3, [pc, #180]	; (574 <dhcp_handle_ack+0x104>)
     4be:	795b      	ldrb	r3, [r3, #5]
     4c0:	2b00      	cmp	r3, #0
     4c2:	d004      	beq.n	4ce <dhcp_handle_ack+0x5e>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
     4c4:	4b2c      	ldr	r3, [pc, #176]	; (578 <dhcp_handle_ack+0x108>)
     4c6:	695a      	ldr	r2, [r3, #20]
     4c8:	693b      	ldr	r3, [r7, #16]
     4ca:	639a      	str	r2, [r3, #56]	; 0x38
     4cc:	e003      	b.n	4d6 <dhcp_handle_ack+0x66>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
     4ce:	693b      	ldr	r3, [r7, #16]
     4d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     4d2:	693b      	ldr	r3, [r7, #16]
     4d4:	639a      	str	r2, [r3, #56]	; 0x38
  }

  /* (y)our internet address */
  ip_addr_copy(dhcp->offered_ip_addr, dhcp->msg_in->yiaddr);
     4d6:	693b      	ldr	r3, [r7, #16]
     4d8:	689b      	ldr	r3, [r3, #8]
     4da:	691a      	ldr	r2, [r3, #16]
     4dc:	693b      	ldr	r3, [r7, #16]
     4de:	625a      	str	r2, [r3, #36]	; 0x24
     boot file name copied in dhcp_parse_reply if not overloaded */
  ip_addr_copy(dhcp->offered_si_addr, dhcp->msg_in->siaddr);
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* subnet mask given? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
     4e0:	4b24      	ldr	r3, [pc, #144]	; (574 <dhcp_handle_ack+0x104>)
     4e2:	799b      	ldrb	r3, [r3, #6]
     4e4:	2b00      	cmp	r3, #0
     4e6:	d00c      	beq.n	502 <dhcp_handle_ack+0x92>
    /* remember given subnet mask */
    ip4_addr_set_u32(&dhcp->offered_sn_mask, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
     4e8:	4b23      	ldr	r3, [pc, #140]	; (578 <dhcp_handle_ack+0x108>)
     4ea:	699b      	ldr	r3, [r3, #24]
     4ec:	4618      	mov	r0, r3
     4ee:	f7ff fffe 	bl	0 <lwip_htonl>
			4ee: R_ARM_THM_CALL	lwip_htonl
     4f2:	4602      	mov	r2, r0
     4f4:	693b      	ldr	r3, [r7, #16]
     4f6:	629a      	str	r2, [r3, #40]	; 0x28
    dhcp->subnet_mask_given = 1;
     4f8:	693b      	ldr	r3, [r7, #16]
     4fa:	f04f 0201 	mov.w	r2, #1
     4fe:	739a      	strb	r2, [r3, #14]
     500:	e003      	b.n	50a <dhcp_handle_ack+0x9a>
  } else {
    dhcp->subnet_mask_given = 0;
     502:	693b      	ldr	r3, [r7, #16]
     504:	f04f 0200 	mov.w	r2, #0
     508:	739a      	strb	r2, [r3, #14]
  }

  /* gateway router */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
     50a:	4b1a      	ldr	r3, [pc, #104]	; (574 <dhcp_handle_ack+0x104>)
     50c:	79db      	ldrb	r3, [r3, #7]
     50e:	2b00      	cmp	r3, #0
     510:	d007      	beq.n	522 <dhcp_handle_ack+0xb2>
    ip4_addr_set_u32(&dhcp->offered_gw_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
     512:	4b19      	ldr	r3, [pc, #100]	; (578 <dhcp_handle_ack+0x108>)
     514:	69db      	ldr	r3, [r3, #28]
     516:	4618      	mov	r0, r3
     518:	f7ff fffe 	bl	0 <lwip_htonl>
			518: R_ARM_THM_CALL	lwip_htonl
     51c:	4602      	mov	r2, r0
     51e:	693b      	ldr	r3, [r7, #16]
     520:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  
#if LWIP_DNS
  /* DNS servers */
  n = 0;
     522:	f04f 0300 	mov.w	r3, #0
     526:	75fb      	strb	r3, [r7, #23]
  while(dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n) && (n < DNS_MAX_SERVERS)) {
     528:	e015      	b.n	556 <dhcp_handle_ack+0xe6>
    ip_addr_t dns_addr;
    ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
     52a:	7dfb      	ldrb	r3, [r7, #23]
     52c:	f103 0208 	add.w	r2, r3, #8
     530:	4b11      	ldr	r3, [pc, #68]	; (578 <dhcp_handle_ack+0x108>)
     532:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     536:	4618      	mov	r0, r3
     538:	f7ff fffe 	bl	0 <lwip_htonl>
			538: R_ARM_THM_CALL	lwip_htonl
     53c:	4603      	mov	r3, r0
     53e:	60fb      	str	r3, [r7, #12]
    dns_setserver(n, &dns_addr);
     540:	7dfa      	ldrb	r2, [r7, #23]
     542:	f107 030c 	add.w	r3, r7, #12
     546:	4610      	mov	r0, r2
     548:	4619      	mov	r1, r3
     54a:	f7ff fffe 	bl	0 <dns_setserver>
			54a: R_ARM_THM_CALL	dns_setserver
    n++;
     54e:	7dfb      	ldrb	r3, [r7, #23]
     550:	f103 0301 	add.w	r3, r3, #1
     554:	75fb      	strb	r3, [r7, #23]
  }
  
#if LWIP_DNS
  /* DNS servers */
  n = 0;
  while(dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n) && (n < DNS_MAX_SERVERS)) {
     556:	7dfb      	ldrb	r3, [r7, #23]
     558:	f103 0308 	add.w	r3, r3, #8
     55c:	4a05      	ldr	r2, [pc, #20]	; (574 <dhcp_handle_ack+0x104>)
     55e:	5cd3      	ldrb	r3, [r2, r3]
     560:	2b00      	cmp	r3, #0
     562:	d002      	beq.n	56a <dhcp_handle_ack+0xfa>
     564:	7dfb      	ldrb	r3, [r7, #23]
     566:	2b01      	cmp	r3, #1
     568:	d9df      	bls.n	52a <dhcp_handle_ack+0xba>
    ip4_addr_set_u32(&dns_addr, htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
    dns_setserver(n, &dns_addr);
    n++;
  }
#endif /* LWIP_DNS */
}
     56a:	f107 0718 	add.w	r7, r7, #24
     56e:	46bd      	mov	sp, r7
     570:	bd80      	pop	{r7, pc}
     572:	bf00      	nop
	...
			574: R_ARM_ABS32	dhcp_rx_options_given
			578: R_ARM_ABS32	dhcp_rx_options_val

0000057c <dhcp_set_struct>:
 * @param netif the netif for which to set the struct dhcp
 * @param dhcp (uninitialised) dhcp struct allocated by the application
 */
void
dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
{
     57c:	b580      	push	{r7, lr}
     57e:	b082      	sub	sp, #8
     580:	af00      	add	r7, sp, #0
     582:	6078      	str	r0, [r7, #4]
     584:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
  LWIP_ASSERT("netif already has a struct dhcp set", netif->dhcp == NULL);

  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
     586:	6838      	ldr	r0, [r7, #0]
     588:	f04f 0100 	mov.w	r1, #0
     58c:	f04f 023c 	mov.w	r2, #60	; 0x3c
     590:	f7ff fffe 	bl	0 <memset>
			590: R_ARM_THM_CALL	memset
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  netif->dhcp = dhcp;
     594:	687b      	ldr	r3, [r7, #4]
     596:	683a      	ldr	r2, [r7, #0]
     598:	629a      	str	r2, [r3, #40]	; 0x28
}
     59a:	f107 0708 	add.w	r7, r7, #8
     59e:	46bd      	mov	sp, r7
     5a0:	bd80      	pop	{r7, pc}
     5a2:	bf00      	nop

000005a4 <dhcp_cleanup>:
 *            struct dhcp since the memory is passed back to the heap.
 *
 * @param netif the netif from which to remove the struct dhcp
 */
void dhcp_cleanup(struct netif *netif)
{
     5a4:	b580      	push	{r7, lr}
     5a6:	b082      	sub	sp, #8
     5a8:	af00      	add	r7, sp, #0
     5aa:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("netif != NULL", netif != NULL);

  if (netif->dhcp != NULL) {
     5ac:	687b      	ldr	r3, [r7, #4]
     5ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5b0:	2b00      	cmp	r3, #0
     5b2:	d008      	beq.n	5c6 <dhcp_cleanup+0x22>
    mem_free(netif->dhcp);
     5b4:	687b      	ldr	r3, [r7, #4]
     5b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5b8:	4618      	mov	r0, r3
     5ba:	f7ff fffe 	bl	0 <mem_free>
			5ba: R_ARM_THM_CALL	mem_free
    netif->dhcp = NULL;
     5be:	687b      	ldr	r3, [r7, #4]
     5c0:	f04f 0200 	mov.w	r2, #0
     5c4:	629a      	str	r2, [r3, #40]	; 0x28
  }
}
     5c6:	f107 0708 	add.w	r7, r7, #8
     5ca:	46bd      	mov	sp, r7
     5cc:	bd80      	pop	{r7, pc}
     5ce:	bf00      	nop

000005d0 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
     5d0:	b580      	push	{r7, lr}
     5d2:	b084      	sub	sp, #16
     5d4:	af00      	add	r7, sp, #0
     5d6:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp;
  err_t result = ERR_OK;
     5d8:	f04f 0300 	mov.w	r3, #0
     5dc:	72fb      	strb	r3, [r7, #11]

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
     5de:	687b      	ldr	r3, [r7, #4]
     5e0:	2b00      	cmp	r3, #0
     5e2:	d102      	bne.n	5ea <dhcp_start+0x1a>
     5e4:	f04f 03f2 	mov.w	r3, #242	; 0xf2
     5e8:	e086      	b.n	6f8 <dhcp_start+0x128>
  dhcp = netif->dhcp;
     5ea:	687b      	ldr	r3, [r7, #4]
     5ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     5ee:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
     5f0:	687b      	ldr	r3, [r7, #4]
     5f2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
     5f6:	f023 0308 	bic.w	r3, r3, #8
     5fa:	b2da      	uxtb	r2, r3
     5fc:	687b      	ldr	r3, [r7, #4]
     5fe:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* check hwtype of the netif */
  if ((netif->flags & NETIF_FLAG_ETHARP) == 0) {
     602:	687b      	ldr	r3, [r7, #4]
     604:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
     608:	f003 0320 	and.w	r3, r3, #32
     60c:	2b00      	cmp	r3, #0
     60e:	d102      	bne.n	616 <dhcp_start+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): No ETHARP netif\n"));
    return ERR_ARG;
     610:	f04f 03f2 	mov.w	r3, #242	; 0xf2
     614:	e070      	b.n	6f8 <dhcp_start+0x128>
  }

  /* check MTU of the netif */
  if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
     616:	687b      	ldr	r3, [r7, #4]
     618:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
     61a:	f240 233f 	movw	r3, #575	; 0x23f
     61e:	429a      	cmp	r2, r3
     620:	d802      	bhi.n	628 <dhcp_start+0x58>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
    return ERR_MEM;
     622:	f04f 03ff 	mov.w	r3, #255	; 0xff
     626:	e067      	b.n	6f8 <dhcp_start+0x128>
  }

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
     628:	68fb      	ldr	r3, [r7, #12]
     62a:	2b00      	cmp	r3, #0
     62c:	d10f      	bne.n	64e <dhcp_start+0x7e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
     62e:	f04f 003c 	mov.w	r0, #60	; 0x3c
     632:	f7ff fffe 	bl	0 <mem_malloc>
			632: R_ARM_THM_CALL	mem_malloc
     636:	4603      	mov	r3, r0
     638:	60fb      	str	r3, [r7, #12]
    if (dhcp == NULL) {
     63a:	68fb      	ldr	r3, [r7, #12]
     63c:	2b00      	cmp	r3, #0
     63e:	d102      	bne.n	646 <dhcp_start+0x76>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
     640:	f04f 03ff 	mov.w	r3, #255	; 0xff
     644:	e058      	b.n	6f8 <dhcp_start+0x128>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
     646:	687b      	ldr	r3, [r7, #4]
     648:	68fa      	ldr	r2, [r7, #12]
     64a:	629a      	str	r2, [r3, #40]	; 0x28
     64c:	e008      	b.n	660 <dhcp_start+0x90>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
  /* already has DHCP client attached */
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
    if (dhcp->pcb != NULL) {
     64e:	68fb      	ldr	r3, [r7, #12]
     650:	685b      	ldr	r3, [r3, #4]
     652:	2b00      	cmp	r3, #0
     654:	d004      	beq.n	660 <dhcp_start+0x90>
      udp_remove(dhcp->pcb);
     656:	68fb      	ldr	r3, [r7, #12]
     658:	685b      	ldr	r3, [r3, #4]
     65a:	4618      	mov	r0, r3
     65c:	f7ff fffe 	bl	0 <udp_remove>
			65c: R_ARM_THM_CALL	udp_remove
    LWIP_ASSERT("pbuf p_out wasn't freed", dhcp->p_out == NULL);
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL );
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
     660:	68f8      	ldr	r0, [r7, #12]
     662:	f04f 0100 	mov.w	r1, #0
     666:	f04f 023c 	mov.w	r2, #60	; 0x3c
     66a:	f7ff fffe 	bl	0 <memset>
			66a: R_ARM_THM_CALL	memset
  /* dhcp_set_state(&dhcp, DHCP_OFF); */
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
     66e:	f7ff fffe 	bl	0 <udp_new>
			66e: R_ARM_THM_CALL	udp_new
     672:	4602      	mov	r2, r0
     674:	68fb      	ldr	r3, [r7, #12]
     676:	605a      	str	r2, [r3, #4]
  if (dhcp->pcb == NULL) {
     678:	68fb      	ldr	r3, [r7, #12]
     67a:	685b      	ldr	r3, [r3, #4]
     67c:	2b00      	cmp	r3, #0
     67e:	d102      	bne.n	686 <dhcp_start+0xb6>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    return ERR_MEM;
     680:	f04f 03ff 	mov.w	r3, #255	; 0xff
     684:	e038      	b.n	6f8 <dhcp_start+0x128>
  }
  ip_set_option(dhcp->pcb, SOF_BROADCAST);
     686:	68fb      	ldr	r3, [r7, #12]
     688:	685b      	ldr	r3, [r3, #4]
     68a:	68fa      	ldr	r2, [r7, #12]
     68c:	6852      	ldr	r2, [r2, #4]
     68e:	7a12      	ldrb	r2, [r2, #8]
     690:	f042 0220 	orr.w	r2, r2, #32
     694:	b2d2      	uxtb	r2, r2
     696:	721a      	strb	r2, [r3, #8]
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
     698:	68fb      	ldr	r3, [r7, #12]
     69a:	685b      	ldr	r3, [r3, #4]
     69c:	4618      	mov	r0, r3
     69e:	4919      	ldr	r1, [pc, #100]	; (704 <dhcp_start+0x134>)
     6a0:	f04f 0244 	mov.w	r2, #68	; 0x44
     6a4:	f7ff fffe 	bl	0 <udp_bind>
			6a4: R_ARM_THM_CALL	udp_bind
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
     6a8:	68fb      	ldr	r3, [r7, #12]
     6aa:	685b      	ldr	r3, [r3, #4]
     6ac:	4618      	mov	r0, r3
     6ae:	4915      	ldr	r1, [pc, #84]	; (704 <dhcp_start+0x134>)
     6b0:	f04f 0243 	mov.w	r2, #67	; 0x43
     6b4:	f7ff fffe 	bl	0 <udp_connect>
			6b4: R_ARM_THM_CALL	udp_connect
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
     6b8:	68fb      	ldr	r3, [r7, #12]
     6ba:	685b      	ldr	r3, [r3, #4]
     6bc:	4618      	mov	r0, r3
     6be:	4912      	ldr	r1, [pc, #72]	; (708 <dhcp_start+0x138>)
     6c0:	687a      	ldr	r2, [r7, #4]
     6c2:	f7ff fffe 	bl	0 <udp_recv>
			6c2: R_ARM_THM_CALL	udp_recv
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
     6c6:	6878      	ldr	r0, [r7, #4]
     6c8:	f000 f982 	bl	9d0 <dhcp_discover>
     6cc:	4603      	mov	r3, r0
     6ce:	72fb      	strb	r3, [r7, #11]
  if (result != ERR_OK) {
     6d0:	f997 300b 	ldrsb.w	r3, [r7, #11]
     6d4:	2b00      	cmp	r3, #0
     6d6:	d005      	beq.n	6e4 <dhcp_start+0x114>
    /* free resources allocated above */
    dhcp_stop(netif);
     6d8:	6878      	ldr	r0, [r7, #4]
     6da:	f7ff fffe 	bl	1094 <dhcp_stop>
			6da: R_ARM_THM_CALL	dhcp_stop
    return ERR_MEM;
     6de:	f04f 03ff 	mov.w	r3, #255	; 0xff
     6e2:	e009      	b.n	6f8 <dhcp_start+0x128>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
     6e4:	687b      	ldr	r3, [r7, #4]
     6e6:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
     6ea:	f043 0308 	orr.w	r3, r3, #8
     6ee:	b2da      	uxtb	r2, r3
     6f0:	687b      	ldr	r3, [r7, #4]
     6f2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  return result;
     6f6:	7afb      	ldrb	r3, [r7, #11]
     6f8:	b25b      	sxtb	r3, r3
}
     6fa:	4618      	mov	r0, r3
     6fc:	f107 0710 	add.w	r7, r7, #16
     700:	46bd      	mov	sp, r7
     702:	bd80      	pop	{r7, pc}
	...
			704: R_ARM_ABS32	ip_addr_any
			708: R_ARM_ABS32	dhcp_recv

0000070c <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
     70c:	b580      	push	{r7, lr}
     70e:	b096      	sub	sp, #88	; 0x58
     710:	af02      	add	r7, sp, #8
     712:	6078      	str	r0, [r7, #4]
  struct dhcp dhcp;
  err_t result = ERR_OK;
     714:	f04f 0300 	mov.w	r3, #0
     718:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  struct udp_pcb *pcb;

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
     71c:	687b      	ldr	r3, [r7, #4]
     71e:	2b00      	cmp	r3, #0
     720:	d079      	beq.n	816 <dhcp_inform+0x10a>

  memset(&dhcp, 0, sizeof(struct dhcp));
     722:	f107 030c 	add.w	r3, r7, #12
     726:	4618      	mov	r0, r3
     728:	f04f 0100 	mov.w	r1, #0
     72c:	f04f 023c 	mov.w	r2, #60	; 0x3c
     730:	f7ff fffe 	bl	0 <memset>
			730: R_ARM_THM_CALL	memset
  dhcp_set_state(&dhcp, DHCP_INFORM);
     734:	f107 030c 	add.w	r3, r7, #12
     738:	4618      	mov	r0, r3
     73a:	f04f 0108 	mov.w	r1, #8
     73e:	f000 fcd5 	bl	10ec <dhcp_set_state>

  if ((netif->dhcp != NULL) && (netif->dhcp->pcb != NULL)) {
     742:	687b      	ldr	r3, [r7, #4]
     744:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     746:	2b00      	cmp	r3, #0
     748:	d009      	beq.n	75e <dhcp_inform+0x52>
     74a:	687b      	ldr	r3, [r7, #4]
     74c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     74e:	685b      	ldr	r3, [r3, #4]
     750:	2b00      	cmp	r3, #0
     752:	d004      	beq.n	75e <dhcp_inform+0x52>
    /* re-use existing pcb */
    pcb = netif->dhcp->pcb;
     754:	687b      	ldr	r3, [r7, #4]
     756:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     758:	685b      	ldr	r3, [r3, #4]
     75a:	64fb      	str	r3, [r7, #76]	; 0x4c
     75c:	e015      	b.n	78a <dhcp_inform+0x7e>
  } else {
    pcb = udp_new();
     75e:	f7ff fffe 	bl	0 <udp_new>
			75e: R_ARM_THM_CALL	udp_new
     762:	64f8      	str	r0, [r7, #76]	; 0x4c
    if (pcb == NULL) {
     764:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     766:	2b00      	cmp	r3, #0
     768:	d054      	beq.n	814 <dhcp_inform+0x108>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
    }
    dhcp.pcb = pcb;
     76a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     76c:	613b      	str	r3, [r7, #16]
    ip_set_option(dhcp.pcb, SOF_BROADCAST);
     76e:	693b      	ldr	r3, [r7, #16]
     770:	693a      	ldr	r2, [r7, #16]
     772:	7a12      	ldrb	r2, [r2, #8]
     774:	f042 0220 	orr.w	r2, r2, #32
     778:	b2d2      	uxtb	r2, r2
     77a:	721a      	strb	r2, [r3, #8]
    udp_bind(dhcp.pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
     77c:	693b      	ldr	r3, [r7, #16]
     77e:	4618      	mov	r0, r3
     780:	4927      	ldr	r1, [pc, #156]	; (820 <dhcp_inform+0x114>)
     782:	f04f 0244 	mov.w	r2, #68	; 0x44
     786:	f7ff fffe 	bl	0 <udp_bind>
			786: R_ARM_THM_CALL	udp_bind
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  }
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, &dhcp, DHCP_INFORM);
     78a:	f107 030c 	add.w	r3, r7, #12
     78e:	6878      	ldr	r0, [r7, #4]
     790:	4619      	mov	r1, r3
     792:	f04f 0208 	mov.w	r2, #8
     796:	f001 f883 	bl	18a0 <dhcp_create_msg>
     79a:	4603      	mov	r3, r0
     79c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
  if (result == ERR_OK) {
     7a0:	f997 304b 	ldrsb.w	r3, [r7, #75]	; 0x4b
     7a4:	2b00      	cmp	r3, #0
     7a6:	d12d      	bne.n	804 <dhcp_inform+0xf8>
    dhcp_option(&dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
     7a8:	f107 030c 	add.w	r3, r7, #12
     7ac:	4618      	mov	r0, r3
     7ae:	f04f 0139 	mov.w	r1, #57	; 0x39
     7b2:	f04f 0202 	mov.w	r2, #2
     7b6:	f000 fcb5 	bl	1124 <dhcp_option>
    dhcp_option_short(&dhcp, DHCP_MAX_MSG_LEN(netif));
     7ba:	687b      	ldr	r3, [r7, #4]
     7bc:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     7be:	f107 020c 	add.w	r2, r7, #12
     7c2:	4610      	mov	r0, r2
     7c4:	4619      	mov	r1, r3
     7c6:	f000 fcf1 	bl	11ac <dhcp_option_short>

    dhcp_option_trailer(&dhcp);
     7ca:	f107 030c 	add.w	r3, r7, #12
     7ce:	4618      	mov	r0, r3
     7d0:	f001 f9c4 	bl	1b5c <dhcp_option_trailer>

    pbuf_realloc(dhcp.p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp.options_out_len);
     7d4:	69fa      	ldr	r2, [r7, #28]
     7d6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
     7d8:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     7dc:	b29b      	uxth	r3, r3
     7de:	4610      	mov	r0, r2
     7e0:	4619      	mov	r1, r3
     7e2:	f7ff fffe 	bl	0 <pbuf_realloc>
			7e2: R_ARM_THM_CALL	pbuf_realloc

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(pcb, dhcp.p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
     7e6:	69fb      	ldr	r3, [r7, #28]
     7e8:	687a      	ldr	r2, [r7, #4]
     7ea:	9200      	str	r2, [sp, #0]
     7ec:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
     7ee:	4619      	mov	r1, r3
     7f0:	4a0c      	ldr	r2, [pc, #48]	; (824 <dhcp_inform+0x118>)
     7f2:	f04f 0343 	mov.w	r3, #67	; 0x43
     7f6:	f7ff fffe 	bl	0 <udp_sendto_if>
			7f6: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(&dhcp);
     7fa:	f107 030c 	add.w	r3, r7, #12
     7fe:	4618      	mov	r0, r3
     800:	f001 f990 	bl	1b24 <dhcp_delete_msg>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp.pcb != NULL) {
     804:	693b      	ldr	r3, [r7, #16]
     806:	2b00      	cmp	r3, #0
     808:	d005      	beq.n	816 <dhcp_inform+0x10a>
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
     80a:	693b      	ldr	r3, [r7, #16]
     80c:	4618      	mov	r0, r3
     80e:	f7ff fffe 	bl	0 <udp_remove>
			80e: R_ARM_THM_CALL	udp_remove
     812:	e000      	b.n	816 <dhcp_inform+0x10a>
    pcb = netif->dhcp->pcb;
  } else {
    pcb = udp_new();
    if (pcb == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform(): could not obtain pcb"));
      return;
     814:	bf00      	nop

  if (dhcp.pcb != NULL) {
    /* otherwise, the existing pcb was used */
    udp_remove(dhcp.pcb);
  }
}
     816:	f107 0750 	add.w	r7, r7, #80	; 0x50
     81a:	46bd      	mov	sp, r7
     81c:	bd80      	pop	{r7, pc}
     81e:	bf00      	nop
	...
			820: R_ARM_ABS32	ip_addr_any
			824: R_ARM_ABS32	ip_addr_broadcast

00000828 <dhcp_network_changed>:
 * This enters the REBOOTING state to verify that the currently bound
 * address is still valid.
 */
void
dhcp_network_changed(struct netif *netif)
{
     828:	b580      	push	{r7, lr}
     82a:	b084      	sub	sp, #16
     82c:	af00      	add	r7, sp, #0
     82e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     830:	687b      	ldr	r3, [r7, #4]
     832:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     834:	60fb      	str	r3, [r7, #12]
  if (!dhcp)
     836:	68fb      	ldr	r3, [r7, #12]
     838:	2b00      	cmp	r3, #0
     83a:	d031      	beq.n	8a0 <dhcp_network_changed+0x78>
    return;
  switch (dhcp->state) {
     83c:	68fb      	ldr	r3, [r7, #12]
     83e:	7b1b      	ldrb	r3, [r3, #12]
     840:	2b0a      	cmp	r3, #10
     842:	d824      	bhi.n	88e <dhcp_network_changed+0x66>
     844:	a201      	add	r2, pc, #4	; (adr r2, 84c <dhcp_network_changed+0x24>)
     846:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     84a:	bf00      	nop
     84c:	000008a5 	.word	0x000008a5
			84c: R_ARM_ABS32	.text
     850:	0000088f 	.word	0x0000088f
			850: R_ARM_ABS32	.text
     854:	0000088f 	.word	0x0000088f
			854: R_ARM_ABS32	.text
     858:	00000879 	.word	0x00000879
			858: R_ARM_ABS32	.text
     85c:	00000879 	.word	0x00000879
			85c: R_ARM_ABS32	.text
     860:	00000879 	.word	0x00000879
			860: R_ARM_ABS32	.text
     864:	0000088f 	.word	0x0000088f
			864: R_ARM_ABS32	.text
     868:	0000088f 	.word	0x0000088f
			868: R_ARM_ABS32	.text
     86c:	0000088f 	.word	0x0000088f
			86c: R_ARM_ABS32	.text
     870:	0000088f 	.word	0x0000088f
			870: R_ARM_ABS32	.text
     874:	00000879 	.word	0x00000879
			874: R_ARM_ABS32	.text
  case DHCP_REBINDING:
  case DHCP_RENEWING:
  case DHCP_BOUND:
  case DHCP_REBOOTING:
    netif_set_down(netif);
     878:	6878      	ldr	r0, [r7, #4]
     87a:	f7ff fffe 	bl	0 <netif_set_down>
			87a: R_ARM_THM_CALL	netif_set_down
    dhcp->tries = 0;
     87e:	68fb      	ldr	r3, [r7, #12]
     880:	f04f 0200 	mov.w	r2, #0
     884:	735a      	strb	r2, [r3, #13]
    dhcp_reboot(netif);
     886:	6878      	ldr	r0, [r7, #4]
     888:	f000 fae0 	bl	e4c <dhcp_reboot>
    break;
     88c:	e00b      	b.n	8a6 <dhcp_network_changed+0x7e>
  case DHCP_OFF:
    /* stay off */
    break;
  default:
    dhcp->tries = 0;
     88e:	68fb      	ldr	r3, [r7, #12]
     890:	f04f 0200 	mov.w	r2, #0
     894:	735a      	strb	r2, [r3, #13]
    if(dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
     896:	6878      	ldr	r0, [r7, #4]
     898:	f000 f89a 	bl	9d0 <dhcp_discover>
    break;
     89c:	bf00      	nop
     89e:	e002      	b.n	8a6 <dhcp_network_changed+0x7e>
void
dhcp_network_changed(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  if (!dhcp)
    return;
     8a0:	bf00      	nop
     8a2:	e000      	b.n	8a6 <dhcp_network_changed+0x7e>
    dhcp->tries = 0;
    dhcp_reboot(netif);
    break;
  case DHCP_OFF:
    /* stay off */
    break;
     8a4:	bf00      	nop
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */
    dhcp_discover(netif);
    break;
  }
}
     8a6:	f107 0710 	add.w	r7, r7, #16
     8aa:	46bd      	mov	sp, r7
     8ac:	bd80      	pop	{r7, pc}
     8ae:	bf00      	nop

000008b0 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, ip_addr_t *addr)
{
     8b0:	b580      	push	{r7, lr}
     8b2:	b082      	sub	sp, #8
     8b4:	af00      	add	r7, sp, #0
     8b6:	6078      	str	r0, [r7, #4]
     8b8:	6039      	str	r1, [r7, #0]
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
     8ba:	687b      	ldr	r3, [r7, #4]
     8bc:	2b00      	cmp	r3, #0
     8be:	d012      	beq.n	8e6 <dhcp_arp_reply+0x36>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
     8c0:	687b      	ldr	r3, [r7, #4]
     8c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     8c4:	2b00      	cmp	r3, #0
     8c6:	d00e      	beq.n	8e6 <dhcp_arp_reply+0x36>
     8c8:	687b      	ldr	r3, [r7, #4]
     8ca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     8cc:	7b1b      	ldrb	r3, [r3, #12]
     8ce:	2b08      	cmp	r3, #8
     8d0:	d109      	bne.n	8e6 <dhcp_arp_reply+0x36>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
      ip4_addr_get_u32(addr)));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
     8d2:	683b      	ldr	r3, [r7, #0]
     8d4:	681a      	ldr	r2, [r3, #0]
     8d6:	687b      	ldr	r3, [r7, #4]
     8d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     8da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     8dc:	429a      	cmp	r2, r3
     8de:	d102      	bne.n	8e6 <dhcp_arp_reply+0x36>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
        ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
     8e0:	6878      	ldr	r0, [r7, #4]
     8e2:	f000 f805 	bl	8f0 <dhcp_decline>
    }
  }
}
     8e6:	f107 0708 	add.w	r7, r7, #8
     8ea:	46bd      	mov	sp, r7
     8ec:	bd80      	pop	{r7, pc}
     8ee:	bf00      	nop

000008f0 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
     8f0:	b580      	push	{r7, lr}
     8f2:	b086      	sub	sp, #24
     8f4:	af02      	add	r7, sp, #8
     8f6:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     8f8:	687b      	ldr	r3, [r7, #4]
     8fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     8fc:	60fb      	str	r3, [r7, #12]
  err_t result = ERR_OK;
     8fe:	f04f 0300 	mov.w	r3, #0
     902:	72fb      	strb	r3, [r7, #11]
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
     904:	68f8      	ldr	r0, [r7, #12]
     906:	f04f 010c 	mov.w	r1, #12
     90a:	f000 fbef 	bl	10ec <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DECLINE);
     90e:	6878      	ldr	r0, [r7, #4]
     910:	68f9      	ldr	r1, [r7, #12]
     912:	f04f 0204 	mov.w	r2, #4
     916:	f000 ffc3 	bl	18a0 <dhcp_create_msg>
     91a:	4603      	mov	r3, r0
     91c:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     91e:	f997 300b 	ldrsb.w	r3, [r7, #11]
     922:	2b00      	cmp	r3, #0
     924:	d12e      	bne.n	984 <dhcp_decline+0x94>
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
     926:	68f8      	ldr	r0, [r7, #12]
     928:	f04f 0132 	mov.w	r1, #50	; 0x32
     92c:	f04f 0204 	mov.w	r2, #4
     930:	f000 fbf8 	bl	1124 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
     934:	68fb      	ldr	r3, [r7, #12]
     936:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     938:	4618      	mov	r0, r3
     93a:	f7ff fffe 	bl	0 <lwip_ntohl>
			93a: R_ARM_THM_CALL	lwip_ntohl
     93e:	4603      	mov	r3, r0
     940:	68f8      	ldr	r0, [r7, #12]
     942:	4619      	mov	r1, r3
     944:	f000 fc5e 	bl	1204 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
     948:	68f8      	ldr	r0, [r7, #12]
     94a:	f001 f907 	bl	1b5c <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     94e:	68fb      	ldr	r3, [r7, #12]
     950:	691a      	ldr	r2, [r3, #16]
     952:	68fb      	ldr	r3, [r7, #12]
     954:	8b1b      	ldrh	r3, [r3, #24]
     956:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     95a:	b29b      	uxth	r3, r3
     95c:	4610      	mov	r0, r2
     95e:	4619      	mov	r1, r3
     960:	f7ff fffe 	bl	0 <pbuf_realloc>
			960: R_ARM_THM_CALL	pbuf_realloc

    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
     964:	68fb      	ldr	r3, [r7, #12]
     966:	685a      	ldr	r2, [r3, #4]
     968:	68fb      	ldr	r3, [r7, #12]
     96a:	691b      	ldr	r3, [r3, #16]
     96c:	6879      	ldr	r1, [r7, #4]
     96e:	9100      	str	r1, [sp, #0]
     970:	4610      	mov	r0, r2
     972:	4619      	mov	r1, r3
     974:	4a14      	ldr	r2, [pc, #80]	; (9c8 <dhcp_decline+0xd8>)
     976:	f04f 0343 	mov.w	r3, #67	; 0x43
     97a:	f7ff fffe 	bl	0 <udp_sendto_if>
			97a: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(dhcp);
     97e:	68f8      	ldr	r0, [r7, #12]
     980:	f001 f8d0 	bl	1b24 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
     984:	68fb      	ldr	r3, [r7, #12]
     986:	7b5b      	ldrb	r3, [r3, #13]
     988:	f103 0301 	add.w	r3, r3, #1
     98c:	b2da      	uxtb	r2, r3
     98e:	68fb      	ldr	r3, [r7, #12]
     990:	735a      	strb	r2, [r3, #13]
  msecs = 10*1000;
     992:	f242 7310 	movw	r3, #10000	; 0x2710
     996:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
     998:	893b      	ldrh	r3, [r7, #8]
     99a:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
     99e:	f103 0303 	add.w	r3, r3, #3
     9a2:	4a0a      	ldr	r2, [pc, #40]	; (9cc <dhcp_decline+0xdc>)
     9a4:	fb82 1203 	smull	r1, r2, r2, r3
     9a8:	ea4f 1262 	mov.w	r2, r2, asr #5
     9ac:	ea4f 73e3 	mov.w	r3, r3, asr #31
     9b0:	1ad3      	subs	r3, r2, r3
     9b2:	b29a      	uxth	r2, r3
     9b4:	68fb      	ldr	r3, [r7, #12]
     9b6:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
     9b8:	7afb      	ldrb	r3, [r7, #11]
     9ba:	b25b      	sxtb	r3, r3
}
     9bc:	4618      	mov	r0, r3
     9be:	f107 0710 	add.w	r7, r7, #16
     9c2:	46bd      	mov	sp, r7
     9c4:	bd80      	pop	{r7, pc}
     9c6:	bf00      	nop
     9c8:	00000000 	.word	0x00000000
			9c8: R_ARM_ABS32	ip_addr_broadcast
     9cc:	10624dd3 	.word	0x10624dd3

000009d0 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
     9d0:	b580      	push	{r7, lr}
     9d2:	b086      	sub	sp, #24
     9d4:	af02      	add	r7, sp, #8
     9d6:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     9d8:	687b      	ldr	r3, [r7, #4]
     9da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     9dc:	60fb      	str	r3, [r7, #12]
  err_t result = ERR_OK;
     9de:	f04f 0300 	mov.w	r3, #0
     9e2:	72fb      	strb	r3, [r7, #11]
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
  ip_addr_set_any(&dhcp->offered_ip_addr);
     9e4:	68fb      	ldr	r3, [r7, #12]
     9e6:	f04f 0200 	mov.w	r2, #0
     9ea:	625a      	str	r2, [r3, #36]	; 0x24
  dhcp_set_state(dhcp, DHCP_SELECTING);
     9ec:	68f8      	ldr	r0, [r7, #12]
     9ee:	f04f 0106 	mov.w	r1, #6
     9f2:	f000 fb7b 	bl	10ec <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER);
     9f6:	6878      	ldr	r0, [r7, #4]
     9f8:	68f9      	ldr	r1, [r7, #12]
     9fa:	f04f 0201 	mov.w	r2, #1
     9fe:	f000 ff4f 	bl	18a0 <dhcp_create_msg>
     a02:	4603      	mov	r3, r0
     a04:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     a06:	f997 300b 	ldrsb.w	r3, [r7, #11]
     a0a:	2b00      	cmp	r3, #0
     a0c:	d145      	bne.n	a9a <dhcp_discover+0xca>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
     a0e:	68f8      	ldr	r0, [r7, #12]
     a10:	f04f 0139 	mov.w	r1, #57	; 0x39
     a14:	f04f 0202 	mov.w	r2, #2
     a18:	f000 fb84 	bl	1124 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
     a1c:	687b      	ldr	r3, [r7, #4]
     a1e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     a20:	68f8      	ldr	r0, [r7, #12]
     a22:	4619      	mov	r1, r3
     a24:	f000 fbc2 	bl	11ac <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
     a28:	68f8      	ldr	r0, [r7, #12]
     a2a:	f04f 0137 	mov.w	r1, #55	; 0x37
     a2e:	f04f 0204 	mov.w	r2, #4
     a32:	f000 fb77 	bl	1124 <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
     a36:	68f8      	ldr	r0, [r7, #12]
     a38:	f04f 0101 	mov.w	r1, #1
     a3c:	f000 fb9c 	bl	1178 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
     a40:	68f8      	ldr	r0, [r7, #12]
     a42:	f04f 0103 	mov.w	r1, #3
     a46:	f000 fb97 	bl	1178 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
     a4a:	68f8      	ldr	r0, [r7, #12]
     a4c:	f04f 011c 	mov.w	r1, #28
     a50:	f000 fb92 	bl	1178 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
     a54:	68f8      	ldr	r0, [r7, #12]
     a56:	f04f 0106 	mov.w	r1, #6
     a5a:	f000 fb8d 	bl	1178 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
     a5e:	68f8      	ldr	r0, [r7, #12]
     a60:	f001 f87c 	bl	1b5c <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     a64:	68fb      	ldr	r3, [r7, #12]
     a66:	691a      	ldr	r2, [r3, #16]
     a68:	68fb      	ldr	r3, [r7, #12]
     a6a:	8b1b      	ldrh	r3, [r3, #24]
     a6c:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     a70:	b29b      	uxth	r3, r3
     a72:	4610      	mov	r0, r2
     a74:	4619      	mov	r1, r3
     a76:	f7ff fffe 	bl	0 <pbuf_realloc>
			a76: R_ARM_THM_CALL	pbuf_realloc

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
     a7a:	68fb      	ldr	r3, [r7, #12]
     a7c:	685a      	ldr	r2, [r3, #4]
     a7e:	68fb      	ldr	r3, [r7, #12]
     a80:	691b      	ldr	r3, [r3, #16]
     a82:	6879      	ldr	r1, [r7, #4]
     a84:	9100      	str	r1, [sp, #0]
     a86:	4610      	mov	r0, r2
     a88:	4619      	mov	r1, r3
     a8a:	4a1a      	ldr	r2, [pc, #104]	; (af4 <dhcp_discover+0x124>)
     a8c:	f04f 0343 	mov.w	r3, #67	; 0x43
     a90:	f7ff fffe 	bl	0 <udp_sendto_if>
			a90: R_ARM_THM_CALL	udp_sendto_if
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_msg(dhcp);
     a94:	68f8      	ldr	r0, [r7, #12]
     a96:	f001 f845 	bl	1b24 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
     a9a:	68fb      	ldr	r3, [r7, #12]
     a9c:	7b5b      	ldrb	r3, [r3, #13]
     a9e:	f103 0301 	add.w	r3, r3, #1
     aa2:	b2da      	uxtb	r2, r3
     aa4:	68fb      	ldr	r3, [r7, #12]
     aa6:	735a      	strb	r2, [r3, #13]
  if(dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = (dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000;
     aa8:	68fb      	ldr	r3, [r7, #12]
     aaa:	7b5b      	ldrb	r3, [r3, #13]
     aac:	2b05      	cmp	r3, #5
     aae:	d807      	bhi.n	ac0 <dhcp_discover+0xf0>
     ab0:	68fb      	ldr	r3, [r7, #12]
     ab2:	7b5b      	ldrb	r3, [r3, #13]
     ab4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
     ab8:	fa02 f303 	lsl.w	r3, r2, r3
     abc:	b29b      	uxth	r3, r3
     abe:	e001      	b.n	ac4 <dhcp_discover+0xf4>
     ac0:	f64e 2360 	movw	r3, #60000	; 0xea60
     ac4:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
     ac6:	893b      	ldrh	r3, [r7, #8]
     ac8:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
     acc:	f103 0303 	add.w	r3, r3, #3
     ad0:	4a09      	ldr	r2, [pc, #36]	; (af8 <dhcp_discover+0x128>)
     ad2:	fb82 1203 	smull	r1, r2, r2, r3
     ad6:	ea4f 1262 	mov.w	r2, r2, asr #5
     ada:	ea4f 73e3 	mov.w	r3, r3, asr #31
     ade:	1ad3      	subs	r3, r2, r3
     ae0:	b29a      	uxth	r2, r3
     ae2:	68fb      	ldr	r3, [r7, #12]
     ae4:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
     ae6:	7afb      	ldrb	r3, [r7, #11]
     ae8:	b25b      	sxtb	r3, r3
}
     aea:	4618      	mov	r0, r3
     aec:	f107 0710 	add.w	r7, r7, #16
     af0:	46bd      	mov	sp, r7
     af2:	bd80      	pop	{r7, pc}
     af4:	00000000 	.word	0x00000000
			af4: R_ARM_ABS32	ip_addr_broadcast
     af8:	10624dd3 	.word	0x10624dd3

00000afc <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
     afc:	b580      	push	{r7, lr}
     afe:	b088      	sub	sp, #32
     b00:	af00      	add	r7, sp, #0
     b02:	6078      	str	r0, [r7, #4]
  u32_t timeout;
  struct dhcp *dhcp;
  ip_addr_t sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
     b04:	687b      	ldr	r3, [r7, #4]
     b06:	2b00      	cmp	r3, #0
     b08:	f000 80a5 	beq.w	c56 <dhcp_bind+0x15a>
  dhcp = netif->dhcp;
     b0c:	687b      	ldr	r3, [r7, #4]
     b0e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     b10:	61bb      	str	r3, [r7, #24]
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
     b12:	69bb      	ldr	r3, [r7, #24]
     b14:	2b00      	cmp	r3, #0
     b16:	f000 809e 	beq.w	c56 <dhcp_bind+0x15a>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
     b1a:	69bb      	ldr	r3, [r7, #24]
     b1c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     b1e:	f1b3 3fff 	cmp.w	r3, #4294967295
     b22:	d01d      	beq.n	b60 <dhcp_bind+0x64>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
     b24:	69bb      	ldr	r3, [r7, #24]
     b26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     b28:	f103 021e 	add.w	r2, r3, #30
     b2c:	4b4c      	ldr	r3, [pc, #304]	; (c60 <dhcp_bind+0x164>)
     b2e:	fba3 1302 	umull	r1, r3, r3, r2
     b32:	ea4f 1353 	mov.w	r3, r3, lsr #5
     b36:	61fb      	str	r3, [r7, #28]
    if(timeout > 0xffff) {
     b38:	69fa      	ldr	r2, [r7, #28]
     b3a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     b3e:	429a      	cmp	r2, r3
     b40:	d902      	bls.n	b48 <dhcp_bind+0x4c>
      timeout = 0xffff;
     b42:	f64f 73ff 	movw	r3, #65535	; 0xffff
     b46:	61fb      	str	r3, [r7, #28]
    }
    dhcp->t1_timeout = (u16_t)timeout;
     b48:	69fb      	ldr	r3, [r7, #28]
     b4a:	b29a      	uxth	r2, r3
     b4c:	69bb      	ldr	r3, [r7, #24]
     b4e:	839a      	strh	r2, [r3, #28]
    if (dhcp->t1_timeout == 0) {
     b50:	69bb      	ldr	r3, [r7, #24]
     b52:	8b9b      	ldrh	r3, [r3, #28]
     b54:	2b00      	cmp	r3, #0
     b56:	d103      	bne.n	b60 <dhcp_bind+0x64>
      dhcp->t1_timeout = 1;
     b58:	69bb      	ldr	r3, [r7, #24]
     b5a:	f04f 0201 	mov.w	r2, #1
     b5e:	839a      	strh	r2, [r3, #28]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
     b60:	69bb      	ldr	r3, [r7, #24]
     b62:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b64:	f1b3 3fff 	cmp.w	r3, #4294967295
     b68:	d01d      	beq.n	ba6 <dhcp_bind+0xaa>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
     b6a:	69bb      	ldr	r3, [r7, #24]
     b6c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b6e:	f103 021e 	add.w	r2, r3, #30
     b72:	4b3b      	ldr	r3, [pc, #236]	; (c60 <dhcp_bind+0x164>)
     b74:	fba3 1302 	umull	r1, r3, r3, r2
     b78:	ea4f 1353 	mov.w	r3, r3, lsr #5
     b7c:	61fb      	str	r3, [r7, #28]
    if(timeout > 0xffff) {
     b7e:	69fa      	ldr	r2, [r7, #28]
     b80:	f64f 73ff 	movw	r3, #65535	; 0xffff
     b84:	429a      	cmp	r2, r3
     b86:	d902      	bls.n	b8e <dhcp_bind+0x92>
      timeout = 0xffff;
     b88:	f64f 73ff 	movw	r3, #65535	; 0xffff
     b8c:	61fb      	str	r3, [r7, #28]
    }
    dhcp->t2_timeout = (u16_t)timeout;
     b8e:	69fb      	ldr	r3, [r7, #28]
     b90:	b29a      	uxth	r2, r3
     b92:	69bb      	ldr	r3, [r7, #24]
     b94:	83da      	strh	r2, [r3, #30]
    if (dhcp->t2_timeout == 0) {
     b96:	69bb      	ldr	r3, [r7, #24]
     b98:	8bdb      	ldrh	r3, [r3, #30]
     b9a:	2b00      	cmp	r3, #0
     b9c:	d103      	bne.n	ba6 <dhcp_bind+0xaa>
      dhcp->t2_timeout = 1;
     b9e:	69bb      	ldr	r3, [r7, #24]
     ba0:	f04f 0201 	mov.w	r2, #1
     ba4:	83da      	strh	r2, [r3, #30]
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }

  /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
  if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
     ba6:	69bb      	ldr	r3, [r7, #24]
     ba8:	8b9a      	ldrh	r2, [r3, #28]
     baa:	69bb      	ldr	r3, [r7, #24]
     bac:	8bdb      	ldrh	r3, [r3, #30]
     bae:	429a      	cmp	r2, r3
     bb0:	d307      	bcc.n	bc2 <dhcp_bind+0xc6>
     bb2:	69bb      	ldr	r3, [r7, #24]
     bb4:	8bdb      	ldrh	r3, [r3, #30]
     bb6:	2b00      	cmp	r3, #0
     bb8:	d003      	beq.n	bc2 <dhcp_bind+0xc6>
    dhcp->t1_timeout = 0;
     bba:	69bb      	ldr	r3, [r7, #24]
     bbc:	f04f 0200 	mov.w	r2, #0
     bc0:	839a      	strh	r2, [r3, #28]
  }

  if (dhcp->subnet_mask_given) {
     bc2:	69bb      	ldr	r3, [r7, #24]
     bc4:	7b9b      	ldrb	r3, [r3, #14]
     bc6:	2b00      	cmp	r3, #0
     bc8:	d003      	beq.n	bd2 <dhcp_bind+0xd6>
    /* copy offered network mask */
    ip_addr_copy(sn_mask, dhcp->offered_sn_mask);
     bca:	69bb      	ldr	r3, [r7, #24]
     bcc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     bce:	613b      	str	r3, [r7, #16]
     bd0:	e016      	b.n	c00 <dhcp_bind+0x104>
  } else {
    /* subnet mask not given, choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
     bd2:	69bb      	ldr	r3, [r7, #24]
     bd4:	f103 0324 	add.w	r3, r3, #36	; 0x24
     bd8:	781b      	ldrb	r3, [r3, #0]
     bda:	75fb      	strb	r3, [r7, #23]
    if (first_octet <= 127) {
     bdc:	7dfb      	ldrb	r3, [r7, #23]
     bde:	b25b      	sxtb	r3, r3
     be0:	2b00      	cmp	r3, #0
     be2:	db03      	blt.n	bec <dhcp_bind+0xf0>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
     be4:	f04f 03ff 	mov.w	r3, #255	; 0xff
     be8:	613b      	str	r3, [r7, #16]
     bea:	e009      	b.n	c00 <dhcp_bind+0x104>
    } else if (first_octet >= 192) {
     bec:	7dfb      	ldrb	r3, [r7, #23]
     bee:	2bbf      	cmp	r3, #191	; 0xbf
     bf0:	d903      	bls.n	bfa <dhcp_bind+0xfe>
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
     bf2:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
     bf6:	613b      	str	r3, [r7, #16]
     bf8:	e002      	b.n	c00 <dhcp_bind+0x104>
    } else {
      ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
     bfa:	f64f 73ff 	movw	r3, #65535	; 0xffff
     bfe:	613b      	str	r3, [r7, #16]
    }
  }

  ip_addr_copy(gw_addr, dhcp->offered_gw_addr);
     c00:	69bb      	ldr	r3, [r7, #24]
     c02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     c04:	60fb      	str	r3, [r7, #12]
  /* gateway address not given? */
  if (ip_addr_isany(&gw_addr)) {
     c06:	68fb      	ldr	r3, [r7, #12]
     c08:	2b00      	cmp	r3, #0
     c0a:	d109      	bne.n	c20 <dhcp_bind+0x124>
    /* copy network address */
    ip_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
     c0c:	69bb      	ldr	r3, [r7, #24]
     c0e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
     c10:	693b      	ldr	r3, [r7, #16]
     c12:	ea02 0303 	and.w	r3, r2, r3
     c16:	60fb      	str	r3, [r7, #12]
    /* use first host address on network as gateway */
    ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
     c18:	68fb      	ldr	r3, [r7, #12]
     c1a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
     c1e:	60fb      	str	r3, [r7, #12]
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
     c20:	69bb      	ldr	r3, [r7, #24]
     c22:	f103 0324 	add.w	r3, r3, #36	; 0x24
     c26:	6878      	ldr	r0, [r7, #4]
     c28:	4619      	mov	r1, r3
     c2a:	f7ff fffe 	bl	0 <netif_set_ipaddr>
			c2a: R_ARM_THM_CALL	netif_set_ipaddr
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&sn_mask)));
  netif_set_netmask(netif, &sn_mask);
     c2e:	f107 0310 	add.w	r3, r7, #16
     c32:	6878      	ldr	r0, [r7, #4]
     c34:	4619      	mov	r1, r3
     c36:	f7ff fffe 	bl	0 <netif_set_netmask>
			c36: R_ARM_THM_CALL	netif_set_netmask
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n",
    ip4_addr_get_u32(&gw_addr)));
  netif_set_gw(netif, &gw_addr);
     c3a:	f107 030c 	add.w	r3, r7, #12
     c3e:	6878      	ldr	r0, [r7, #4]
     c40:	4619      	mov	r1, r3
     c42:	f7ff fffe 	bl	0 <netif_set_gw>
			c42: R_ARM_THM_CALL	netif_set_gw
  /* bring the interface up */
  netif_set_up(netif);
     c46:	6878      	ldr	r0, [r7, #4]
     c48:	f7ff fffe 	bl	0 <netif_set_up>
			c48: R_ARM_THM_CALL	netif_set_up
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
     c4c:	69b8      	ldr	r0, [r7, #24]
     c4e:	f04f 010a 	mov.w	r1, #10
     c52:	f000 fa4b 	bl	10ec <dhcp_set_state>
}
     c56:	f107 0720 	add.w	r7, r7, #32
     c5a:	46bd      	mov	sp, r7
     c5c:	bd80      	pop	{r7, pc}
     c5e:	bf00      	nop
     c60:	88888889 	.word	0x88888889

00000c64 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
     c64:	b580      	push	{r7, lr}
     c66:	b086      	sub	sp, #24
     c68:	af02      	add	r7, sp, #8
     c6a:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     c6c:	687b      	ldr	r3, [r7, #4]
     c6e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     c70:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
     c72:	68f8      	ldr	r0, [r7, #12]
     c74:	f04f 0105 	mov.w	r1, #5
     c78:	f000 fa38 	bl	10ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
     c7c:	6878      	ldr	r0, [r7, #4]
     c7e:	68f9      	ldr	r1, [r7, #12]
     c80:	f04f 0203 	mov.w	r2, #3
     c84:	f000 fe0c 	bl	18a0 <dhcp_create_msg>
     c88:	4603      	mov	r3, r0
     c8a:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     c8c:	f997 300b 	ldrsb.w	r3, [r7, #11]
     c90:	2b00      	cmp	r3, #0
     c92:	d12d      	bne.n	cf0 <dhcp_renew+0x8c>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
     c94:	68f8      	ldr	r0, [r7, #12]
     c96:	f04f 0139 	mov.w	r1, #57	; 0x39
     c9a:	f04f 0202 	mov.w	r2, #2
     c9e:	f000 fa41 	bl	1124 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
     ca2:	687b      	ldr	r3, [r7, #4]
     ca4:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     ca6:	68f8      	ldr	r0, [r7, #12]
     ca8:	4619      	mov	r1, r3
     caa:	f000 fa7f 	bl	11ac <dhcp_option_short>
#if LWIP_NETIF_HOSTNAME
    dhcp_option_hostname(dhcp, netif);
#endif /* LWIP_NETIF_HOSTNAME */

    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
     cae:	68f8      	ldr	r0, [r7, #12]
     cb0:	f000 ff54 	bl	1b5c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     cb4:	68fb      	ldr	r3, [r7, #12]
     cb6:	691a      	ldr	r2, [r3, #16]
     cb8:	68fb      	ldr	r3, [r7, #12]
     cba:	8b1b      	ldrh	r3, [r3, #24]
     cbc:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     cc0:	b29b      	uxth	r3, r3
     cc2:	4610      	mov	r0, r2
     cc4:	4619      	mov	r1, r3
     cc6:	f7ff fffe 	bl	0 <pbuf_realloc>
			cc6: R_ARM_THM_CALL	pbuf_realloc

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
     cca:	68fb      	ldr	r3, [r7, #12]
     ccc:	6859      	ldr	r1, [r3, #4]
     cce:	68fb      	ldr	r3, [r7, #12]
     cd0:	691a      	ldr	r2, [r3, #16]
     cd2:	68fb      	ldr	r3, [r7, #12]
     cd4:	f103 0320 	add.w	r3, r3, #32
     cd8:	6878      	ldr	r0, [r7, #4]
     cda:	9000      	str	r0, [sp, #0]
     cdc:	4608      	mov	r0, r1
     cde:	4611      	mov	r1, r2
     ce0:	461a      	mov	r2, r3
     ce2:	f04f 0343 	mov.w	r3, #67	; 0x43
     ce6:	f7ff fffe 	bl	0 <udp_sendto_if>
			ce6: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(dhcp);
     cea:	68f8      	ldr	r0, [r7, #12]
     cec:	f000 ff1a 	bl	1b24 <dhcp_delete_msg>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
     cf0:	68fb      	ldr	r3, [r7, #12]
     cf2:	7b5b      	ldrb	r3, [r3, #13]
     cf4:	f103 0301 	add.w	r3, r3, #1
     cf8:	b2da      	uxtb	r2, r3
     cfa:	68fb      	ldr	r3, [r7, #12]
     cfc:	735a      	strb	r2, [r3, #13]
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
     cfe:	68fb      	ldr	r3, [r7, #12]
     d00:	7b5b      	ldrb	r3, [r3, #13]
     d02:	2b09      	cmp	r3, #9
     d04:	d80c      	bhi.n	d20 <dhcp_renew+0xbc>
     d06:	68fb      	ldr	r3, [r7, #12]
     d08:	7b5b      	ldrb	r3, [r3, #13]
     d0a:	461a      	mov	r2, r3
     d0c:	ea4f 1242 	mov.w	r2, r2, lsl #5
     d10:	1ad2      	subs	r2, r2, r3
     d12:	ea4f 0282 	mov.w	r2, r2, lsl #2
     d16:	18d3      	adds	r3, r2, r3
     d18:	ea4f 1303 	mov.w	r3, r3, lsl #4
     d1c:	b29b      	uxth	r3, r3
     d1e:	e001      	b.n	d24 <dhcp_renew+0xc0>
     d20:	f644 6320 	movw	r3, #20000	; 0x4e20
     d24:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
     d26:	893b      	ldrh	r3, [r7, #8]
     d28:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
     d2c:	f103 0303 	add.w	r3, r3, #3
     d30:	4a08      	ldr	r2, [pc, #32]	; (d54 <dhcp_renew+0xf0>)
     d32:	fb82 1203 	smull	r1, r2, r2, r3
     d36:	ea4f 1262 	mov.w	r2, r2, asr #5
     d3a:	ea4f 73e3 	mov.w	r3, r3, asr #31
     d3e:	1ad3      	subs	r3, r2, r3
     d40:	b29a      	uxth	r2, r3
     d42:	68fb      	ldr	r3, [r7, #12]
     d44:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
     d46:	7afb      	ldrb	r3, [r7, #11]
     d48:	b25b      	sxtb	r3, r3
}
     d4a:	4618      	mov	r0, r3
     d4c:	f107 0710 	add.w	r7, r7, #16
     d50:	46bd      	mov	sp, r7
     d52:	bd80      	pop	{r7, pc}
     d54:	10624dd3 	.word	0x10624dd3

00000d58 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
     d58:	b580      	push	{r7, lr}
     d5a:	b086      	sub	sp, #24
     d5c:	af02      	add	r7, sp, #8
     d5e:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     d60:	687b      	ldr	r3, [r7, #4]
     d62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     d64:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
     d66:	68f8      	ldr	r0, [r7, #12]
     d68:	f04f 0104 	mov.w	r1, #4
     d6c:	f000 f9be 	bl	10ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
     d70:	6878      	ldr	r0, [r7, #4]
     d72:	68f9      	ldr	r1, [r7, #12]
     d74:	f04f 0203 	mov.w	r2, #3
     d78:	f000 fd92 	bl	18a0 <dhcp_create_msg>
     d7c:	4603      	mov	r3, r0
     d7e:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     d80:	f997 300b 	ldrsb.w	r3, [r7, #11]
     d84:	2b00      	cmp	r3, #0
     d86:	d12a      	bne.n	dde <dhcp_rebind+0x86>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
     d88:	68f8      	ldr	r0, [r7, #12]
     d8a:	f04f 0139 	mov.w	r1, #57	; 0x39
     d8e:	f04f 0202 	mov.w	r2, #2
     d92:	f000 f9c7 	bl	1124 <dhcp_option>
    dhcp_option_short(dhcp, DHCP_MAX_MSG_LEN(netif));
     d96:	687b      	ldr	r3, [r7, #4]
     d98:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     d9a:	68f8      	ldr	r0, [r7, #12]
     d9c:	4619      	mov	r1, r3
     d9e:	f000 fa05 	bl	11ac <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
     da2:	68f8      	ldr	r0, [r7, #12]
     da4:	f000 feda 	bl	1b5c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     da8:	68fb      	ldr	r3, [r7, #12]
     daa:	691a      	ldr	r2, [r3, #16]
     dac:	68fb      	ldr	r3, [r7, #12]
     dae:	8b1b      	ldrh	r3, [r3, #24]
     db0:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     db4:	b29b      	uxth	r3, r3
     db6:	4610      	mov	r0, r2
     db8:	4619      	mov	r1, r3
     dba:	f7ff fffe 	bl	0 <pbuf_realloc>
			dba: R_ARM_THM_CALL	pbuf_realloc

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
     dbe:	68fb      	ldr	r3, [r7, #12]
     dc0:	685a      	ldr	r2, [r3, #4]
     dc2:	68fb      	ldr	r3, [r7, #12]
     dc4:	691b      	ldr	r3, [r3, #16]
     dc6:	6879      	ldr	r1, [r7, #4]
     dc8:	9100      	str	r1, [sp, #0]
     dca:	4610      	mov	r0, r2
     dcc:	4619      	mov	r1, r3
     dce:	4a1d      	ldr	r2, [pc, #116]	; (e44 <dhcp_rebind+0xec>)
     dd0:	f04f 0343 	mov.w	r3, #67	; 0x43
     dd4:	f7ff fffe 	bl	0 <udp_sendto_if>
			dd4: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(dhcp);
     dd8:	68f8      	ldr	r0, [r7, #12]
     dda:	f000 fea3 	bl	1b24 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
     dde:	68fb      	ldr	r3, [r7, #12]
     de0:	7b5b      	ldrb	r3, [r3, #13]
     de2:	f103 0301 	add.w	r3, r3, #1
     de6:	b2da      	uxtb	r2, r3
     de8:	68fb      	ldr	r3, [r7, #12]
     dea:	735a      	strb	r2, [r3, #13]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
     dec:	68fb      	ldr	r3, [r7, #12]
     dee:	7b5b      	ldrb	r3, [r3, #13]
     df0:	2b09      	cmp	r3, #9
     df2:	d80c      	bhi.n	e0e <dhcp_rebind+0xb6>
     df4:	68fb      	ldr	r3, [r7, #12]
     df6:	7b5b      	ldrb	r3, [r3, #13]
     df8:	461a      	mov	r2, r3
     dfa:	ea4f 1242 	mov.w	r2, r2, lsl #5
     dfe:	1ad2      	subs	r2, r2, r3
     e00:	ea4f 0282 	mov.w	r2, r2, lsl #2
     e04:	18d3      	adds	r3, r2, r3
     e06:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     e0a:	b29b      	uxth	r3, r3
     e0c:	e001      	b.n	e12 <dhcp_rebind+0xba>
     e0e:	f242 7310 	movw	r3, #10000	; 0x2710
     e12:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
     e14:	893b      	ldrh	r3, [r7, #8]
     e16:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
     e1a:	f103 0303 	add.w	r3, r3, #3
     e1e:	4a0a      	ldr	r2, [pc, #40]	; (e48 <dhcp_rebind+0xf0>)
     e20:	fb82 1203 	smull	r1, r2, r2, r3
     e24:	ea4f 1262 	mov.w	r2, r2, asr #5
     e28:	ea4f 73e3 	mov.w	r3, r3, asr #31
     e2c:	1ad3      	subs	r3, r2, r3
     e2e:	b29a      	uxth	r2, r3
     e30:	68fb      	ldr	r3, [r7, #12]
     e32:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
     e34:	7afb      	ldrb	r3, [r7, #11]
     e36:	b25b      	sxtb	r3, r3
}
     e38:	4618      	mov	r0, r3
     e3a:	f107 0710 	add.w	r7, r7, #16
     e3e:	46bd      	mov	sp, r7
     e40:	bd80      	pop	{r7, pc}
     e42:	bf00      	nop
     e44:	00000000 	.word	0x00000000
			e44: R_ARM_ABS32	ip_addr_broadcast
     e48:	10624dd3 	.word	0x10624dd3

00000e4c <dhcp_reboot>:
 *
 * @param netif network interface which must reboot
 */
static err_t
dhcp_reboot(struct netif *netif)
{
     e4c:	b580      	push	{r7, lr}
     e4e:	b086      	sub	sp, #24
     e50:	af02      	add	r7, sp, #8
     e52:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     e54:	687b      	ldr	r3, [r7, #4]
     e56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     e58:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
  dhcp_set_state(dhcp, DHCP_REBOOTING);
     e5a:	68f8      	ldr	r0, [r7, #12]
     e5c:	f04f 0103 	mov.w	r1, #3
     e60:	f000 f944 	bl	10ec <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_REQUEST);
     e64:	6878      	ldr	r0, [r7, #4]
     e66:	68f9      	ldr	r1, [r7, #12]
     e68:	f04f 0203 	mov.w	r2, #3
     e6c:	f000 fd18 	bl	18a0 <dhcp_create_msg>
     e70:	4603      	mov	r3, r0
     e72:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     e74:	f997 300b 	ldrsb.w	r3, [r7, #11]
     e78:	2b00      	cmp	r3, #0
     e7a:	d13a      	bne.n	ef2 <dhcp_reboot+0xa6>
    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
     e7c:	68f8      	ldr	r0, [r7, #12]
     e7e:	f04f 0139 	mov.w	r1, #57	; 0x39
     e82:	f04f 0202 	mov.w	r2, #2
     e86:	f000 f94d 	bl	1124 <dhcp_option>
    dhcp_option_short(dhcp, 576);
     e8a:	68f8      	ldr	r0, [r7, #12]
     e8c:	f44f 7110 	mov.w	r1, #576	; 0x240
     e90:	f000 f98c 	bl	11ac <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
     e94:	68f8      	ldr	r0, [r7, #12]
     e96:	f04f 0132 	mov.w	r1, #50	; 0x32
     e9a:	f04f 0204 	mov.w	r2, #4
     e9e:	f000 f941 	bl	1124 <dhcp_option>
    dhcp_option_long(dhcp, ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
     ea2:	68fb      	ldr	r3, [r7, #12]
     ea4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     ea6:	4618      	mov	r0, r3
     ea8:	f7ff fffe 	bl	0 <lwip_ntohl>
			ea8: R_ARM_THM_CALL	lwip_ntohl
     eac:	4603      	mov	r3, r0
     eae:	68f8      	ldr	r0, [r7, #12]
     eb0:	4619      	mov	r1, r3
     eb2:	f000 f9a7 	bl	1204 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
     eb6:	68f8      	ldr	r0, [r7, #12]
     eb8:	f000 fe50 	bl	1b5c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     ebc:	68fb      	ldr	r3, [r7, #12]
     ebe:	691a      	ldr	r2, [r3, #16]
     ec0:	68fb      	ldr	r3, [r7, #12]
     ec2:	8b1b      	ldrh	r3, [r3, #24]
     ec4:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     ec8:	b29b      	uxth	r3, r3
     eca:	4610      	mov	r0, r2
     ecc:	4619      	mov	r1, r3
     ece:	f7ff fffe 	bl	0 <pbuf_realloc>
			ece: R_ARM_THM_CALL	pbuf_realloc

    /* broadcast to server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
     ed2:	68fb      	ldr	r3, [r7, #12]
     ed4:	685a      	ldr	r2, [r3, #4]
     ed6:	68fb      	ldr	r3, [r7, #12]
     ed8:	691b      	ldr	r3, [r3, #16]
     eda:	6879      	ldr	r1, [r7, #4]
     edc:	9100      	str	r1, [sp, #0]
     ede:	4610      	mov	r0, r2
     ee0:	4619      	mov	r1, r3
     ee2:	4a1d      	ldr	r2, [pc, #116]	; (f58 <dhcp_reboot+0x10c>)
     ee4:	f04f 0343 	mov.w	r3, #67	; 0x43
     ee8:	f7ff fffe 	bl	0 <udp_sendto_if>
			ee8: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(dhcp);
     eec:	68f8      	ldr	r0, [r7, #12]
     eee:	f000 fe19 	bl	1b24 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
     ef2:	68fb      	ldr	r3, [r7, #12]
     ef4:	7b5b      	ldrb	r3, [r3, #13]
     ef6:	f103 0301 	add.w	r3, r3, #1
     efa:	b2da      	uxtb	r2, r3
     efc:	68fb      	ldr	r3, [r7, #12]
     efe:	735a      	strb	r2, [r3, #13]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
     f00:	68fb      	ldr	r3, [r7, #12]
     f02:	7b5b      	ldrb	r3, [r3, #13]
     f04:	2b09      	cmp	r3, #9
     f06:	d80c      	bhi.n	f22 <dhcp_reboot+0xd6>
     f08:	68fb      	ldr	r3, [r7, #12]
     f0a:	7b5b      	ldrb	r3, [r3, #13]
     f0c:	461a      	mov	r2, r3
     f0e:	ea4f 1242 	mov.w	r2, r2, lsl #5
     f12:	1ad2      	subs	r2, r2, r3
     f14:	ea4f 0282 	mov.w	r2, r2, lsl #2
     f18:	18d3      	adds	r3, r2, r3
     f1a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     f1e:	b29b      	uxth	r3, r3
     f20:	e001      	b.n	f26 <dhcp_reboot+0xda>
     f22:	f242 7310 	movw	r3, #10000	; 0x2710
     f26:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
     f28:	893b      	ldrh	r3, [r7, #8]
     f2a:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
     f2e:	f103 0303 	add.w	r3, r3, #3
     f32:	4a0a      	ldr	r2, [pc, #40]	; (f5c <dhcp_reboot+0x110>)
     f34:	fb82 1203 	smull	r1, r2, r2, r3
     f38:	ea4f 1262 	mov.w	r2, r2, asr #5
     f3c:	ea4f 73e3 	mov.w	r3, r3, asr #31
     f40:	1ad3      	subs	r3, r2, r3
     f42:	b29a      	uxth	r2, r3
     f44:	68fb      	ldr	r3, [r7, #12]
     f46:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
     f48:	7afb      	ldrb	r3, [r7, #11]
     f4a:	b25b      	sxtb	r3, r3
}
     f4c:	4618      	mov	r0, r3
     f4e:	f107 0710 	add.w	r7, r7, #16
     f52:	46bd      	mov	sp, r7
     f54:	bd80      	pop	{r7, pc}
     f56:	bf00      	nop
     f58:	00000000 	.word	0x00000000
			f58: R_ARM_ABS32	ip_addr_broadcast
     f5c:	10624dd3 	.word	0x10624dd3

00000f60 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
     f60:	b580      	push	{r7, lr}
     f62:	b086      	sub	sp, #24
     f64:	af02      	add	r7, sp, #8
     f66:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp = netif->dhcp;
     f68:	687b      	ldr	r3, [r7, #4]
     f6a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     f6c:	60fb      	str	r3, [r7, #12]
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
     f6e:	68f8      	ldr	r0, [r7, #12]
     f70:	f04f 0100 	mov.w	r1, #0
     f74:	f000 f8ba 	bl	10ec <dhcp_set_state>
  /* clean old DHCP offer */
  ip_addr_set_zero(&dhcp->server_ip_addr);
     f78:	68fb      	ldr	r3, [r7, #12]
     f7a:	f04f 0200 	mov.w	r2, #0
     f7e:	621a      	str	r2, [r3, #32]
  ip_addr_set_zero(&dhcp->offered_ip_addr);
     f80:	68fb      	ldr	r3, [r7, #12]
     f82:	f04f 0200 	mov.w	r2, #0
     f86:	625a      	str	r2, [r3, #36]	; 0x24
  ip_addr_set_zero(&dhcp->offered_sn_mask);
     f88:	68fb      	ldr	r3, [r7, #12]
     f8a:	f04f 0200 	mov.w	r2, #0
     f8e:	629a      	str	r2, [r3, #40]	; 0x28
  ip_addr_set_zero(&dhcp->offered_gw_addr);
     f90:	68fb      	ldr	r3, [r7, #12]
     f92:	f04f 0200 	mov.w	r2, #0
     f96:	62da      	str	r2, [r3, #44]	; 0x2c
#if LWIP_DHCP_BOOTP_FILE
  ip_addr_set_zero(&dhcp->offered_si_addr);
#endif /* LWIP_DHCP_BOOTP_FILE */
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
     f98:	68fb      	ldr	r3, [r7, #12]
     f9a:	f04f 0200 	mov.w	r2, #0
     f9e:	639a      	str	r2, [r3, #56]	; 0x38
     fa0:	68fb      	ldr	r3, [r7, #12]
     fa2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     fa4:	68fb      	ldr	r3, [r7, #12]
     fa6:	635a      	str	r2, [r3, #52]	; 0x34
     fa8:	68fb      	ldr	r3, [r7, #12]
     faa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
     fac:	68fb      	ldr	r3, [r7, #12]
     fae:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_msg(netif, dhcp, DHCP_RELEASE);
     fb0:	6878      	ldr	r0, [r7, #4]
     fb2:	68f9      	ldr	r1, [r7, #12]
     fb4:	f04f 0207 	mov.w	r2, #7
     fb8:	f000 fc72 	bl	18a0 <dhcp_create_msg>
     fbc:	4603      	mov	r3, r0
     fbe:	72fb      	strb	r3, [r7, #11]
  if (result == ERR_OK) {
     fc0:	f997 300b 	ldrsb.w	r3, [r7, #11]
     fc4:	2b00      	cmp	r3, #0
     fc6:	d120      	bne.n	100a <dhcp_release+0xaa>
    dhcp_option_trailer(dhcp);
     fc8:	68f8      	ldr	r0, [r7, #12]
     fca:	f000 fdc7 	bl	1b5c <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
     fce:	68fb      	ldr	r3, [r7, #12]
     fd0:	691a      	ldr	r2, [r3, #16]
     fd2:	68fb      	ldr	r3, [r7, #12]
     fd4:	8b1b      	ldrh	r3, [r3, #24]
     fd6:	f103 03f0 	add.w	r3, r3, #240	; 0xf0
     fda:	b29b      	uxth	r3, r3
     fdc:	4610      	mov	r0, r2
     fde:	4619      	mov	r1, r3
     fe0:	f7ff fffe 	bl	0 <pbuf_realloc>
			fe0: R_ARM_THM_CALL	pbuf_realloc

    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
     fe4:	68fb      	ldr	r3, [r7, #12]
     fe6:	6859      	ldr	r1, [r3, #4]
     fe8:	68fb      	ldr	r3, [r7, #12]
     fea:	691a      	ldr	r2, [r3, #16]
     fec:	68fb      	ldr	r3, [r7, #12]
     fee:	f103 0320 	add.w	r3, r3, #32
     ff2:	6878      	ldr	r0, [r7, #4]
     ff4:	9000      	str	r0, [sp, #0]
     ff6:	4608      	mov	r0, r1
     ff8:	4611      	mov	r1, r2
     ffa:	461a      	mov	r2, r3
     ffc:	f04f 0343 	mov.w	r3, #67	; 0x43
    1000:	f7ff fffe 	bl	0 <udp_sendto_if>
			1000: R_ARM_THM_CALL	udp_sendto_if
    dhcp_delete_msg(dhcp);
    1004:	68f8      	ldr	r0, [r7, #12]
    1006:	f000 fd8d 	bl	1b24 <dhcp_delete_msg>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
    100a:	68fb      	ldr	r3, [r7, #12]
    100c:	7b5b      	ldrb	r3, [r3, #13]
    100e:	f103 0301 	add.w	r3, r3, #1
    1012:	b2da      	uxtb	r2, r3
    1014:	68fb      	ldr	r3, [r7, #12]
    1016:	735a      	strb	r2, [r3, #13]
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
    1018:	68fb      	ldr	r3, [r7, #12]
    101a:	7b5b      	ldrb	r3, [r3, #13]
    101c:	2b09      	cmp	r3, #9
    101e:	d80c      	bhi.n	103a <dhcp_release+0xda>
    1020:	68fb      	ldr	r3, [r7, #12]
    1022:	7b5b      	ldrb	r3, [r3, #13]
    1024:	461a      	mov	r2, r3
    1026:	ea4f 1242 	mov.w	r2, r2, lsl #5
    102a:	1ad2      	subs	r2, r2, r3
    102c:	ea4f 0282 	mov.w	r2, r2, lsl #2
    1030:	18d3      	adds	r3, r2, r3
    1032:	ea4f 03c3 	mov.w	r3, r3, lsl #3
    1036:	b29b      	uxth	r3, r3
    1038:	e001      	b.n	103e <dhcp_release+0xde>
    103a:	f242 7310 	movw	r3, #10000	; 0x2710
    103e:	813b      	strh	r3, [r7, #8]
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
    1040:	893b      	ldrh	r3, [r7, #8]
    1042:	f503 73f8 	add.w	r3, r3, #496	; 0x1f0
    1046:	f103 0303 	add.w	r3, r3, #3
    104a:	4a10      	ldr	r2, [pc, #64]	; (108c <dhcp_release+0x12c>)
    104c:	fb82 1203 	smull	r1, r2, r2, r3
    1050:	ea4f 1262 	mov.w	r2, r2, asr #5
    1054:	ea4f 73e3 	mov.w	r3, r3, asr #31
    1058:	1ad3      	subs	r3, r2, r3
    105a:	b29a      	uxth	r2, r3
    105c:	68fb      	ldr	r3, [r7, #12]
    105e:	835a      	strh	r2, [r3, #26]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
    1060:	6878      	ldr	r0, [r7, #4]
    1062:	f7ff fffe 	bl	0 <netif_set_down>
			1062: R_ARM_THM_CALL	netif_set_down
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
    1066:	6878      	ldr	r0, [r7, #4]
    1068:	4909      	ldr	r1, [pc, #36]	; (1090 <dhcp_release+0x130>)
    106a:	f7ff fffe 	bl	0 <netif_set_ipaddr>
			106a: R_ARM_THM_CALL	netif_set_ipaddr
  netif_set_gw(netif, IP_ADDR_ANY);
    106e:	6878      	ldr	r0, [r7, #4]
    1070:	4907      	ldr	r1, [pc, #28]	; (1090 <dhcp_release+0x130>)
    1072:	f7ff fffe 	bl	0 <netif_set_gw>
			1072: R_ARM_THM_CALL	netif_set_gw
  netif_set_netmask(netif, IP_ADDR_ANY);
    1076:	6878      	ldr	r0, [r7, #4]
    1078:	4905      	ldr	r1, [pc, #20]	; (1090 <dhcp_release+0x130>)
    107a:	f7ff fffe 	bl	0 <netif_set_netmask>
			107a: R_ARM_THM_CALL	netif_set_netmask
  
  return result;
    107e:	7afb      	ldrb	r3, [r7, #11]
    1080:	b25b      	sxtb	r3, r3
}
    1082:	4618      	mov	r0, r3
    1084:	f107 0710 	add.w	r7, r7, #16
    1088:	46bd      	mov	sp, r7
    108a:	bd80      	pop	{r7, pc}
    108c:	10624dd3 	.word	0x10624dd3
    1090:	00000000 	.word	0x00000000
			1090: R_ARM_ABS32	ip_addr_any

00001094 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
    1094:	b580      	push	{r7, lr}
    1096:	b084      	sub	sp, #16
    1098:	af00      	add	r7, sp, #0
    109a:	6078      	str	r0, [r7, #4]
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
    109c:	687b      	ldr	r3, [r7, #4]
    109e:	2b00      	cmp	r3, #0
    10a0:	d020      	beq.n	10e4 <dhcp_stop+0x50>
  dhcp = netif->dhcp;
    10a2:	687b      	ldr	r3, [r7, #4]
    10a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    10a6:	60fb      	str	r3, [r7, #12]
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
    10a8:	687b      	ldr	r3, [r7, #4]
    10aa:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
    10ae:	f023 0308 	bic.w	r3, r3, #8
    10b2:	b2da      	uxtb	r2, r3
    10b4:	687b      	ldr	r3, [r7, #4]
    10b6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
    10ba:	68fb      	ldr	r3, [r7, #12]
    10bc:	2b00      	cmp	r3, #0
    10be:	d011      	beq.n	10e4 <dhcp_stop+0x50>
      autoip_stop(netif);
      dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
    }
#endif /* LWIP_DHCP_AUTOIP_COOP */

    if (dhcp->pcb != NULL) {
    10c0:	68fb      	ldr	r3, [r7, #12]
    10c2:	685b      	ldr	r3, [r3, #4]
    10c4:	2b00      	cmp	r3, #0
    10c6:	d008      	beq.n	10da <dhcp_stop+0x46>
      udp_remove(dhcp->pcb);
    10c8:	68fb      	ldr	r3, [r7, #12]
    10ca:	685b      	ldr	r3, [r3, #4]
    10cc:	4618      	mov	r0, r3
    10ce:	f7ff fffe 	bl	0 <udp_remove>
			10ce: R_ARM_THM_CALL	udp_remove
      dhcp->pcb = NULL;
    10d2:	68fb      	ldr	r3, [r7, #12]
    10d4:	f04f 0200 	mov.w	r2, #0
    10d8:	605a      	str	r2, [r3, #4]
    }
    LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);
    dhcp_set_state(dhcp, DHCP_OFF);
    10da:	68f8      	ldr	r0, [r7, #12]
    10dc:	f04f 0100 	mov.w	r1, #0
    10e0:	f000 f804 	bl	10ec <dhcp_set_state>
  }
}
    10e4:	f107 0710 	add.w	r7, r7, #16
    10e8:	46bd      	mov	sp, r7
    10ea:	bd80      	pop	{r7, pc}

000010ec <dhcp_set_state>:
 *
 * If the state changed, reset the number of tries.
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
    10ec:	b480      	push	{r7}
    10ee:	b083      	sub	sp, #12
    10f0:	af00      	add	r7, sp, #0
    10f2:	6078      	str	r0, [r7, #4]
    10f4:	460b      	mov	r3, r1
    10f6:	70fb      	strb	r3, [r7, #3]
  if (new_state != dhcp->state) {
    10f8:	687b      	ldr	r3, [r7, #4]
    10fa:	7b1b      	ldrb	r3, [r3, #12]
    10fc:	78fa      	ldrb	r2, [r7, #3]
    10fe:	429a      	cmp	r2, r3
    1100:	d00a      	beq.n	1118 <dhcp_set_state+0x2c>
    dhcp->state = new_state;
    1102:	687b      	ldr	r3, [r7, #4]
    1104:	78fa      	ldrb	r2, [r7, #3]
    1106:	731a      	strb	r2, [r3, #12]
    dhcp->tries = 0;
    1108:	687b      	ldr	r3, [r7, #4]
    110a:	f04f 0200 	mov.w	r2, #0
    110e:	735a      	strb	r2, [r3, #13]
    dhcp->request_timeout = 0;
    1110:	687b      	ldr	r3, [r7, #4]
    1112:	f04f 0200 	mov.w	r2, #0
    1116:	835a      	strh	r2, [r3, #26]
    }
    else {
//    	xme_hal_dio_led_set(XME_BSP_LED_IP_CONFIG_PORT, XME_BSP_LED_IP_CONFIG_PIN, XME_HAL_DIO_LED_OFF);
    }
  }
}
    1118:	f107 070c 	add.w	r7, r7, #12
    111c:	46bd      	mov	sp, r7
    111e:	bc80      	pop	{r7}
    1120:	4770      	bx	lr
    1122:	bf00      	nop

00001124 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
    1124:	b480      	push	{r7}
    1126:	b083      	sub	sp, #12
    1128:	af00      	add	r7, sp, #0
    112a:	6078      	str	r0, [r7, #4]
    112c:	4613      	mov	r3, r2
    112e:	460a      	mov	r2, r1
    1130:	70fa      	strb	r2, [r7, #3]
    1132:	70bb      	strb	r3, [r7, #2]
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
    1134:	687b      	ldr	r3, [r7, #4]
    1136:	6959      	ldr	r1, [r3, #20]
    1138:	687b      	ldr	r3, [r7, #4]
    113a:	8b1b      	ldrh	r3, [r3, #24]
    113c:	461a      	mov	r2, r3
    113e:	188a      	adds	r2, r1, r2
    1140:	78f9      	ldrb	r1, [r7, #3]
    1142:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1146:	f103 0301 	add.w	r3, r3, #1
    114a:	b29a      	uxth	r2, r3
    114c:	687b      	ldr	r3, [r7, #4]
    114e:	831a      	strh	r2, [r3, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
    1150:	687b      	ldr	r3, [r7, #4]
    1152:	6959      	ldr	r1, [r3, #20]
    1154:	687b      	ldr	r3, [r7, #4]
    1156:	8b1b      	ldrh	r3, [r3, #24]
    1158:	461a      	mov	r2, r3
    115a:	188a      	adds	r2, r1, r2
    115c:	78b9      	ldrb	r1, [r7, #2]
    115e:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1162:	f103 0301 	add.w	r3, r3, #1
    1166:	b29a      	uxth	r2, r3
    1168:	687b      	ldr	r3, [r7, #4]
    116a:	831a      	strh	r2, [r3, #24]
}
    116c:	f107 070c 	add.w	r7, r7, #12
    1170:	46bd      	mov	sp, r7
    1172:	bc80      	pop	{r7}
    1174:	4770      	bx	lr
    1176:	bf00      	nop

00001178 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
    1178:	b480      	push	{r7}
    117a:	b083      	sub	sp, #12
    117c:	af00      	add	r7, sp, #0
    117e:	6078      	str	r0, [r7, #4]
    1180:	460b      	mov	r3, r1
    1182:	70fb      	strb	r3, [r7, #3]
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
    1184:	687b      	ldr	r3, [r7, #4]
    1186:	6959      	ldr	r1, [r3, #20]
    1188:	687b      	ldr	r3, [r7, #4]
    118a:	8b1b      	ldrh	r3, [r3, #24]
    118c:	461a      	mov	r2, r3
    118e:	188a      	adds	r2, r1, r2
    1190:	78f9      	ldrb	r1, [r7, #3]
    1192:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1196:	f103 0301 	add.w	r3, r3, #1
    119a:	b29a      	uxth	r2, r3
    119c:	687b      	ldr	r3, [r7, #4]
    119e:	831a      	strh	r2, [r3, #24]
}
    11a0:	f107 070c 	add.w	r7, r7, #12
    11a4:	46bd      	mov	sp, r7
    11a6:	bc80      	pop	{r7}
    11a8:	4770      	bx	lr
    11aa:	bf00      	nop

000011ac <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
    11ac:	b480      	push	{r7}
    11ae:	b083      	sub	sp, #12
    11b0:	af00      	add	r7, sp, #0
    11b2:	6078      	str	r0, [r7, #4]
    11b4:	460b      	mov	r3, r1
    11b6:	807b      	strh	r3, [r7, #2]
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
    11b8:	687b      	ldr	r3, [r7, #4]
    11ba:	6958      	ldr	r0, [r3, #20]
    11bc:	687b      	ldr	r3, [r7, #4]
    11be:	8b1b      	ldrh	r3, [r3, #24]
    11c0:	461a      	mov	r2, r3
    11c2:	8879      	ldrh	r1, [r7, #2]
    11c4:	ea4f 2111 	mov.w	r1, r1, lsr #8
    11c8:	b289      	uxth	r1, r1
    11ca:	b2c9      	uxtb	r1, r1
    11cc:	1882      	adds	r2, r0, r2
    11ce:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    11d2:	f103 0301 	add.w	r3, r3, #1
    11d6:	b29a      	uxth	r2, r3
    11d8:	687b      	ldr	r3, [r7, #4]
    11da:	831a      	strh	r2, [r3, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
    11dc:	687b      	ldr	r3, [r7, #4]
    11de:	6958      	ldr	r0, [r3, #20]
    11e0:	687b      	ldr	r3, [r7, #4]
    11e2:	8b1b      	ldrh	r3, [r3, #24]
    11e4:	461a      	mov	r2, r3
    11e6:	8879      	ldrh	r1, [r7, #2]
    11e8:	b2c9      	uxtb	r1, r1
    11ea:	1882      	adds	r2, r0, r2
    11ec:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    11f0:	f103 0301 	add.w	r3, r3, #1
    11f4:	b29a      	uxth	r2, r3
    11f6:	687b      	ldr	r3, [r7, #4]
    11f8:	831a      	strh	r2, [r3, #24]
}
    11fa:	f107 070c 	add.w	r7, r7, #12
    11fe:	46bd      	mov	sp, r7
    1200:	bc80      	pop	{r7}
    1202:	4770      	bx	lr

00001204 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
    1204:	b480      	push	{r7}
    1206:	b083      	sub	sp, #12
    1208:	af00      	add	r7, sp, #0
    120a:	6078      	str	r0, [r7, #4]
    120c:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
    120e:	687b      	ldr	r3, [r7, #4]
    1210:	6958      	ldr	r0, [r3, #20]
    1212:	687b      	ldr	r3, [r7, #4]
    1214:	8b1b      	ldrh	r3, [r3, #24]
    1216:	461a      	mov	r2, r3
    1218:	6839      	ldr	r1, [r7, #0]
    121a:	ea4f 6111 	mov.w	r1, r1, lsr #24
    121e:	b2c9      	uxtb	r1, r1
    1220:	1882      	adds	r2, r0, r2
    1222:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1226:	f103 0301 	add.w	r3, r3, #1
    122a:	b29a      	uxth	r2, r3
    122c:	687b      	ldr	r3, [r7, #4]
    122e:	831a      	strh	r2, [r3, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
    1230:	687b      	ldr	r3, [r7, #4]
    1232:	6958      	ldr	r0, [r3, #20]
    1234:	687b      	ldr	r3, [r7, #4]
    1236:	8b1b      	ldrh	r3, [r3, #24]
    1238:	461a      	mov	r2, r3
    123a:	6839      	ldr	r1, [r7, #0]
    123c:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
    1240:	ea4f 4111 	mov.w	r1, r1, lsr #16
    1244:	b2c9      	uxtb	r1, r1
    1246:	1882      	adds	r2, r0, r2
    1248:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    124c:	f103 0301 	add.w	r3, r3, #1
    1250:	b29a      	uxth	r2, r3
    1252:	687b      	ldr	r3, [r7, #4]
    1254:	831a      	strh	r2, [r3, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
    1256:	687b      	ldr	r3, [r7, #4]
    1258:	6958      	ldr	r0, [r3, #20]
    125a:	687b      	ldr	r3, [r7, #4]
    125c:	8b1b      	ldrh	r3, [r3, #24]
    125e:	461a      	mov	r2, r3
    1260:	6839      	ldr	r1, [r7, #0]
    1262:	f401 417f 	and.w	r1, r1, #65280	; 0xff00
    1266:	ea4f 2111 	mov.w	r1, r1, lsr #8
    126a:	b2c9      	uxtb	r1, r1
    126c:	1882      	adds	r2, r0, r2
    126e:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1272:	f103 0301 	add.w	r3, r3, #1
    1276:	b29a      	uxth	r2, r3
    1278:	687b      	ldr	r3, [r7, #4]
    127a:	831a      	strh	r2, [r3, #24]
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
    127c:	687b      	ldr	r3, [r7, #4]
    127e:	6958      	ldr	r0, [r3, #20]
    1280:	687b      	ldr	r3, [r7, #4]
    1282:	8b1b      	ldrh	r3, [r3, #24]
    1284:	461a      	mov	r2, r3
    1286:	6839      	ldr	r1, [r7, #0]
    1288:	b2c9      	uxtb	r1, r1
    128a:	1882      	adds	r2, r0, r2
    128c:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1290:	f103 0301 	add.w	r3, r3, #1
    1294:	b29a      	uxth	r2, r3
    1296:	687b      	ldr	r3, [r7, #4]
    1298:	831a      	strh	r2, [r3, #24]
}
    129a:	f107 070c 	add.w	r7, r7, #12
    129e:	46bd      	mov	sp, r7
    12a0:	bc80      	pop	{r7}
    12a2:	4770      	bx	lr

000012a4 <dhcp_parse_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_parse_reply(struct dhcp *dhcp, struct pbuf *p)
{
    12a4:	b580      	push	{r7, lr}
    12a6:	b08e      	sub	sp, #56	; 0x38
    12a8:	af00      	add	r7, sp, #0
    12aa:	6078      	str	r0, [r7, #4]
    12ac:	6039      	str	r1, [r7, #0]
  u16_t offset;
  u16_t offset_max;
  u16_t options_idx;
  u16_t options_idx_max;
  struct pbuf *q;
  int parse_file_as_options = 0;
    12ae:	f04f 0300 	mov.w	r3, #0
    12b2:	627b      	str	r3, [r7, #36]	; 0x24
  int parse_sname_as_options = 0;
    12b4:	f04f 0300 	mov.w	r3, #0
    12b8:	623b      	str	r3, [r7, #32]

  /* clear received options */
  dhcp_clear_all_options(dhcp);
    12ba:	48a7      	ldr	r0, [pc, #668]	; (1558 <dhcp_parse_reply+0x2b4>)
    12bc:	f04f 0100 	mov.w	r1, #0
    12c0:	f04f 020a 	mov.w	r2, #10
    12c4:	f7ff fffe 	bl	0 <memset>
			12c4: R_ARM_THM_CALL	memset
  /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
  if (p->len < DHCP_SNAME_OFS) {
    12c8:	683b      	ldr	r3, [r7, #0]
    12ca:	895b      	ldrh	r3, [r3, #10]
    12cc:	2b2b      	cmp	r3, #43	; 0x2b
    12ce:	d802      	bhi.n	12d6 <dhcp_parse_reply+0x32>
    return ERR_BUF;
    12d0:	f04f 03fe 	mov.w	r3, #254	; 0xfe
    12d4:	e22d      	b.n	1732 <dhcp_parse_reply+0x48e>
  }
  dhcp->msg_in = (struct dhcp_msg *)p->payload;
    12d6:	683b      	ldr	r3, [r7, #0]
    12d8:	685b      	ldr	r3, [r3, #4]
    12da:	461a      	mov	r2, r3
    12dc:	687b      	ldr	r3, [r7, #4]
    12de:	609a      	str	r2, [r3, #8]
#endif /* LWIP_DHCP_BOOTP_FILE */

  /* parse options */

  /* start with options field */
  options_idx = DHCP_OPTIONS_OFS;
    12e0:	f04f 03f0 	mov.w	r3, #240	; 0xf0
    12e4:	85fb      	strh	r3, [r7, #46]	; 0x2e
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
    12e6:	683b      	ldr	r3, [r7, #0]
    12e8:	891b      	ldrh	r3, [r3, #8]
    12ea:	85bb      	strh	r3, [r7, #44]	; 0x2c
again:
  q = p;
    12ec:	683b      	ldr	r3, [r7, #0]
    12ee:	62bb      	str	r3, [r7, #40]	; 0x28
  while((q != NULL) && (options_idx >= q->len)) {
    12f0:	e00c      	b.n	130c <dhcp_parse_reply+0x68>
    options_idx -= q->len;
    12f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    12f4:	895b      	ldrh	r3, [r3, #10]
    12f6:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
    12f8:	1ad3      	subs	r3, r2, r3
    12fa:	85fb      	strh	r3, [r7, #46]	; 0x2e
    options_idx_max -= q->len;
    12fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    12fe:	895b      	ldrh	r3, [r3, #10]
    1300:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
    1302:	1ad3      	subs	r3, r2, r3
    1304:	85bb      	strh	r3, [r7, #44]	; 0x2c
    q = q->next;
    1306:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1308:	681b      	ldr	r3, [r3, #0]
    130a:	62bb      	str	r3, [r7, #40]	; 0x28
  options_idx = DHCP_OPTIONS_OFS;
  /* parse options to the end of the received packet */
  options_idx_max = p->tot_len;
again:
  q = p;
  while((q != NULL) && (options_idx >= q->len)) {
    130c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    130e:	2b00      	cmp	r3, #0
    1310:	d004      	beq.n	131c <dhcp_parse_reply+0x78>
    1312:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1314:	895b      	ldrh	r3, [r3, #10]
    1316:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
    1318:	429a      	cmp	r2, r3
    131a:	d2ea      	bcs.n	12f2 <dhcp_parse_reply+0x4e>
    options_idx -= q->len;
    options_idx_max -= q->len;
    q = q->next;
  }
  if (q == NULL) {
    131c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    131e:	2b00      	cmp	r3, #0
    1320:	d102      	bne.n	1328 <dhcp_parse_reply+0x84>
    return ERR_BUF;
    1322:	f04f 03fe 	mov.w	r3, #254	; 0xfe
    1326:	e204      	b.n	1732 <dhcp_parse_reply+0x48e>
  }
  offset = options_idx;
    1328:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
    132a:	867b      	strh	r3, [r7, #50]	; 0x32
  offset_max = options_idx_max;
    132c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
    132e:	863b      	strh	r3, [r7, #48]	; 0x30
  options = (u8_t*)q->payload;
    1330:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1332:	685b      	ldr	r3, [r3, #4]
    1334:	637b      	str	r3, [r7, #52]	; 0x34
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    1336:	e1b0      	b.n	169a <dhcp_parse_reply+0x3f6>
    u8_t op = options[offset];
    1338:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    133a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    133c:	18d3      	adds	r3, r2, r3
    133e:	781b      	ldrb	r3, [r3, #0]
    1340:	757b      	strb	r3, [r7, #21]
    u8_t len;
    u8_t decode_len = 0;
    1342:	f04f 0300 	mov.w	r3, #0
    1346:	77bb      	strb	r3, [r7, #30]
    int decode_idx = -1;
    1348:	f04f 33ff 	mov.w	r3, #4294967295
    134c:	61bb      	str	r3, [r7, #24]
    u16_t val_offset = offset + 2;
    134e:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    1350:	f103 0302 	add.w	r3, r3, #2
    1354:	82fb      	strh	r3, [r7, #22]
    /* len byte might be in the next pbuf */
    if (offset + 1 < q->len) {
    1356:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    1358:	f103 0201 	add.w	r2, r3, #1
    135c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    135e:	895b      	ldrh	r3, [r3, #10]
    1360:	429a      	cmp	r2, r3
    1362:	da07      	bge.n	1374 <dhcp_parse_reply+0xd0>
      len = options[offset + 1];
    1364:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    1366:	f103 0301 	add.w	r3, r3, #1
    136a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    136c:	18d3      	adds	r3, r2, r3
    136e:	781b      	ldrb	r3, [r3, #0]
    1370:	77fb      	strb	r3, [r7, #31]
    1372:	e00b      	b.n	138c <dhcp_parse_reply+0xe8>
    } else {
      len = (q->next != NULL ? ((u8_t*)q->next->payload)[0] : 0);
    1374:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1376:	681b      	ldr	r3, [r3, #0]
    1378:	2b00      	cmp	r3, #0
    137a:	d004      	beq.n	1386 <dhcp_parse_reply+0xe2>
    137c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    137e:	681b      	ldr	r3, [r3, #0]
    1380:	685b      	ldr	r3, [r3, #4]
    1382:	781b      	ldrb	r3, [r3, #0]
    1384:	e001      	b.n	138a <dhcp_parse_reply+0xe6>
    1386:	f04f 0300 	mov.w	r3, #0
    138a:	77fb      	strb	r3, [r7, #31]
    }
    /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
    decode_len = len;
    138c:	7ffb      	ldrb	r3, [r7, #31]
    138e:	77bb      	strb	r3, [r7, #30]
    switch(op) {
    1390:	7d7b      	ldrb	r3, [r7, #21]
    1392:	2b3b      	cmp	r3, #59	; 0x3b
    1394:	f200 80f6 	bhi.w	1584 <dhcp_parse_reply+0x2e0>
    1398:	a201      	add	r2, pc, #4	; (adr r2, 13a0 <dhcp_parse_reply+0xfc>)
    139a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    139e:	bf00      	nop
    13a0:	00001491 	.word	0x00001491
			13a0: R_ARM_ABS32	.text
    13a4:	000014a5 	.word	0x000014a5
			13a4: R_ARM_ABS32	.text
    13a8:	00001585 	.word	0x00001585
			13a8: R_ARM_ABS32	.text
    13ac:	000014b9 	.word	0x000014b9
			13ac: R_ARM_ABS32	.text
    13b0:	00001585 	.word	0x00001585
			13b0: R_ARM_ABS32	.text
    13b4:	00001585 	.word	0x00001585
			13b4: R_ARM_ABS32	.text
    13b8:	000014d5 	.word	0x000014d5
			13b8: R_ARM_ABS32	.text
    13bc:	00001585 	.word	0x00001585
			13bc: R_ARM_ABS32	.text
    13c0:	00001585 	.word	0x00001585
			13c0: R_ARM_ABS32	.text
    13c4:	00001585 	.word	0x00001585
			13c4: R_ARM_ABS32	.text
    13c8:	00001585 	.word	0x00001585
			13c8: R_ARM_ABS32	.text
    13cc:	00001585 	.word	0x00001585
			13cc: R_ARM_ABS32	.text
    13d0:	00001585 	.word	0x00001585
			13d0: R_ARM_ABS32	.text
    13d4:	00001585 	.word	0x00001585
			13d4: R_ARM_ABS32	.text
    13d8:	00001585 	.word	0x00001585
			13d8: R_ARM_ABS32	.text
    13dc:	00001585 	.word	0x00001585
			13dc: R_ARM_ABS32	.text
    13e0:	00001585 	.word	0x00001585
			13e0: R_ARM_ABS32	.text
    13e4:	00001585 	.word	0x00001585
			13e4: R_ARM_ABS32	.text
    13e8:	00001585 	.word	0x00001585
			13e8: R_ARM_ABS32	.text
    13ec:	00001585 	.word	0x00001585
			13ec: R_ARM_ABS32	.text
    13f0:	00001585 	.word	0x00001585
			13f0: R_ARM_ABS32	.text
    13f4:	00001585 	.word	0x00001585
			13f4: R_ARM_ABS32	.text
    13f8:	00001585 	.word	0x00001585
			13f8: R_ARM_ABS32	.text
    13fc:	00001585 	.word	0x00001585
			13fc: R_ARM_ABS32	.text
    1400:	00001585 	.word	0x00001585
			1400: R_ARM_ABS32	.text
    1404:	00001585 	.word	0x00001585
			1404: R_ARM_ABS32	.text
    1408:	00001585 	.word	0x00001585
			1408: R_ARM_ABS32	.text
    140c:	00001585 	.word	0x00001585
			140c: R_ARM_ABS32	.text
    1410:	00001585 	.word	0x00001585
			1410: R_ARM_ABS32	.text
    1414:	00001585 	.word	0x00001585
			1414: R_ARM_ABS32	.text
    1418:	00001585 	.word	0x00001585
			1418: R_ARM_ABS32	.text
    141c:	00001585 	.word	0x00001585
			141c: R_ARM_ABS32	.text
    1420:	00001585 	.word	0x00001585
			1420: R_ARM_ABS32	.text
    1424:	00001585 	.word	0x00001585
			1424: R_ARM_ABS32	.text
    1428:	00001585 	.word	0x00001585
			1428: R_ARM_ABS32	.text
    142c:	00001585 	.word	0x00001585
			142c: R_ARM_ABS32	.text
    1430:	00001585 	.word	0x00001585
			1430: R_ARM_ABS32	.text
    1434:	00001585 	.word	0x00001585
			1434: R_ARM_ABS32	.text
    1438:	00001585 	.word	0x00001585
			1438: R_ARM_ABS32	.text
    143c:	00001585 	.word	0x00001585
			143c: R_ARM_ABS32	.text
    1440:	00001585 	.word	0x00001585
			1440: R_ARM_ABS32	.text
    1444:	00001585 	.word	0x00001585
			1444: R_ARM_ABS32	.text
    1448:	00001585 	.word	0x00001585
			1448: R_ARM_ABS32	.text
    144c:	00001585 	.word	0x00001585
			144c: R_ARM_ABS32	.text
    1450:	00001585 	.word	0x00001585
			1450: R_ARM_ABS32	.text
    1454:	00001585 	.word	0x00001585
			1454: R_ARM_ABS32	.text
    1458:	00001585 	.word	0x00001585
			1458: R_ARM_ABS32	.text
    145c:	00001585 	.word	0x00001585
			145c: R_ARM_ABS32	.text
    1460:	00001585 	.word	0x00001585
			1460: R_ARM_ABS32	.text
    1464:	00001585 	.word	0x00001585
			1464: R_ARM_ABS32	.text
    1468:	00001585 	.word	0x00001585
			1468: R_ARM_ABS32	.text
    146c:	00001507 	.word	0x00001507
			146c: R_ARM_ABS32	.text
    1470:	0000151b 	.word	0x0000151b
			1470: R_ARM_ABS32	.text
    1474:	0000152f 	.word	0x0000152f
			1474: R_ARM_ABS32	.text
    1478:	00001543 	.word	0x00001543
			1478: R_ARM_ABS32	.text
    147c:	00001585 	.word	0x00001585
			147c: R_ARM_ABS32	.text
    1480:	00001585 	.word	0x00001585
			1480: R_ARM_ABS32	.text
    1484:	00001585 	.word	0x00001585
			1484: R_ARM_ABS32	.text
    1488:	0000155d 	.word	0x0000155d
			1488: R_ARM_ABS32	.text
    148c:	00001571 	.word	0x00001571
			148c: R_ARM_ABS32	.text
      /* case(DHCP_OPTION_END): handled above */
      case(DHCP_OPTION_PAD):
        /* special option: no len encoded */
        decode_len = len = 0;
    1490:	f04f 0300 	mov.w	r3, #0
    1494:	77fb      	strb	r3, [r7, #31]
    1496:	7ffb      	ldrb	r3, [r7, #31]
    1498:	77bb      	strb	r3, [r7, #30]
        /* will be increased below */
        offset--;
    149a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    149c:	f103 33ff 	add.w	r3, r3, #4294967295
    14a0:	867b      	strh	r3, [r7, #50]	; 0x32
        break;
    14a2:	e073      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_SUBNET_MASK):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    14a4:	7ffb      	ldrb	r3, [r7, #31]
    14a6:	2b04      	cmp	r3, #4
    14a8:	d002      	beq.n	14b0 <dhcp_parse_reply+0x20c>
    14aa:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    14ae:	e140      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
    14b0:	f04f 0306 	mov.w	r3, #6
    14b4:	61bb      	str	r3, [r7, #24]
        break;
    14b6:	e069      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_ROUTER):
        decode_len = 4; /* only copy the first given router */
    14b8:	f04f 0304 	mov.w	r3, #4
    14bc:	77bb      	strb	r3, [r7, #30]
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    14be:	7ffa      	ldrb	r2, [r7, #31]
    14c0:	7fbb      	ldrb	r3, [r7, #30]
    14c2:	429a      	cmp	r2, r3
    14c4:	d202      	bcs.n	14cc <dhcp_parse_reply+0x228>
    14c6:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    14ca:	e132      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_ROUTER;
    14cc:	f04f 0307 	mov.w	r3, #7
    14d0:	61bb      	str	r3, [r7, #24]
        break;
    14d2:	e05b      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_DNS_SERVER):
        /* special case: there might be more than one server */
        LWIP_ERROR("len % 4 == 0", len % 4 == 0, return ERR_VAL;);
    14d4:	7ffb      	ldrb	r3, [r7, #31]
    14d6:	f003 0303 	and.w	r3, r3, #3
    14da:	b2db      	uxtb	r3, r3
    14dc:	2b00      	cmp	r3, #0
    14de:	d002      	beq.n	14e6 <dhcp_parse_reply+0x242>
    14e0:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    14e4:	e125      	b.n	1732 <dhcp_parse_reply+0x48e>
        /* limit number of DNS servers */
        decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
    14e6:	7ffb      	ldrb	r3, [r7, #31]
    14e8:	2b08      	cmp	r3, #8
    14ea:	bf28      	it	cs
    14ec:	2308      	movcs	r3, #8
    14ee:	77bb      	strb	r3, [r7, #30]
        LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
    14f0:	7ffa      	ldrb	r2, [r7, #31]
    14f2:	7fbb      	ldrb	r3, [r7, #30]
    14f4:	429a      	cmp	r2, r3
    14f6:	d202      	bcs.n	14fe <dhcp_parse_reply+0x25a>
    14f8:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    14fc:	e119      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
    14fe:	f04f 0308 	mov.w	r3, #8
    1502:	61bb      	str	r3, [r7, #24]
        break;
    1504:	e042      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_LEASE_TIME):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    1506:	7ffb      	ldrb	r3, [r7, #31]
    1508:	2b04      	cmp	r3, #4
    150a:	d002      	beq.n	1512 <dhcp_parse_reply+0x26e>
    150c:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    1510:	e10f      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
    1512:	f04f 0303 	mov.w	r3, #3
    1516:	61bb      	str	r3, [r7, #24]
        break;
    1518:	e038      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_OVERLOAD):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    151a:	7ffb      	ldrb	r3, [r7, #31]
    151c:	2b01      	cmp	r3, #1
    151e:	d002      	beq.n	1526 <dhcp_parse_reply+0x282>
    1520:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    1524:	e105      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_OVERLOAD;
    1526:	f04f 0300 	mov.w	r3, #0
    152a:	61bb      	str	r3, [r7, #24]
        break;
    152c:	e02e      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_MESSAGE_TYPE):
        LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
    152e:	7ffb      	ldrb	r3, [r7, #31]
    1530:	2b01      	cmp	r3, #1
    1532:	d002      	beq.n	153a <dhcp_parse_reply+0x296>
    1534:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    1538:	e0fb      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
    153a:	f04f 0301 	mov.w	r3, #1
    153e:	61bb      	str	r3, [r7, #24]
        break;
    1540:	e024      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_SERVER_ID):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    1542:	7ffb      	ldrb	r3, [r7, #31]
    1544:	2b04      	cmp	r3, #4
    1546:	d002      	beq.n	154e <dhcp_parse_reply+0x2aa>
    1548:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    154c:	e0f1      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_SERVER_ID;
    154e:	f04f 0302 	mov.w	r3, #2
    1552:	61bb      	str	r3, [r7, #24]
        break;
    1554:	e01a      	b.n	158c <dhcp_parse_reply+0x2e8>
    1556:	bf00      	nop
    1558:	00000000 	.word	0x00000000
			1558: R_ARM_ABS32	dhcp_rx_options_given
      case(DHCP_OPTION_T1):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    155c:	7ffb      	ldrb	r3, [r7, #31]
    155e:	2b04      	cmp	r3, #4
    1560:	d002      	beq.n	1568 <dhcp_parse_reply+0x2c4>
    1562:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    1566:	e0e4      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_T1;
    1568:	f04f 0304 	mov.w	r3, #4
    156c:	61bb      	str	r3, [r7, #24]
        break;
    156e:	e00d      	b.n	158c <dhcp_parse_reply+0x2e8>
      case(DHCP_OPTION_T2):
        LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
    1570:	7ffb      	ldrb	r3, [r7, #31]
    1572:	2b04      	cmp	r3, #4
    1574:	d002      	beq.n	157c <dhcp_parse_reply+0x2d8>
    1576:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    157a:	e0da      	b.n	1732 <dhcp_parse_reply+0x48e>
        decode_idx = DHCP_OPTION_IDX_T2;
    157c:	f04f 0305 	mov.w	r3, #5
    1580:	61bb      	str	r3, [r7, #24]
        break;
    1582:	e003      	b.n	158c <dhcp_parse_reply+0x2e8>
      default:
        decode_len = 0;
    1584:	f04f 0300 	mov.w	r3, #0
    1588:	77bb      	strb	r3, [r7, #30]
        LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", op));
        break;
    158a:	bf00      	nop
    }
    offset += len + 2;
    158c:	7ffb      	ldrb	r3, [r7, #31]
    158e:	b29a      	uxth	r2, r3
    1590:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    1592:	18d3      	adds	r3, r2, r3
    1594:	b29b      	uxth	r3, r3
    1596:	f103 0302 	add.w	r3, r3, #2
    159a:	867b      	strh	r3, [r7, #50]	; 0x32
    if (decode_len > 0) {
    159c:	7fbb      	ldrb	r3, [r7, #30]
    159e:	2b00      	cmp	r3, #0
    15a0:	d05f      	beq.n	1662 <dhcp_parse_reply+0x3be>
      u32_t value = 0;
    15a2:	f04f 0300 	mov.w	r3, #0
    15a6:	60bb      	str	r3, [r7, #8]
      u16_t copy_len;
decode_next:
      LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
      if (!dhcp_option_given(dhcp, decode_idx)) {
    15a8:	4a65      	ldr	r2, [pc, #404]	; (1740 <dhcp_parse_reply+0x49c>)
    15aa:	69bb      	ldr	r3, [r7, #24]
    15ac:	18d3      	adds	r3, r2, r3
    15ae:	781b      	ldrb	r3, [r3, #0]
    15b0:	2b00      	cmp	r3, #0
    15b2:	d156      	bne.n	1662 <dhcp_parse_reply+0x3be>
        copy_len = LWIP_MIN(decode_len, 4);
    15b4:	7fbb      	ldrb	r3, [r7, #30]
    15b6:	2b03      	cmp	r3, #3
    15b8:	d802      	bhi.n	15c0 <dhcp_parse_reply+0x31c>
    15ba:	7fbb      	ldrb	r3, [r7, #30]
    15bc:	b29b      	uxth	r3, r3
    15be:	e001      	b.n	15c4 <dhcp_parse_reply+0x320>
    15c0:	f04f 0304 	mov.w	r3, #4
    15c4:	827b      	strh	r3, [r7, #18]
        pbuf_copy_partial(q, &value, copy_len, val_offset);
    15c6:	f107 0108 	add.w	r1, r7, #8
    15ca:	8a7a      	ldrh	r2, [r7, #18]
    15cc:	8afb      	ldrh	r3, [r7, #22]
    15ce:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    15d0:	f7ff fffe 	bl	0 <pbuf_copy_partial>
			15d0: R_ARM_THM_CALL	pbuf_copy_partial
        if (decode_len > 4) {
    15d4:	7fbb      	ldrb	r3, [r7, #30]
    15d6:	2b04      	cmp	r3, #4
    15d8:	d924      	bls.n	1624 <dhcp_parse_reply+0x380>
          /* decode more than one u32_t */
          LWIP_ERROR("decode_len % 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
    15da:	7fbb      	ldrb	r3, [r7, #30]
    15dc:	f003 0303 	and.w	r3, r3, #3
    15e0:	b2db      	uxtb	r3, r3
    15e2:	2b00      	cmp	r3, #0
    15e4:	d002      	beq.n	15ec <dhcp_parse_reply+0x348>
    15e6:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    15ea:	e0a2      	b.n	1732 <dhcp_parse_reply+0x48e>
          dhcp_got_option(dhcp, decode_idx);
    15ec:	4a54      	ldr	r2, [pc, #336]	; (1740 <dhcp_parse_reply+0x49c>)
    15ee:	69bb      	ldr	r3, [r7, #24]
    15f0:	18d3      	adds	r3, r2, r3
    15f2:	f04f 0201 	mov.w	r2, #1
    15f6:	701a      	strb	r2, [r3, #0]
          dhcp_set_option_value(dhcp, decode_idx, htonl(value));
    15f8:	68bb      	ldr	r3, [r7, #8]
    15fa:	4618      	mov	r0, r3
    15fc:	f7ff fffe 	bl	0 <lwip_htonl>
			15fc: R_ARM_THM_CALL	lwip_htonl
    1600:	4601      	mov	r1, r0
    1602:	4b50      	ldr	r3, [pc, #320]	; (1744 <dhcp_parse_reply+0x4a0>)
    1604:	69ba      	ldr	r2, [r7, #24]
    1606:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
          decode_len -= 4;
    160a:	7fbb      	ldrb	r3, [r7, #30]
    160c:	f1a3 0304 	sub.w	r3, r3, #4
    1610:	77bb      	strb	r3, [r7, #30]
          val_offset += 4;
    1612:	8afb      	ldrh	r3, [r7, #22]
    1614:	f103 0304 	add.w	r3, r3, #4
    1618:	82fb      	strh	r3, [r7, #22]
          decode_idx++;
    161a:	69bb      	ldr	r3, [r7, #24]
    161c:	f103 0301 	add.w	r3, r3, #1
    1620:	61bb      	str	r3, [r7, #24]
          goto decode_next;
    1622:	e7c1      	b.n	15a8 <dhcp_parse_reply+0x304>
        } else if (decode_len == 4) {
    1624:	7fbb      	ldrb	r3, [r7, #30]
    1626:	2b04      	cmp	r3, #4
    1628:	d106      	bne.n	1638 <dhcp_parse_reply+0x394>
          value = ntohl(value);
    162a:	68bb      	ldr	r3, [r7, #8]
    162c:	4618      	mov	r0, r3
    162e:	f7ff fffe 	bl	0 <lwip_ntohl>
			162e: R_ARM_THM_CALL	lwip_ntohl
    1632:	4603      	mov	r3, r0
    1634:	60bb      	str	r3, [r7, #8]
    1636:	e009      	b.n	164c <dhcp_parse_reply+0x3a8>
        } else {
          LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
    1638:	7fbb      	ldrb	r3, [r7, #30]
    163a:	2b01      	cmp	r3, #1
    163c:	d002      	beq.n	1644 <dhcp_parse_reply+0x3a0>
    163e:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    1642:	e076      	b.n	1732 <dhcp_parse_reply+0x48e>
          value = ((u8_t*)&value)[0];
    1644:	f107 0308 	add.w	r3, r7, #8
    1648:	781b      	ldrb	r3, [r3, #0]
    164a:	60bb      	str	r3, [r7, #8]
        }
        dhcp_got_option(dhcp, decode_idx);
    164c:	4a3c      	ldr	r2, [pc, #240]	; (1740 <dhcp_parse_reply+0x49c>)
    164e:	69bb      	ldr	r3, [r7, #24]
    1650:	18d3      	adds	r3, r2, r3
    1652:	f04f 0201 	mov.w	r2, #1
    1656:	701a      	strb	r2, [r3, #0]
        dhcp_set_option_value(dhcp, decode_idx, value);
    1658:	68b9      	ldr	r1, [r7, #8]
    165a:	4b3a      	ldr	r3, [pc, #232]	; (1744 <dhcp_parse_reply+0x4a0>)
    165c:	69ba      	ldr	r2, [r7, #24]
    165e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }
    }
    if (offset >= q->len) {
    1662:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1664:	895b      	ldrh	r3, [r3, #10]
    1666:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
    1668:	429a      	cmp	r2, r3
    166a:	d316      	bcc.n	169a <dhcp_parse_reply+0x3f6>
      offset -= q->len;
    166c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    166e:	895b      	ldrh	r3, [r3, #10]
    1670:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
    1672:	1ad3      	subs	r3, r2, r3
    1674:	867b      	strh	r3, [r7, #50]	; 0x32
      offset_max -= q->len;
    1676:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1678:	895b      	ldrh	r3, [r3, #10]
    167a:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
    167c:	1ad3      	subs	r3, r2, r3
    167e:	863b      	strh	r3, [r7, #48]	; 0x30
      if ((offset < offset_max) && offset_max) {
    1680:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
    1682:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    1684:	429a      	cmp	r2, r3
    1686:	d216      	bcs.n	16b6 <dhcp_parse_reply+0x412>
    1688:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    168a:	2b00      	cmp	r3, #0
    168c:	d013      	beq.n	16b6 <dhcp_parse_reply+0x412>
        q = q->next;
    168e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1690:	681b      	ldr	r3, [r3, #0]
    1692:	62bb      	str	r3, [r7, #40]	; 0x28
        LWIP_ASSERT("next pbuf was null", q);
        options = (u8_t*)q->payload;
    1694:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1696:	685b      	ldr	r3, [r3, #4]
    1698:	637b      	str	r3, [r7, #52]	; 0x34
  }
  offset = options_idx;
  offset_max = options_idx_max;
  options = (u8_t*)q->payload;
  /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
  while((q != NULL) && (options[offset] != DHCP_OPTION_END) && (offset < offset_max)) {
    169a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    169c:	2b00      	cmp	r3, #0
    169e:	d00a      	beq.n	16b6 <dhcp_parse_reply+0x412>
    16a0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
    16a2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    16a4:	18d3      	adds	r3, r2, r3
    16a6:	781b      	ldrb	r3, [r3, #0]
    16a8:	2bff      	cmp	r3, #255	; 0xff
    16aa:	d004      	beq.n	16b6 <dhcp_parse_reply+0x412>
    16ac:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
    16ae:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
    16b0:	429a      	cmp	r2, r3
    16b2:	f4ff ae41 	bcc.w	1338 <dhcp_parse_reply+0x94>
        break;
      }
    }
  }
  /* is this an overloaded message? */
  if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
    16b6:	4b22      	ldr	r3, [pc, #136]	; (1740 <dhcp_parse_reply+0x49c>)
    16b8:	781b      	ldrb	r3, [r3, #0]
    16ba:	2b00      	cmp	r3, #0
    16bc:	d01d      	beq.n	16fa <dhcp_parse_reply+0x456>
    u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    16be:	4b21      	ldr	r3, [pc, #132]	; (1744 <dhcp_parse_reply+0x4a0>)
    16c0:	681b      	ldr	r3, [r3, #0]
    16c2:	60fb      	str	r3, [r7, #12]
    dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
    16c4:	4b1e      	ldr	r3, [pc, #120]	; (1740 <dhcp_parse_reply+0x49c>)
    16c6:	f04f 0200 	mov.w	r2, #0
    16ca:	701a      	strb	r2, [r3, #0]
    if (overload == DHCP_OVERLOAD_FILE) {
    16cc:	68fb      	ldr	r3, [r7, #12]
    16ce:	2b01      	cmp	r3, #1
    16d0:	d103      	bne.n	16da <dhcp_parse_reply+0x436>
      parse_file_as_options = 1;
    16d2:	f04f 0301 	mov.w	r3, #1
    16d6:	627b      	str	r3, [r7, #36]	; 0x24
    16d8:	e00f      	b.n	16fa <dhcp_parse_reply+0x456>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME) {
    16da:	68fb      	ldr	r3, [r7, #12]
    16dc:	2b02      	cmp	r3, #2
    16de:	d103      	bne.n	16e8 <dhcp_parse_reply+0x444>
      parse_sname_as_options = 1;
    16e0:	f04f 0301 	mov.w	r3, #1
    16e4:	623b      	str	r3, [r7, #32]
    16e6:	e008      	b.n	16fa <dhcp_parse_reply+0x456>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
    } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
    16e8:	68fb      	ldr	r3, [r7, #12]
    16ea:	2b03      	cmp	r3, #3
    16ec:	d105      	bne.n	16fa <dhcp_parse_reply+0x456>
      parse_sname_as_options = 1;
    16ee:	f04f 0301 	mov.w	r3, #1
    16f2:	623b      	str	r3, [r7, #32]
      parse_file_as_options = 1;
    16f4:	f04f 0301 	mov.w	r3, #1
    16f8:	627b      	str	r3, [r7, #36]	; 0x24
      /* make sure the string is really NULL-terminated */
      dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
    }
#endif /* LWIP_DHCP_BOOTP_FILE */
  }
  if (parse_file_as_options) {
    16fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    16fc:	2b00      	cmp	r3, #0
    16fe:	d009      	beq.n	1714 <dhcp_parse_reply+0x470>
    /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
    parse_file_as_options = 0;
    1700:	f04f 0300 	mov.w	r3, #0
    1704:	627b      	str	r3, [r7, #36]	; 0x24
    options_idx = DHCP_FILE_OFS;
    1706:	f04f 036c 	mov.w	r3, #108	; 0x6c
    170a:	85fb      	strh	r3, [r7, #46]	; 0x2e
    options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
    170c:	f04f 03ec 	mov.w	r3, #236	; 0xec
    1710:	85bb      	strh	r3, [r7, #44]	; 0x2c
    goto again;
    1712:	e5eb      	b.n	12ec <dhcp_parse_reply+0x48>
  } else if (parse_sname_as_options) {
    1714:	6a3b      	ldr	r3, [r7, #32]
    1716:	2b00      	cmp	r3, #0
    1718:	d009      	beq.n	172e <dhcp_parse_reply+0x48a>
    parse_sname_as_options = 0;
    171a:	f04f 0300 	mov.w	r3, #0
    171e:	623b      	str	r3, [r7, #32]
    options_idx = DHCP_SNAME_OFS;
    1720:	f04f 032c 	mov.w	r3, #44	; 0x2c
    1724:	85fb      	strh	r3, [r7, #46]	; 0x2e
    options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
    1726:	f04f 036c 	mov.w	r3, #108	; 0x6c
    172a:	85bb      	strh	r3, [r7, #44]	; 0x2c
    goto again;
    172c:	e5de      	b.n	12ec <dhcp_parse_reply+0x48>
  }
  return ERR_OK;
    172e:	f04f 0300 	mov.w	r3, #0
    1732:	b25b      	sxtb	r3, r3
}
    1734:	4618      	mov	r0, r3
    1736:	f107 0738 	add.w	r7, r7, #56	; 0x38
    173a:	46bd      	mov	sp, r7
    173c:	bd80      	pop	{r7, pc}
    173e:	bf00      	nop
	...
			1740: R_ARM_ABS32	dhcp_rx_options_given
			1744: R_ARM_ABS32	dhcp_rx_options_val

00001748 <dhcp_recv>:
/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void
dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
    1748:	b580      	push	{r7, lr}
    174a:	b08a      	sub	sp, #40	; 0x28
    174c:	af00      	add	r7, sp, #0
    174e:	60f8      	str	r0, [r7, #12]
    1750:	60b9      	str	r1, [r7, #8]
    1752:	607a      	str	r2, [r7, #4]
    1754:	603b      	str	r3, [r7, #0]
  struct netif *netif = (struct netif *)arg;
    1756:	68fb      	ldr	r3, [r7, #12]
    1758:	623b      	str	r3, [r7, #32]
  struct dhcp *dhcp = netif->dhcp;
    175a:	6a3b      	ldr	r3, [r7, #32]
    175c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    175e:	61fb      	str	r3, [r7, #28]
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
    1760:	687b      	ldr	r3, [r7, #4]
    1762:	685b      	ldr	r3, [r3, #4]
    1764:	61bb      	str	r3, [r7, #24]
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    1766:	687b      	ldr	r3, [r7, #4]
    1768:	895b      	ldrh	r3, [r3, #10]
    176a:	2b2b      	cmp	r3, #43	; 0x2b
    176c:	d97e      	bls.n	186c <dhcp_recv+0x124>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    176e:	69bb      	ldr	r3, [r7, #24]
    1770:	781b      	ldrb	r3, [r3, #0]
    1772:	2b02      	cmp	r3, #2
    1774:	d17c      	bne.n	1870 <dhcp_recv+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    1776:	f04f 0300 	mov.w	r3, #0
    177a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    177e:	e012      	b.n	17a6 <dhcp_recv+0x5e>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
    1780:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    1784:	6a3a      	ldr	r2, [r7, #32]
    1786:	18d3      	adds	r3, r2, r3
    1788:	f893 202f 	ldrb.w	r2, [r3, #47]	; 0x2f
    178c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    1790:	69b9      	ldr	r1, [r7, #24]
    1792:	18cb      	adds	r3, r1, r3
    1794:	7f1b      	ldrb	r3, [r3, #28]
    1796:	429a      	cmp	r2, r3
    1798:	d16c      	bne.n	1874 <dhcp_recv+0x12c>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    179a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    179e:	f103 0301 	add.w	r3, r3, #1
    17a2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    17a6:	6a3b      	ldr	r3, [r7, #32]
    17a8:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
    17ac:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
    17b0:	429a      	cmp	r2, r3
    17b2:	d3e5      	bcc.n	1780 <dhcp_recv+0x38>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    17b4:	69bb      	ldr	r3, [r7, #24]
    17b6:	685b      	ldr	r3, [r3, #4]
    17b8:	4618      	mov	r0, r3
    17ba:	f7ff fffe 	bl	0 <lwip_ntohl>
			17ba: R_ARM_THM_CALL	lwip_ntohl
    17be:	4602      	mov	r2, r0
    17c0:	69fb      	ldr	r3, [r7, #28]
    17c2:	681b      	ldr	r3, [r3, #0]
    17c4:	429a      	cmp	r2, r3
    17c6:	d157      	bne.n	1878 <dhcp_recv+0x130>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    17c8:	69f8      	ldr	r0, [r7, #28]
    17ca:	6879      	ldr	r1, [r7, #4]
    17cc:	f7ff fd6a 	bl	12a4 <dhcp_parse_reply>
    17d0:	4603      	mov	r3, r0
    17d2:	2b00      	cmp	r3, #0
    17d4:	d152      	bne.n	187c <dhcp_recv+0x134>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    17d6:	4b30      	ldr	r3, [pc, #192]	; (1898 <dhcp_recv+0x150>)
    17d8:	785b      	ldrb	r3, [r3, #1]
    17da:	2b00      	cmp	r3, #0
    17dc:	d050      	beq.n	1880 <dhcp_recv+0x138>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
    17de:	4b2f      	ldr	r3, [pc, #188]	; (189c <dhcp_recv+0x154>)
    17e0:	685b      	ldr	r3, [r3, #4]
    17e2:	75fb      	strb	r3, [r7, #23]
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
    17e4:	7dfb      	ldrb	r3, [r7, #23]
    17e6:	2b05      	cmp	r3, #5
    17e8:	d11a      	bne.n	1820 <dhcp_recv+0xd8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
    17ea:	69fb      	ldr	r3, [r7, #28]
    17ec:	7b1b      	ldrb	r3, [r3, #12]
    17ee:	2b01      	cmp	r3, #1
    17f0:	d106      	bne.n	1800 <dhcp_recv+0xb8>
      dhcp_handle_ack(netif);
    17f2:	6a38      	ldr	r0, [r7, #32]
    17f4:	f7fe fe3c 	bl	470 <dhcp_handle_ack>
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
    17f8:	6a38      	ldr	r0, [r7, #32]
    17fa:	f7fe fc25 	bl	48 <dhcp_check>
    17fe:	e040      	b.n	1882 <dhcp_recv+0x13a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
    1800:	69fb      	ldr	r3, [r7, #28]
    1802:	7b1b      	ldrb	r3, [r3, #12]
    1804:	2b03      	cmp	r3, #3
    1806:	d007      	beq.n	1818 <dhcp_recv+0xd0>
    1808:	69fb      	ldr	r3, [r7, #28]
    180a:	7b1b      	ldrb	r3, [r3, #12]
    180c:	2b04      	cmp	r3, #4
    180e:	d003      	beq.n	1818 <dhcp_recv+0xd0>
    1810:	69fb      	ldr	r3, [r7, #28]
    1812:	7b1b      	ldrb	r3, [r3, #12]
    1814:	2b05      	cmp	r3, #5
    1816:	d134      	bne.n	1882 <dhcp_recv+0x13a>
      dhcp_bind(netif);
    1818:	6a38      	ldr	r0, [r7, #32]
    181a:	f7ff f96f 	bl	afc <dhcp_bind>
    181e:	e030      	b.n	1882 <dhcp_recv+0x13a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    1820:	7dfb      	ldrb	r3, [r7, #23]
    1822:	2b06      	cmp	r3, #6
    1824:	d113      	bne.n	184e <dhcp_recv+0x106>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    1826:	69fb      	ldr	r3, [r7, #28]
    1828:	7b1b      	ldrb	r3, [r3, #12]
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    182a:	2b03      	cmp	r3, #3
    182c:	d00b      	beq.n	1846 <dhcp_recv+0xfe>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    182e:	69fb      	ldr	r3, [r7, #28]
    1830:	7b1b      	ldrb	r3, [r3, #12]
    1832:	2b01      	cmp	r3, #1
    1834:	d007      	beq.n	1846 <dhcp_recv+0xfe>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    1836:	69fb      	ldr	r3, [r7, #28]
    1838:	7b1b      	ldrb	r3, [r3, #12]
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
    183a:	2b04      	cmp	r3, #4
    183c:	d003      	beq.n	1846 <dhcp_recv+0xfe>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    183e:	69fb      	ldr	r3, [r7, #28]
    1840:	7b1b      	ldrb	r3, [r3, #12]
    1842:	2b05      	cmp	r3, #5
    1844:	d103      	bne.n	184e <dhcp_recv+0x106>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
    dhcp_handle_nak(netif);
    1846:	6a38      	ldr	r0, [r7, #32]
    1848:	f7fe fbda 	bl	0 <dhcp_handle_nak>
    184c:	e019      	b.n	1882 <dhcp_recv+0x13a>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
    184e:	7dfb      	ldrb	r3, [r7, #23]
    1850:	2b02      	cmp	r3, #2
    1852:	d116      	bne.n	1882 <dhcp_recv+0x13a>
    1854:	69fb      	ldr	r3, [r7, #28]
    1856:	7b1b      	ldrb	r3, [r3, #12]
    1858:	2b06      	cmp	r3, #6
    185a:	d112      	bne.n	1882 <dhcp_recv+0x13a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
    185c:	69fb      	ldr	r3, [r7, #28]
    185e:	f04f 0200 	mov.w	r2, #0
    1862:	835a      	strh	r2, [r3, #26]
    /* remember offered lease */
    dhcp_handle_offer(netif);
    1864:	6a38      	ldr	r0, [r7, #32]
    1866:	f7fe fc27 	bl	b8 <dhcp_handle_offer>
    186a:	e00a      	b.n	1882 <dhcp_recv+0x13a>

  LWIP_ASSERT("reply wasn't freed", dhcp->msg_in == NULL);

  if (p->len < DHCP_MIN_REPLY_LEN) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
    goto free_pbuf_and_return;
    186c:	bf00      	nop
    186e:	e008      	b.n	1882 <dhcp_recv+0x13a>
  }

  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
    1870:	bf00      	nop
    1872:	e006      	b.n	1882 <dhcp_recv+0x13a>
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
        ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    1874:	bf00      	nop
    1876:	e004      	b.n	1882 <dhcp_recv+0x13a>
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
    1878:	bf00      	nop
    187a:	e002      	b.n	1882 <dhcp_recv+0x13a>
  }
  /* option fields could be unfold? */
  if (dhcp_parse_reply(dhcp, p) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
    187c:	bf00      	nop
    187e:	e000      	b.n	1882 <dhcp_recv+0x13a>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
    1880:	bf00      	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  dhcp->msg_in = NULL;
    1882:	69fb      	ldr	r3, [r7, #28]
    1884:	f04f 0200 	mov.w	r2, #0
    1888:	609a      	str	r2, [r3, #8]
  pbuf_free(p);
    188a:	6878      	ldr	r0, [r7, #4]
    188c:	f7ff fffe 	bl	0 <pbuf_free>
			188c: R_ARM_THM_CALL	pbuf_free
}
    1890:	f107 0728 	add.w	r7, r7, #40	; 0x28
    1894:	46bd      	mov	sp, r7
    1896:	bd80      	pop	{r7, pc}
	...
			1898: R_ARM_ABS32	dhcp_rx_options_given
			189c: R_ARM_ABS32	dhcp_rx_options_val

000018a0 <dhcp_create_msg>:
 * @param dhcp dhcp control struct
 * @param message_type message type of the request
 */
static err_t
dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type)
{
    18a0:	b590      	push	{r4, r7, lr}
    18a2:	b087      	sub	sp, #28
    18a4:	af00      	add	r7, sp, #0
    18a6:	60f8      	str	r0, [r7, #12]
    18a8:	60b9      	str	r1, [r7, #8]
    18aa:	4613      	mov	r3, r2
    18ac:	71fb      	strb	r3, [r7, #7]
  if (!xid_initialised) {
    xid = DHCP_GLOBAL_XID;
    xid_initialised = !xid_initialised;
  }
#endif
  LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return ERR_ARG;);
    18ae:	68fb      	ldr	r3, [r7, #12]
    18b0:	2b00      	cmp	r3, #0
    18b2:	d102      	bne.n	18ba <dhcp_create_msg+0x1a>
    18b4:	f04f 03f2 	mov.w	r3, #242	; 0xf2
    18b8:	e12d      	b.n	1b16 <dhcp_create_msg+0x276>
  LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
    18ba:	68bb      	ldr	r3, [r7, #8]
    18bc:	2b00      	cmp	r3, #0
    18be:	d102      	bne.n	18c6 <dhcp_create_msg+0x26>
    18c0:	f04f 03fa 	mov.w	r3, #250	; 0xfa
    18c4:	e127      	b.n	1b16 <dhcp_create_msg+0x276>
  LWIP_ASSERT("dhcp_create_msg: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_msg: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
    18c6:	f04f 0000 	mov.w	r0, #0
    18ca:	f44f 719a 	mov.w	r1, #308	; 0x134
    18ce:	f04f 0200 	mov.w	r2, #0
    18d2:	f7ff fffe 	bl	0 <pbuf_alloc>
			18d2: R_ARM_THM_CALL	pbuf_alloc
    18d6:	4602      	mov	r2, r0
    18d8:	68bb      	ldr	r3, [r7, #8]
    18da:	611a      	str	r2, [r3, #16]
  if (dhcp->p_out == NULL) {
    18dc:	68bb      	ldr	r3, [r7, #8]
    18de:	691b      	ldr	r3, [r3, #16]
    18e0:	2b00      	cmp	r3, #0
    18e2:	d102      	bne.n	18ea <dhcp_create_msg+0x4a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("dhcp_create_msg(): could not allocate pbuf\n"));
    return ERR_MEM;
    18e4:	f04f 03ff 	mov.w	r3, #255	; 0xff
    18e8:	e115      	b.n	1b16 <dhcp_create_msg+0x276>
  }
  LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* reuse transaction identifier in retransmissions */
  if (dhcp->tries == 0) {
    18ea:	68bb      	ldr	r3, [r7, #8]
    18ec:	7b5b      	ldrb	r3, [r3, #13]
    18ee:	2b00      	cmp	r3, #0
    18f0:	d105      	bne.n	18fe <dhcp_create_msg+0x5e>
#if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
    xid = LWIP_RAND();
#else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
    xid++;
    18f2:	4b79      	ldr	r3, [pc, #484]	; (1ad8 <dhcp_create_msg+0x238>)
    18f4:	681b      	ldr	r3, [r3, #0]
    18f6:	f103 0201 	add.w	r2, r3, #1
    18fa:	4b77      	ldr	r3, [pc, #476]	; (1ad8 <dhcp_create_msg+0x238>)
    18fc:	601a      	str	r2, [r3, #0]
#endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
  }
  dhcp->xid = xid;
    18fe:	4b76      	ldr	r3, [pc, #472]	; (1ad8 <dhcp_create_msg+0x238>)
    1900:	681a      	ldr	r2, [r3, #0]
    1902:	68bb      	ldr	r3, [r7, #8]
    1904:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
              ("transaction id xid(%"X32_F")\n", xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
    1906:	68bb      	ldr	r3, [r7, #8]
    1908:	691b      	ldr	r3, [r3, #16]
    190a:	685b      	ldr	r3, [r3, #4]
    190c:	461a      	mov	r2, r3
    190e:	68bb      	ldr	r3, [r7, #8]
    1910:	615a      	str	r2, [r3, #20]

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
    1912:	68bb      	ldr	r3, [r7, #8]
    1914:	695b      	ldr	r3, [r3, #20]
    1916:	f04f 0201 	mov.w	r2, #1
    191a:	701a      	strb	r2, [r3, #0]
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
    191c:	68bb      	ldr	r3, [r7, #8]
    191e:	695b      	ldr	r3, [r3, #20]
    1920:	f04f 0201 	mov.w	r2, #1
    1924:	705a      	strb	r2, [r3, #1]
  dhcp->msg_out->hlen = netif->hwaddr_len;
    1926:	68bb      	ldr	r3, [r7, #8]
    1928:	695b      	ldr	r3, [r3, #20]
    192a:	68fa      	ldr	r2, [r7, #12]
    192c:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
    1930:	709a      	strb	r2, [r3, #2]
  dhcp->msg_out->hops = 0;
    1932:	68bb      	ldr	r3, [r7, #8]
    1934:	695b      	ldr	r3, [r3, #20]
    1936:	f04f 0200 	mov.w	r2, #0
    193a:	70da      	strb	r2, [r3, #3]
  dhcp->msg_out->xid = htonl(dhcp->xid);
    193c:	68bb      	ldr	r3, [r7, #8]
    193e:	695c      	ldr	r4, [r3, #20]
    1940:	68bb      	ldr	r3, [r7, #8]
    1942:	681b      	ldr	r3, [r3, #0]
    1944:	4618      	mov	r0, r3
    1946:	f7ff fffe 	bl	0 <lwip_htonl>
			1946: R_ARM_THM_CALL	lwip_htonl
    194a:	4603      	mov	r3, r0
    194c:	6063      	str	r3, [r4, #4]
  dhcp->msg_out->secs = 0;
    194e:	68bb      	ldr	r3, [r7, #8]
    1950:	695b      	ldr	r3, [r3, #20]
    1952:	f04f 0200 	mov.w	r2, #0
    1956:	721a      	strb	r2, [r3, #8]
    1958:	f04f 0200 	mov.w	r2, #0
    195c:	725a      	strb	r2, [r3, #9]
  /* we don't need the broadcast flag since we can receive unicast traffic
     before being fully configured! */
  dhcp->msg_out->flags = 0;
    195e:	68bb      	ldr	r3, [r7, #8]
    1960:	695b      	ldr	r3, [r3, #20]
    1962:	f04f 0200 	mov.w	r2, #0
    1966:	729a      	strb	r2, [r3, #10]
    1968:	f04f 0200 	mov.w	r2, #0
    196c:	72da      	strb	r2, [r3, #11]
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
    196e:	68bb      	ldr	r3, [r7, #8]
    1970:	695b      	ldr	r3, [r3, #20]
    1972:	f04f 0200 	mov.w	r2, #0
    1976:	731a      	strb	r2, [r3, #12]
    1978:	f04f 0200 	mov.w	r2, #0
    197c:	735a      	strb	r2, [r3, #13]
    197e:	f04f 0200 	mov.w	r2, #0
    1982:	739a      	strb	r2, [r3, #14]
    1984:	f04f 0200 	mov.w	r2, #0
    1988:	73da      	strb	r2, [r3, #15]
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
    198a:	79fb      	ldrb	r3, [r7, #7]
    198c:	2b08      	cmp	r3, #8
    198e:	d00d      	beq.n	19ac <dhcp_create_msg+0x10c>
    1990:	79fb      	ldrb	r3, [r7, #7]
    1992:	2b04      	cmp	r3, #4
    1994:	d00a      	beq.n	19ac <dhcp_create_msg+0x10c>
    1996:	79fb      	ldrb	r3, [r7, #7]
    1998:	2b03      	cmp	r3, #3
    199a:	d10c      	bne.n	19b6 <dhcp_create_msg+0x116>
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    199c:	68bb      	ldr	r3, [r7, #8]
    199e:	7b1b      	ldrb	r3, [r3, #12]
     before being fully configured! */
  dhcp->msg_out->flags = 0;
  ip_addr_set_zero(&dhcp->msg_out->ciaddr);
  /* set ciaddr to netif->ip_addr based on message_type and state */
  if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) ||
      ((message_type == DHCP_REQUEST) && /* DHCP_BOUND not used for sending! */
    19a0:	2b05      	cmp	r3, #5
    19a2:	d003      	beq.n	19ac <dhcp_create_msg+0x10c>
       ((dhcp->state==DHCP_RENEWING) || dhcp->state==DHCP_REBINDING))) {
    19a4:	68bb      	ldr	r3, [r7, #8]
    19a6:	7b1b      	ldrb	r3, [r3, #12]
    19a8:	2b04      	cmp	r3, #4
    19aa:	d104      	bne.n	19b6 <dhcp_create_msg+0x116>
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
    19ac:	68bb      	ldr	r3, [r7, #8]
    19ae:	695b      	ldr	r3, [r3, #20]
    19b0:	68fa      	ldr	r2, [r7, #12]
    19b2:	6852      	ldr	r2, [r2, #4]
    19b4:	60da      	str	r2, [r3, #12]
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
    19b6:	68bb      	ldr	r3, [r7, #8]
    19b8:	695b      	ldr	r3, [r3, #20]
    19ba:	f04f 0200 	mov.w	r2, #0
    19be:	741a      	strb	r2, [r3, #16]
    19c0:	f04f 0200 	mov.w	r2, #0
    19c4:	745a      	strb	r2, [r3, #17]
    19c6:	f04f 0200 	mov.w	r2, #0
    19ca:	749a      	strb	r2, [r3, #18]
    19cc:	f04f 0200 	mov.w	r2, #0
    19d0:	74da      	strb	r2, [r3, #19]
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
    19d2:	68bb      	ldr	r3, [r7, #8]
    19d4:	695b      	ldr	r3, [r3, #20]
    19d6:	f04f 0200 	mov.w	r2, #0
    19da:	751a      	strb	r2, [r3, #20]
    19dc:	f04f 0200 	mov.w	r2, #0
    19e0:	755a      	strb	r2, [r3, #21]
    19e2:	f04f 0200 	mov.w	r2, #0
    19e6:	759a      	strb	r2, [r3, #22]
    19e8:	f04f 0200 	mov.w	r2, #0
    19ec:	75da      	strb	r2, [r3, #23]
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
    19ee:	68bb      	ldr	r3, [r7, #8]
    19f0:	695b      	ldr	r3, [r3, #20]
    19f2:	f04f 0200 	mov.w	r2, #0
    19f6:	761a      	strb	r2, [r3, #24]
    19f8:	f04f 0200 	mov.w	r2, #0
    19fc:	765a      	strb	r2, [r3, #25]
    19fe:	f04f 0200 	mov.w	r2, #0
    1a02:	769a      	strb	r2, [r3, #26]
    1a04:	f04f 0200 	mov.w	r2, #0
    1a08:	76da      	strb	r2, [r3, #27]
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    1a0a:	f04f 0300 	mov.w	r3, #0
    1a0e:	82fb      	strh	r3, [r7, #22]
    1a10:	e016      	b.n	1a40 <dhcp_create_msg+0x1a0>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
    1a12:	68bb      	ldr	r3, [r7, #8]
    1a14:	6959      	ldr	r1, [r3, #20]
    1a16:	8afa      	ldrh	r2, [r7, #22]
    1a18:	68fb      	ldr	r3, [r7, #12]
    1a1a:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
    1a1e:	8af8      	ldrh	r0, [r7, #22]
    1a20:	4298      	cmp	r0, r3
    1a22:	d205      	bcs.n	1a30 <dhcp_create_msg+0x190>
    1a24:	8afb      	ldrh	r3, [r7, #22]
    1a26:	68f8      	ldr	r0, [r7, #12]
    1a28:	18c3      	adds	r3, r0, r3
    1a2a:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
    1a2e:	e001      	b.n	1a34 <dhcp_create_msg+0x194>
    1a30:	f04f 0300 	mov.w	r3, #0
    1a34:	188a      	adds	r2, r1, r2
    1a36:	7713      	strb	r3, [r2, #28]
    ip_addr_copy(dhcp->msg_out->ciaddr, netif->ip_addr);
  }
  ip_addr_set_zero(&dhcp->msg_out->yiaddr);
  ip_addr_set_zero(&dhcp->msg_out->siaddr);
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    1a38:	8afb      	ldrh	r3, [r7, #22]
    1a3a:	f103 0301 	add.w	r3, r3, #1
    1a3e:	82fb      	strh	r3, [r7, #22]
    1a40:	8afb      	ldrh	r3, [r7, #22]
    1a42:	2b0f      	cmp	r3, #15
    1a44:	d9e5      	bls.n	1a12 <dhcp_create_msg+0x172>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    1a46:	f04f 0300 	mov.w	r3, #0
    1a4a:	82fb      	strh	r3, [r7, #22]
    1a4c:	e00b      	b.n	1a66 <dhcp_create_msg+0x1c6>
    dhcp->msg_out->sname[i] = 0;
    1a4e:	68bb      	ldr	r3, [r7, #8]
    1a50:	695a      	ldr	r2, [r3, #20]
    1a52:	8afb      	ldrh	r3, [r7, #22]
    1a54:	18d3      	adds	r3, r2, r3
    1a56:	f04f 0200 	mov.w	r2, #0
    1a5a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  ip_addr_set_zero(&dhcp->msg_out->giaddr);
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    1a5e:	8afb      	ldrh	r3, [r7, #22]
    1a60:	f103 0301 	add.w	r3, r3, #1
    1a64:	82fb      	strh	r3, [r7, #22]
    1a66:	8afb      	ldrh	r3, [r7, #22]
    1a68:	2b3f      	cmp	r3, #63	; 0x3f
    1a6a:	d9f0      	bls.n	1a4e <dhcp_create_msg+0x1ae>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    1a6c:	f04f 0300 	mov.w	r3, #0
    1a70:	82fb      	strh	r3, [r7, #22]
    1a72:	e00b      	b.n	1a8c <dhcp_create_msg+0x1ec>
    dhcp->msg_out->file[i] = 0;
    1a74:	68bb      	ldr	r3, [r7, #8]
    1a76:	695a      	ldr	r2, [r3, #20]
    1a78:	8afb      	ldrh	r3, [r7, #22]
    1a7a:	18d3      	adds	r3, r2, r3
    1a7c:	f04f 0200 	mov.w	r2, #0
    1a80:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    1a84:	8afb      	ldrh	r3, [r7, #22]
    1a86:	f103 0301 	add.w	r3, r3, #1
    1a8a:	82fb      	strh	r3, [r7, #22]
    1a8c:	8afb      	ldrh	r3, [r7, #22]
    1a8e:	2b7f      	cmp	r3, #127	; 0x7f
    1a90:	d9f0      	bls.n	1a74 <dhcp_create_msg+0x1d4>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
    1a92:	68bb      	ldr	r3, [r7, #8]
    1a94:	695b      	ldr	r3, [r3, #20]
    1a96:	f04f 0200 	mov.w	r2, #0
    1a9a:	f042 0263 	orr.w	r2, r2, #99	; 0x63
    1a9e:	f883 20ec 	strb.w	r2, [r3, #236]	; 0xec
    1aa2:	f04f 0200 	mov.w	r2, #0
    1aa6:	f062 027d 	orn	r2, r2, #125	; 0x7d
    1aaa:	f883 20ed 	strb.w	r2, [r3, #237]	; 0xed
    1aae:	f04f 0200 	mov.w	r2, #0
    1ab2:	f042 0253 	orr.w	r2, r2, #83	; 0x53
    1ab6:	f883 20ee 	strb.w	r2, [r3, #238]	; 0xee
    1aba:	f04f 0200 	mov.w	r2, #0
    1abe:	f042 0263 	orr.w	r2, r2, #99	; 0x63
    1ac2:	f883 20ef 	strb.w	r2, [r3, #239]	; 0xef
  dhcp->options_out_len = 0;
    1ac6:	68bb      	ldr	r3, [r7, #8]
    1ac8:	f04f 0200 	mov.w	r2, #0
    1acc:	831a      	strh	r2, [r3, #24]
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    1ace:	f04f 0300 	mov.w	r3, #0
    1ad2:	82fb      	strh	r3, [r7, #22]
    1ad4:	e00e      	b.n	1af4 <dhcp_create_msg+0x254>
    1ad6:	bf00      	nop
    1ad8:	00000000 	.word	0x00000000
			1ad8: R_ARM_ABS32	.data
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
    1adc:	68bb      	ldr	r3, [r7, #8]
    1ade:	6959      	ldr	r1, [r3, #20]
    1ae0:	8afb      	ldrh	r3, [r7, #22]
    1ae2:	8afa      	ldrh	r2, [r7, #22]
    1ae4:	b2d2      	uxtb	r2, r2
    1ae6:	18cb      	adds	r3, r1, r3
    1ae8:	f883 20f0 	strb.w	r2, [r3, #240]	; 0xf0
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    1aec:	8afb      	ldrh	r3, [r7, #22]
    1aee:	f103 0301 	add.w	r3, r3, #1
    1af2:	82fb      	strh	r3, [r7, #22]
    1af4:	8afb      	ldrh	r3, [r7, #22]
    1af6:	2b43      	cmp	r3, #67	; 0x43
    1af8:	d9f0      	bls.n	1adc <dhcp_create_msg+0x23c>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  /* Add option MESSAGE_TYPE */
  dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
    1afa:	68b8      	ldr	r0, [r7, #8]
    1afc:	f04f 0135 	mov.w	r1, #53	; 0x35
    1b00:	f04f 0201 	mov.w	r2, #1
    1b04:	f7ff fb0e 	bl	1124 <dhcp_option>
  dhcp_option_byte(dhcp, message_type);
    1b08:	79fb      	ldrb	r3, [r7, #7]
    1b0a:	68b8      	ldr	r0, [r7, #8]
    1b0c:	4619      	mov	r1, r3
    1b0e:	f7ff fb33 	bl	1178 <dhcp_option_byte>
  return ERR_OK;
    1b12:	f04f 0300 	mov.w	r3, #0
    1b16:	b25b      	sxtb	r3, r3
}
    1b18:	4618      	mov	r0, r3
    1b1a:	f107 071c 	add.w	r7, r7, #28
    1b1e:	46bd      	mov	sp, r7
    1b20:	bd90      	pop	{r4, r7, pc}
    1b22:	bf00      	nop

00001b24 <dhcp_delete_msg>:
 *
 * @param dhcp the dhcp struct to free the request from
 */
static void
dhcp_delete_msg(struct dhcp *dhcp)
{
    1b24:	b580      	push	{r7, lr}
    1b26:	b082      	sub	sp, #8
    1b28:	af00      	add	r7, sp, #0
    1b2a:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("dhcp_delete_msg: dhcp != NULL", (dhcp != NULL), return;);
    1b2c:	687b      	ldr	r3, [r7, #4]
    1b2e:	2b00      	cmp	r3, #0
    1b30:	d010      	beq.n	1b54 <dhcp_delete_msg+0x30>
  LWIP_ASSERT("dhcp_delete_msg: dhcp->p_out != NULL", dhcp->p_out != NULL);
  LWIP_ASSERT("dhcp_delete_msg: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  if (dhcp->p_out != NULL) {
    1b32:	687b      	ldr	r3, [r7, #4]
    1b34:	691b      	ldr	r3, [r3, #16]
    1b36:	2b00      	cmp	r3, #0
    1b38:	d004      	beq.n	1b44 <dhcp_delete_msg+0x20>
    pbuf_free(dhcp->p_out);
    1b3a:	687b      	ldr	r3, [r7, #4]
    1b3c:	691b      	ldr	r3, [r3, #16]
    1b3e:	4618      	mov	r0, r3
    1b40:	f7ff fffe 	bl	0 <pbuf_free>
			1b40: R_ARM_THM_CALL	pbuf_free
  }
  dhcp->p_out = NULL;
    1b44:	687b      	ldr	r3, [r7, #4]
    1b46:	f04f 0200 	mov.w	r2, #0
    1b4a:	611a      	str	r2, [r3, #16]
  dhcp->msg_out = NULL;
    1b4c:	687b      	ldr	r3, [r7, #4]
    1b4e:	f04f 0200 	mov.w	r2, #0
    1b52:	615a      	str	r2, [r3, #20]
}
    1b54:	f107 0708 	add.w	r7, r7, #8
    1b58:	46bd      	mov	sp, r7
    1b5a:	bd80      	pop	{r7, pc}

00001b5c <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
    1b5c:	b480      	push	{r7}
    1b5e:	b083      	sub	sp, #12
    1b60:	af00      	add	r7, sp, #0
    1b62:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
    1b64:	687b      	ldr	r3, [r7, #4]
    1b66:	2b00      	cmp	r3, #0
    1b68:	d02c      	beq.n	1bc4 <dhcp_option_trailer+0x68>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
    1b6a:	687b      	ldr	r3, [r7, #4]
    1b6c:	6959      	ldr	r1, [r3, #20]
    1b6e:	687b      	ldr	r3, [r7, #4]
    1b70:	8b1b      	ldrh	r3, [r3, #24]
    1b72:	461a      	mov	r2, r3
    1b74:	188a      	adds	r2, r1, r2
    1b76:	f04f 01ff 	mov.w	r1, #255	; 0xff
    1b7a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1b7e:	f103 0301 	add.w	r3, r3, #1
    1b82:	b29a      	uxth	r2, r3
    1b84:	687b      	ldr	r3, [r7, #4]
    1b86:	831a      	strh	r2, [r3, #24]
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    1b88:	e00e      	b.n	1ba8 <dhcp_option_trailer+0x4c>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
    1b8a:	687b      	ldr	r3, [r7, #4]
    1b8c:	6959      	ldr	r1, [r3, #20]
    1b8e:	687b      	ldr	r3, [r7, #4]
    1b90:	8b1b      	ldrh	r3, [r3, #24]
    1b92:	461a      	mov	r2, r3
    1b94:	188a      	adds	r2, r1, r2
    1b96:	f04f 0100 	mov.w	r1, #0
    1b9a:	f882 10f0 	strb.w	r1, [r2, #240]	; 0xf0
    1b9e:	f103 0301 	add.w	r3, r3, #1
    1ba2:	b29a      	uxth	r2, r3
    1ba4:	687b      	ldr	r3, [r7, #4]
    1ba6:	831a      	strh	r2, [r3, #24]
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    1ba8:	687b      	ldr	r3, [r7, #4]
    1baa:	8b1b      	ldrh	r3, [r3, #24]
    1bac:	2b43      	cmp	r3, #67	; 0x43
    1bae:	d905      	bls.n	1bbc <dhcp_option_trailer+0x60>
    1bb0:	687b      	ldr	r3, [r7, #4]
    1bb2:	8b1b      	ldrh	r3, [r3, #24]
    1bb4:	f003 0303 	and.w	r3, r3, #3
    1bb8:	2b00      	cmp	r3, #0
    1bba:	d003      	beq.n	1bc4 <dhcp_option_trailer+0x68>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    1bbc:	687b      	ldr	r3, [r7, #4]
    1bbe:	8b1b      	ldrh	r3, [r3, #24]
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while (((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) &&
    1bc0:	2b43      	cmp	r3, #67	; 0x43
    1bc2:	d9e2      	bls.n	1b8a <dhcp_option_trailer+0x2e>
         (dhcp->options_out_len < DHCP_OPTIONS_LEN)) {
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
    1bc4:	f107 070c 	add.w	r7, r7, #12
    1bc8:	46bd      	mov	sp, r7
    1bca:	bc80      	pop	{r7}
    1bcc:	4770      	bx	lr
    1bce:	bf00      	nop

dns.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  49336 Jul 30 19:07 2021 dns.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009a4  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000009d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000678  00000000  00000000  000009d8  2**2
                  ALLOC
  3 .debug_abbrev 000001bc  00000000  00000000  000009d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000099a  00000000  00000000  00000b94  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000660  00000000  00000000  0000152e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 000086d0  00000000  00000000  00001b8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000010  00000000  00000000  0000a260  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    000002ce  00000000  00000000  0000a270  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000065  00000000  00000000  0000a53e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 000000ee  00000000  00000000  0000a5a3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  0000a691  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    0000042e  00000000  00000000  0000a6b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0000aadf  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000ab0a  2**0
                  CONTENTS, READONLY
 15 .debug_frame  0000019c  00000000  00000000  0000ab3c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 dns.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 dns_pcb
00000004 l       .bss	00000000 dns_seqno
00000008 l       .bss	00000000 dns_table
00000468 l       .bss	00000000 dns_servers
00000470 l       .bss	00000000 dns_payload_buffer
00000674 l       .bss	00000000 dns_payload
00000000 l    d  .rodata	00000000 .rodata
000005c4 l     F .text	00000220 dns_recv
00000598 l     F .text	0000002c dns_check_entries
00000120 l     F .text	00000080 dns_lookup
000001a0 l     F .text	00000074 dns_compare_name
00000214 l     F .text	00000052 dns_parse_name
00000268 l     F .text	00000198 dns_send
00000400 l     F .text	00000198 dns_check_entry
000007e4 l     F .text	0000013c dns_enqueue
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000088 dns_init
00000000         *UND*	00000000 ipaddr_addr
00000000         *UND*	00000000 udp_new
00000000         *UND*	00000000 udp_bind
00000000         *UND*	00000000 udp_recv
00000088 g     F .text	0000004c dns_setserver
00000000         *UND*	00000000 ip_addr_any
000000d4 g     F .text	00000034 dns_getserver
00000108 g     F .text	00000018 dns_tmr
00000000         *UND*	00000000 strcmp
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 memset
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 pbuf_realloc
00000000         *UND*	00000000 udp_connect
00000000         *UND*	00000000 udp_sendto
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 pbuf_copy_partial
00000000         *UND*	00000000 lwip_ntohl
00000000         *UND*	00000000 strlen
00000920 g     F .text	00000084 dns_gethostbyname



Disassembly of section .text:

00000000 <dns_init>:
 * Initialize the resolver: set up the UDP pcb and configure the default server
 * (DNS_SERVER_ADDRESS).
 */
void
dns_init()
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
  ip_addr_t dnsserver;

  dns_payload = (u8_t *)LWIP_MEM_ALIGN(dns_payload_buffer);
   6:	4b1a      	ldr	r3, [pc, #104]	; (70 <dns_init+0x70>)
   8:	f103 0303 	add.w	r3, r3, #3
   c:	f023 0303 	bic.w	r3, r3, #3
  10:	461a      	mov	r2, r3
  12:	4b18      	ldr	r3, [pc, #96]	; (74 <dns_init+0x74>)
  14:	601a      	str	r2, [r3, #0]
  
  /* initialize default DNS server address */
  DNS_SERVER_ADDRESS(&dnsserver);
  16:	4818      	ldr	r0, [pc, #96]	; (78 <dns_init+0x78>)
  18:	f7ff fffe 	bl	0 <ipaddr_addr>
			18: R_ARM_THM_CALL	ipaddr_addr
  1c:	4603      	mov	r3, r0
  1e:	607b      	str	r3, [r7, #4]

  LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));

  /* if dns client not yet initialized... */
  if (dns_pcb == NULL) {
  20:	4b16      	ldr	r3, [pc, #88]	; (7c <dns_init+0x7c>)
  22:	681b      	ldr	r3, [r3, #0]
  24:	2b00      	cmp	r3, #0
  26:	d11f      	bne.n	68 <dns_init+0x68>
    dns_pcb = udp_new();
  28:	f7ff fffe 	bl	0 <udp_new>
			28: R_ARM_THM_CALL	udp_new
  2c:	4602      	mov	r2, r0
  2e:	4b13      	ldr	r3, [pc, #76]	; (7c <dns_init+0x7c>)
  30:	601a      	str	r2, [r3, #0]

    if (dns_pcb != NULL) {
  32:	4b12      	ldr	r3, [pc, #72]	; (7c <dns_init+0x7c>)
  34:	681b      	ldr	r3, [r3, #0]
  36:	2b00      	cmp	r3, #0
  38:	d016      	beq.n	68 <dns_init+0x68>
       * global variable) */
      LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
        DNS_STATE_UNUSED == 0);

      /* initialize DNS client */
      udp_bind(dns_pcb, IP_ADDR_ANY, 0);
  3a:	4b10      	ldr	r3, [pc, #64]	; (7c <dns_init+0x7c>)
  3c:	681b      	ldr	r3, [r3, #0]
  3e:	4618      	mov	r0, r3
  40:	490f      	ldr	r1, [pc, #60]	; (80 <dns_init+0x80>)
  42:	f04f 0200 	mov.w	r2, #0
  46:	f7ff fffe 	bl	0 <udp_bind>
			46: R_ARM_THM_CALL	udp_bind
      udp_recv(dns_pcb, dns_recv, NULL);
  4a:	4b0c      	ldr	r3, [pc, #48]	; (7c <dns_init+0x7c>)
  4c:	681b      	ldr	r3, [r3, #0]
  4e:	4618      	mov	r0, r3
  50:	490c      	ldr	r1, [pc, #48]	; (84 <dns_init+0x84>)
  52:	f04f 0200 	mov.w	r2, #0
  56:	f7ff fffe 	bl	0 <udp_recv>
			56: R_ARM_THM_CALL	udp_recv

      /* initialize default DNS primary server */
      dns_setserver(0, &dnsserver);
  5a:	f107 0304 	add.w	r3, r7, #4
  5e:	f04f 0000 	mov.w	r0, #0
  62:	4619      	mov	r1, r3
  64:	f7ff fffe 	bl	88 <dns_setserver>
			64: R_ARM_THM_CALL	dns_setserver
    }
  }
#if DNS_LOCAL_HOSTLIST
  dns_init_local();
#endif
}
  68:	f107 0708 	add.w	r7, r7, #8
  6c:	46bd      	mov	sp, r7
  6e:	bd80      	pop	{r7, pc}
  70:	00000470 	.word	0x00000470
			70: R_ARM_ABS32	.bss
  74:	00000674 	.word	0x00000674
			74: R_ARM_ABS32	.bss
	...
			78: R_ARM_ABS32	.rodata
			7c: R_ARM_ABS32	.bss
			80: R_ARM_ABS32	ip_addr_any
			84: R_ARM_ABS32	dns_recv

00000088 <dns_setserver>:
 * @param numdns the index of the DNS server to set must be < DNS_MAX_SERVERS
 * @param dnsserver IP address of the DNS server to set
 */
void
dns_setserver(u8_t numdns, ip_addr_t *dnsserver)
{
  88:	b480      	push	{r7}
  8a:	b083      	sub	sp, #12
  8c:	af00      	add	r7, sp, #0
  8e:	4603      	mov	r3, r0
  90:	6039      	str	r1, [r7, #0]
  92:	71fb      	strb	r3, [r7, #7]
  if ((numdns < DNS_MAX_SERVERS) && (dns_pcb != NULL) &&
  94:	79fb      	ldrb	r3, [r7, #7]
  96:	2b01      	cmp	r3, #1
  98:	d813      	bhi.n	c2 <dns_setserver+0x3a>
  9a:	4b0c      	ldr	r3, [pc, #48]	; (cc <dns_setserver+0x44>)
  9c:	681b      	ldr	r3, [r3, #0]
  9e:	2b00      	cmp	r3, #0
  a0:	d00f      	beq.n	c2 <dns_setserver+0x3a>
  a2:	683b      	ldr	r3, [r7, #0]
  a4:	2b00      	cmp	r3, #0
  a6:	d00c      	beq.n	c2 <dns_setserver+0x3a>
      (dnsserver != NULL) && !ip_addr_isany(dnsserver)) {
  a8:	683b      	ldr	r3, [r7, #0]
  aa:	2b00      	cmp	r3, #0
  ac:	d009      	beq.n	c2 <dns_setserver+0x3a>
  ae:	683b      	ldr	r3, [r7, #0]
  b0:	681b      	ldr	r3, [r3, #0]
  b2:	2b00      	cmp	r3, #0
  b4:	d005      	beq.n	c2 <dns_setserver+0x3a>
    dns_servers[numdns] = (*dnsserver);
  b6:	79fa      	ldrb	r2, [r7, #7]
  b8:	4b05      	ldr	r3, [pc, #20]	; (d0 <dns_setserver+0x48>)
  ba:	6839      	ldr	r1, [r7, #0]
  bc:	6809      	ldr	r1, [r1, #0]
  be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }
}
  c2:	f107 070c 	add.w	r7, r7, #12
  c6:	46bd      	mov	sp, r7
  c8:	bc80      	pop	{r7}
  ca:	4770      	bx	lr
  cc:	00000000 	.word	0x00000000
			cc: R_ARM_ABS32	.bss
  d0:	00000468 	.word	0x00000468
			d0: R_ARM_ABS32	.bss

000000d4 <dns_getserver>:
 * @return IP address of the indexed DNS server or "ip_addr_any" if the DNS
 *         server has not been configured.
 */
ip_addr_t
dns_getserver(u8_t numdns)
{
  d4:	b480      	push	{r7}
  d6:	b083      	sub	sp, #12
  d8:	af00      	add	r7, sp, #0
  da:	4603      	mov	r3, r0
  dc:	71fb      	strb	r3, [r7, #7]
  if (numdns < DNS_MAX_SERVERS) {
  de:	79fb      	ldrb	r3, [r7, #7]
  e0:	2b01      	cmp	r3, #1
  e2:	d804      	bhi.n	ee <dns_getserver+0x1a>
    return dns_servers[numdns];
  e4:	79fa      	ldrb	r2, [r7, #7]
  e6:	4b06      	ldr	r3, [pc, #24]	; (100 <dns_getserver+0x2c>)
  e8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  ec:	e001      	b.n	f2 <dns_getserver+0x1e>
  } else {
    return *IP_ADDR_ANY;
  ee:	4b05      	ldr	r3, [pc, #20]	; (104 <dns_getserver+0x30>)
  f0:	681b      	ldr	r3, [r3, #0]
  }
}
  f2:	4618      	mov	r0, r3
  f4:	f107 070c 	add.w	r7, r7, #12
  f8:	46bd      	mov	sp, r7
  fa:	bc80      	pop	{r7}
  fc:	4770      	bx	lr
  fe:	bf00      	nop
 100:	00000468 	.word	0x00000468
			100: R_ARM_ABS32	.bss
 104:	00000000 	.word	0x00000000
			104: R_ARM_ABS32	ip_addr_any

00000108 <dns_tmr>:
 * The DNS resolver client timer - handle retries and timeouts and should
 * be called every DNS_TMR_INTERVAL milliseconds (every second by default).
 */
void
dns_tmr(void)
{
 108:	b580      	push	{r7, lr}
 10a:	af00      	add	r7, sp, #0
  if (dns_pcb != NULL) {
 10c:	4b03      	ldr	r3, [pc, #12]	; (11c <dns_tmr+0x14>)
 10e:	681b      	ldr	r3, [r3, #0]
 110:	2b00      	cmp	r3, #0
 112:	d001      	beq.n	118 <dns_tmr+0x10>
    LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
    dns_check_entries();
 114:	f000 fa40 	bl	598 <dns_check_entries>
  }
}
 118:	bd80      	pop	{r7, pc}
 11a:	bf00      	nop
 11c:	00000000 	.word	0x00000000
			11c: R_ARM_ABS32	.bss

00000120 <dns_lookup>:
 *         better check for failure: != IPADDR_NONE) or IPADDR_NONE if the hostname
 *         was not found in the cached dns_table.
 */
static u32_t
dns_lookup(const char *name)
{
 120:	b580      	push	{r7, lr}
 122:	b084      	sub	sp, #16
 124:	af00      	add	r7, sp, #0
 126:	6078      	str	r0, [r7, #4]
    return addr;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 128:	f04f 0300 	mov.w	r3, #0
 12c:	73fb      	strb	r3, [r7, #15]
 12e:	e02a      	b.n	186 <dns_lookup+0x66>
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 130:	7bfb      	ldrb	r3, [r7, #15]
 132:	4a1a      	ldr	r2, [pc, #104]	; (19c <dns_lookup+0x7c>)
 134:	f44f 718c 	mov.w	r1, #280	; 0x118
 138:	fb01 f303 	mul.w	r3, r1, r3
 13c:	18d3      	adds	r3, r2, r3
 13e:	781b      	ldrb	r3, [r3, #0]
 140:	2b03      	cmp	r3, #3
 142:	d11c      	bne.n	17e <dns_lookup+0x5e>
        (strcmp(name, dns_table[i].name) == 0)) {
 144:	7bfb      	ldrb	r3, [r7, #15]
 146:	f44f 728c 	mov.w	r2, #280	; 0x118
 14a:	fb02 f303 	mul.w	r3, r2, r3
 14e:	f103 0208 	add.w	r2, r3, #8
 152:	4b12      	ldr	r3, [pc, #72]	; (19c <dns_lookup+0x7c>)
 154:	18d3      	adds	r3, r2, r3
 156:	f103 0304 	add.w	r3, r3, #4
 15a:	6878      	ldr	r0, [r7, #4]
 15c:	4619      	mov	r1, r3
 15e:	f7ff fffe 	bl	0 <strcmp>
			15e: R_ARM_THM_CALL	strcmp
 162:	4603      	mov	r3, r0
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
    if ((dns_table[i].state == DNS_STATE_DONE) &&
 164:	2b00      	cmp	r3, #0
 166:	d10a      	bne.n	17e <dns_lookup+0x5e>
        (strcmp(name, dns_table[i].name) == 0)) {
      LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
      ip_addr_debug_print(DNS_DEBUG, &(dns_table[i].ipaddr));
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      return ip4_addr_get_u32(&dns_table[i].ipaddr);
 168:	7bfb      	ldrb	r3, [r7, #15]
 16a:	4a0c      	ldr	r2, [pc, #48]	; (19c <dns_lookup+0x7c>)
 16c:	f44f 718c 	mov.w	r1, #280	; 0x118
 170:	fb01 f303 	mul.w	r3, r1, r3
 174:	18d3      	adds	r3, r2, r3
 176:	f503 7386 	add.w	r3, r3, #268	; 0x10c
 17a:	681b      	ldr	r3, [r3, #0]
 17c:	e008      	b.n	190 <dns_lookup+0x70>
    return addr;
  }
#endif /* DNS_LOOKUP_LOCAL_EXTERN */

  /* Walk through name list, return entry if found. If not, return NULL. */
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 17e:	7bfb      	ldrb	r3, [r7, #15]
 180:	f103 0301 	add.w	r3, r3, #1
 184:	73fb      	strb	r3, [r7, #15]
 186:	7bfb      	ldrb	r3, [r7, #15]
 188:	2b03      	cmp	r3, #3
 18a:	d9d1      	bls.n	130 <dns_lookup+0x10>
      LWIP_DEBUGF(DNS_DEBUG, ("\n"));
      return ip4_addr_get_u32(&dns_table[i].ipaddr);
    }
  }

  return IPADDR_NONE;
 18c:	f04f 33ff 	mov.w	r3, #4294967295
}
 190:	4618      	mov	r0, r3
 192:	f107 0710 	add.w	r7, r7, #16
 196:	46bd      	mov	sp, r7
 198:	bd80      	pop	{r7, pc}
 19a:	bf00      	nop
 19c:	00000008 	.word	0x00000008
			19c: R_ARM_ABS32	.bss

000001a0 <dns_compare_name>:
 * @param response encoded hostname in the DNS response
 * @return 0: names equal; 1: names differ
 */
static u8_t
dns_compare_name(unsigned char *query, unsigned char *response)
{
 1a0:	b480      	push	{r7}
 1a2:	b085      	sub	sp, #20
 1a4:	af00      	add	r7, sp, #0
 1a6:	6078      	str	r0, [r7, #4]
 1a8:	6039      	str	r1, [r7, #0]
  unsigned char n;

  do {
    n = *response++;
 1aa:	683b      	ldr	r3, [r7, #0]
 1ac:	781b      	ldrb	r3, [r3, #0]
 1ae:	73fb      	strb	r3, [r7, #15]
 1b0:	683b      	ldr	r3, [r7, #0]
 1b2:	f103 0301 	add.w	r3, r3, #1
 1b6:	603b      	str	r3, [r7, #0]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 1b8:	7bfb      	ldrb	r3, [r7, #15]
 1ba:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 1be:	2bc0      	cmp	r3, #192	; 0xc0
 1c0:	d115      	bne.n	1ee <dns_compare_name+0x4e>
      /* Compressed name */
      break;
 1c2:	e01f      	b.n	204 <dns_compare_name+0x64>
    } else {
      /* Not compressed name */
      while (n > 0) {
        if ((*query) != (*response)) {
 1c4:	687b      	ldr	r3, [r7, #4]
 1c6:	781a      	ldrb	r2, [r3, #0]
 1c8:	683b      	ldr	r3, [r7, #0]
 1ca:	781b      	ldrb	r3, [r3, #0]
 1cc:	429a      	cmp	r2, r3
 1ce:	d002      	beq.n	1d6 <dns_compare_name+0x36>
          return 1;
 1d0:	f04f 0301 	mov.w	r3, #1
 1d4:	e018      	b.n	208 <dns_compare_name+0x68>
        }
        ++response;
 1d6:	683b      	ldr	r3, [r7, #0]
 1d8:	f103 0301 	add.w	r3, r3, #1
 1dc:	603b      	str	r3, [r7, #0]
        ++query;
 1de:	687b      	ldr	r3, [r7, #4]
 1e0:	f103 0301 	add.w	r3, r3, #1
 1e4:	607b      	str	r3, [r7, #4]
        --n;
 1e6:	7bfb      	ldrb	r3, [r7, #15]
 1e8:	f103 33ff 	add.w	r3, r3, #4294967295
 1ec:	73fb      	strb	r3, [r7, #15]
    if ((n & 0xc0) == 0xc0) {
      /* Compressed name */
      break;
    } else {
      /* Not compressed name */
      while (n > 0) {
 1ee:	7bfb      	ldrb	r3, [r7, #15]
 1f0:	2b00      	cmp	r3, #0
 1f2:	d1e7      	bne.n	1c4 <dns_compare_name+0x24>
        }
        ++response;
        ++query;
        --n;
      };
      ++query;
 1f4:	687b      	ldr	r3, [r7, #4]
 1f6:	f103 0301 	add.w	r3, r3, #1
 1fa:	607b      	str	r3, [r7, #4]
    }
  } while (*response != 0);
 1fc:	683b      	ldr	r3, [r7, #0]
 1fe:	781b      	ldrb	r3, [r3, #0]
 200:	2b00      	cmp	r3, #0
 202:	d1d2      	bne.n	1aa <dns_compare_name+0xa>

  return 0;
 204:	f04f 0300 	mov.w	r3, #0
}
 208:	4618      	mov	r0, r3
 20a:	f107 0714 	add.w	r7, r7, #20
 20e:	46bd      	mov	sp, r7
 210:	bc80      	pop	{r7}
 212:	4770      	bx	lr

00000214 <dns_parse_name>:
 * @param query encoded DNS name in the DNS server response
 * @return end of the name
 */
static unsigned char *
dns_parse_name(unsigned char *query)
{
 214:	b480      	push	{r7}
 216:	b085      	sub	sp, #20
 218:	af00      	add	r7, sp, #0
 21a:	6078      	str	r0, [r7, #4]
  unsigned char n;

  do {
    n = *query++;
 21c:	687b      	ldr	r3, [r7, #4]
 21e:	781b      	ldrb	r3, [r3, #0]
 220:	73fb      	strb	r3, [r7, #15]
 222:	687b      	ldr	r3, [r7, #4]
 224:	f103 0301 	add.w	r3, r3, #1
 228:	607b      	str	r3, [r7, #4]
    /** @see RFC 1035 - 4.1.4. Message compression */
    if ((n & 0xc0) == 0xc0) {
 22a:	7bfb      	ldrb	r3, [r7, #15]
 22c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 230:	2bc0      	cmp	r3, #192	; 0xc0
 232:	d108      	bne.n	246 <dns_parse_name+0x32>
      /* Compressed name */
      break;
 234:	e00e      	b.n	254 <dns_parse_name+0x40>
    } else {
      /* Not compressed name */
      while (n > 0) {
        ++query;
 236:	687b      	ldr	r3, [r7, #4]
 238:	f103 0301 	add.w	r3, r3, #1
 23c:	607b      	str	r3, [r7, #4]
        --n;
 23e:	7bfb      	ldrb	r3, [r7, #15]
 240:	f103 33ff 	add.w	r3, r3, #4294967295
 244:	73fb      	strb	r3, [r7, #15]
    if ((n & 0xc0) == 0xc0) {
      /* Compressed name */
      break;
    } else {
      /* Not compressed name */
      while (n > 0) {
 246:	7bfb      	ldrb	r3, [r7, #15]
 248:	2b00      	cmp	r3, #0
 24a:	d1f4      	bne.n	236 <dns_parse_name+0x22>
        ++query;
        --n;
      };
    }
  } while (*query != 0);
 24c:	687b      	ldr	r3, [r7, #4]
 24e:	781b      	ldrb	r3, [r3, #0]
 250:	2b00      	cmp	r3, #0
 252:	d1e3      	bne.n	21c <dns_parse_name+0x8>

  return query + 1;
 254:	687b      	ldr	r3, [r7, #4]
 256:	f103 0301 	add.w	r3, r3, #1
}
 25a:	4618      	mov	r0, r3
 25c:	f107 0714 	add.w	r7, r7, #20
 260:	46bd      	mov	sp, r7
 262:	bc80      	pop	{r7}
 264:	4770      	bx	lr
 266:	bf00      	nop

00000268 <dns_send>:
 *        DNS query packet
 * @return ERR_OK if packet is sent; an err_t indicating the problem otherwise
 */
static err_t
dns_send(u8_t numdns, const char* name, u8_t id)
{
 268:	b580      	push	{r7, lr}
 26a:	b08c      	sub	sp, #48	; 0x30
 26c:	af00      	add	r7, sp, #0
 26e:	60b9      	str	r1, [r7, #8]
 270:	4613      	mov	r3, r2
 272:	4602      	mov	r2, r0
 274:	73fa      	strb	r2, [r7, #15]
 276:	71fb      	strb	r3, [r7, #7]
  u8_t n;

  LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
              (u16_t)(numdns), name));
  LWIP_ASSERT("dns server out of array", numdns < DNS_MAX_SERVERS);
  LWIP_ASSERT("dns server has no IP address set", !ip_addr_isany(&dns_servers[numdns]));
 278:	7bfb      	ldrb	r3, [r7, #15]
 27a:	ea4f 0283 	mov.w	r2, r3, lsl #2
 27e:	4b5e      	ldr	r3, [pc, #376]	; (3f8 <dns_send+0x190>)
 280:	18d3      	adds	r3, r2, r3
 282:	2b00      	cmp	r3, #0

  /* if here, we have either a new query or a retry on a previous query to process */
  p = pbuf_alloc(PBUF_TRANSPORT, SIZEOF_DNS_HDR + DNS_MAX_NAME_LENGTH +
 284:	f04f 0000 	mov.w	r0, #0
 288:	f44f 7188 	mov.w	r1, #272	; 0x110
 28c:	f04f 0200 	mov.w	r2, #0
 290:	f7ff fffe 	bl	0 <pbuf_alloc>
			290: R_ARM_THM_CALL	pbuf_alloc
 294:	61f8      	str	r0, [r7, #28]
                 SIZEOF_DNS_QUERY, PBUF_RAM);
  if (p != NULL) {
 296:	69fb      	ldr	r3, [r7, #28]
 298:	2b00      	cmp	r3, #0
 29a:	f000 80a0 	beq.w	3de <dns_send+0x176>
    LWIP_ASSERT("pbuf must be in one piece", p->next == NULL);
    /* fill dns header */
    hdr = (struct dns_hdr*)p->payload;
 29e:	69fb      	ldr	r3, [r7, #28]
 2a0:	685b      	ldr	r3, [r3, #4]
 2a2:	61bb      	str	r3, [r7, #24]
    memset(hdr, 0, SIZEOF_DNS_HDR);
 2a4:	69b8      	ldr	r0, [r7, #24]
 2a6:	f04f 0100 	mov.w	r1, #0
 2aa:	f04f 020c 	mov.w	r2, #12
 2ae:	f7ff fffe 	bl	0 <memset>
			2ae: R_ARM_THM_CALL	memset
    hdr->id = htons(id);
 2b2:	79fb      	ldrb	r3, [r7, #7]
 2b4:	b29b      	uxth	r3, r3
 2b6:	4618      	mov	r0, r3
 2b8:	f7ff fffe 	bl	0 <lwip_htons>
			2b8: R_ARM_THM_CALL	lwip_htons
 2bc:	4603      	mov	r3, r0
 2be:	461a      	mov	r2, r3
 2c0:	69bb      	ldr	r3, [r7, #24]
 2c2:	801a      	strh	r2, [r3, #0]
    hdr->flags1 = DNS_FLAG1_RD;
 2c4:	69bb      	ldr	r3, [r7, #24]
 2c6:	f04f 0201 	mov.w	r2, #1
 2ca:	709a      	strb	r2, [r3, #2]
    hdr->numquestions = PP_HTONS(1);
 2cc:	69bb      	ldr	r3, [r7, #24]
 2ce:	f04f 0200 	mov.w	r2, #0
 2d2:	711a      	strb	r2, [r3, #4]
 2d4:	f04f 0200 	mov.w	r2, #0
 2d8:	f042 0201 	orr.w	r2, r2, #1
 2dc:	715a      	strb	r2, [r3, #5]
    query = (char*)hdr + SIZEOF_DNS_HDR;
 2de:	69bb      	ldr	r3, [r7, #24]
 2e0:	f103 030c 	add.w	r3, r3, #12
 2e4:	62bb      	str	r3, [r7, #40]	; 0x28
    pHostname = name;
 2e6:	68bb      	ldr	r3, [r7, #8]
 2e8:	627b      	str	r3, [r7, #36]	; 0x24
    --pHostname;
 2ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 2ec:	f103 33ff 	add.w	r3, r3, #4294967295
 2f0:	627b      	str	r3, [r7, #36]	; 0x24

    /* convert hostname into suitable query format. */
    do {
      ++pHostname;
 2f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 2f4:	f103 0301 	add.w	r3, r3, #1
 2f8:	627b      	str	r3, [r7, #36]	; 0x24
      nptr = query;
 2fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 2fc:	617b      	str	r3, [r7, #20]
      ++query;
 2fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 300:	f103 0301 	add.w	r3, r3, #1
 304:	62bb      	str	r3, [r7, #40]	; 0x28
      for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
 306:	f04f 0300 	mov.w	r3, #0
 30a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 30e:	e011      	b.n	334 <dns_send+0xcc>
        *query = *pHostname;
 310:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 312:	781a      	ldrb	r2, [r3, #0]
 314:	6abb      	ldr	r3, [r7, #40]	; 0x28
 316:	701a      	strb	r2, [r3, #0]
        ++query;
 318:	6abb      	ldr	r3, [r7, #40]	; 0x28
 31a:	f103 0301 	add.w	r3, r3, #1
 31e:	62bb      	str	r3, [r7, #40]	; 0x28
        ++n;
 320:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 324:	f103 0301 	add.w	r3, r3, #1
 328:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    /* convert hostname into suitable query format. */
    do {
      ++pHostname;
      nptr = query;
      ++query;
      for(n = 0; *pHostname != '.' && *pHostname != 0; ++pHostname) {
 32c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 32e:	f103 0301 	add.w	r3, r3, #1
 332:	627b      	str	r3, [r7, #36]	; 0x24
 334:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 336:	781b      	ldrb	r3, [r3, #0]
 338:	2b2e      	cmp	r3, #46	; 0x2e
 33a:	d003      	beq.n	344 <dns_send+0xdc>
 33c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 33e:	781b      	ldrb	r3, [r3, #0]
 340:	2b00      	cmp	r3, #0
 342:	d1e5      	bne.n	310 <dns_send+0xa8>
        *query = *pHostname;
        ++query;
        ++n;
      }
      *nptr = n;
 344:	697b      	ldr	r3, [r7, #20]
 346:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 34a:	701a      	strb	r2, [r3, #0]
    } while(*pHostname != 0);
 34c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 34e:	781b      	ldrb	r3, [r3, #0]
 350:	2b00      	cmp	r3, #0
 352:	d1ce      	bne.n	2f2 <dns_send+0x8a>
    *query++='\0';
 354:	6abb      	ldr	r3, [r7, #40]	; 0x28
 356:	f04f 0200 	mov.w	r2, #0
 35a:	701a      	strb	r2, [r3, #0]
 35c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 35e:	f103 0301 	add.w	r3, r3, #1
 362:	62bb      	str	r3, [r7, #40]	; 0x28

    /* fill dns query */
    qry.type = PP_HTONS(DNS_RRTYPE_A);
 364:	f44f 7380 	mov.w	r3, #256	; 0x100
 368:	823b      	strh	r3, [r7, #16]
    qry.cls = PP_HTONS(DNS_RRCLASS_IN);
 36a:	f44f 7380 	mov.w	r3, #256	; 0x100
 36e:	827b      	strh	r3, [r7, #18]
    SMEMCPY(query, &qry, SIZEOF_DNS_QUERY);
 370:	f107 0310 	add.w	r3, r7, #16
 374:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 376:	4619      	mov	r1, r3
 378:	f04f 0204 	mov.w	r2, #4
 37c:	f7ff fffe 	bl	0 <memcpy>
			37c: R_ARM_THM_CALL	memcpy

    /* resize pbuf to the exact dns query */
    pbuf_realloc(p, (u16_t)((query + SIZEOF_DNS_QUERY) - ((char*)(p->payload))));
 380:	6abb      	ldr	r3, [r7, #40]	; 0x28
 382:	f103 0304 	add.w	r3, r3, #4
 386:	b29a      	uxth	r2, r3
 388:	69fb      	ldr	r3, [r7, #28]
 38a:	685b      	ldr	r3, [r3, #4]
 38c:	b29b      	uxth	r3, r3
 38e:	1ad3      	subs	r3, r2, r3
 390:	b29b      	uxth	r3, r3
 392:	69f8      	ldr	r0, [r7, #28]
 394:	4619      	mov	r1, r3
 396:	f7ff fffe 	bl	0 <pbuf_realloc>
			396: R_ARM_THM_CALL	pbuf_realloc

    /* connect to the server for faster receiving */
    udp_connect(dns_pcb, &dns_servers[numdns], DNS_SERVER_PORT);
 39a:	4b18      	ldr	r3, [pc, #96]	; (3fc <dns_send+0x194>)
 39c:	681a      	ldr	r2, [r3, #0]
 39e:	7bfb      	ldrb	r3, [r7, #15]
 3a0:	ea4f 0183 	mov.w	r1, r3, lsl #2
 3a4:	4b14      	ldr	r3, [pc, #80]	; (3f8 <dns_send+0x190>)
 3a6:	18cb      	adds	r3, r1, r3
 3a8:	4610      	mov	r0, r2
 3aa:	4619      	mov	r1, r3
 3ac:	f04f 0235 	mov.w	r2, #53	; 0x35
 3b0:	f7ff fffe 	bl	0 <udp_connect>
			3b0: R_ARM_THM_CALL	udp_connect
    /* send dns packet */
    err = udp_sendto(dns_pcb, p, &dns_servers[numdns], DNS_SERVER_PORT);
 3b4:	4b11      	ldr	r3, [pc, #68]	; (3fc <dns_send+0x194>)
 3b6:	681a      	ldr	r2, [r3, #0]
 3b8:	7bfb      	ldrb	r3, [r7, #15]
 3ba:	ea4f 0183 	mov.w	r1, r3, lsl #2
 3be:	4b0e      	ldr	r3, [pc, #56]	; (3f8 <dns_send+0x190>)
 3c0:	18cb      	adds	r3, r1, r3
 3c2:	4610      	mov	r0, r2
 3c4:	69f9      	ldr	r1, [r7, #28]
 3c6:	461a      	mov	r2, r3
 3c8:	f04f 0335 	mov.w	r3, #53	; 0x35
 3cc:	f7ff fffe 	bl	0 <udp_sendto>
			3cc: R_ARM_THM_CALL	udp_sendto
 3d0:	4603      	mov	r3, r0
 3d2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    /* free pbuf */
    pbuf_free(p);
 3d6:	69f8      	ldr	r0, [r7, #28]
 3d8:	f7ff fffe 	bl	0 <pbuf_free>
			3d8: R_ARM_THM_CALL	pbuf_free
 3dc:	e003      	b.n	3e6 <dns_send+0x17e>
  } else {
    err = ERR_MEM;
 3de:	f04f 03ff 	mov.w	r3, #255	; 0xff
 3e2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  }

  return err;
 3e6:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 3ea:	b25b      	sxtb	r3, r3
}
 3ec:	4618      	mov	r0, r3
 3ee:	f107 0730 	add.w	r7, r7, #48	; 0x30
 3f2:	46bd      	mov	sp, r7
 3f4:	bd80      	pop	{r7, pc}
 3f6:	bf00      	nop
 3f8:	00000468 	.word	0x00000468
			3f8: R_ARM_ABS32	.bss
 3fc:	00000000 	.word	0x00000000
			3fc: R_ARM_ABS32	.bss

00000400 <dns_check_entry>:
 *
 * @param i index of the dns_table entry to check
 */
static void
dns_check_entry(u8_t i)
{
 400:	b580      	push	{r7, lr}
 402:	b084      	sub	sp, #16
 404:	af00      	add	r7, sp, #0
 406:	4603      	mov	r3, r0
 408:	71fb      	strb	r3, [r7, #7]
  err_t err;
  struct dns_table_entry *pEntry = &dns_table[i];
 40a:	79fb      	ldrb	r3, [r7, #7]
 40c:	f44f 728c 	mov.w	r2, #280	; 0x118
 410:	fb02 f203 	mul.w	r2, r2, r3
 414:	4b5e      	ldr	r3, [pc, #376]	; (590 <dns_check_entry+0x190>)
 416:	18d3      	adds	r3, r2, r3
 418:	60fb      	str	r3, [r7, #12]

  LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);

  switch(pEntry->state) {
 41a:	68fb      	ldr	r3, [r7, #12]
 41c:	781b      	ldrb	r3, [r3, #0]
 41e:	2b03      	cmp	r3, #3
 420:	f200 80ad 	bhi.w	57e <dns_check_entry+0x17e>
 424:	a201      	add	r2, pc, #4	; (adr r2, 42c <dns_check_entry+0x2c>)
 426:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 42a:	bf00      	nop
 42c:	0000057f 	.word	0x0000057f
			42c: R_ARM_ABS32	.text
 430:	0000043d 	.word	0x0000043d
			430: R_ARM_ABS32	.text
 434:	00000479 	.word	0x00000479
			434: R_ARM_ABS32	.text
 438:	00000557 	.word	0x00000557
			438: R_ARM_ABS32	.text

    case DNS_STATE_NEW: {
      /* initialize new entry */
      pEntry->state   = DNS_STATE_ASKING;
 43c:	68fb      	ldr	r3, [r7, #12]
 43e:	f04f 0202 	mov.w	r2, #2
 442:	701a      	strb	r2, [r3, #0]
      pEntry->numdns  = 0;
 444:	68fb      	ldr	r3, [r7, #12]
 446:	f04f 0200 	mov.w	r2, #0
 44a:	705a      	strb	r2, [r3, #1]
      pEntry->tmr     = 1;
 44c:	68fb      	ldr	r3, [r7, #12]
 44e:	f04f 0201 	mov.w	r2, #1
 452:	709a      	strb	r2, [r3, #2]
      pEntry->retries = 0;
 454:	68fb      	ldr	r3, [r7, #12]
 456:	f04f 0200 	mov.w	r2, #0
 45a:	70da      	strb	r2, [r3, #3]
      
      /* send DNS packet for this entry */
      err = dns_send(pEntry->numdns, pEntry->name, i);
 45c:	68fb      	ldr	r3, [r7, #12]
 45e:	7859      	ldrb	r1, [r3, #1]
 460:	68fb      	ldr	r3, [r7, #12]
 462:	f103 020c 	add.w	r2, r3, #12
 466:	79fb      	ldrb	r3, [r7, #7]
 468:	4608      	mov	r0, r1
 46a:	4611      	mov	r1, r2
 46c:	461a      	mov	r2, r3
 46e:	f7ff fefb 	bl	268 <dns_send>
 472:	4603      	mov	r3, r0
 474:	72fb      	strb	r3, [r7, #11]
      if (err != ERR_OK) {
        LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                    ("dns_send returned error: %s\n", lwip_strerr(err)));
      }
      break;
 476:	e087      	b.n	588 <dns_check_entry+0x188>
    }

    case DNS_STATE_ASKING: {
      if (--pEntry->tmr == 0) {
 478:	68fb      	ldr	r3, [r7, #12]
 47a:	789b      	ldrb	r3, [r3, #2]
 47c:	f103 33ff 	add.w	r3, r3, #4294967295
 480:	b2da      	uxtb	r2, r3
 482:	68fb      	ldr	r3, [r7, #12]
 484:	709a      	strb	r2, [r3, #2]
 486:	68fb      	ldr	r3, [r7, #12]
 488:	789b      	ldrb	r3, [r3, #2]
 48a:	2b00      	cmp	r3, #0
 48c:	d179      	bne.n	582 <dns_check_entry+0x182>
        if (++pEntry->retries == DNS_MAX_RETRIES) {
 48e:	68fb      	ldr	r3, [r7, #12]
 490:	78db      	ldrb	r3, [r3, #3]
 492:	f103 0301 	add.w	r3, r3, #1
 496:	b2da      	uxtb	r2, r3
 498:	68fb      	ldr	r3, [r7, #12]
 49a:	70da      	strb	r2, [r3, #3]
 49c:	68fb      	ldr	r3, [r7, #12]
 49e:	78db      	ldrb	r3, [r3, #3]
 4a0:	2b04      	cmp	r3, #4
 4a2:	d146      	bne.n	532 <dns_check_entry+0x132>
          if ((pEntry->numdns+1<DNS_MAX_SERVERS) && !ip_addr_isany(&dns_servers[pEntry->numdns+1])) {
 4a4:	68fb      	ldr	r3, [r7, #12]
 4a6:	785b      	ldrb	r3, [r3, #1]
 4a8:	f103 0301 	add.w	r3, r3, #1
 4ac:	2b01      	cmp	r3, #1
 4ae:	dc24      	bgt.n	4fa <dns_check_entry+0xfa>
 4b0:	68fb      	ldr	r3, [r7, #12]
 4b2:	785b      	ldrb	r3, [r3, #1]
 4b4:	f103 0301 	add.w	r3, r3, #1
 4b8:	ea4f 0283 	mov.w	r2, r3, lsl #2
 4bc:	4b35      	ldr	r3, [pc, #212]	; (594 <dns_check_entry+0x194>)
 4be:	18d3      	adds	r3, r2, r3
 4c0:	2b00      	cmp	r3, #0
 4c2:	d01a      	beq.n	4fa <dns_check_entry+0xfa>
 4c4:	68fb      	ldr	r3, [r7, #12]
 4c6:	785b      	ldrb	r3, [r3, #1]
 4c8:	f103 0301 	add.w	r3, r3, #1
 4cc:	ea4f 0283 	mov.w	r2, r3, lsl #2
 4d0:	4b30      	ldr	r3, [pc, #192]	; (594 <dns_check_entry+0x194>)
 4d2:	18d3      	adds	r3, r2, r3
 4d4:	681b      	ldr	r3, [r3, #0]
 4d6:	2b00      	cmp	r3, #0
 4d8:	d00f      	beq.n	4fa <dns_check_entry+0xfa>
            /* change of server */
            pEntry->numdns++;
 4da:	68fb      	ldr	r3, [r7, #12]
 4dc:	785b      	ldrb	r3, [r3, #1]
 4de:	f103 0301 	add.w	r3, r3, #1
 4e2:	b2da      	uxtb	r2, r3
 4e4:	68fb      	ldr	r3, [r7, #12]
 4e6:	705a      	strb	r2, [r3, #1]
            pEntry->tmr     = 1;
 4e8:	68fb      	ldr	r3, [r7, #12]
 4ea:	f04f 0201 	mov.w	r2, #1
 4ee:	709a      	strb	r2, [r3, #2]
            pEntry->retries = 0;
 4f0:	68fb      	ldr	r3, [r7, #12]
 4f2:	f04f 0200 	mov.w	r2, #0
 4f6:	70da      	strb	r2, [r3, #3]
            break;
 4f8:	e046      	b.n	588 <dns_check_entry+0x188>
          } else {
            LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", pEntry->name));
            /* call specified callback function if provided */
            if (pEntry->found)
 4fa:	68fb      	ldr	r3, [r7, #12]
 4fc:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 500:	2b00      	cmp	r3, #0
 502:	d00c      	beq.n	51e <dns_check_entry+0x11e>
              (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
 504:	68fb      	ldr	r3, [r7, #12]
 506:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 50a:	68fa      	ldr	r2, [r7, #12]
 50c:	f102 010c 	add.w	r1, r2, #12
 510:	68fa      	ldr	r2, [r7, #12]
 512:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
 516:	4608      	mov	r0, r1
 518:	f04f 0100 	mov.w	r1, #0
 51c:	4798      	blx	r3
            /* flush this entry */
            pEntry->state   = DNS_STATE_UNUSED;
 51e:	68fb      	ldr	r3, [r7, #12]
 520:	f04f 0200 	mov.w	r2, #0
 524:	701a      	strb	r2, [r3, #0]
            pEntry->found   = NULL;
 526:	68fb      	ldr	r3, [r7, #12]
 528:	f04f 0200 	mov.w	r2, #0
 52c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            break;
 530:	e02a      	b.n	588 <dns_check_entry+0x188>
          }
        }

        /* wait longer for the next retry */
        pEntry->tmr = pEntry->retries;
 532:	68fb      	ldr	r3, [r7, #12]
 534:	78da      	ldrb	r2, [r3, #3]
 536:	68fb      	ldr	r3, [r7, #12]
 538:	709a      	strb	r2, [r3, #2]

        /* send DNS packet for this entry */
        err = dns_send(pEntry->numdns, pEntry->name, i);
 53a:	68fb      	ldr	r3, [r7, #12]
 53c:	7859      	ldrb	r1, [r3, #1]
 53e:	68fb      	ldr	r3, [r7, #12]
 540:	f103 020c 	add.w	r2, r3, #12
 544:	79fb      	ldrb	r3, [r7, #7]
 546:	4608      	mov	r0, r1
 548:	4611      	mov	r1, r2
 54a:	461a      	mov	r2, r3
 54c:	f7ff fe8c 	bl	268 <dns_send>
 550:	4603      	mov	r3, r0
 552:	72fb      	strb	r3, [r7, #11]
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 554:	e018      	b.n	588 <dns_check_entry+0x188>
    }

    case DNS_STATE_DONE: {
      /* if the time to live is nul */
      if (--pEntry->ttl == 0) {
 556:	68fb      	ldr	r3, [r7, #12]
 558:	689b      	ldr	r3, [r3, #8]
 55a:	f103 32ff 	add.w	r2, r3, #4294967295
 55e:	68fb      	ldr	r3, [r7, #12]
 560:	609a      	str	r2, [r3, #8]
 562:	68fb      	ldr	r3, [r7, #12]
 564:	689b      	ldr	r3, [r3, #8]
 566:	2b00      	cmp	r3, #0
 568:	d10d      	bne.n	586 <dns_check_entry+0x186>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
        /* flush this entry */
        pEntry->state = DNS_STATE_UNUSED;
 56a:	68fb      	ldr	r3, [r7, #12]
 56c:	f04f 0200 	mov.w	r2, #0
 570:	701a      	strb	r2, [r3, #0]
        pEntry->found = NULL;
 572:	68fb      	ldr	r3, [r7, #12]
 574:	f04f 0200 	mov.w	r2, #0
 578:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
      }
      break;
 57c:	e004      	b.n	588 <dns_check_entry+0x188>
    case DNS_STATE_UNUSED:
      /* nothing to do */
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
      break;
 57e:	bf00      	nop
 580:	e002      	b.n	588 <dns_check_entry+0x188>
        if (err != ERR_OK) {
          LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
                      ("dns_send returned error: %s\n", lwip_strerr(err)));
        }
      }
      break;
 582:	bf00      	nop
 584:	e000      	b.n	588 <dns_check_entry+0x188>
        LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", pEntry->name));
        /* flush this entry */
        pEntry->state = DNS_STATE_UNUSED;
        pEntry->found = NULL;
      }
      break;
 586:	bf00      	nop
      break;
    default:
      LWIP_ASSERT("unknown dns_table entry state:", 0);
      break;
  }
}
 588:	f107 0710 	add.w	r7, r7, #16
 58c:	46bd      	mov	sp, r7
 58e:	bd80      	pop	{r7, pc}
 590:	00000008 	.word	0x00000008
			590: R_ARM_ABS32	.bss
 594:	00000468 	.word	0x00000468
			594: R_ARM_ABS32	.bss

00000598 <dns_check_entries>:
/**
 * Call dns_check_entry for each entry in dns_table - check all entries.
 */
static void
dns_check_entries(void)
{
 598:	b580      	push	{r7, lr}
 59a:	b082      	sub	sp, #8
 59c:	af00      	add	r7, sp, #0
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 59e:	f04f 0300 	mov.w	r3, #0
 5a2:	71fb      	strb	r3, [r7, #7]
 5a4:	e007      	b.n	5b6 <dns_check_entries+0x1e>
    dns_check_entry(i);
 5a6:	79fb      	ldrb	r3, [r7, #7]
 5a8:	4618      	mov	r0, r3
 5aa:	f7ff ff29 	bl	400 <dns_check_entry>
static void
dns_check_entries(void)
{
  u8_t i;

  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 5ae:	79fb      	ldrb	r3, [r7, #7]
 5b0:	f103 0301 	add.w	r3, r3, #1
 5b4:	71fb      	strb	r3, [r7, #7]
 5b6:	79fb      	ldrb	r3, [r7, #7]
 5b8:	2b03      	cmp	r3, #3
 5ba:	d9f4      	bls.n	5a6 <dns_check_entries+0xe>
    dns_check_entry(i);
  }
}
 5bc:	f107 0708 	add.w	r7, r7, #8
 5c0:	46bd      	mov	sp, r7
 5c2:	bd80      	pop	{r7, pc}

000005c4 <dns_recv>:
 *
 * @params see udp.h
 */
static void
dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, ip_addr_t *addr, u16_t port)
{
 5c4:	b580      	push	{r7, lr}
 5c6:	b08e      	sub	sp, #56	; 0x38
 5c8:	af00      	add	r7, sp, #0
 5ca:	60f8      	str	r0, [r7, #12]
 5cc:	60b9      	str	r1, [r7, #8]
 5ce:	607a      	str	r2, [r7, #4]
 5d0:	603b      	str	r3, [r7, #0]
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);

  /* is the dns message too big ? */
  if (p->tot_len > DNS_MSG_SIZE) {
 5d2:	687b      	ldr	r3, [r7, #4]
 5d4:	891b      	ldrh	r3, [r3, #8]
 5d6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 5da:	f200 80ea 	bhi.w	7b2 <dns_recv+0x1ee>
    /* free pbuf and return */
    goto memerr;
  }

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
 5de:	687b      	ldr	r3, [r7, #4]
 5e0:	891b      	ldrh	r3, [r3, #8]
 5e2:	2b19      	cmp	r3, #25
 5e4:	f240 80e7 	bls.w	7b6 <dns_recv+0x1f2>
    /* free pbuf and return */
    goto memerr;
  }

  /* copy dns payload inside static buffer for processing */ 
  if (pbuf_copy_partial(p, dns_payload, p->tot_len, 0) == p->tot_len) {
 5e8:	4b7b      	ldr	r3, [pc, #492]	; (7d8 <dns_recv+0x214>)
 5ea:	681a      	ldr	r2, [r3, #0]
 5ec:	687b      	ldr	r3, [r7, #4]
 5ee:	891b      	ldrh	r3, [r3, #8]
 5f0:	6878      	ldr	r0, [r7, #4]
 5f2:	4611      	mov	r1, r2
 5f4:	461a      	mov	r2, r3
 5f6:	f04f 0300 	mov.w	r3, #0
 5fa:	f7ff fffe 	bl	0 <pbuf_copy_partial>
			5fa: R_ARM_THM_CALL	pbuf_copy_partial
 5fe:	4603      	mov	r3, r0
 600:	461a      	mov	r2, r3
 602:	687b      	ldr	r3, [r7, #4]
 604:	891b      	ldrh	r3, [r3, #8]
 606:	429a      	cmp	r2, r3
 608:	f040 80d7 	bne.w	7ba <dns_recv+0x1f6>
    /* The ID in the DNS header should be our entry into the name table. */
    hdr = (struct dns_hdr*)dns_payload;
 60c:	4b72      	ldr	r3, [pc, #456]	; (7d8 <dns_recv+0x214>)
 60e:	681b      	ldr	r3, [r3, #0]
 610:	62fb      	str	r3, [r7, #44]	; 0x2c
    i = htons(hdr->id);
 612:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 614:	881b      	ldrh	r3, [r3, #0]
 616:	b29b      	uxth	r3, r3
 618:	4618      	mov	r0, r3
 61a:	f7ff fffe 	bl	0 <lwip_htons>
			61a: R_ARM_THM_CALL	lwip_htons
 61e:	4603      	mov	r3, r0
 620:	857b      	strh	r3, [r7, #42]	; 0x2a
    if (i < DNS_TABLE_SIZE) {
 622:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 624:	2b03      	cmp	r3, #3
 626:	f200 80ca 	bhi.w	7be <dns_recv+0x1fa>
      pEntry = &dns_table[i];
 62a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 62c:	f44f 728c 	mov.w	r2, #280	; 0x118
 630:	fb02 f203 	mul.w	r2, r2, r3
 634:	4b69      	ldr	r3, [pc, #420]	; (7dc <dns_recv+0x218>)
 636:	18d3      	adds	r3, r2, r3
 638:	627b      	str	r3, [r7, #36]	; 0x24
      if(pEntry->state == DNS_STATE_ASKING) {
 63a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 63c:	781b      	ldrb	r3, [r3, #0]
 63e:	2b02      	cmp	r3, #2
 640:	f040 80bf 	bne.w	7c2 <dns_recv+0x1fe>
        /* This entry is now completed. */
        pEntry->state = DNS_STATE_DONE;
 644:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 646:	f04f 0203 	mov.w	r2, #3
 64a:	701a      	strb	r2, [r3, #0]
        pEntry->err   = hdr->flags2 & DNS_FLAG2_ERR_MASK;
 64c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 64e:	78db      	ldrb	r3, [r3, #3]
 650:	f003 030f 	and.w	r3, r3, #15
 654:	b2da      	uxtb	r2, r3
 656:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 658:	715a      	strb	r2, [r3, #5]

        /* We only care about the question(s) and the answers. The authrr
           and the extrarr are simply discarded. */
        nquestions = htons(hdr->numquestions);
 65a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 65c:	889b      	ldrh	r3, [r3, #4]
 65e:	b29b      	uxth	r3, r3
 660:	4618      	mov	r0, r3
 662:	f7ff fffe 	bl	0 <lwip_htons>
			662: R_ARM_THM_CALL	lwip_htons
 666:	4603      	mov	r3, r0
 668:	847b      	strh	r3, [r7, #34]	; 0x22
        nanswers   = htons(hdr->numanswers);
 66a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 66c:	88db      	ldrh	r3, [r3, #6]
 66e:	b29b      	uxth	r3, r3
 670:	4618      	mov	r0, r3
 672:	f7ff fffe 	bl	0 <lwip_htons>
			672: R_ARM_THM_CALL	lwip_htons
 676:	4603      	mov	r3, r0
 678:	867b      	strh	r3, [r7, #50]	; 0x32

        /* Check for error. If so, call callback to inform. */
        if (((hdr->flags1 & DNS_FLAG1_RESPONSE) == 0) || (pEntry->err != 0) || (nquestions != 1)) {
 67a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 67c:	789b      	ldrb	r3, [r3, #2]
 67e:	b2db      	uxtb	r3, r3
 680:	b25b      	sxtb	r3, r3
 682:	2b00      	cmp	r3, #0
 684:	da79      	bge.n	77a <dns_recv+0x1b6>
 686:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 688:	795b      	ldrb	r3, [r3, #5]
 68a:	2b00      	cmp	r3, #0
 68c:	d175      	bne.n	77a <dns_recv+0x1b6>
 68e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 690:	2b01      	cmp	r3, #1
 692:	d172      	bne.n	77a <dns_recv+0x1b6>
          goto responseerr;
        }

#if DNS_DOES_NAME_CHECK
        /* Check if the name in the "question" part match with the name in the entry. */
        if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
 694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 696:	f103 020c 	add.w	r2, r3, #12
 69a:	4b4f      	ldr	r3, [pc, #316]	; (7d8 <dns_recv+0x214>)
 69c:	681b      	ldr	r3, [r3, #0]
 69e:	f103 030c 	add.w	r3, r3, #12
 6a2:	4610      	mov	r0, r2
 6a4:	4619      	mov	r1, r3
 6a6:	f7ff fd7b 	bl	1a0 <dns_compare_name>
 6aa:	4603      	mov	r3, r0
 6ac:	2b00      	cmp	r3, #0
 6ae:	d163      	bne.n	778 <dns_recv+0x1b4>
          goto responseerr;
        }
#endif /* DNS_DOES_NAME_CHECK */

        /* Skip the name in the "question" part */
        pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;
 6b0:	4b49      	ldr	r3, [pc, #292]	; (7d8 <dns_recv+0x214>)
 6b2:	681b      	ldr	r3, [r3, #0]
 6b4:	f103 030c 	add.w	r3, r3, #12
 6b8:	4618      	mov	r0, r3
 6ba:	f7ff fdab 	bl	214 <dns_parse_name>
 6be:	4603      	mov	r3, r0
 6c0:	f103 0304 	add.w	r3, r3, #4
 6c4:	637b      	str	r3, [r7, #52]	; 0x34

        while (nanswers > 0) {
 6c6:	e053      	b.n	770 <dns_recv+0x1ac>
          /* skip answer resource record's host name */
          pHostname = (char *) dns_parse_name((unsigned char *)pHostname);
 6c8:	6b78      	ldr	r0, [r7, #52]	; 0x34
 6ca:	f7ff fda3 	bl	214 <dns_parse_name>
 6ce:	6378      	str	r0, [r7, #52]	; 0x34

          /* Check for IP address type and Internet class. Others are discarded. */
          SMEMCPY(&ans, pHostname, SIZEOF_DNS_ANSWER);
 6d0:	f107 0314 	add.w	r3, r7, #20
 6d4:	4618      	mov	r0, r3
 6d6:	6b79      	ldr	r1, [r7, #52]	; 0x34
 6d8:	f04f 020a 	mov.w	r2, #10
 6dc:	f7ff fffe 	bl	0 <memcpy>
			6dc: R_ARM_THM_CALL	memcpy
          if((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) &&
 6e0:	8abb      	ldrh	r3, [r7, #20]
 6e2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 6e6:	d135      	bne.n	754 <dns_recv+0x190>
 6e8:	8afb      	ldrh	r3, [r7, #22]
 6ea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 6ee:	d131      	bne.n	754 <dns_recv+0x190>
             (ans.len == PP_HTONS(sizeof(ip_addr_t))) ) {
 6f0:	8bbb      	ldrh	r3, [r7, #28]
          /* skip answer resource record's host name */
          pHostname = (char *) dns_parse_name((unsigned char *)pHostname);

          /* Check for IP address type and Internet class. Others are discarded. */
          SMEMCPY(&ans, pHostname, SIZEOF_DNS_ANSWER);
          if((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) &&
 6f2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 6f6:	d12d      	bne.n	754 <dns_recv+0x190>
             (ans.len == PP_HTONS(sizeof(ip_addr_t))) ) {
            /* read the answer resource record's TTL, and maximize it if needed */
            pEntry->ttl = ntohl(ans.ttl);
 6f8:	69bb      	ldr	r3, [r7, #24]
 6fa:	4618      	mov	r0, r3
 6fc:	f7ff fffe 	bl	0 <lwip_ntohl>
			6fc: R_ARM_THM_CALL	lwip_ntohl
 700:	4602      	mov	r2, r0
 702:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 704:	609a      	str	r2, [r3, #8]
            if (pEntry->ttl > DNS_MAX_TTL) {
 706:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 708:	689a      	ldr	r2, [r3, #8]
 70a:	4b35      	ldr	r3, [pc, #212]	; (7e0 <dns_recv+0x21c>)
 70c:	429a      	cmp	r2, r3
 70e:	d902      	bls.n	716 <dns_recv+0x152>
              pEntry->ttl = DNS_MAX_TTL;
 710:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 712:	4a33      	ldr	r2, [pc, #204]	; (7e0 <dns_recv+0x21c>)
 714:	609a      	str	r2, [r3, #8]
            }
            /* read the IP address after answer resource record's header */
            SMEMCPY(&(pEntry->ipaddr), (pHostname+SIZEOF_DNS_ANSWER), sizeof(ip_addr_t));
 716:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 718:	f503 7286 	add.w	r2, r3, #268	; 0x10c
 71c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 71e:	f103 030a 	add.w	r3, r3, #10
 722:	4610      	mov	r0, r2
 724:	4619      	mov	r1, r3
 726:	f04f 0204 	mov.w	r2, #4
 72a:	f7ff fffe 	bl	0 <memcpy>
			72a: R_ARM_THM_CALL	memcpy
            LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", pEntry->name));
            ip_addr_debug_print(DNS_DEBUG, (&(pEntry->ipaddr)));
            LWIP_DEBUGF(DNS_DEBUG, ("\n"));
            /* call specified callback function if provided */
            if (pEntry->found) {
 72e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 730:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 734:	2b00      	cmp	r3, #0
 736:	d046      	beq.n	7c6 <dns_recv+0x202>
              (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
 738:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 73a:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 73e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 740:	f102 000c 	add.w	r0, r2, #12
 744:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 746:	f502 7186 	add.w	r1, r2, #268	; 0x10c
 74a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 74c:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
 750:	4798      	blx	r3
            }
            /* deallocate memory and return */
            goto memerr;
 752:	e039      	b.n	7c8 <dns_recv+0x204>
          } else {
            pHostname = pHostname + SIZEOF_DNS_ANSWER + htons(ans.len);
 754:	8bbb      	ldrh	r3, [r7, #28]
 756:	4618      	mov	r0, r3
 758:	f7ff fffe 	bl	0 <lwip_htons>
			758: R_ARM_THM_CALL	lwip_htons
 75c:	4603      	mov	r3, r0
 75e:	f103 030a 	add.w	r3, r3, #10
 762:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 764:	18d3      	adds	r3, r2, r3
 766:	637b      	str	r3, [r7, #52]	; 0x34
          }
          --nanswers;
 768:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 76a:	f103 33ff 	add.w	r3, r3, #4294967295
 76e:	867b      	strh	r3, [r7, #50]	; 0x32
#endif /* DNS_DOES_NAME_CHECK */

        /* Skip the name in the "question" part */
        pHostname = (char *) dns_parse_name((unsigned char *)dns_payload + SIZEOF_DNS_HDR) + SIZEOF_DNS_QUERY;

        while (nanswers > 0) {
 770:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 772:	2b00      	cmp	r3, #0
 774:	d1a8      	bne.n	6c8 <dns_recv+0x104>
          }
          --nanswers;
        }
        LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", pEntry->name));
        /* call callback to indicate error, clean up memory and return */
        goto responseerr;
 776:	e000      	b.n	77a <dns_recv+0x1b6>
#if DNS_DOES_NAME_CHECK
        /* Check if the name in the "question" part match with the name in the entry. */
        if (dns_compare_name((unsigned char *)(pEntry->name), (unsigned char *)dns_payload + SIZEOF_DNS_HDR) != 0) {
          LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", pEntry->name));
          /* call callback to indicate error, clean up memory and return */
          goto responseerr;
 778:	bf00      	nop
  /* deallocate memory and return */
  goto memerr;

responseerr:
  /* ERROR: call specified callback function with NULL as name to indicate an error */
  if (pEntry->found) {
 77a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 77c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 780:	2b00      	cmp	r3, #0
 782:	d00c      	beq.n	79e <dns_recv+0x1da>
    (*pEntry->found)(pEntry->name, NULL, pEntry->arg);
 784:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 786:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 78a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 78c:	f102 010c 	add.w	r1, r2, #12
 790:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 792:	f8d2 2114 	ldr.w	r2, [r2, #276]	; 0x114
 796:	4608      	mov	r0, r1
 798:	f04f 0100 	mov.w	r1, #0
 79c:	4798      	blx	r3
  }
  /* flush this entry */
  pEntry->state = DNS_STATE_UNUSED;
 79e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 7a0:	f04f 0200 	mov.w	r2, #0
 7a4:	701a      	strb	r2, [r3, #0]
  pEntry->found = NULL;
 7a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 7a8:	f04f 0200 	mov.w	r2, #0
 7ac:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
 7b0:	e00a      	b.n	7c8 <dns_recv+0x204>

  /* is the dns message too big ? */
  if (p->tot_len > DNS_MSG_SIZE) {
    LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too big\n"));
    /* free pbuf and return */
    goto memerr;
 7b2:	bf00      	nop
 7b4:	e008      	b.n	7c8 <dns_recv+0x204>

  /* is the dns message big enough ? */
  if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY + SIZEOF_DNS_ANSWER)) {
    LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
    /* free pbuf and return */
    goto memerr;
 7b6:	bf00      	nop
 7b8:	e006      	b.n	7c8 <dns_recv+0x204>
      }
    }
  }

  /* deallocate memory and return */
  goto memerr;
 7ba:	bf00      	nop
 7bc:	e004      	b.n	7c8 <dns_recv+0x204>
 7be:	bf00      	nop
 7c0:	e002      	b.n	7c8 <dns_recv+0x204>
 7c2:	bf00      	nop
 7c4:	e000      	b.n	7c8 <dns_recv+0x204>
            /* call specified callback function if provided */
            if (pEntry->found) {
              (*pEntry->found)(pEntry->name, &pEntry->ipaddr, pEntry->arg);
            }
            /* deallocate memory and return */
            goto memerr;
 7c6:	bf00      	nop
  pEntry->state = DNS_STATE_UNUSED;
  pEntry->found = NULL;

memerr:
  /* free pbuf */
  pbuf_free(p);
 7c8:	6878      	ldr	r0, [r7, #4]
 7ca:	f7ff fffe 	bl	0 <pbuf_free>
			7ca: R_ARM_THM_CALL	pbuf_free
  return;
}
 7ce:	f107 0738 	add.w	r7, r7, #56	; 0x38
 7d2:	46bd      	mov	sp, r7
 7d4:	bd80      	pop	{r7, pc}
 7d6:	bf00      	nop
 7d8:	00000674 	.word	0x00000674
			7d8: R_ARM_ABS32	.bss
 7dc:	00000008 	.word	0x00000008
			7dc: R_ARM_ABS32	.bss
 7e0:	00093a80 	.word	0x00093a80

000007e4 <dns_enqueue>:
 * @param callback_arg argument to pass to the callback function
 * @return @return a err_t return code.
 */
static err_t
dns_enqueue(const char *name, dns_found_callback found, void *callback_arg)
{
 7e4:	b580      	push	{r7, lr}
 7e6:	b088      	sub	sp, #32
 7e8:	af00      	add	r7, sp, #0
 7ea:	60f8      	str	r0, [r7, #12]
 7ec:	60b9      	str	r1, [r7, #8]
 7ee:	607a      	str	r2, [r7, #4]
  u8_t i;
  u8_t lseq, lseqi;
  struct dns_table_entry *pEntry = NULL;
 7f0:	f04f 0300 	mov.w	r3, #0
 7f4:	61bb      	str	r3, [r7, #24]
  size_t namelen;

  /* search an unused entry, or the oldest one */
  lseq = lseqi = 0;
 7f6:	f04f 0300 	mov.w	r3, #0
 7fa:	777b      	strb	r3, [r7, #29]
 7fc:	7f7b      	ldrb	r3, [r7, #29]
 7fe:	77bb      	strb	r3, [r7, #30]
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 800:	f04f 0300 	mov.w	r3, #0
 804:	77fb      	strb	r3, [r7, #31]
 806:	e024      	b.n	852 <dns_enqueue+0x6e>
    pEntry = &dns_table[i];
 808:	7ffb      	ldrb	r3, [r7, #31]
 80a:	f44f 728c 	mov.w	r2, #280	; 0x118
 80e:	fb02 f203 	mul.w	r2, r2, r3
 812:	4b41      	ldr	r3, [pc, #260]	; (918 <dns_enqueue+0x134>)
 814:	18d3      	adds	r3, r2, r3
 816:	61bb      	str	r3, [r7, #24]
    /* is it an unused entry ? */
    if (pEntry->state == DNS_STATE_UNUSED)
 818:	69bb      	ldr	r3, [r7, #24]
 81a:	781b      	ldrb	r3, [r3, #0]
 81c:	2b00      	cmp	r3, #0
 81e:	d01c      	beq.n	85a <dns_enqueue+0x76>
      break;

    /* check if this is the oldest completed entry */
    if (pEntry->state == DNS_STATE_DONE) {
 820:	69bb      	ldr	r3, [r7, #24]
 822:	781b      	ldrb	r3, [r3, #0]
 824:	2b03      	cmp	r3, #3
 826:	d110      	bne.n	84a <dns_enqueue+0x66>
      if ((dns_seqno - pEntry->seqno) > lseq) {
 828:	4b3c      	ldr	r3, [pc, #240]	; (91c <dns_enqueue+0x138>)
 82a:	781b      	ldrb	r3, [r3, #0]
 82c:	461a      	mov	r2, r3
 82e:	69bb      	ldr	r3, [r7, #24]
 830:	791b      	ldrb	r3, [r3, #4]
 832:	1ad2      	subs	r2, r2, r3
 834:	7fbb      	ldrb	r3, [r7, #30]
 836:	429a      	cmp	r2, r3
 838:	dd07      	ble.n	84a <dns_enqueue+0x66>
        lseq = dns_seqno - pEntry->seqno;
 83a:	4b38      	ldr	r3, [pc, #224]	; (91c <dns_enqueue+0x138>)
 83c:	781a      	ldrb	r2, [r3, #0]
 83e:	69bb      	ldr	r3, [r7, #24]
 840:	791b      	ldrb	r3, [r3, #4]
 842:	1ad3      	subs	r3, r2, r3
 844:	77bb      	strb	r3, [r7, #30]
        lseqi = i;
 846:	7ffb      	ldrb	r3, [r7, #31]
 848:	777b      	strb	r3, [r7, #29]
  struct dns_table_entry *pEntry = NULL;
  size_t namelen;

  /* search an unused entry, or the oldest one */
  lseq = lseqi = 0;
  for (i = 0; i < DNS_TABLE_SIZE; ++i) {
 84a:	7ffb      	ldrb	r3, [r7, #31]
 84c:	f103 0301 	add.w	r3, r3, #1
 850:	77fb      	strb	r3, [r7, #31]
 852:	7ffb      	ldrb	r3, [r7, #31]
 854:	2b03      	cmp	r3, #3
 856:	d9d7      	bls.n	808 <dns_enqueue+0x24>
 858:	e000      	b.n	85c <dns_enqueue+0x78>
    pEntry = &dns_table[i];
    /* is it an unused entry ? */
    if (pEntry->state == DNS_STATE_UNUSED)
      break;
 85a:	bf00      	nop
      }
    }
  }

  /* if we don't have found an unused entry, use the oldest completed one */
  if (i == DNS_TABLE_SIZE) {
 85c:	7ffb      	ldrb	r3, [r7, #31]
 85e:	2b04      	cmp	r3, #4
 860:	d119      	bne.n	896 <dns_enqueue+0xb2>
    if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
 862:	7f7b      	ldrb	r3, [r7, #29]
 864:	2b03      	cmp	r3, #3
 866:	d809      	bhi.n	87c <dns_enqueue+0x98>
 868:	7f7b      	ldrb	r3, [r7, #29]
 86a:	4a2b      	ldr	r2, [pc, #172]	; (918 <dns_enqueue+0x134>)
 86c:	f44f 718c 	mov.w	r1, #280	; 0x118
 870:	fb01 f303 	mul.w	r3, r1, r3
 874:	18d3      	adds	r3, r2, r3
 876:	781b      	ldrb	r3, [r3, #0]
 878:	2b03      	cmp	r3, #3
 87a:	d002      	beq.n	882 <dns_enqueue+0x9e>
      /* no entry can't be used now, table is full */
      LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
      return ERR_MEM;
 87c:	f04f 03ff 	mov.w	r3, #255	; 0xff
 880:	e043      	b.n	90a <dns_enqueue+0x126>
    } else {
      /* use the oldest completed one */
      i = lseqi;
 882:	7f7b      	ldrb	r3, [r7, #29]
 884:	77fb      	strb	r3, [r7, #31]
      pEntry = &dns_table[i];
 886:	7ffb      	ldrb	r3, [r7, #31]
 888:	f44f 728c 	mov.w	r2, #280	; 0x118
 88c:	fb02 f203 	mul.w	r2, r2, r3
 890:	4b21      	ldr	r3, [pc, #132]	; (918 <dns_enqueue+0x134>)
 892:	18d3      	adds	r3, r2, r3
 894:	61bb      	str	r3, [r7, #24]

  /* use this entry */
  LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));

  /* fill the entry */
  pEntry->state = DNS_STATE_NEW;
 896:	69bb      	ldr	r3, [r7, #24]
 898:	f04f 0201 	mov.w	r2, #1
 89c:	701a      	strb	r2, [r3, #0]
  pEntry->seqno = dns_seqno++;
 89e:	4b1f      	ldr	r3, [pc, #124]	; (91c <dns_enqueue+0x138>)
 8a0:	781b      	ldrb	r3, [r3, #0]
 8a2:	69ba      	ldr	r2, [r7, #24]
 8a4:	4619      	mov	r1, r3
 8a6:	7111      	strb	r1, [r2, #4]
 8a8:	f103 0301 	add.w	r3, r3, #1
 8ac:	b2da      	uxtb	r2, r3
 8ae:	4b1b      	ldr	r3, [pc, #108]	; (91c <dns_enqueue+0x138>)
 8b0:	701a      	strb	r2, [r3, #0]
  pEntry->found = found;
 8b2:	69bb      	ldr	r3, [r7, #24]
 8b4:	68ba      	ldr	r2, [r7, #8]
 8b6:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  pEntry->arg   = callback_arg;
 8ba:	69bb      	ldr	r3, [r7, #24]
 8bc:	687a      	ldr	r2, [r7, #4]
 8be:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  namelen = LWIP_MIN(strlen(name), DNS_MAX_NAME_LENGTH-1);
 8c2:	68f8      	ldr	r0, [r7, #12]
 8c4:	f7ff fffe 	bl	0 <strlen>
			8c4: R_ARM_THM_CALL	strlen
 8c8:	4603      	mov	r3, r0
 8ca:	2bfe      	cmp	r3, #254	; 0xfe
 8cc:	d804      	bhi.n	8d8 <dns_enqueue+0xf4>
 8ce:	68f8      	ldr	r0, [r7, #12]
 8d0:	f7ff fffe 	bl	0 <strlen>
			8d0: R_ARM_THM_CALL	strlen
 8d4:	4603      	mov	r3, r0
 8d6:	e001      	b.n	8dc <dns_enqueue+0xf8>
 8d8:	f04f 03ff 	mov.w	r3, #255	; 0xff
 8dc:	617b      	str	r3, [r7, #20]
  MEMCPY(pEntry->name, name, namelen);
 8de:	69bb      	ldr	r3, [r7, #24]
 8e0:	f103 030c 	add.w	r3, r3, #12
 8e4:	4618      	mov	r0, r3
 8e6:	68f9      	ldr	r1, [r7, #12]
 8e8:	697a      	ldr	r2, [r7, #20]
 8ea:	f7ff fffe 	bl	0 <memcpy>
			8ea: R_ARM_THM_CALL	memcpy
  pEntry->name[namelen] = 0;
 8ee:	69ba      	ldr	r2, [r7, #24]
 8f0:	697b      	ldr	r3, [r7, #20]
 8f2:	18d3      	adds	r3, r2, r3
 8f4:	f103 0308 	add.w	r3, r3, #8
 8f8:	f04f 0200 	mov.w	r2, #0
 8fc:	711a      	strb	r2, [r3, #4]

  /* force to send query without waiting timer */
  dns_check_entry(i);
 8fe:	7ffb      	ldrb	r3, [r7, #31]
 900:	4618      	mov	r0, r3
 902:	f7ff fd7d 	bl	400 <dns_check_entry>

  /* dns query is enqueued */
  return ERR_INPROGRESS;
 906:	f04f 03fb 	mov.w	r3, #251	; 0xfb
 90a:	b25b      	sxtb	r3, r3
}
 90c:	4618      	mov	r0, r3
 90e:	f107 0720 	add.w	r7, r7, #32
 912:	46bd      	mov	sp, r7
 914:	bd80      	pop	{r7, pc}
 916:	bf00      	nop
 918:	00000008 	.word	0x00000008
			918: R_ARM_ABS32	.bss
 91c:	00000004 	.word	0x00000004
			91c: R_ARM_ABS32	.bss

00000920 <dns_gethostbyname>:
 * @return a err_t return code.
 */
err_t
dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
                  void *callback_arg)
{
 920:	b580      	push	{r7, lr}
 922:	b086      	sub	sp, #24
 924:	af00      	add	r7, sp, #0
 926:	60f8      	str	r0, [r7, #12]
 928:	60b9      	str	r1, [r7, #8]
 92a:	607a      	str	r2, [r7, #4]
 92c:	603b      	str	r3, [r7, #0]
  u32_t ipaddr;
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((dns_pcb == NULL) || (addr == NULL) ||
 92e:	4b1c      	ldr	r3, [pc, #112]	; (9a0 <dns_gethostbyname+0x80>)
 930:	681b      	ldr	r3, [r3, #0]
 932:	2b00      	cmp	r3, #0
 934:	d00f      	beq.n	956 <dns_gethostbyname+0x36>
 936:	68bb      	ldr	r3, [r7, #8]
 938:	2b00      	cmp	r3, #0
 93a:	d00c      	beq.n	956 <dns_gethostbyname+0x36>
 93c:	68fb      	ldr	r3, [r7, #12]
 93e:	2b00      	cmp	r3, #0
 940:	d009      	beq.n	956 <dns_gethostbyname+0x36>
      (!hostname) || (!hostname[0]) ||
 942:	68fb      	ldr	r3, [r7, #12]
 944:	781b      	ldrb	r3, [r3, #0]
 946:	2b00      	cmp	r3, #0
 948:	d005      	beq.n	956 <dns_gethostbyname+0x36>
      (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
 94a:	68f8      	ldr	r0, [r7, #12]
 94c:	f7ff fffe 	bl	0 <strlen>
			94c: R_ARM_THM_CALL	strlen
 950:	4603      	mov	r3, r0
{
  u32_t ipaddr;
  /* not initialized or no valid server yet, or invalid addr pointer
   * or invalid hostname or invalid hostname length */
  if ((dns_pcb == NULL) || (addr == NULL) ||
      (!hostname) || (!hostname[0]) ||
 952:	2bff      	cmp	r3, #255	; 0xff
 954:	d902      	bls.n	95c <dns_gethostbyname+0x3c>
      (strlen(hostname) >= DNS_MAX_NAME_LENGTH)) {
    return ERR_ARG;
 956:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 95a:	e01b      	b.n	994 <dns_gethostbyname+0x74>
    return ERR_OK;
  }
#endif /* LWIP_HAVE_LOOPIF */

  /* host name already in octet notation? set ip addr and return ERR_OK */
  ipaddr = ipaddr_addr(hostname);
 95c:	68f8      	ldr	r0, [r7, #12]
 95e:	f7ff fffe 	bl	0 <ipaddr_addr>
			95e: R_ARM_THM_CALL	ipaddr_addr
 962:	6178      	str	r0, [r7, #20]
  if (ipaddr == IPADDR_NONE) {
 964:	697b      	ldr	r3, [r7, #20]
 966:	f1b3 3fff 	cmp.w	r3, #4294967295
 96a:	d103      	bne.n	974 <dns_gethostbyname+0x54>
    /* already have this address cached? */
    ipaddr = dns_lookup(hostname);
 96c:	68f8      	ldr	r0, [r7, #12]
 96e:	f7ff fbd7 	bl	120 <dns_lookup>
 972:	6178      	str	r0, [r7, #20]
  }
  if (ipaddr != IPADDR_NONE) {
 974:	697b      	ldr	r3, [r7, #20]
 976:	f1b3 3fff 	cmp.w	r3, #4294967295
 97a:	d005      	beq.n	988 <dns_gethostbyname+0x68>
    ip4_addr_set_u32(addr, ipaddr);
 97c:	68bb      	ldr	r3, [r7, #8]
 97e:	697a      	ldr	r2, [r7, #20]
 980:	601a      	str	r2, [r3, #0]
    return ERR_OK;
 982:	f04f 0300 	mov.w	r3, #0
 986:	e005      	b.n	994 <dns_gethostbyname+0x74>
  }

  /* queue query with specified callback */
  return dns_enqueue(hostname, found, callback_arg);
 988:	68f8      	ldr	r0, [r7, #12]
 98a:	6879      	ldr	r1, [r7, #4]
 98c:	683a      	ldr	r2, [r7, #0]
 98e:	f7ff ff29 	bl	7e4 <dns_enqueue>
 992:	4603      	mov	r3, r0
 994:	b25b      	sxtb	r3, r3
}
 996:	4618      	mov	r0, r3
 998:	f107 0718 	add.w	r7, r7, #24
 99c:	46bd      	mov	sp, r7
 99e:	bd80      	pop	{r7, pc}
 9a0:	00000000 	.word	0x00000000
			9a0: R_ARM_ABS32	.bss

init.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  63760 Jul 30 19:07 2021 init.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000030  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000064  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000064  2**0
                  ALLOC
  3 .debug_abbrev 0000003f  00000000  00000000  00000064  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000007b  00000000  00000000  000000a3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000058d  00000000  00000000  0000011e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000e810  00000000  00000000  000006ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000002c  00000000  00000000  0000eebb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000020  00000000  00000000  0000eee7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000012  00000000  00000000  0000ef07  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000ef19  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000000cf  00000000  00000000  0000ef39  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000f008  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000f033  2**0
                  CONTENTS, READONLY
 14 .debug_frame  0000002c  00000000  00000000  0000f064  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 init.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	0000002e lwip_init
00000000         *UND*	00000000 sys_init
00000000         *UND*	00000000 mem_init
00000000         *UND*	00000000 memp_init
00000000         *UND*	00000000 netif_init
00000000         *UND*	00000000 lwip_socket_init
00000000         *UND*	00000000 udp_init
00000000         *UND*	00000000 tcp_init
00000000         *UND*	00000000 igmp_init
00000000         *UND*	00000000 dns_init
00000000         *UND*	00000000 sys_timeouts_init



Disassembly of section .text:

00000000 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
   0:	b580      	push	{r7, lr}
   2:	af00      	add	r7, sp, #0
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
   4:	f7ff fffe 	bl	0 <sys_init>
			4: R_ARM_THM_CALL	sys_init
#endif /* !NO_SYS */
  mem_init();
   8:	f7ff fffe 	bl	0 <mem_init>
			8: R_ARM_THM_CALL	mem_init
  memp_init();
   c:	f7ff fffe 	bl	0 <memp_init>
			c: R_ARM_THM_CALL	memp_init
  pbuf_init();
  netif_init();
  10:	f7ff fffe 	bl	0 <netif_init>
			10: R_ARM_THM_CALL	netif_init
#if LWIP_SOCKET
  lwip_socket_init();
  14:	f7ff fffe 	bl	0 <lwip_socket_init>
			14: R_ARM_THM_CALL	lwip_socket_init
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
  18:	f7ff fffe 	bl	0 <udp_init>
			18: R_ARM_THM_CALL	udp_init
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
  1c:	f7ff fffe 	bl	0 <tcp_init>
			1c: R_ARM_THM_CALL	tcp_init
#endif /* LWIP_SNMP */
#if LWIP_AUTOIP
  autoip_init();
#endif /* LWIP_AUTOIP */
#if LWIP_IGMP
  igmp_init();
  20:	f7ff fffe 	bl	0 <igmp_init>
			20: R_ARM_THM_CALL	igmp_init
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
  24:	f7ff fffe 	bl	0 <dns_init>
			24: R_ARM_THM_CALL	dns_init
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
  28:	f7ff fffe 	bl	0 <sys_timeouts_init>
			28: R_ARM_THM_CALL	sys_timeouts_init
#endif /* LWIP_TIMERS */
}
  2c:	bd80      	pop	{r7, pc}
  2e:	bf00      	nop

mem.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  51360 Jul 30 19:07 2021 mem.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000578  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000005ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000014  00000000  00000000  000005ac  2**2
                  ALLOC
  3 .debug_abbrev 00000159  00000000  00000000  000005ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000003fe  00000000  00000000  00000705  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000692  00000000  00000000  00000b03  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000a48f  00000000  00000000  00001195  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000150  00000000  00000000  0000b624  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000064  00000000  00000000  0000b774  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000097  00000000  00000000  0000b7d8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000b86f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000001e7  00000000  00000000  0000b88f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000ba76  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000baa1  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000cc  00000000  00000000  0000bad4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 mem.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 ram
00000004 l       .bss	00000000 ram_end
00000008 l       .bss	00000000 lfree
0000000c l       .bss	00000000 mem_mutex
00000000 l     F .text	000000cc plug_holes
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000654       O *COM*	00000004 ram_heap
000000cc g     F .text	00000090 mem_init
00000000         *UND*	00000000 sys_sem_new
0000015c g     F .text	0000008c mem_free
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
00000000         *UND*	00000000 sys_arch_sem_wait
00000000         *UND*	00000000 sys_sem_signal
000001e8 g     F .text	000001bc mem_trim
000003a4 g     F .text	0000018c mem_malloc
00000530 g     F .text	00000046 mem_calloc
00000000         *UND*	00000000 memset



Disassembly of section .text:

00000000 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);

  nmem = (struct mem *)(void *)&ram[mem->next];
   8:	4b2d      	ldr	r3, [pc, #180]	; (c0 <plug_holes+0xc0>)
   a:	681b      	ldr	r3, [r3, #0]
   c:	461a      	mov	r2, r3
   e:	687b      	ldr	r3, [r7, #4]
  10:	881b      	ldrh	r3, [r3, #0]
  12:	18d3      	adds	r3, r2, r3
  14:	60fb      	str	r3, [r7, #12]
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  16:	687a      	ldr	r2, [r7, #4]
  18:	68fb      	ldr	r3, [r7, #12]
  1a:	429a      	cmp	r2, r3
  1c:	d022      	beq.n	64 <plug_holes+0x64>
  1e:	68fb      	ldr	r3, [r7, #12]
  20:	791b      	ldrb	r3, [r3, #4]
  22:	2b00      	cmp	r3, #0
  24:	d11e      	bne.n	64 <plug_holes+0x64>
  26:	68fa      	ldr	r2, [r7, #12]
  28:	4b26      	ldr	r3, [pc, #152]	; (c4 <plug_holes+0xc4>)
  2a:	681b      	ldr	r3, [r3, #0]
  2c:	429a      	cmp	r2, r3
  2e:	d019      	beq.n	64 <plug_holes+0x64>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  30:	4b25      	ldr	r3, [pc, #148]	; (c8 <plug_holes+0xc8>)
  32:	681a      	ldr	r2, [r3, #0]
  34:	68fb      	ldr	r3, [r7, #12]
  36:	429a      	cmp	r2, r3
  38:	d102      	bne.n	40 <plug_holes+0x40>
      lfree = mem;
  3a:	4b23      	ldr	r3, [pc, #140]	; (c8 <plug_holes+0xc8>)
  3c:	687a      	ldr	r2, [r7, #4]
  3e:	601a      	str	r2, [r3, #0]
    }
    mem->next = nmem->next;
  40:	68fb      	ldr	r3, [r7, #12]
  42:	881a      	ldrh	r2, [r3, #0]
  44:	687b      	ldr	r3, [r7, #4]
  46:	801a      	strh	r2, [r3, #0]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
  48:	4b1d      	ldr	r3, [pc, #116]	; (c0 <plug_holes+0xc0>)
  4a:	681b      	ldr	r3, [r3, #0]
  4c:	461a      	mov	r2, r3
  4e:	68fb      	ldr	r3, [r7, #12]
  50:	881b      	ldrh	r3, [r3, #0]
  52:	18d3      	adds	r3, r2, r3
  54:	687a      	ldr	r2, [r7, #4]
  56:	b291      	uxth	r1, r2
  58:	4a19      	ldr	r2, [pc, #100]	; (c0 <plug_holes+0xc0>)
  5a:	6812      	ldr	r2, [r2, #0]
  5c:	b292      	uxth	r2, r2
  5e:	1a8a      	subs	r2, r1, r2
  60:	b292      	uxth	r2, r2
  62:	805a      	strh	r2, [r3, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
  64:	4b16      	ldr	r3, [pc, #88]	; (c0 <plug_holes+0xc0>)
  66:	681b      	ldr	r3, [r3, #0]
  68:	461a      	mov	r2, r3
  6a:	687b      	ldr	r3, [r7, #4]
  6c:	885b      	ldrh	r3, [r3, #2]
  6e:	18d3      	adds	r3, r2, r3
  70:	60bb      	str	r3, [r7, #8]
  if (pmem != mem && pmem->used == 0) {
  72:	68ba      	ldr	r2, [r7, #8]
  74:	687b      	ldr	r3, [r7, #4]
  76:	429a      	cmp	r2, r3
  78:	d01d      	beq.n	b6 <plug_holes+0xb6>
  7a:	68bb      	ldr	r3, [r7, #8]
  7c:	791b      	ldrb	r3, [r3, #4]
  7e:	2b00      	cmp	r3, #0
  80:	d119      	bne.n	b6 <plug_holes+0xb6>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  82:	4b11      	ldr	r3, [pc, #68]	; (c8 <plug_holes+0xc8>)
  84:	681a      	ldr	r2, [r3, #0]
  86:	687b      	ldr	r3, [r7, #4]
  88:	429a      	cmp	r2, r3
  8a:	d102      	bne.n	92 <plug_holes+0x92>
      lfree = pmem;
  8c:	4b0e      	ldr	r3, [pc, #56]	; (c8 <plug_holes+0xc8>)
  8e:	68ba      	ldr	r2, [r7, #8]
  90:	601a      	str	r2, [r3, #0]
    }
    pmem->next = mem->next;
  92:	687b      	ldr	r3, [r7, #4]
  94:	881a      	ldrh	r2, [r3, #0]
  96:	68bb      	ldr	r3, [r7, #8]
  98:	801a      	strh	r2, [r3, #0]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
  9a:	4b09      	ldr	r3, [pc, #36]	; (c0 <plug_holes+0xc0>)
  9c:	681b      	ldr	r3, [r3, #0]
  9e:	461a      	mov	r2, r3
  a0:	687b      	ldr	r3, [r7, #4]
  a2:	881b      	ldrh	r3, [r3, #0]
  a4:	18d3      	adds	r3, r2, r3
  a6:	68ba      	ldr	r2, [r7, #8]
  a8:	b291      	uxth	r1, r2
  aa:	4a05      	ldr	r2, [pc, #20]	; (c0 <plug_holes+0xc0>)
  ac:	6812      	ldr	r2, [r2, #0]
  ae:	b292      	uxth	r2, r2
  b0:	1a8a      	subs	r2, r1, r2
  b2:	b292      	uxth	r2, r2
  b4:	805a      	strh	r2, [r3, #2]
  }
}
  b6:	f107 0714 	add.w	r7, r7, #20
  ba:	46bd      	mov	sp, r7
  bc:	bc80      	pop	{r7}
  be:	4770      	bx	lr
  c0:	00000000 	.word	0x00000000
			c0: R_ARM_ABS32	.bss
  c4:	00000004 	.word	0x00000004
			c4: R_ARM_ABS32	.bss
  c8:	00000008 	.word	0x00000008
			c8: R_ARM_ABS32	.bss

000000cc <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  cc:	b580      	push	{r7, lr}
  ce:	b082      	sub	sp, #8
  d0:	af00      	add	r7, sp, #0

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  d2:	4b1d      	ldr	r3, [pc, #116]	; (148 <mem_init+0x7c>)
  d4:	f103 0303 	add.w	r3, r3, #3
  d8:	f023 0303 	bic.w	r3, r3, #3
  dc:	461a      	mov	r2, r3
  de:	4b1b      	ldr	r3, [pc, #108]	; (14c <mem_init+0x80>)
  e0:	601a      	str	r2, [r3, #0]
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  e2:	4b1a      	ldr	r3, [pc, #104]	; (14c <mem_init+0x80>)
  e4:	681b      	ldr	r3, [r3, #0]
  e6:	607b      	str	r3, [r7, #4]
  mem->next = MEM_SIZE_ALIGNED;
  e8:	687b      	ldr	r3, [r7, #4]
  ea:	f44f 62c8 	mov.w	r2, #1600	; 0x640
  ee:	801a      	strh	r2, [r3, #0]
  mem->prev = 0;
  f0:	687b      	ldr	r3, [r7, #4]
  f2:	f04f 0200 	mov.w	r2, #0
  f6:	805a      	strh	r2, [r3, #2]
  mem->used = 0;
  f8:	687b      	ldr	r3, [r7, #4]
  fa:	f04f 0200 	mov.w	r2, #0
  fe:	711a      	strb	r2, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 100:	4b12      	ldr	r3, [pc, #72]	; (14c <mem_init+0x80>)
 102:	681b      	ldr	r3, [r3, #0]
 104:	f503 62c8 	add.w	r2, r3, #1600	; 0x640
 108:	4b11      	ldr	r3, [pc, #68]	; (150 <mem_init+0x84>)
 10a:	601a      	str	r2, [r3, #0]
  ram_end->used = 1;
 10c:	4b10      	ldr	r3, [pc, #64]	; (150 <mem_init+0x84>)
 10e:	681b      	ldr	r3, [r3, #0]
 110:	f04f 0201 	mov.w	r2, #1
 114:	711a      	strb	r2, [r3, #4]
  ram_end->next = MEM_SIZE_ALIGNED;
 116:	4b0e      	ldr	r3, [pc, #56]	; (150 <mem_init+0x84>)
 118:	681b      	ldr	r3, [r3, #0]
 11a:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 11e:	801a      	strh	r2, [r3, #0]
  ram_end->prev = MEM_SIZE_ALIGNED;
 120:	4b0b      	ldr	r3, [pc, #44]	; (150 <mem_init+0x84>)
 122:	681b      	ldr	r3, [r3, #0]
 124:	f44f 62c8 	mov.w	r2, #1600	; 0x640
 128:	805a      	strh	r2, [r3, #2]

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 12a:	4b08      	ldr	r3, [pc, #32]	; (14c <mem_init+0x80>)
 12c:	681b      	ldr	r3, [r3, #0]
 12e:	461a      	mov	r2, r3
 130:	4b08      	ldr	r3, [pc, #32]	; (154 <mem_init+0x88>)
 132:	601a      	str	r2, [r3, #0]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 134:	4808      	ldr	r0, [pc, #32]	; (158 <mem_init+0x8c>)
 136:	f04f 0101 	mov.w	r1, #1
 13a:	f7ff fffe 	bl	0 <sys_sem_new>
			13a: R_ARM_THM_CALL	sys_sem_new
    LWIP_ASSERT("failed to create mem_mutex", 0);
  }
}
 13e:	f107 0708 	add.w	r7, r7, #8
 142:	46bd      	mov	sp, r7
 144:	bd80      	pop	{r7, pc}
 146:	bf00      	nop
	...
			148: R_ARM_ABS32	ram_heap
			14c: R_ARM_ABS32	.bss
 150:	00000004 	.word	0x00000004
			150: R_ARM_ABS32	.bss
 154:	00000008 	.word	0x00000008
			154: R_ARM_ABS32	.bss
 158:	0000000c 	.word	0x0000000c
			158: R_ARM_ABS32	.bss

0000015c <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 15c:	b580      	push	{r7, lr}
 15e:	b084      	sub	sp, #16
 160:	af00      	add	r7, sp, #0
 162:	6078      	str	r0, [r7, #4]
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 164:	687b      	ldr	r3, [r7, #4]
 166:	2b00      	cmp	r3, #0
 168:	d030      	beq.n	1cc <mem_free+0x70>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 16a:	687a      	ldr	r2, [r7, #4]
 16c:	4b1a      	ldr	r3, [pc, #104]	; (1d8 <mem_free+0x7c>)
 16e:	681b      	ldr	r3, [r3, #0]
 170:	429a      	cmp	r2, r3
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 172:	687a      	ldr	r2, [r7, #4]
 174:	4b18      	ldr	r3, [pc, #96]	; (1d8 <mem_free+0x7c>)
 176:	681b      	ldr	r3, [r3, #0]
 178:	429a      	cmp	r2, r3
 17a:	d304      	bcc.n	186 <mem_free+0x2a>
 17c:	687a      	ldr	r2, [r7, #4]
 17e:	4b17      	ldr	r3, [pc, #92]	; (1dc <mem_free+0x80>)
 180:	681b      	ldr	r3, [r3, #0]
 182:	429a      	cmp	r2, r3
 184:	d306      	bcc.n	194 <mem_free+0x38>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 186:	f7ff fffe 	bl	0 <sys_arch_protect>
			186: R_ARM_THM_CALL	sys_arch_protect
 18a:	60b8      	str	r0, [r7, #8]
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
 18c:	68b8      	ldr	r0, [r7, #8]
 18e:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			18e: R_ARM_THM_CALL	sys_arch_unprotect
    return;
 192:	e01c      	b.n	1ce <mem_free+0x72>
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 194:	4812      	ldr	r0, [pc, #72]	; (1e0 <mem_free+0x84>)
 196:	f04f 0100 	mov.w	r1, #0
 19a:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			19a: R_ARM_THM_CALL	sys_arch_sem_wait
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 19e:	687b      	ldr	r3, [r7, #4]
 1a0:	f1a3 0308 	sub.w	r3, r3, #8
 1a4:	60fb      	str	r3, [r7, #12]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 1a6:	68fb      	ldr	r3, [r7, #12]
 1a8:	f04f 0200 	mov.w	r2, #0
 1ac:	711a      	strb	r2, [r3, #4]

  if (mem < lfree) {
 1ae:	4b0d      	ldr	r3, [pc, #52]	; (1e4 <mem_free+0x88>)
 1b0:	681b      	ldr	r3, [r3, #0]
 1b2:	68fa      	ldr	r2, [r7, #12]
 1b4:	429a      	cmp	r2, r3
 1b6:	d202      	bcs.n	1be <mem_free+0x62>
    /* the newly freed struct is now the lowest */
    lfree = mem;
 1b8:	4b0a      	ldr	r3, [pc, #40]	; (1e4 <mem_free+0x88>)
 1ba:	68fa      	ldr	r2, [r7, #12]
 1bc:	601a      	str	r2, [r3, #0]
  }

  MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
 1be:	68f8      	ldr	r0, [r7, #12]
 1c0:	f7ff ff1e 	bl	0 <plug_holes>
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 1c4:	4806      	ldr	r0, [pc, #24]	; (1c <sys_sem_signal+0x1c>)
 1c6:	f7ff fffe 	bl	0 <sys_sem_signal>
			1c6: R_ARM_THM_CALL	sys_sem_signal
 1ca:	e000      	b.n	1ce <mem_free+0x72>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
 1cc:	bf00      	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 1ce:	f107 0710 	add.w	r7, r7, #16
 1d2:	46bd      	mov	sp, r7
 1d4:	bd80      	pop	{r7, pc}
 1d6:	bf00      	nop
 1d8:	00000000 	.word	0x00000000
			1d8: R_ARM_ABS32	.bss
 1dc:	00000004 	.word	0x00000004
			1dc: R_ARM_ABS32	.bss
 1e0:	0000000c 	.word	0x0000000c
			1e0: R_ARM_ABS32	.bss
 1e4:	00000008 	.word	0x00000008
			1e4: R_ARM_ABS32	.bss

000001e8 <mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 1e8:	b580      	push	{r7, lr}
 1ea:	b088      	sub	sp, #32
 1ec:	af00      	add	r7, sp, #0
 1ee:	6078      	str	r0, [r7, #4]
 1f0:	460b      	mov	r3, r1
 1f2:	807b      	strh	r3, [r7, #2]
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 1f4:	887b      	ldrh	r3, [r7, #2]
 1f6:	f103 0303 	add.w	r3, r3, #3
 1fa:	b29b      	uxth	r3, r3
 1fc:	f023 0303 	bic.w	r3, r3, #3
 200:	807b      	strh	r3, [r7, #2]

  if(newsize < MIN_SIZE_ALIGNED) {
 202:	887b      	ldrh	r3, [r7, #2]
 204:	2b0b      	cmp	r3, #11
 206:	d802      	bhi.n	20e <mem_trim+0x26>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 208:	f04f 030c 	mov.w	r3, #12
 20c:	807b      	strh	r3, [r7, #2]
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 20e:	887b      	ldrh	r3, [r7, #2]
 210:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 214:	d902      	bls.n	21c <mem_trim+0x34>
    return NULL;
 216:	f04f 0300 	mov.w	r3, #0
 21a:	e0b6      	b.n	38a <mem_trim+0x1a2>
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 21c:	687a      	ldr	r2, [r7, #4]
 21e:	4b5d      	ldr	r3, [pc, #372]	; (394 <mem_trim+0x1ac>)
 220:	681b      	ldr	r3, [r3, #0]
 222:	429a      	cmp	r2, r3
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 224:	687a      	ldr	r2, [r7, #4]
 226:	4b5b      	ldr	r3, [pc, #364]	; (394 <mem_trim+0x1ac>)
 228:	681b      	ldr	r3, [r3, #0]
 22a:	429a      	cmp	r2, r3
 22c:	d304      	bcc.n	238 <mem_trim+0x50>
 22e:	687a      	ldr	r2, [r7, #4]
 230:	4b59      	ldr	r3, [pc, #356]	; (398 <mem_trim+0x1b0>)
 232:	681b      	ldr	r3, [r3, #0]
 234:	429a      	cmp	r2, r3
 236:	d307      	bcc.n	248 <mem_trim+0x60>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 238:	f7ff fffe 	bl	0 <sys_arch_protect>
			238: R_ARM_THM_CALL	sys_arch_protect
 23c:	60f8      	str	r0, [r7, #12]
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
 23e:	68f8      	ldr	r0, [r7, #12]
 240:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			240: R_ARM_THM_CALL	sys_arch_unprotect
    return rmem;
 244:	687b      	ldr	r3, [r7, #4]
 246:	e0a0      	b.n	38a <mem_trim+0x1a2>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 248:	687b      	ldr	r3, [r7, #4]
 24a:	f1a3 0308 	sub.w	r3, r3, #8
 24e:	61fb      	str	r3, [r7, #28]
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 250:	69fb      	ldr	r3, [r7, #28]
 252:	b29a      	uxth	r2, r3
 254:	4b4f      	ldr	r3, [pc, #316]	; (394 <mem_trim+0x1ac>)
 256:	681b      	ldr	r3, [r3, #0]
 258:	b29b      	uxth	r3, r3
 25a:	1ad3      	subs	r3, r2, r3
 25c:	837b      	strh	r3, [r7, #26]

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 25e:	69fb      	ldr	r3, [r7, #28]
 260:	881a      	ldrh	r2, [r3, #0]
 262:	8b7b      	ldrh	r3, [r7, #26]
 264:	1ad3      	subs	r3, r2, r3
 266:	b29b      	uxth	r3, r3
 268:	f1a3 0308 	sub.w	r3, r3, #8
 26c:	833b      	strh	r3, [r7, #24]
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
  if (newsize > size) {
 26e:	887a      	ldrh	r2, [r7, #2]
 270:	8b3b      	ldrh	r3, [r7, #24]
 272:	429a      	cmp	r2, r3
 274:	d902      	bls.n	27c <mem_trim+0x94>
    /* not supported */
    return NULL;
 276:	f04f 0300 	mov.w	r3, #0
 27a:	e086      	b.n	38a <mem_trim+0x1a2>
  }
  if (newsize == size) {
 27c:	887a      	ldrh	r2, [r7, #2]
 27e:	8b3b      	ldrh	r3, [r7, #24]
 280:	429a      	cmp	r2, r3
 282:	d101      	bne.n	288 <mem_trim+0xa0>
    /* No change in size, simply return */
    return rmem;
 284:	687b      	ldr	r3, [r7, #4]
 286:	e080      	b.n	38a <mem_trim+0x1a2>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 288:	4844      	ldr	r0, [pc, #272]	; (39c <mem_trim+0x1b4>)
 28a:	f04f 0100 	mov.w	r1, #0
 28e:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			28e: R_ARM_THM_CALL	sys_arch_sem_wait

  mem2 = (struct mem *)(void *)&ram[mem->next];
 292:	4b40      	ldr	r3, [pc, #256]	; (394 <mem_trim+0x1ac>)
 294:	681b      	ldr	r3, [r3, #0]
 296:	461a      	mov	r2, r3
 298:	69fb      	ldr	r3, [r7, #28]
 29a:	881b      	ldrh	r3, [r3, #0]
 29c:	18d3      	adds	r3, r2, r3
 29e:	617b      	str	r3, [r7, #20]
  if(mem2->used == 0) {
 2a0:	697b      	ldr	r3, [r7, #20]
 2a2:	791b      	ldrb	r3, [r3, #4]
 2a4:	2b00      	cmp	r3, #0
 2a6:	d136      	bne.n	316 <mem_trim+0x12e>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 2a8:	697b      	ldr	r3, [r7, #20]
 2aa:	881b      	ldrh	r3, [r3, #0]
 2ac:	827b      	strh	r3, [r7, #18]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 2ae:	8b7a      	ldrh	r2, [r7, #26]
 2b0:	887b      	ldrh	r3, [r7, #2]
 2b2:	18d3      	adds	r3, r2, r3
 2b4:	b29b      	uxth	r3, r3
 2b6:	f103 0308 	add.w	r3, r3, #8
 2ba:	823b      	strh	r3, [r7, #16]
    if (lfree == mem2) {
 2bc:	4b38      	ldr	r3, [pc, #224]	; (3a0 <mem_trim+0x1b8>)
 2be:	681a      	ldr	r2, [r3, #0]
 2c0:	697b      	ldr	r3, [r7, #20]
 2c2:	429a      	cmp	r2, r3
 2c4:	d106      	bne.n	2d4 <mem_trim+0xec>
      lfree = (struct mem *)(void *)&ram[ptr2];
 2c6:	4b33      	ldr	r3, [pc, #204]	; (394 <mem_trim+0x1ac>)
 2c8:	681b      	ldr	r3, [r3, #0]
 2ca:	461a      	mov	r2, r3
 2cc:	8a3b      	ldrh	r3, [r7, #16]
 2ce:	18d2      	adds	r2, r2, r3
 2d0:	4b33      	ldr	r3, [pc, #204]	; (3a0 <mem_trim+0x1b8>)
 2d2:	601a      	str	r2, [r3, #0]
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
 2d4:	4b2f      	ldr	r3, [pc, #188]	; (394 <mem_trim+0x1ac>)
 2d6:	681b      	ldr	r3, [r3, #0]
 2d8:	461a      	mov	r2, r3
 2da:	8a3b      	ldrh	r3, [r7, #16]
 2dc:	18d3      	adds	r3, r2, r3
 2de:	617b      	str	r3, [r7, #20]
    mem2->used = 0;
 2e0:	697b      	ldr	r3, [r7, #20]
 2e2:	f04f 0200 	mov.w	r2, #0
 2e6:	711a      	strb	r2, [r3, #4]
    /* restore the next pointer */
    mem2->next = next;
 2e8:	697b      	ldr	r3, [r7, #20]
 2ea:	8a7a      	ldrh	r2, [r7, #18]
 2ec:	801a      	strh	r2, [r3, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 2ee:	697b      	ldr	r3, [r7, #20]
 2f0:	8b7a      	ldrh	r2, [r7, #26]
 2f2:	805a      	strh	r2, [r3, #2]
    /* link mem to it */
    mem->next = ptr2;
 2f4:	69fb      	ldr	r3, [r7, #28]
 2f6:	8a3a      	ldrh	r2, [r7, #16]
 2f8:	801a      	strh	r2, [r3, #0]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 2fa:	697b      	ldr	r3, [r7, #20]
 2fc:	881b      	ldrh	r3, [r3, #0]
 2fe:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 302:	d03e      	beq.n	382 <mem_trim+0x19a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 304:	4b23      	ldr	r3, [pc, #140]	; (394 <mem_trim+0x1ac>)
 306:	681b      	ldr	r3, [r3, #0]
 308:	461a      	mov	r2, r3
 30a:	697b      	ldr	r3, [r7, #20]
 30c:	881b      	ldrh	r3, [r3, #0]
 30e:	18d3      	adds	r3, r2, r3
 310:	8a3a      	ldrh	r2, [r7, #16]
 312:	805a      	strh	r2, [r3, #2]
 314:	e035      	b.n	382 <mem_trim+0x19a>
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 316:	887b      	ldrh	r3, [r7, #2]
 318:	f103 0214 	add.w	r2, r3, #20
 31c:	8b3b      	ldrh	r3, [r7, #24]
 31e:	429a      	cmp	r2, r3
 320:	d82f      	bhi.n	382 <mem_trim+0x19a>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 322:	8b7a      	ldrh	r2, [r7, #26]
 324:	887b      	ldrh	r3, [r7, #2]
 326:	18d3      	adds	r3, r2, r3
 328:	b29b      	uxth	r3, r3
 32a:	f103 0308 	add.w	r3, r3, #8
 32e:	823b      	strh	r3, [r7, #16]
    mem2 = (struct mem *)(void *)&ram[ptr2];
 330:	4b18      	ldr	r3, [pc, #96]	; (394 <mem_trim+0x1ac>)
 332:	681b      	ldr	r3, [r3, #0]
 334:	461a      	mov	r2, r3
 336:	8a3b      	ldrh	r3, [r7, #16]
 338:	18d3      	adds	r3, r2, r3
 33a:	617b      	str	r3, [r7, #20]
    if (mem2 < lfree) {
 33c:	4b18      	ldr	r3, [pc, #96]	; (3a0 <mem_trim+0x1b8>)
 33e:	681b      	ldr	r3, [r3, #0]
 340:	697a      	ldr	r2, [r7, #20]
 342:	429a      	cmp	r2, r3
 344:	d202      	bcs.n	34c <mem_trim+0x164>
      lfree = mem2;
 346:	4b16      	ldr	r3, [pc, #88]	; (3a0 <mem_trim+0x1b8>)
 348:	697a      	ldr	r2, [r7, #20]
 34a:	601a      	str	r2, [r3, #0]
    }
    mem2->used = 0;
 34c:	697b      	ldr	r3, [r7, #20]
 34e:	f04f 0200 	mov.w	r2, #0
 352:	711a      	strb	r2, [r3, #4]
    mem2->next = mem->next;
 354:	69fb      	ldr	r3, [r7, #28]
 356:	881a      	ldrh	r2, [r3, #0]
 358:	697b      	ldr	r3, [r7, #20]
 35a:	801a      	strh	r2, [r3, #0]
    mem2->prev = ptr;
 35c:	697b      	ldr	r3, [r7, #20]
 35e:	8b7a      	ldrh	r2, [r7, #26]
 360:	805a      	strh	r2, [r3, #2]
    mem->next = ptr2;
 362:	69fb      	ldr	r3, [r7, #28]
 364:	8a3a      	ldrh	r2, [r7, #16]
 366:	801a      	strh	r2, [r3, #0]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 368:	697b      	ldr	r3, [r7, #20]
 36a:	881b      	ldrh	r3, [r3, #0]
 36c:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 370:	d007      	beq.n	382 <mem_trim+0x19a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 372:	4b08      	ldr	r3, [pc, #32]	; (394 <mem_trim+0x1ac>)
 374:	681b      	ldr	r3, [r3, #0]
 376:	461a      	mov	r2, r3
 378:	697b      	ldr	r3, [r7, #20]
 37a:	881b      	ldrh	r3, [r3, #0]
 37c:	18d3      	adds	r3, r2, r3
 37e:	8a3a      	ldrh	r2, [r7, #16]
 380:	805a      	strh	r2, [r3, #2]
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 382:	4806      	ldr	r0, [pc, #24]	; (39c <mem_trim+0x1b4>)
 384:	f7ff fffe 	bl	0 <sys_sem_signal>
			384: R_ARM_THM_CALL	sys_sem_signal
  return rmem;
 388:	687b      	ldr	r3, [r7, #4]
}
 38a:	4618      	mov	r0, r3
 38c:	f107 0720 	add.w	r7, r7, #32
 390:	46bd      	mov	sp, r7
 392:	bd80      	pop	{r7, pc}
 394:	00000000 	.word	0x00000000
			394: R_ARM_ABS32	.bss
 398:	00000004 	.word	0x00000004
			398: R_ARM_ABS32	.bss
 39c:	0000000c 	.word	0x0000000c
			39c: R_ARM_ABS32	.bss
 3a0:	00000008 	.word	0x00000008
			3a0: R_ARM_ABS32	.bss

000003a4 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 3a4:	b580      	push	{r7, lr}
 3a6:	b088      	sub	sp, #32
 3a8:	af00      	add	r7, sp, #0
 3aa:	4603      	mov	r3, r0
 3ac:	80fb      	strh	r3, [r7, #6]
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 3ae:	88fb      	ldrh	r3, [r7, #6]
 3b0:	2b00      	cmp	r3, #0
 3b2:	d102      	bne.n	3ba <mem_malloc+0x16>
    return NULL;
 3b4:	f04f 0300 	mov.w	r3, #0
 3b8:	e0ad      	b.n	516 <mem_malloc+0x172>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 3ba:	88fb      	ldrh	r3, [r7, #6]
 3bc:	f103 0303 	add.w	r3, r3, #3
 3c0:	b29b      	uxth	r3, r3
 3c2:	f023 0303 	bic.w	r3, r3, #3
 3c6:	80fb      	strh	r3, [r7, #6]

  if(size < MIN_SIZE_ALIGNED) {
 3c8:	88fb      	ldrh	r3, [r7, #6]
 3ca:	2b0b      	cmp	r3, #11
 3cc:	d802      	bhi.n	3d4 <mem_malloc+0x30>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 3ce:	f04f 030c 	mov.w	r3, #12
 3d2:	80fb      	strh	r3, [r7, #6]
  }

  if (size > MEM_SIZE_ALIGNED) {
 3d4:	88fb      	ldrh	r3, [r7, #6]
 3d6:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 3da:	d902      	bls.n	3e2 <mem_malloc+0x3e>
    return NULL;
 3dc:	f04f 0300 	mov.w	r3, #0
 3e0:	e099      	b.n	516 <mem_malloc+0x172>
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 3e2:	484f      	ldr	r0, [pc, #316]	; (520 <mem_malloc+0x17c>)
 3e4:	f04f 0100 	mov.w	r1, #0
 3e8:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			3e8: R_ARM_THM_CALL	sys_arch_sem_wait
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 3ec:	4b4d      	ldr	r3, [pc, #308]	; (524 <mem_malloc+0x180>)
 3ee:	681b      	ldr	r3, [r3, #0]
 3f0:	b29a      	uxth	r2, r3
 3f2:	4b4d      	ldr	r3, [pc, #308]	; (528 <mem_malloc+0x184>)
 3f4:	681b      	ldr	r3, [r3, #0]
 3f6:	b29b      	uxth	r3, r3
 3f8:	1ad3      	subs	r3, r2, r3
 3fa:	83fb      	strh	r3, [r7, #30]
 3fc:	e07f      	b.n	4fe <mem_malloc+0x15a>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
 3fe:	4b4a      	ldr	r3, [pc, #296]	; (528 <mem_malloc+0x184>)
 400:	681b      	ldr	r3, [r3, #0]
 402:	461a      	mov	r2, r3
 404:	8bfb      	ldrh	r3, [r7, #30]
 406:	18d3      	adds	r3, r2, r3
 408:	617b      	str	r3, [r7, #20]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 40a:	697b      	ldr	r3, [r7, #20]
 40c:	791b      	ldrb	r3, [r3, #4]
 40e:	2b00      	cmp	r3, #0
 410:	d16e      	bne.n	4f0 <mem_malloc+0x14c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 412:	697b      	ldr	r3, [r7, #20]
 414:	881b      	ldrh	r3, [r3, #0]
 416:	461a      	mov	r2, r3
 418:	8bfb      	ldrh	r3, [r7, #30]
 41a:	1ad3      	subs	r3, r2, r3
 41c:	f1a3 0208 	sub.w	r2, r3, #8
 420:	88fb      	ldrh	r3, [r7, #6]
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 422:	429a      	cmp	r2, r3
 424:	d364      	bcc.n	4f0 <mem_malloc+0x14c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 426:	697b      	ldr	r3, [r7, #20]
 428:	881b      	ldrh	r3, [r3, #0]
 42a:	461a      	mov	r2, r3
 42c:	8bfb      	ldrh	r3, [r7, #30]
 42e:	1ad3      	subs	r3, r2, r3
 430:	f1a3 0208 	sub.w	r2, r3, #8
 434:	88fb      	ldrh	r3, [r7, #6]
 436:	f103 0314 	add.w	r3, r3, #20
 43a:	429a      	cmp	r2, r3
 43c:	d32c      	bcc.n	498 <mem_malloc+0xf4>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 43e:	8bfa      	ldrh	r2, [r7, #30]
 440:	88fb      	ldrh	r3, [r7, #6]
 442:	18d3      	adds	r3, r2, r3
 444:	b29b      	uxth	r3, r3
 446:	f103 0308 	add.w	r3, r3, #8
 44a:	827b      	strh	r3, [r7, #18]
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
 44c:	4b36      	ldr	r3, [pc, #216]	; (528 <mem_malloc+0x184>)
 44e:	681b      	ldr	r3, [r3, #0]
 450:	461a      	mov	r2, r3
 452:	8a7b      	ldrh	r3, [r7, #18]
 454:	18d3      	adds	r3, r2, r3
 456:	60fb      	str	r3, [r7, #12]
          mem2->used = 0;
 458:	68fb      	ldr	r3, [r7, #12]
 45a:	f04f 0200 	mov.w	r2, #0
 45e:	711a      	strb	r2, [r3, #4]
          mem2->next = mem->next;
 460:	697b      	ldr	r3, [r7, #20]
 462:	881a      	ldrh	r2, [r3, #0]
 464:	68fb      	ldr	r3, [r7, #12]
 466:	801a      	strh	r2, [r3, #0]
          mem2->prev = ptr;
 468:	68fb      	ldr	r3, [r7, #12]
 46a:	8bfa      	ldrh	r2, [r7, #30]
 46c:	805a      	strh	r2, [r3, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 46e:	697b      	ldr	r3, [r7, #20]
 470:	8a7a      	ldrh	r2, [r7, #18]
 472:	801a      	strh	r2, [r3, #0]
          mem->used = 1;
 474:	697b      	ldr	r3, [r7, #20]
 476:	f04f 0201 	mov.w	r2, #1
 47a:	711a      	strb	r2, [r3, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 47c:	68fb      	ldr	r3, [r7, #12]
 47e:	881b      	ldrh	r3, [r3, #0]
 480:	f5b3 6fc8 	cmp.w	r3, #1600	; 0x640
 484:	d00c      	beq.n	4a0 <mem_malloc+0xfc>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 486:	4b28      	ldr	r3, [pc, #160]	; (528 <mem_malloc+0x184>)
 488:	681b      	ldr	r3, [r3, #0]
 48a:	461a      	mov	r2, r3
 48c:	68fb      	ldr	r3, [r7, #12]
 48e:	881b      	ldrh	r3, [r3, #0]
 490:	18d3      	adds	r3, r2, r3
 492:	8a7a      	ldrh	r2, [r7, #18]
 494:	805a      	strh	r2, [r3, #2]
 496:	e003      	b.n	4a0 <mem_malloc+0xfc>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 498:	697b      	ldr	r3, [r7, #20]
 49a:	f04f 0201 	mov.w	r2, #1
 49e:	711a      	strb	r2, [r3, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 4a0:	4b20      	ldr	r3, [pc, #128]	; (524 <mem_malloc+0x180>)
 4a2:	681b      	ldr	r3, [r3, #0]
 4a4:	697a      	ldr	r2, [r7, #20]
 4a6:	429a      	cmp	r2, r3
 4a8:	d11b      	bne.n	4e2 <mem_malloc+0x13e>
          struct mem *cur = lfree;
 4aa:	4b1e      	ldr	r3, [pc, #120]	; (524 <mem_malloc+0x180>)
 4ac:	681b      	ldr	r3, [r3, #0]
 4ae:	61bb      	str	r3, [r7, #24]
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 4b0:	e006      	b.n	4c0 <mem_malloc+0x11c>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 4b2:	4b1d      	ldr	r3, [pc, #116]	; (528 <mem_malloc+0x184>)
 4b4:	681b      	ldr	r3, [r3, #0]
 4b6:	461a      	mov	r2, r3
 4b8:	69bb      	ldr	r3, [r7, #24]
 4ba:	881b      	ldrh	r3, [r3, #0]
 4bc:	18d3      	adds	r3, r2, r3
 4be:	61bb      	str	r3, [r7, #24]
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 4c0:	69bb      	ldr	r3, [r7, #24]
 4c2:	791b      	ldrb	r3, [r3, #4]
 4c4:	2b00      	cmp	r3, #0
 4c6:	d004      	beq.n	4d2 <mem_malloc+0x12e>
 4c8:	4b18      	ldr	r3, [pc, #96]	; (52c <mem_malloc+0x188>)
 4ca:	681b      	ldr	r3, [r3, #0]
 4cc:	69ba      	ldr	r2, [r7, #24]
 4ce:	429a      	cmp	r2, r3
 4d0:	d1ef      	bne.n	4b2 <mem_malloc+0x10e>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
 4d2:	4b14      	ldr	r3, [pc, #80]	; (524 <mem_malloc+0x180>)
 4d4:	69ba      	ldr	r2, [r7, #24]
 4d6:	601a      	str	r2, [r3, #0]
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
 4d8:	4b12      	ldr	r3, [pc, #72]	; (524 <mem_malloc+0x180>)
 4da:	681a      	ldr	r2, [r3, #0]
 4dc:	4b13      	ldr	r3, [pc, #76]	; (52c <mem_malloc+0x188>)
 4de:	681b      	ldr	r3, [r3, #0]
 4e0:	429a      	cmp	r2, r3
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 4e2:	480f      	ldr	r0, [pc, #60]	; (520 <mem_malloc+0x17c>)
 4e4:	f7ff fffe 	bl	0 <sys_sem_signal>
			4e4: R_ARM_THM_CALL	sys_sem_signal
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 4e8:	697b      	ldr	r3, [r7, #20]
 4ea:	f103 0308 	add.w	r3, r3, #8
 4ee:	e012      	b.n	516 <mem_malloc+0x172>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
 4f0:	4b0d      	ldr	r3, [pc, #52]	; (528 <mem_malloc+0x184>)
 4f2:	681b      	ldr	r3, [r3, #0]
 4f4:	461a      	mov	r2, r3
 4f6:	8bfb      	ldrh	r3, [r7, #30]
 4f8:	18d3      	adds	r3, r2, r3
 4fa:	881b      	ldrh	r3, [r3, #0]
 4fc:	83fb      	strh	r3, [r7, #30]
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 4fe:	8bfa      	ldrh	r2, [r7, #30]
 500:	88fb      	ldrh	r3, [r7, #6]
 502:	f5c3 63c8 	rsb	r3, r3, #1600	; 0x640
 506:	429a      	cmp	r2, r3
 508:	f6ff af79 	blt.w	3fe <mem_malloc+0x5a>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 50c:	4804      	ldr	r0, [pc, #16]	; (14 <sys_sem_signal+0x14>)
 50e:	f7ff fffe 	bl	0 <sys_sem_signal>
			50e: R_ARM_THM_CALL	sys_sem_signal
  return NULL;
 512:	f04f 0300 	mov.w	r3, #0
}
 516:	4618      	mov	r0, r3
 518:	f107 0720 	add.w	r7, r7, #32
 51c:	46bd      	mov	sp, r7
 51e:	bd80      	pop	{r7, pc}
 520:	0000000c 	.word	0x0000000c
			520: R_ARM_ABS32	.bss
 524:	00000008 	.word	0x00000008
			524: R_ARM_ABS32	.bss
 528:	00000000 	.word	0x00000000
			528: R_ARM_ABS32	.bss
 52c:	00000004 	.word	0x00000004
			52c: R_ARM_ABS32	.bss

00000530 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
 530:	b580      	push	{r7, lr}
 532:	b084      	sub	sp, #16
 534:	af00      	add	r7, sp, #0
 536:	4602      	mov	r2, r0
 538:	460b      	mov	r3, r1
 53a:	80fa      	strh	r2, [r7, #6]
 53c:	80bb      	strh	r3, [r7, #4]
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
 53e:	88fb      	ldrh	r3, [r7, #6]
 540:	88ba      	ldrh	r2, [r7, #4]
 542:	fb02 f303 	mul.w	r3, r2, r3
 546:	b29b      	uxth	r3, r3
 548:	4618      	mov	r0, r3
 54a:	f7ff fffe 	bl	3a4 <mem_malloc>
			54a: R_ARM_THM_CALL	mem_malloc
 54e:	60f8      	str	r0, [r7, #12]
  if (p) {
 550:	68fb      	ldr	r3, [r7, #12]
 552:	2b00      	cmp	r3, #0
 554:	d009      	beq.n	56a <mem_calloc+0x3a>
    /* zero the memory */
    memset(p, 0, count * size);
 556:	88fb      	ldrh	r3, [r7, #6]
 558:	88ba      	ldrh	r2, [r7, #4]
 55a:	fb02 f303 	mul.w	r3, r2, r3
 55e:	68f8      	ldr	r0, [r7, #12]
 560:	f04f 0100 	mov.w	r1, #0
 564:	461a      	mov	r2, r3
 566:	f7ff fffe 	bl	0 <memset>
			566: R_ARM_THM_CALL	memset
  }
  return p;
 56a:	68fb      	ldr	r3, [r7, #12]
}
 56c:	4618      	mov	r0, r3
 56e:	f107 0710 	add.w	r7, r7, #16
 572:	46bd      	mov	sp, r7
 574:	bd80      	pop	{r7, pc}
 576:	bf00      	nop

memp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  71064 Jul 30 19:07 2021 memp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000140  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000174  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00004048  00000000  00000000  00000174  2**2
                  ALLOC
  3 .debug_abbrev 00000118  00000000  00000000  00000174  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000002ad  00000000  00000000  0000028c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000007cb  00000000  00000000  00000539  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000f903  00000000  00000000  00000d04  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000040  00000000  00000000  00010608  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    000000a8  00000000  00000000  00010648  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000003e  00000000  00000000  000106f0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 00000060  00000000  00000000  0001072e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  0001078e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    0000026e  00000000  00000000  000107ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  00010a1c  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  00010a47  2**0
                  CONTENTS, READONLY
 15 .debug_frame  0000006c  00000000  00000000  00010a78  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 memp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 memp_tab
00000000 l    d  .rodata	00000000 .rodata
00000000 l     O .rodata	00000020 memp_sizes
00000020 l     O .rodata	00000020 memp_num
00000040 l       .bss	00000000 memp_memory
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	000000a8 memp_init
000000a8 g     F .text	00000050 memp_malloc
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
000000f8 g     F .text	00000048 memp_free



Disassembly of section .text:

00000000 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
   6:	f04f 0300 	mov.w	r3, #0
   a:	807b      	strh	r3, [r7, #2]
   c:	e003      	b.n	16 <memp_init+0x16>
   e:	887b      	ldrh	r3, [r7, #2]
  10:	f103 0301 	add.w	r3, r3, #1
  14:	807b      	strh	r3, [r7, #2]
  16:	887b      	ldrh	r3, [r7, #2]
  18:	2b0f      	cmp	r3, #15
  1a:	d9f8      	bls.n	e <memp_init+0xe>
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
  1c:	4b1e      	ldr	r3, [pc, #120]	; (98 <memp_init+0x98>)
  1e:	f103 0303 	add.w	r3, r3, #3
  22:	f023 0303 	bic.w	r3, r3, #3
  26:	607b      	str	r3, [r7, #4]
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  28:	f04f 0300 	mov.w	r3, #0
  2c:	807b      	strh	r3, [r7, #2]
  2e:	e02a      	b.n	86 <memp_init+0x86>
    memp_tab[i] = NULL;
  30:	887a      	ldrh	r2, [r7, #2]
  32:	4b1a      	ldr	r3, [pc, #104]	; (9c <memp_init+0x9c>)
  34:	f04f 0100 	mov.w	r1, #0
  38:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  3c:	f04f 0300 	mov.w	r3, #0
  40:	803b      	strh	r3, [r7, #0]
  42:	e015      	b.n	70 <memp_init+0x70>
      memp->next = memp_tab[i];
  44:	887a      	ldrh	r2, [r7, #2]
  46:	4b15      	ldr	r3, [pc, #84]	; (9c <memp_init+0x9c>)
  48:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
  4c:	687b      	ldr	r3, [r7, #4]
  4e:	601a      	str	r2, [r3, #0]
      memp_tab[i] = memp;
  50:	887a      	ldrh	r2, [r7, #2]
  52:	4b12      	ldr	r3, [pc, #72]	; (9c <memp_init+0x9c>)
  54:	6879      	ldr	r1, [r7, #4]
  56:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
  5a:	887a      	ldrh	r2, [r7, #2]
  5c:	4b10      	ldr	r3, [pc, #64]	; (a0 <memp_init+0xa0>)
  5e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  62:	687a      	ldr	r2, [r7, #4]
  64:	18d3      	adds	r3, r2, r3
  66:	607b      	str	r3, [r7, #4]
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  68:	883b      	ldrh	r3, [r7, #0]
  6a:	f103 0301 	add.w	r3, r3, #1
  6e:	803b      	strh	r3, [r7, #0]
  70:	887a      	ldrh	r2, [r7, #2]
  72:	4b0c      	ldr	r3, [pc, #48]	; (a4 <memp_init+0xa4>)
  74:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
  78:	883a      	ldrh	r2, [r7, #0]
  7a:	429a      	cmp	r2, r3
  7c:	d3e2      	bcc.n	44 <memp_init+0x44>

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  7e:	887b      	ldrh	r3, [r7, #2]
  80:	f103 0301 	add.w	r3, r3, #1
  84:	807b      	strh	r3, [r7, #2]
  86:	887b      	ldrh	r3, [r7, #2]
  88:	2b0f      	cmp	r3, #15
  8a:	d9d1      	bls.n	30 <memp_init+0x30>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8c:	f107 070c 	add.w	r7, r7, #12
  90:	46bd      	mov	sp, r7
  92:	bc80      	pop	{r7}
  94:	4770      	bx	lr
  96:	bf00      	nop
  98:	00000040 	.word	0x00000040
			98: R_ARM_ABS32	.bss
	...
			9c: R_ARM_ABS32	.bss
			a0: R_ARM_ABS32	.rodata
  a4:	00000020 	.word	0x00000020
			a4: R_ARM_ABS32	.rodata

000000a8 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  a8:	b580      	push	{r7, lr}
  aa:	b084      	sub	sp, #16
  ac:	af00      	add	r7, sp, #0
  ae:	4603      	mov	r3, r0
  b0:	71fb      	strb	r3, [r7, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  b2:	79fb      	ldrb	r3, [r7, #7]
  b4:	2b0f      	cmp	r3, #15
  b6:	d902      	bls.n	be <memp_malloc+0x16>
  b8:	f04f 0300 	mov.w	r3, #0
  bc:	e014      	b.n	2c <sys_arch_protect+0x2c>

  SYS_ARCH_PROTECT(old_level);
  be:	f7ff fffe 	bl	0 <sys_arch_protect>
			be: R_ARM_THM_CALL	sys_arch_protect
  c2:	60b8      	str	r0, [r7, #8]
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  c4:	79fa      	ldrb	r2, [r7, #7]
  c6:	4b0b      	ldr	r3, [pc, #44]	; (f4 <memp_malloc+0x4c>)
  c8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  cc:	60fb      	str	r3, [r7, #12]
  
  if (memp != NULL) {
  ce:	68fb      	ldr	r3, [r7, #12]
  d0:	2b00      	cmp	r3, #0
  d2:	d005      	beq.n	e0 <memp_malloc+0x38>
    memp_tab[type] = memp->next;
  d4:	79fa      	ldrb	r2, [r7, #7]
  d6:	68fb      	ldr	r3, [r7, #12]
  d8:	6819      	ldr	r1, [r3, #0]
  da:	4b06      	ldr	r3, [pc, #24]	; (f4 <memp_malloc+0x4c>)
  dc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);
  e0:	68b8      	ldr	r0, [r7, #8]
  e2:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			e2: R_ARM_THM_CALL	sys_arch_unprotect

  return memp;
  e6:	68fb      	ldr	r3, [r7, #12]
}
  e8:	4618      	mov	r0, r3
  ea:	f107 0710 	add.w	r7, r7, #16
  ee:	46bd      	mov	sp, r7
  f0:	bd80      	pop	{r7, pc}
  f2:	bf00      	nop
  f4:	00000000 	.word	0x00000000
			f4: R_ARM_ABS32	.bss

000000f8 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  f8:	b580      	push	{r7, lr}
  fa:	b084      	sub	sp, #16
  fc:	af00      	add	r7, sp, #0
  fe:	4603      	mov	r3, r0
 100:	6039      	str	r1, [r7, #0]
 102:	71fb      	strb	r3, [r7, #7]
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 104:	683b      	ldr	r3, [r7, #0]
 106:	2b00      	cmp	r3, #0
 108:	d013      	beq.n	132 <memp_free+0x3a>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);
 10a:	683b      	ldr	r3, [r7, #0]
 10c:	60fb      	str	r3, [r7, #12]

  SYS_ARCH_PROTECT(old_level);
 10e:	f7ff fffe 	bl	0 <sys_arch_protect>
			10e: R_ARM_THM_CALL	sys_arch_protect
 112:	60b8      	str	r0, [r7, #8]
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
 114:	79fa      	ldrb	r2, [r7, #7]
 116:	4b09      	ldr	r3, [pc, #36]	; (13c <memp_free+0x44>)
 118:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 11c:	68fb      	ldr	r3, [r7, #12]
 11e:	601a      	str	r2, [r3, #0]
  memp_tab[type] = memp;
 120:	79fa      	ldrb	r2, [r7, #7]
 122:	4b06      	ldr	r3, [pc, #24]	; (13c <memp_free+0x44>)
 124:	68f9      	ldr	r1, [r7, #12]
 126:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 12a:	68b8      	ldr	r0, [r7, #8]
 12c:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			12c: R_ARM_THM_CALL	sys_arch_unprotect
 130:	e000      	b.n	134 <memp_free+0x3c>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
 132:	bf00      	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 134:	f107 0710 	add.w	r7, r7, #16
 138:	46bd      	mov	sp, r7
 13a:	bd80      	pop	{r7, pc}
 13c:	00000000 	.word	0x00000000
			13c: R_ARM_ABS32	.bss

netif.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  56736 Jul 30 19:07 2021 netif.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000052c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000560  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000001  00000000  00000000  00000560  2**0
                  ALLOC
  3 .debug_abbrev 00000232  00000000  00000000  00000560  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000010f3  00000000  00000000  00000792  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000045d  00000000  00000000  00001885  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00009a59  00000000  00000000  00001ce2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000033c  00000000  00000000  0000b73b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000161  00000000  00000000  0000ba77  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000021a  00000000  00000000  0000bbd8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000bdf2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  0000be12  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000007b9  00000000  00000000  0000be2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0000c5e3  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000c60e  2**0
                  CONTENTS, READONLY
 15 .debug_frame  000001d0  00000000  00000000  0000c640  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 netif.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 netif_num
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 netif_list
00000004       O *COM*	00000004 netif_default
00000000 g     F .text	0000000a netif_init
0000000c g     F .text	000000c8 netif_add
000000d4 g     F .text	0000002e netif_set_addr
00000000         *UND*	00000000 igmp_start
00000224 g     F .text	000000b4 netif_set_ipaddr
00000300 g     F .text	00000028 netif_set_netmask
000002d8 g     F .text	00000028 netif_set_gw
00000104 g     F .text	000000a4 netif_remove
00000000         *UND*	00000000 igmp_stop
000003c4 g     F .text	00000056 netif_set_down
00000328 g     F .text	0000001c netif_set_default
000001a8 g     F .text	0000007c netif_find
00000000         *UND*	00000000 tcp_abort
00000000         *UND*	00000000 tcp_active_pcbs
00000000         *UND*	00000000 tcp_listen_pcbs
00000344 g     F .text	0000007e netif_set_up
00000000         *UND*	00000000 etharp_request
00000000         *UND*	00000000 igmp_report_groups
00000000         *UND*	00000000 etharp_cleanup_netif
0000041c g     F .text	00000020 netif_set_status_callback
0000043c g     F .text	0000008e netif_set_link_up
00000000         *UND*	00000000 dhcp_network_changed
000004cc g     F .text	00000040 netif_set_link_down
0000050c g     F .text	00000020 netif_set_link_callback



Disassembly of section .text:

00000000 <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
  netif_add(&loop_netif, &loop_ipaddr, &loop_netmask, &loop_gw, NULL, netif_loopif_init, tcpip_input);
#endif /* NO_SYS */
  netif_set_up(&loop_netif);

#endif /* LWIP_HAVE_LOOPIF */
}
   4:	46bd      	mov	sp, r7
   6:	bc80      	pop	{r7}
   8:	4770      	bx	lr
   a:	bf00      	nop

0000000c <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
   c:	b580      	push	{r7, lr}
   e:	b084      	sub	sp, #16
  10:	af00      	add	r7, sp, #0
  12:	60f8      	str	r0, [r7, #12]
  14:	60b9      	str	r1, [r7, #8]
  16:	607a      	str	r2, [r7, #4]
  18:	603b      	str	r3, [r7, #0]

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
  1a:	68fb      	ldr	r3, [r7, #12]
  1c:	f04f 0200 	mov.w	r2, #0
  20:	605a      	str	r2, [r3, #4]
  ip_addr_set_zero(&netif->netmask);
  22:	68fb      	ldr	r3, [r7, #12]
  24:	f04f 0200 	mov.w	r2, #0
  28:	609a      	str	r2, [r3, #8]
  ip_addr_set_zero(&netif->gw);
  2a:	68fb      	ldr	r3, [r7, #12]
  2c:	f04f 0200 	mov.w	r2, #0
  30:	60da      	str	r2, [r3, #12]
  netif->flags = 0;
  32:	68fb      	ldr	r3, [r7, #12]
  34:	f04f 0200 	mov.w	r2, #0
  38:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  3c:	68fb      	ldr	r3, [r7, #12]
  3e:	f04f 0200 	mov.w	r2, #0
  42:	629a      	str	r2, [r3, #40]	; 0x28
#if LWIP_AUTOIP
  /* netif not under AutoIP control by default */
  netif->autoip = NULL;
#endif /* LWIP_AUTOIP */
#if LWIP_NETIF_STATUS_CALLBACK
  netif->status_callback = NULL;
  44:	68fb      	ldr	r3, [r7, #12]
  46:	f04f 0200 	mov.w	r2, #0
  4a:	61da      	str	r2, [r3, #28]
#endif /* LWIP_NETIF_STATUS_CALLBACK */
#if LWIP_NETIF_LINK_CALLBACK
  netif->link_callback = NULL;
  4c:	68fb      	ldr	r3, [r7, #12]
  4e:	f04f 0200 	mov.w	r2, #0
  52:	621a      	str	r2, [r3, #32]
#endif /* LWIP_NETIF_LINK_CALLBACK */
#if LWIP_IGMP
  netif->igmp_mac_filter = NULL;
  54:	68fb      	ldr	r3, [r7, #12]
  56:	f04f 0200 	mov.w	r2, #0
  5a:	63da      	str	r2, [r3, #60]	; 0x3c
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  5c:	68fb      	ldr	r3, [r7, #12]
  5e:	69ba      	ldr	r2, [r7, #24]
  60:	625a      	str	r2, [r3, #36]	; 0x24
  netif->num = netif_num++;
  62:	4b1a      	ldr	r3, [pc, #104]	; (cc <netif_add+0xc0>)
  64:	781b      	ldrb	r3, [r3, #0]
  66:	68fa      	ldr	r2, [r7, #12]
  68:	4619      	mov	r1, r3
  6a:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
  6e:	f103 0301 	add.w	r3, r3, #1
  72:	b2da      	uxtb	r2, r3
  74:	4b15      	ldr	r3, [pc, #84]	; (cc <netif_add+0xc0>)
  76:	701a      	strb	r2, [r3, #0]
  netif->input = input;
  78:	68fb      	ldr	r3, [r7, #12]
  7a:	6a3a      	ldr	r2, [r7, #32]
  7c:	611a      	str	r2, [r3, #16]
  NETIF_SET_HWADDRHINT(netif, NULL);
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  7e:	68f8      	ldr	r0, [r7, #12]
  80:	68b9      	ldr	r1, [r7, #8]
  82:	687a      	ldr	r2, [r7, #4]
  84:	683b      	ldr	r3, [r7, #0]
  86:	f7ff fffe 	bl	d4 <netif_set_addr>
			86: R_ARM_THM_CALL	netif_set_addr

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  8a:	69fb      	ldr	r3, [r7, #28]
  8c:	68f8      	ldr	r0, [r7, #12]
  8e:	4798      	blx	r3
  90:	4603      	mov	r3, r0
  92:	2b00      	cmp	r3, #0
  94:	d002      	beq.n	9c <netif_add+0x90>
    return NULL;
  96:	f04f 0300 	mov.w	r3, #0
  9a:	e011      	b.n	c0 <netif_add+0xb4>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  9c:	4b0c      	ldr	r3, [pc, #48]	; (d0 <netif_add+0xc4>)
  9e:	681a      	ldr	r2, [r3, #0]
  a0:	68fb      	ldr	r3, [r7, #12]
  a2:	601a      	str	r2, [r3, #0]
  netif_list = netif;
  a4:	4b0a      	ldr	r3, [pc, #40]	; (d0 <netif_add+0xc4>)
  a6:	68fa      	ldr	r2, [r7, #12]
  a8:	601a      	str	r2, [r3, #0]
  snmp_inc_iflist();

#if LWIP_IGMP
  /* start IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
  aa:	68fb      	ldr	r3, [r7, #12]
  ac:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  b0:	b2db      	uxtb	r3, r3
  b2:	b25b      	sxtb	r3, r3
  b4:	2b00      	cmp	r3, #0
  b6:	da02      	bge.n	be <netif_add+0xb2>
    igmp_start(netif);
  b8:	68f8      	ldr	r0, [r7, #12]
  ba:	f7ff fffe 	bl	0 <igmp_start>
			ba: R_ARM_THM_CALL	igmp_start
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  be:	68fb      	ldr	r3, [r7, #12]
}
  c0:	4618      	mov	r0, r3
  c2:	f107 0710 	add.w	r7, r7, #16
  c6:	46bd      	mov	sp, r7
  c8:	bd80      	pop	{r7, pc}
  ca:	bf00      	nop
	...
			cc: R_ARM_ABS32	.bss
			d0: R_ARM_ABS32	netif_list

000000d4 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  d4:	b580      	push	{r7, lr}
  d6:	b084      	sub	sp, #16
  d8:	af00      	add	r7, sp, #0
  da:	60f8      	str	r0, [r7, #12]
  dc:	60b9      	str	r1, [r7, #8]
  de:	607a      	str	r2, [r7, #4]
  e0:	603b      	str	r3, [r7, #0]
  netif_set_ipaddr(netif, ipaddr);
  e2:	68f8      	ldr	r0, [r7, #12]
  e4:	68b9      	ldr	r1, [r7, #8]
  e6:	f7ff fffe 	bl	224 <netif_set_ipaddr>
			e6: R_ARM_THM_CALL	netif_set_ipaddr
  netif_set_netmask(netif, netmask);
  ea:	68f8      	ldr	r0, [r7, #12]
  ec:	6879      	ldr	r1, [r7, #4]
  ee:	f7ff fffe 	bl	300 <netif_set_netmask>
			ee: R_ARM_THM_CALL	netif_set_netmask
  netif_set_gw(netif, gw);
  f2:	68f8      	ldr	r0, [r7, #12]
  f4:	6839      	ldr	r1, [r7, #0]
  f6:	f7ff fffe 	bl	2d8 <netif_set_gw>
			f6: R_ARM_THM_CALL	netif_set_gw
}
  fa:	f107 0710 	add.w	r7, r7, #16
  fe:	46bd      	mov	sp, r7
 100:	bd80      	pop	{r7, pc}
 102:	bf00      	nop

00000104 <netif_remove>:
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 104:	b580      	push	{r7, lr}
 106:	b084      	sub	sp, #16
 108:	af00      	add	r7, sp, #0
 10a:	6078      	str	r0, [r7, #4]
  if (netif == NULL) {
 10c:	687b      	ldr	r3, [r7, #4]
 10e:	2b00      	cmp	r3, #0
 110:	d03f      	beq.n	192 <netif_remove+0x8e>
    return;
  }

#if LWIP_IGMP
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
 112:	687b      	ldr	r3, [r7, #4]
 114:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 118:	b2db      	uxtb	r3, r3
 11a:	b25b      	sxtb	r3, r3
 11c:	2b00      	cmp	r3, #0
 11e:	da02      	bge.n	126 <netif_remove+0x22>
    igmp_stop(netif);
 120:	6878      	ldr	r0, [r7, #4]
 122:	f7ff fffe 	bl	0 <igmp_stop>
			122: R_ARM_THM_CALL	igmp_stop
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
 126:	687b      	ldr	r3, [r7, #4]
 128:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 12c:	f003 0301 	and.w	r3, r3, #1
 130:	b2db      	uxtb	r3, r3
 132:	2b00      	cmp	r3, #0
 134:	d002      	beq.n	13c <netif_remove+0x38>
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 136:	6878      	ldr	r0, [r7, #4]
 138:	f7ff fffe 	bl	3c4 <netif_set_down>
			138: R_ARM_THM_CALL	netif_set_down
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
 13c:	4b18      	ldr	r3, [pc, #96]	; (1a0 <netif_remove+0x9c>)
 13e:	681a      	ldr	r2, [r3, #0]
 140:	687b      	ldr	r3, [r7, #4]
 142:	429a      	cmp	r2, r3
 144:	d104      	bne.n	150 <netif_remove+0x4c>
    netif_list = netif->next;
 146:	687b      	ldr	r3, [r7, #4]
 148:	681a      	ldr	r2, [r3, #0]
 14a:	4b15      	ldr	r3, [pc, #84]	; (1a0 <netif_remove+0x9c>)
 14c:	601a      	str	r2, [r3, #0]
 14e:	e016      	b.n	17e <netif_remove+0x7a>
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 150:	4b13      	ldr	r3, [pc, #76]	; (1a0 <netif_remove+0x9c>)
 152:	681b      	ldr	r3, [r3, #0]
 154:	60fb      	str	r3, [r7, #12]
 156:	e00c      	b.n	172 <netif_remove+0x6e>
      if (tmpNetif->next == netif) {
 158:	68fb      	ldr	r3, [r7, #12]
 15a:	681a      	ldr	r2, [r3, #0]
 15c:	687b      	ldr	r3, [r7, #4]
 15e:	429a      	cmp	r2, r3
 160:	d104      	bne.n	16c <netif_remove+0x68>
        tmpNetif->next = netif->next;
 162:	687b      	ldr	r3, [r7, #4]
 164:	681a      	ldr	r2, [r3, #0]
 166:	68fb      	ldr	r3, [r7, #12]
 168:	601a      	str	r2, [r3, #0]
        break;
 16a:	e005      	b.n	178 <netif_remove+0x74>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 16c:	68fb      	ldr	r3, [r7, #12]
 16e:	681b      	ldr	r3, [r3, #0]
 170:	60fb      	str	r3, [r7, #12]
 172:	68fb      	ldr	r3, [r7, #12]
 174:	2b00      	cmp	r3, #0
 176:	d1ef      	bne.n	158 <netif_remove+0x54>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
 178:	68fb      	ldr	r3, [r7, #12]
 17a:	2b00      	cmp	r3, #0
 17c:	d00b      	beq.n	196 <netif_remove+0x92>
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
 17e:	4b09      	ldr	r3, [pc, #36]	; (1a4 <netif_remove+0xa0>)
 180:	681a      	ldr	r2, [r3, #0]
 182:	687b      	ldr	r3, [r7, #4]
 184:	429a      	cmp	r2, r3
 186:	d107      	bne.n	198 <netif_remove+0x94>
    /* reset default netif */
    netif_set_default(NULL);
 188:	f04f 0000 	mov.w	r0, #0
 18c:	f7ff fffe 	bl	328 <netif_set_default>
			18c: R_ARM_THM_CALL	netif_set_default
 190:	e002      	b.n	198 <netif_remove+0x94>
 */
void
netif_remove(struct netif *netif)
{
  if (netif == NULL) {
    return;
 192:	bf00      	nop
 194:	e000      	b.n	198 <netif_remove+0x94>
        tmpNetif->next = netif->next;
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
 196:	bf00      	nop
  if (netif->remove_callback) {
    netif->remove_callback(netif);
  }
#endif /* LWIP_NETIF_REMOVE_CALLBACK */
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
 198:	f107 0710 	add.w	r7, r7, #16
 19c:	46bd      	mov	sp, r7
 19e:	bd80      	pop	{r7, pc}
	...
			1a0: R_ARM_ABS32	netif_list
			1a4: R_ARM_ABS32	netif_default

000001a8 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
 1a8:	b480      	push	{r7}
 1aa:	b085      	sub	sp, #20
 1ac:	af00      	add	r7, sp, #0
 1ae:	6078      	str	r0, [r7, #4]
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
 1b0:	687b      	ldr	r3, [r7, #4]
 1b2:	2b00      	cmp	r3, #0
 1b4:	d102      	bne.n	1bc <netif_find+0x14>
    return NULL;
 1b6:	f04f 0300 	mov.w	r3, #0
 1ba:	e02a      	b.n	212 <netif_find+0x6a>
  }

  num = name[2] - '0';
 1bc:	687b      	ldr	r3, [r7, #4]
 1be:	f103 0302 	add.w	r3, r3, #2
 1c2:	781b      	ldrb	r3, [r3, #0]
 1c4:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 1c8:	72fb      	strb	r3, [r7, #11]

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 1ca:	4b15      	ldr	r3, [pc, #84]	; (220 <netif_find+0x78>)
 1cc:	681b      	ldr	r3, [r3, #0]
 1ce:	60fb      	str	r3, [r7, #12]
 1d0:	e01a      	b.n	208 <netif_find+0x60>
    if (num == netif->num &&
 1d2:	68fb      	ldr	r3, [r7, #12]
 1d4:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 1d8:	7afa      	ldrb	r2, [r7, #11]
 1da:	429a      	cmp	r2, r3
 1dc:	d111      	bne.n	202 <netif_find+0x5a>
       name[0] == netif->name[0] &&
 1de:	687b      	ldr	r3, [r7, #4]
 1e0:	781a      	ldrb	r2, [r3, #0]
 1e2:	68fb      	ldr	r3, [r7, #12]
 1e4:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
 1e8:	429a      	cmp	r2, r3
 1ea:	d10a      	bne.n	202 <netif_find+0x5a>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
 1ec:	687b      	ldr	r3, [r7, #4]
 1ee:	f103 0301 	add.w	r3, r3, #1
 1f2:	781a      	ldrb	r2, [r3, #0]
 1f4:	68fb      	ldr	r3, [r7, #12]
 1f6:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
 1fa:	429a      	cmp	r2, r3
 1fc:	d101      	bne.n	202 <netif_find+0x5a>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
 1fe:	68fb      	ldr	r3, [r7, #12]
 200:	e007      	b.n	212 <netif_find+0x6a>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 202:	68fb      	ldr	r3, [r7, #12]
 204:	681b      	ldr	r3, [r3, #0]
 206:	60fb      	str	r3, [r7, #12]
 208:	68fb      	ldr	r3, [r7, #12]
 20a:	2b00      	cmp	r3, #0
 20c:	d1e1      	bne.n	1d2 <netif_find+0x2a>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
 20e:	f04f 0300 	mov.w	r3, #0
}
 212:	4618      	mov	r0, r3
 214:	f107 0714 	add.w	r7, r7, #20
 218:	46bd      	mov	sp, r7
 21a:	bc80      	pop	{r7}
 21c:	4770      	bx	lr
 21e:	bf00      	nop
 220:	00000000 	.word	0x00000000
			220: R_ARM_ABS32	netif_list

00000224 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 224:	b580      	push	{r7, lr}
 226:	b086      	sub	sp, #24
 228:	af00      	add	r7, sp, #0
 22a:	6078      	str	r0, [r7, #4]
 22c:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 22e:	683b      	ldr	r3, [r7, #0]
 230:	2b00      	cmp	r3, #0
 232:	d03f      	beq.n	2b4 <netif_set_ipaddr+0x90>
 234:	683b      	ldr	r3, [r7, #0]
 236:	681a      	ldr	r2, [r3, #0]
 238:	687b      	ldr	r3, [r7, #4]
 23a:	685b      	ldr	r3, [r3, #4]
 23c:	429a      	cmp	r2, r3
 23e:	d039      	beq.n	2b4 <netif_set_ipaddr+0x90>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 240:	4b23      	ldr	r3, [pc, #140]	; (2d0 <netif_set_ipaddr+0xac>)
 242:	681b      	ldr	r3, [r3, #0]
 244:	617b      	str	r3, [r7, #20]
    while (pcb != NULL) {
 246:	e011      	b.n	26c <netif_set_ipaddr+0x48>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 248:	697b      	ldr	r3, [r7, #20]
 24a:	681a      	ldr	r2, [r3, #0]
 24c:	687b      	ldr	r3, [r7, #4]
 24e:	685b      	ldr	r3, [r3, #4]
 250:	429a      	cmp	r2, r3
 252:	d108      	bne.n	266 <netif_set_ipaddr+0x42>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 254:	697b      	ldr	r3, [r7, #20]
 256:	68db      	ldr	r3, [r3, #12]
 258:	60fb      	str	r3, [r7, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 25a:	6978      	ldr	r0, [r7, #20]
 25c:	f7ff fffe 	bl	0 <tcp_abort>
			25c: R_ARM_THM_CALL	tcp_abort
        pcb = next;
 260:	68fb      	ldr	r3, [r7, #12]
 262:	617b      	str	r3, [r7, #20]
 264:	e002      	b.n	26c <netif_set_ipaddr+0x48>
      } else {
        pcb = pcb->next;
 266:	697b      	ldr	r3, [r7, #20]
 268:	68db      	ldr	r3, [r3, #12]
 26a:	617b      	str	r3, [r7, #20]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 26c:	697b      	ldr	r3, [r7, #20]
 26e:	2b00      	cmp	r3, #0
 270:	d1ea      	bne.n	248 <netif_set_ipaddr+0x24>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 272:	4b18      	ldr	r3, [pc, #96]	; (2d4 <netif_set_ipaddr+0xb0>)
 274:	681b      	ldr	r3, [r3, #0]
 276:	613b      	str	r3, [r7, #16]
 278:	e019      	b.n	2ae <netif_set_ipaddr+0x8a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 27a:	693b      	ldr	r3, [r7, #16]
 27c:	2b00      	cmp	r3, #0
 27e:	d013      	beq.n	2a8 <netif_set_ipaddr+0x84>
 280:	693b      	ldr	r3, [r7, #16]
 282:	681b      	ldr	r3, [r3, #0]
 284:	2b00      	cmp	r3, #0
 286:	d00f      	beq.n	2a8 <netif_set_ipaddr+0x84>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
 288:	693b      	ldr	r3, [r7, #16]
 28a:	681a      	ldr	r2, [r3, #0]
 28c:	687b      	ldr	r3, [r7, #4]
 28e:	685b      	ldr	r3, [r3, #4]
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 290:	429a      	cmp	r2, r3
 292:	d109      	bne.n	2a8 <netif_set_ipaddr+0x84>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 294:	683b      	ldr	r3, [r7, #0]
 296:	2b00      	cmp	r3, #0
 298:	d002      	beq.n	2a0 <netif_set_ipaddr+0x7c>
 29a:	683b      	ldr	r3, [r7, #0]
 29c:	681b      	ldr	r3, [r3, #0]
 29e:	e001      	b.n	2a4 <netif_set_ipaddr+0x80>
 2a0:	f04f 0300 	mov.w	r3, #0
 2a4:	693a      	ldr	r2, [r7, #16]
 2a6:	6013      	str	r3, [r2, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 2a8:	693b      	ldr	r3, [r7, #16]
 2aa:	68db      	ldr	r3, [r3, #12]
 2ac:	613b      	str	r3, [r7, #16]
 2ae:	693b      	ldr	r3, [r7, #16]
 2b0:	2b00      	cmp	r3, #0
 2b2:	d1e2      	bne.n	27a <netif_set_ipaddr+0x56>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 2b4:	683b      	ldr	r3, [r7, #0]
 2b6:	2b00      	cmp	r3, #0
 2b8:	d002      	beq.n	2c0 <netif_set_ipaddr+0x9c>
 2ba:	683b      	ldr	r3, [r7, #0]
 2bc:	681b      	ldr	r3, [r3, #0]
 2be:	e001      	b.n	2c4 <netif_set_ipaddr+0xa0>
 2c0:	f04f 0300 	mov.w	r3, #0
 2c4:	687a      	ldr	r2, [r7, #4]
 2c6:	6053      	str	r3, [r2, #4]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->ip_addr),
    ip4_addr2_16(&netif->ip_addr),
    ip4_addr3_16(&netif->ip_addr),
    ip4_addr4_16(&netif->ip_addr)));
}
 2c8:	f107 0718 	add.w	r7, r7, #24
 2cc:	46bd      	mov	sp, r7
 2ce:	bd80      	pop	{r7, pc}
	...
			2d0: R_ARM_ABS32	tcp_active_pcbs
			2d4: R_ARM_ABS32	tcp_listen_pcbs

000002d8 <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
 2d8:	b480      	push	{r7}
 2da:	b083      	sub	sp, #12
 2dc:	af00      	add	r7, sp, #0
 2de:	6078      	str	r0, [r7, #4]
 2e0:	6039      	str	r1, [r7, #0]
  ip_addr_set(&(netif->gw), gw);
 2e2:	683b      	ldr	r3, [r7, #0]
 2e4:	2b00      	cmp	r3, #0
 2e6:	d002      	beq.n	2ee <netif_set_gw+0x16>
 2e8:	683b      	ldr	r3, [r7, #0]
 2ea:	681b      	ldr	r3, [r3, #0]
 2ec:	e001      	b.n	2f2 <netif_set_gw+0x1a>
 2ee:	f04f 0300 	mov.w	r3, #0
 2f2:	687a      	ldr	r2, [r7, #4]
 2f4:	60d3      	str	r3, [r2, #12]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->gw),
    ip4_addr2_16(&netif->gw),
    ip4_addr3_16(&netif->gw),
    ip4_addr4_16(&netif->gw)));
}
 2f6:	f107 070c 	add.w	r7, r7, #12
 2fa:	46bd      	mov	sp, r7
 2fc:	bc80      	pop	{r7}
 2fe:	4770      	bx	lr

00000300 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
 300:	b480      	push	{r7}
 302:	b083      	sub	sp, #12
 304:	af00      	add	r7, sp, #0
 306:	6078      	str	r0, [r7, #4]
 308:	6039      	str	r1, [r7, #0]
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 30a:	683b      	ldr	r3, [r7, #0]
 30c:	2b00      	cmp	r3, #0
 30e:	d002      	beq.n	316 <netif_set_netmask+0x16>
 310:	683b      	ldr	r3, [r7, #0]
 312:	681b      	ldr	r3, [r3, #0]
 314:	e001      	b.n	31a <netif_set_netmask+0x1a>
 316:	f04f 0300 	mov.w	r3, #0
 31a:	687a      	ldr	r2, [r7, #4]
 31c:	6093      	str	r3, [r2, #8]
    netif->name[0], netif->name[1],
    ip4_addr1_16(&netif->netmask),
    ip4_addr2_16(&netif->netmask),
    ip4_addr3_16(&netif->netmask),
    ip4_addr4_16(&netif->netmask)));
}
 31e:	f107 070c 	add.w	r7, r7, #12
 322:	46bd      	mov	sp, r7
 324:	bc80      	pop	{r7}
 326:	4770      	bx	lr

00000328 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
 328:	b480      	push	{r7}
 32a:	b083      	sub	sp, #12
 32c:	af00      	add	r7, sp, #0
 32e:	6078      	str	r0, [r7, #4]
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 330:	4b03      	ldr	r3, [pc, #12]	; (340 <netif_set_default+0x18>)
 332:	687a      	ldr	r2, [r7, #4]
 334:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
 336:	f107 070c 	add.w	r7, r7, #12
 33a:	46bd      	mov	sp, r7
 33c:	bc80      	pop	{r7}
 33e:	4770      	bx	lr
 340:	00000000 	.word	0x00000000
			340: R_ARM_ABS32	netif_default

00000344 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 344:	b580      	push	{r7, lr}
 346:	b082      	sub	sp, #8
 348:	af00      	add	r7, sp, #0
 34a:	6078      	str	r0, [r7, #4]
  if (!(netif->flags & NETIF_FLAG_UP)) {
 34c:	687b      	ldr	r3, [r7, #4]
 34e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 352:	f003 0301 	and.w	r3, r3, #1
 356:	2b00      	cmp	r3, #0
 358:	d12f      	bne.n	3ba <netif_set_up+0x76>
    netif->flags |= NETIF_FLAG_UP;
 35a:	687b      	ldr	r3, [r7, #4]
 35c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 360:	f043 0301 	orr.w	r3, r3, #1
 364:	b2da      	uxtb	r2, r3
 366:	687b      	ldr	r3, [r7, #4]
 368:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif /* LWIP_SNMP */

    NETIF_STATUS_CALLBACK(netif);
 36c:	687b      	ldr	r3, [r7, #4]
 36e:	69db      	ldr	r3, [r3, #28]
 370:	2b00      	cmp	r3, #0
 372:	d003      	beq.n	37c <netif_set_up+0x38>
 374:	687b      	ldr	r3, [r7, #4]
 376:	69db      	ldr	r3, [r3, #28]
 378:	6878      	ldr	r0, [r7, #4]
 37a:	4798      	blx	r3

    if (netif->flags & NETIF_FLAG_LINK_UP) {
 37c:	687b      	ldr	r3, [r7, #4]
 37e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 382:	f003 0310 	and.w	r3, r3, #16
 386:	2b00      	cmp	r3, #0
 388:	d017      	beq.n	3ba <netif_set_up+0x76>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 38a:	687b      	ldr	r3, [r7, #4]
 38c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 390:	f003 0320 	and.w	r3, r3, #32
 394:	2b00      	cmp	r3, #0
 396:	d006      	beq.n	3a6 <netif_set_up+0x62>
        etharp_gratuitous(netif);
 398:	687b      	ldr	r3, [r7, #4]
 39a:	f103 0304 	add.w	r3, r3, #4
 39e:	6878      	ldr	r0, [r7, #4]
 3a0:	4619      	mov	r1, r3
 3a2:	f7ff fffe 	bl	0 <etharp_request>
			3a2: R_ARM_THM_CALL	etharp_request
      }
#endif /* LWIP_ARP */

#if LWIP_IGMP
      /* resend IGMP memberships */
      if (netif->flags & NETIF_FLAG_IGMP) {
 3a6:	687b      	ldr	r3, [r7, #4]
 3a8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 3ac:	b2db      	uxtb	r3, r3
 3ae:	b25b      	sxtb	r3, r3
 3b0:	2b00      	cmp	r3, #0
 3b2:	da02      	bge.n	3ba <netif_set_up+0x76>
        igmp_report_groups( netif);
 3b4:	6878      	ldr	r0, [r7, #4]
 3b6:	f7ff fffe 	bl	0 <igmp_report_groups>
			3b6: R_ARM_THM_CALL	igmp_report_groups
      }
#endif /* LWIP_IGMP */
    }
  }
}
 3ba:	f107 0708 	add.w	r7, r7, #8
 3be:	46bd      	mov	sp, r7
 3c0:	bd80      	pop	{r7, pc}
 3c2:	bf00      	nop

000003c4 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
 3c4:	b580      	push	{r7, lr}
 3c6:	b082      	sub	sp, #8
 3c8:	af00      	add	r7, sp, #0
 3ca:	6078      	str	r0, [r7, #4]
  if (netif->flags & NETIF_FLAG_UP) {
 3cc:	687b      	ldr	r3, [r7, #4]
 3ce:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 3d2:	f003 0301 	and.w	r3, r3, #1
 3d6:	b2db      	uxtb	r3, r3
 3d8:	2b00      	cmp	r3, #0
 3da:	d01a      	beq.n	412 <netif_set_down+0x4e>
    netif->flags &= ~NETIF_FLAG_UP;
 3dc:	687b      	ldr	r3, [r7, #4]
 3de:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 3e2:	f023 0301 	bic.w	r3, r3, #1
 3e6:	b2da      	uxtb	r2, r3
 3e8:	687b      	ldr	r3, [r7, #4]
 3ea:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 3ee:	687b      	ldr	r3, [r7, #4]
 3f0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 3f4:	f003 0320 	and.w	r3, r3, #32
 3f8:	2b00      	cmp	r3, #0
 3fa:	d002      	beq.n	402 <netif_set_down+0x3e>
      etharp_cleanup_netif(netif);
 3fc:	6878      	ldr	r0, [r7, #4]
 3fe:	f7ff fffe 	bl	0 <etharp_cleanup_netif>
			3fe: R_ARM_THM_CALL	etharp_cleanup_netif
    }
#endif /* LWIP_ARP */
    NETIF_STATUS_CALLBACK(netif);
 402:	687b      	ldr	r3, [r7, #4]
 404:	69db      	ldr	r3, [r3, #28]
 406:	2b00      	cmp	r3, #0
 408:	d003      	beq.n	412 <netif_set_down+0x4e>
 40a:	687b      	ldr	r3, [r7, #4]
 40c:	69db      	ldr	r3, [r3, #28]
 40e:	6878      	ldr	r0, [r7, #4]
 410:	4798      	blx	r3
  }
}
 412:	f107 0708 	add.w	r7, r7, #8
 416:	46bd      	mov	sp, r7
 418:	bd80      	pop	{r7, pc}
 41a:	bf00      	nop

0000041c <netif_set_status_callback>:
#if LWIP_NETIF_STATUS_CALLBACK
/**
 * Set callback to be called when interface is brought up/down
 */
void netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
{
 41c:	b480      	push	{r7}
 41e:	b083      	sub	sp, #12
 420:	af00      	add	r7, sp, #0
 422:	6078      	str	r0, [r7, #4]
 424:	6039      	str	r1, [r7, #0]
  if (netif) {
 426:	687b      	ldr	r3, [r7, #4]
 428:	2b00      	cmp	r3, #0
 42a:	d002      	beq.n	432 <netif_set_status_callback+0x16>
    netif->status_callback = status_callback;
 42c:	687b      	ldr	r3, [r7, #4]
 42e:	683a      	ldr	r2, [r7, #0]
 430:	61da      	str	r2, [r3, #28]
  }
}
 432:	f107 070c 	add.w	r7, r7, #12
 436:	46bd      	mov	sp, r7
 438:	bc80      	pop	{r7}
 43a:	4770      	bx	lr

0000043c <netif_set_link_up>:

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
 43c:	b580      	push	{r7, lr}
 43e:	b082      	sub	sp, #8
 440:	af00      	add	r7, sp, #0
 442:	6078      	str	r0, [r7, #4]
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 444:	687b      	ldr	r3, [r7, #4]
 446:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 44a:	f003 0310 	and.w	r3, r3, #16
 44e:	2b00      	cmp	r3, #0
 450:	d137      	bne.n	4c2 <netif_set_link_up+0x86>
    netif->flags |= NETIF_FLAG_LINK_UP;
 452:	687b      	ldr	r3, [r7, #4]
 454:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 458:	f043 0310 	orr.w	r3, r3, #16
 45c:	b2da      	uxtb	r2, r3
 45e:	687b      	ldr	r3, [r7, #4]
 460:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

#if LWIP_DHCP
    if (netif->dhcp) {
 464:	687b      	ldr	r3, [r7, #4]
 466:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 468:	2b00      	cmp	r3, #0
 46a:	d002      	beq.n	472 <netif_set_link_up+0x36>
      dhcp_network_changed(netif);
 46c:	6878      	ldr	r0, [r7, #4]
 46e:	f7ff fffe 	bl	0 <dhcp_network_changed>
			46e: R_ARM_THM_CALL	dhcp_network_changed
    if (netif->autoip) {
      autoip_network_changed(netif);
    }
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
 472:	687b      	ldr	r3, [r7, #4]
 474:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 478:	f003 0301 	and.w	r3, r3, #1
 47c:	b2db      	uxtb	r3, r3
 47e:	2b00      	cmp	r3, #0
 480:	d017      	beq.n	4b2 <netif_set_link_up+0x76>
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 482:	687b      	ldr	r3, [r7, #4]
 484:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 488:	f003 0320 	and.w	r3, r3, #32
 48c:	2b00      	cmp	r3, #0
 48e:	d006      	beq.n	49e <netif_set_link_up+0x62>
        etharp_gratuitous(netif);
 490:	687b      	ldr	r3, [r7, #4]
 492:	f103 0304 	add.w	r3, r3, #4
 496:	6878      	ldr	r0, [r7, #4]
 498:	4619      	mov	r1, r3
 49a:	f7ff fffe 	bl	0 <etharp_request>
			49a: R_ARM_THM_CALL	etharp_request
      }
#endif /* LWIP_ARP */

#if LWIP_IGMP
      /* resend IGMP memberships */
      if (netif->flags & NETIF_FLAG_IGMP) {
 49e:	687b      	ldr	r3, [r7, #4]
 4a0:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 4a4:	b2db      	uxtb	r3, r3
 4a6:	b25b      	sxtb	r3, r3
 4a8:	2b00      	cmp	r3, #0
 4aa:	da02      	bge.n	4b2 <netif_set_link_up+0x76>
        igmp_report_groups( netif);
 4ac:	6878      	ldr	r0, [r7, #4]
 4ae:	f7ff fffe 	bl	0 <igmp_report_groups>
			4ae: R_ARM_THM_CALL	igmp_report_groups
      }
#endif /* LWIP_IGMP */
    }
    NETIF_LINK_CALLBACK(netif);
 4b2:	687b      	ldr	r3, [r7, #4]
 4b4:	6a1b      	ldr	r3, [r3, #32]
 4b6:	2b00      	cmp	r3, #0
 4b8:	d003      	beq.n	4c2 <netif_set_link_up+0x86>
 4ba:	687b      	ldr	r3, [r7, #4]
 4bc:	6a1b      	ldr	r3, [r3, #32]
 4be:	6878      	ldr	r0, [r7, #4]
 4c0:	4798      	blx	r3
  }
}
 4c2:	f107 0708 	add.w	r7, r7, #8
 4c6:	46bd      	mov	sp, r7
 4c8:	bd80      	pop	{r7, pc}
 4ca:	bf00      	nop

000004cc <netif_set_link_down>:

/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
 4cc:	b580      	push	{r7, lr}
 4ce:	b082      	sub	sp, #8
 4d0:	af00      	add	r7, sp, #0
 4d2:	6078      	str	r0, [r7, #4]
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 4d4:	687b      	ldr	r3, [r7, #4]
 4d6:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 4da:	f003 0310 	and.w	r3, r3, #16
 4de:	2b00      	cmp	r3, #0
 4e0:	d010      	beq.n	504 <netif_set_link_down+0x38>
    netif->flags &= ~NETIF_FLAG_LINK_UP;
 4e2:	687b      	ldr	r3, [r7, #4]
 4e4:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 4e8:	f023 0310 	bic.w	r3, r3, #16
 4ec:	b2da      	uxtb	r2, r3
 4ee:	687b      	ldr	r3, [r7, #4]
 4f0:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    NETIF_LINK_CALLBACK(netif);
 4f4:	687b      	ldr	r3, [r7, #4]
 4f6:	6a1b      	ldr	r3, [r3, #32]
 4f8:	2b00      	cmp	r3, #0
 4fa:	d003      	beq.n	504 <netif_set_link_down+0x38>
 4fc:	687b      	ldr	r3, [r7, #4]
 4fe:	6a1b      	ldr	r3, [r3, #32]
 500:	6878      	ldr	r0, [r7, #4]
 502:	4798      	blx	r3
  }
}
 504:	f107 0708 	add.w	r7, r7, #8
 508:	46bd      	mov	sp, r7
 50a:	bd80      	pop	{r7, pc}

0000050c <netif_set_link_callback>:
#if LWIP_NETIF_LINK_CALLBACK
/**
 * Set callback to be called when link is brought up/down
 */
void netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
{
 50c:	b480      	push	{r7}
 50e:	b083      	sub	sp, #12
 510:	af00      	add	r7, sp, #0
 512:	6078      	str	r0, [r7, #4]
 514:	6039      	str	r1, [r7, #0]
  if (netif) {
 516:	687b      	ldr	r3, [r7, #4]
 518:	2b00      	cmp	r3, #0
 51a:	d002      	beq.n	522 <netif_set_link_callback+0x16>
    netif->link_callback = link_callback;
 51c:	687b      	ldr	r3, [r7, #4]
 51e:	683a      	ldr	r2, [r7, #0]
 520:	621a      	str	r2, [r3, #32]
  }
}
 522:	f107 070c 	add.w	r7, r7, #12
 526:	46bd      	mov	sp, r7
 528:	bc80      	pop	{r7}
 52a:	4770      	bx	lr

pbuf.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  77468 Jul 30 19:07 2021 pbuf.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ba0  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000bd4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000bd4  2**0
                  ALLOC
  3 .debug_abbrev 00000206  00000000  00000000  00000bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000f1a  00000000  00000000  00000dda  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000992  00000000  00000000  00001cf4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000e069  00000000  00000000  00002686  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000460  00000000  00000000  000106ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000139  00000000  00000000  00010b4f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000156  00000000  00000000  00010c88  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00010dde  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000007b1  00000000  00000000  00010dfe  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  000115af  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  000115da  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000280  00000000  00000000  0001160c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 pbuf.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     F .text	0000005c pbuf_free_ooseq
0000005c l     F .text	00000014 pbuf_free_ooseq_callback
00000070 l     F .text	00000060 pbuf_pool_is_empty
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000001       O *COM*	00000001 pbuf_free_ooseq_pending
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
00000000         *UND*	00000000 tcp_segs_free
00000000         *UND*	00000000 tcp_active_pcbs
00000000         *UND*	00000000 tcpip_callback_with_block
000000d0 g     F .text	00000248 pbuf_alloc
00000000         *UND*	00000000 memp_malloc
000004dc g     F .text	000000ba pbuf_free
00000000         *UND*	00000000 mem_malloc
00000318 g     F .text	000000d0 pbuf_realloc
00000000         *UND*	00000000 mem_trim
000003e8 g     F .text	000000f4 pbuf_header
00000000         *UND*	00000000 memp_free
00000000         *UND*	00000000 mem_free
00000598 g     F .text	00000032 pbuf_clen
000005cc g     F .text	00000030 pbuf_ref
000005fc g     F .text	0000005a pbuf_cat
00000658 g     F .text	00000020 pbuf_chain
00000678 g     F .text	0000005c pbuf_dechain
000006d4 g     F .text	00000122 pbuf_copy
00000000         *UND*	00000000 memcpy
000007f8 g     F .text	000000d2 pbuf_copy_partial
000008cc g     F .text	000000a8 pbuf_take
00000974 g     F .text	00000054 pbuf_coalesce
000009c8 g     F .text	00000064 pbuf_get_at
00000a2c g     F .text	000000a6 pbuf_memcmp
00000ad4 g     F .text	00000068 pbuf_memfind
00000b3c g     F .text	00000062 pbuf_strstr
00000000         *UND*	00000000 strlen



Disassembly of section .text:

00000000 <pbuf_free_ooseq>:
#if !NO_SYS
static
#endif /* !NO_SYS */
void
pbuf_free_ooseq(void)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
  struct tcp_pcb* pcb;
  SYS_ARCH_DECL_PROTECT(old_level);

  SYS_ARCH_PROTECT(old_level);
   6:	f7ff fffe 	bl	0 <sys_arch_protect>
			6: R_ARM_THM_CALL	sys_arch_protect
   a:	6038      	str	r0, [r7, #0]
  pbuf_free_ooseq_pending = 0;
   c:	4b11      	ldr	r3, [pc, #68]	; (54 <pbuf_free_ooseq+0x54>)
   e:	f04f 0200 	mov.w	r2, #0
  12:	701a      	strb	r2, [r3, #0]
  SYS_ARCH_UNPROTECT(old_level);
  14:	6838      	ldr	r0, [r7, #0]
  16:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			16: R_ARM_THM_CALL	sys_arch_unprotect

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
  1a:	4b0f      	ldr	r3, [pc, #60]	; (58 <pbuf_free_ooseq+0x58>)
  1c:	681b      	ldr	r3, [r3, #0]
  1e:	607b      	str	r3, [r7, #4]
  20:	e010      	b.n	44 <pbuf_free_ooseq+0x44>
    if (NULL != pcb->ooseq) {
  22:	687b      	ldr	r3, [r7, #4]
  24:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  26:	2b00      	cmp	r3, #0
  28:	d009      	beq.n	3e <pbuf_free_ooseq+0x3e>
      /** Free the ooseq pbufs of one PCB only */
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
      tcp_segs_free(pcb->ooseq);
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  2e:	4618      	mov	r0, r3
  30:	f7ff fffe 	bl	0 <tcp_segs_free>
			30: R_ARM_THM_CALL	tcp_segs_free
      pcb->ooseq = NULL;
  34:	687b      	ldr	r3, [r7, #4]
  36:	f04f 0200 	mov.w	r2, #0
  3a:	675a      	str	r2, [r3, #116]	; 0x74
      return;
  3c:	e005      	b.n	4a <pbuf_free_ooseq+0x4a>

  SYS_ARCH_PROTECT(old_level);
  pbuf_free_ooseq_pending = 0;
  SYS_ARCH_UNPROTECT(old_level);

  for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
  3e:	687b      	ldr	r3, [r7, #4]
  40:	68db      	ldr	r3, [r3, #12]
  42:	607b      	str	r3, [r7, #4]
  44:	687b      	ldr	r3, [r7, #4]
  46:	2b00      	cmp	r3, #0
  48:	d1eb      	bne.n	22 <pbuf_free_ooseq+0x22>
      tcp_segs_free(pcb->ooseq);
      pcb->ooseq = NULL;
      return;
    }
  }
}
  4a:	f107 0708 	add.w	r7, r7, #8
  4e:	46bd      	mov	sp, r7
  50:	bd80      	pop	{r7, pc}
  52:	bf00      	nop
	...
			54: R_ARM_ABS32	pbuf_free_ooseq_pending
			58: R_ARM_ABS32	tcp_active_pcbs

0000005c <pbuf_free_ooseq_callback>:
/**
 * Just a callback function for tcpip_timeout() that calls pbuf_free_ooseq().
 */
static void
pbuf_free_ooseq_callback(void *arg)
{
  5c:	b580      	push	{r7, lr}
  5e:	b082      	sub	sp, #8
  60:	af00      	add	r7, sp, #0
  62:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  pbuf_free_ooseq();
  64:	f7ff ffcc 	bl	0 <pbuf_free_ooseq>
}
  68:	f107 0708 	add.w	r7, r7, #8
  6c:	46bd      	mov	sp, r7
  6e:	bd80      	pop	{r7, pc}

00000070 <pbuf_pool_is_empty>:
#endif /* !NO_SYS */

/** Queue a call to pbuf_free_ooseq if not already queued. */
static void
pbuf_pool_is_empty(void)
{
  70:	b580      	push	{r7, lr}
  72:	b082      	sub	sp, #8
  74:	af00      	add	r7, sp, #0
  pbuf_free_ooseq_pending = 1;
  SYS_ARCH_UNPROTECT(old_level);
#else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
  u8_t queued;
  SYS_ARCH_DECL_PROTECT(old_level);
  SYS_ARCH_PROTECT(old_level);
  76:	f7ff fffe 	bl	0 <sys_arch_protect>
			76: R_ARM_THM_CALL	sys_arch_protect
  7a:	6078      	str	r0, [r7, #4]
  queued = pbuf_free_ooseq_pending;
  7c:	4b12      	ldr	r3, [pc, #72]	; (c8 <pbuf_pool_is_empty+0x58>)
  7e:	781b      	ldrb	r3, [r3, #0]
  80:	70fb      	strb	r3, [r7, #3]
  pbuf_free_ooseq_pending = 1;
  82:	4b11      	ldr	r3, [pc, #68]	; (c8 <pbuf_pool_is_empty+0x58>)
  84:	f04f 0201 	mov.w	r2, #1
  88:	701a      	strb	r2, [r3, #0]
  SYS_ARCH_UNPROTECT(old_level);
  8a:	6878      	ldr	r0, [r7, #4]
  8c:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			8c: R_ARM_THM_CALL	sys_arch_unprotect

  if(!queued) {
  90:	78fb      	ldrb	r3, [r7, #3]
  92:	2b00      	cmp	r3, #0
  94:	d113      	bne.n	be <pbuf_pool_is_empty+0x4e>
    /* queue a call to pbuf_free_ooseq if not already queued */
    PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
  96:	480d      	ldr	r0, [pc, #52]	; (cc <pbuf_pool_is_empty+0x5c>)
  98:	f04f 0100 	mov.w	r1, #0
  9c:	f04f 0200 	mov.w	r2, #0
  a0:	f7ff fffe 	bl	0 <tcpip_callback_with_block>
			a0: R_ARM_THM_CALL	tcpip_callback_with_block
  a4:	4603      	mov	r3, r0
  a6:	2b00      	cmp	r3, #0
  a8:	d009      	beq.n	be <pbuf_pool_is_empty+0x4e>
  aa:	f7ff fffe 	bl	0 <sys_arch_protect>
			aa: R_ARM_THM_CALL	sys_arch_protect
  ae:	6078      	str	r0, [r7, #4]
  b0:	4b05      	ldr	r3, [pc, #20]	; (c8 <pbuf_pool_is_empty+0x58>)
  b2:	f04f 0200 	mov.w	r2, #0
  b6:	701a      	strb	r2, [r3, #0]
  b8:	6878      	ldr	r0, [r7, #4]
  ba:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			ba: R_ARM_THM_CALL	sys_arch_unprotect
  }
#endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
}
  be:	f107 0708 	add.w	r7, r7, #8
  c2:	46bd      	mov	sp, r7
  c4:	bd80      	pop	{r7, pc}
  c6:	bf00      	nop
	...
			c8: R_ARM_ABS32	pbuf_free_ooseq_pending
			cc: R_ARM_ABS32	pbuf_free_ooseq_callback

000000d0 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  d0:	b580      	push	{r7, lr}
  d2:	b088      	sub	sp, #32
  d4:	af00      	add	r7, sp, #0
  d6:	4613      	mov	r3, r2
  d8:	4602      	mov	r2, r0
  da:	71fa      	strb	r2, [r7, #7]
  dc:	460a      	mov	r2, r1
  de:	80ba      	strh	r2, [r7, #4]
  e0:	70fb      	strb	r3, [r7, #3]
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
  e2:	79fb      	ldrb	r3, [r7, #7]
  e4:	2b03      	cmp	r3, #3
  e6:	d81b      	bhi.n	120 <pbuf_alloc+0x50>
  e8:	a201      	add	r2, pc, #4	; (adr r2, f0 <pbuf_alloc+0x20>)
  ea:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  ee:	bf00      	nop
  f0:	00000101 	.word	0x00000101
			f0: R_ARM_ABS32	.text
  f4:	00000109 	.word	0x00000109
			f4: R_ARM_ABS32	.text
  f8:	00000111 	.word	0x00000111
			f8: R_ARM_ABS32	.text
  fc:	00000119 	.word	0x00000119
			fc: R_ARM_ABS32	.text
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 100:	f04f 0336 	mov.w	r3, #54	; 0x36
 104:	82fb      	strh	r3, [r7, #22]
    break;
 106:	e00e      	b.n	126 <pbuf_alloc+0x56>
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 108:	f04f 0322 	mov.w	r3, #34	; 0x22
 10c:	82fb      	strh	r3, [r7, #22]
    break;
 10e:	e00a      	b.n	126 <pbuf_alloc+0x56>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 110:	f04f 030e 	mov.w	r3, #14
 114:	82fb      	strh	r3, [r7, #22]
    break;
 116:	e006      	b.n	126 <pbuf_alloc+0x56>
  case PBUF_RAW:
    offset = 0;
 118:	f04f 0300 	mov.w	r3, #0
 11c:	82fb      	strh	r3, [r7, #22]
    break;
 11e:	e002      	b.n	126 <pbuf_alloc+0x56>
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
 120:	f04f 0300 	mov.w	r3, #0
 124:	e0f3      	b.n	30e <pbuf_alloc+0x23e>
  }

  switch (type) {
 126:	78fb      	ldrb	r3, [r7, #3]
 128:	2b03      	cmp	r3, #3
 12a:	f200 80e4 	bhi.w	2f6 <pbuf_alloc+0x226>
 12e:	a201      	add	r2, pc, #4	; (adr r2, 134 <pbuf_alloc+0x64>)
 130:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 134:	0000024d 	.word	0x0000024d
			134: R_ARM_ABS32	.text
 138:	000002b9 	.word	0x000002b9
			138: R_ARM_ABS32	.text
 13c:	000002b9 	.word	0x000002b9
			13c: R_ARM_ABS32	.text
 140:	00000145 	.word	0x00000145
			140: R_ARM_ABS32	.text
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 144:	f04f 000f 	mov.w	r0, #15
 148:	f7ff fffe 	bl	0 <memp_malloc>
			148: R_ARM_THM_CALL	memp_malloc
 14c:	4603      	mov	r3, r0
 14e:	61fb      	str	r3, [r7, #28]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 150:	69fb      	ldr	r3, [r7, #28]
 152:	2b00      	cmp	r3, #0
 154:	d104      	bne.n	160 <pbuf_alloc+0x90>
      PBUF_POOL_IS_EMPTY();
 156:	f7ff ff8b 	bl	70 <pbuf_pool_is_empty>
      return NULL;
 15a:	f04f 0300 	mov.w	r3, #0
 15e:	e0d6      	b.n	30e <pbuf_alloc+0x23e>
    }
    p->type = type;
 160:	69fb      	ldr	r3, [r7, #28]
 162:	78fa      	ldrb	r2, [r7, #3]
 164:	731a      	strb	r2, [r3, #12]
    p->next = NULL;
 166:	69fb      	ldr	r3, [r7, #28]
 168:	f04f 0200 	mov.w	r2, #0
 16c:	601a      	str	r2, [r3, #0]

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 16e:	8afb      	ldrh	r3, [r7, #22]
 170:	f103 0310 	add.w	r3, r3, #16
 174:	69fa      	ldr	r2, [r7, #28]
 176:	18d3      	adds	r3, r2, r3
 178:	f103 0303 	add.w	r3, r3, #3
 17c:	f023 0303 	bic.w	r3, r3, #3
 180:	461a      	mov	r2, r3
 182:	69fb      	ldr	r3, [r7, #28]
 184:	605a      	str	r2, [r3, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 186:	69fb      	ldr	r3, [r7, #28]
 188:	88ba      	ldrh	r2, [r7, #4]
 18a:	811a      	strh	r2, [r3, #8]
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 18c:	8afb      	ldrh	r3, [r7, #22]
 18e:	f103 0303 	add.w	r3, r3, #3
 192:	f023 0303 	bic.w	r3, r3, #3
 196:	f5c3 63c2 	rsb	r3, r3, #1552	; 0x610
 19a:	f103 0304 	add.w	r3, r3, #4
 19e:	88ba      	ldrh	r2, [r7, #4]
 1a0:	4293      	cmp	r3, r2
 1a2:	bfa8      	it	ge
 1a4:	4613      	movge	r3, r2
 1a6:	b29a      	uxth	r2, r3
 1a8:	69fb      	ldr	r3, [r7, #28]
 1aa:	815a      	strh	r2, [r3, #10]
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 1ac:	69fb      	ldr	r3, [r7, #28]
 1ae:	f04f 0201 	mov.w	r2, #1
 1b2:	81da      	strh	r2, [r3, #14]

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
 1b4:	69fb      	ldr	r3, [r7, #28]
 1b6:	61bb      	str	r3, [r7, #24]
    /* remaining length to be allocated */
    rem_len = length - p->len;
 1b8:	88ba      	ldrh	r2, [r7, #4]
 1ba:	69fb      	ldr	r3, [r7, #28]
 1bc:	895b      	ldrh	r3, [r3, #10]
 1be:	1ad3      	subs	r3, r2, r3
 1c0:	613b      	str	r3, [r7, #16]
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 1c2:	e03f      	b.n	244 <pbuf_alloc+0x174>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 1c4:	f04f 000f 	mov.w	r0, #15
 1c8:	f7ff fffe 	bl	0 <memp_malloc>
			1c8: R_ARM_THM_CALL	memp_malloc
 1cc:	4603      	mov	r3, r0
 1ce:	60fb      	str	r3, [r7, #12]
      if (q == NULL) {
 1d0:	68fb      	ldr	r3, [r7, #12]
 1d2:	2b00      	cmp	r3, #0
 1d4:	d107      	bne.n	1e6 <pbuf_alloc+0x116>
        PBUF_POOL_IS_EMPTY();
 1d6:	f7ff ff4b 	bl	70 <pbuf_pool_is_empty>
        /* free chain so far allocated */
        pbuf_free(p);
 1da:	69f8      	ldr	r0, [r7, #28]
 1dc:	f7ff fffe 	bl	4dc <pbuf_free>
			1dc: R_ARM_THM_CALL	pbuf_free
        /* bail out unsuccesfully */
        return NULL;
 1e0:	f04f 0300 	mov.w	r3, #0
 1e4:	e093      	b.n	30e <pbuf_alloc+0x23e>
      }
      q->type = type;
 1e6:	68fb      	ldr	r3, [r7, #12]
 1e8:	78fa      	ldrb	r2, [r7, #3]
 1ea:	731a      	strb	r2, [r3, #12]
      q->flags = 0;
 1ec:	68fb      	ldr	r3, [r7, #12]
 1ee:	f04f 0200 	mov.w	r2, #0
 1f2:	735a      	strb	r2, [r3, #13]
      q->next = NULL;
 1f4:	68fb      	ldr	r3, [r7, #12]
 1f6:	f04f 0200 	mov.w	r2, #0
 1fa:	601a      	str	r2, [r3, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
 1fc:	69bb      	ldr	r3, [r7, #24]
 1fe:	68fa      	ldr	r2, [r7, #12]
 200:	601a      	str	r2, [r3, #0]
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 202:	693b      	ldr	r3, [r7, #16]
 204:	b29a      	uxth	r2, r3
 206:	68fb      	ldr	r3, [r7, #12]
 208:	811a      	strh	r2, [r3, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 20a:	693b      	ldr	r3, [r7, #16]
 20c:	b29a      	uxth	r2, r3
 20e:	f240 6313 	movw	r3, #1555	; 0x613
 212:	429a      	cmp	r2, r3
 214:	d802      	bhi.n	21c <pbuf_alloc+0x14c>
 216:	693b      	ldr	r3, [r7, #16]
 218:	b29b      	uxth	r3, r3
 21a:	e001      	b.n	220 <pbuf_alloc+0x150>
 21c:	f240 6314 	movw	r3, #1556	; 0x614
 220:	68fa      	ldr	r2, [r7, #12]
 222:	8153      	strh	r3, [r2, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 224:	68fb      	ldr	r3, [r7, #12]
 226:	f103 0210 	add.w	r2, r3, #16
 22a:	68fb      	ldr	r3, [r7, #12]
 22c:	605a      	str	r2, [r3, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 22e:	68fb      	ldr	r3, [r7, #12]
 230:	f04f 0201 	mov.w	r2, #1
 234:	81da      	strh	r2, [r3, #14]
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 236:	68fb      	ldr	r3, [r7, #12]
 238:	895b      	ldrh	r3, [r3, #10]
 23a:	693a      	ldr	r2, [r7, #16]
 23c:	1ad3      	subs	r3, r2, r3
 23e:	613b      	str	r3, [r7, #16]
      /* remember this pbuf for linkage in next iteration */
      r = q;
 240:	68fb      	ldr	r3, [r7, #12]
 242:	61bb      	str	r3, [r7, #24]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 244:	693b      	ldr	r3, [r7, #16]
 246:	2b00      	cmp	r3, #0
 248:	dcbc      	bgt.n	1c4 <pbuf_alloc+0xf4>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
 24a:	e057      	b.n	2fc <pbuf_alloc+0x22c>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 24c:	8afb      	ldrh	r3, [r7, #22]
 24e:	f103 0313 	add.w	r3, r3, #19
 252:	b29b      	uxth	r3, r3
 254:	f023 0303 	bic.w	r3, r3, #3
 258:	b29a      	uxth	r2, r3
 25a:	88bb      	ldrh	r3, [r7, #4]
 25c:	f103 0303 	add.w	r3, r3, #3
 260:	b29b      	uxth	r3, r3
 262:	f023 0303 	bic.w	r3, r3, #3
 266:	b29b      	uxth	r3, r3
 268:	18d3      	adds	r3, r2, r3
 26a:	b29b      	uxth	r3, r3
 26c:	4618      	mov	r0, r3
 26e:	f7ff fffe 	bl	0 <mem_malloc>
			26e: R_ARM_THM_CALL	mem_malloc
 272:	4603      	mov	r3, r0
 274:	61fb      	str	r3, [r7, #28]
    if (p == NULL) {
 276:	69fb      	ldr	r3, [r7, #28]
 278:	2b00      	cmp	r3, #0
 27a:	d102      	bne.n	282 <pbuf_alloc+0x1b2>
      return NULL;
 27c:	f04f 0300 	mov.w	r3, #0
 280:	e045      	b.n	30e <pbuf_alloc+0x23e>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 282:	8afb      	ldrh	r3, [r7, #22]
 284:	f103 0310 	add.w	r3, r3, #16
 288:	69fa      	ldr	r2, [r7, #28]
 28a:	18d3      	adds	r3, r2, r3
 28c:	f103 0303 	add.w	r3, r3, #3
 290:	f023 0303 	bic.w	r3, r3, #3
 294:	461a      	mov	r2, r3
 296:	69fb      	ldr	r3, [r7, #28]
 298:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
 29a:	69fb      	ldr	r3, [r7, #28]
 29c:	88ba      	ldrh	r2, [r7, #4]
 29e:	811a      	strh	r2, [r3, #8]
 2a0:	69fb      	ldr	r3, [r7, #28]
 2a2:	891a      	ldrh	r2, [r3, #8]
 2a4:	69fb      	ldr	r3, [r7, #28]
 2a6:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
 2a8:	69fb      	ldr	r3, [r7, #28]
 2aa:	f04f 0200 	mov.w	r2, #0
 2ae:	601a      	str	r2, [r3, #0]
    p->type = type;
 2b0:	69fb      	ldr	r3, [r7, #28]
 2b2:	78fa      	ldrb	r2, [r7, #3]
 2b4:	731a      	strb	r2, [r3, #12]

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
 2b6:	e021      	b.n	2fc <pbuf_alloc+0x22c>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 2b8:	f04f 000e 	mov.w	r0, #14
 2bc:	f7ff fffe 	bl	0 <memp_malloc>
			2bc: R_ARM_THM_CALL	memp_malloc
 2c0:	4603      	mov	r3, r0
 2c2:	61fb      	str	r3, [r7, #28]
    if (p == NULL) {
 2c4:	69fb      	ldr	r3, [r7, #28]
 2c6:	2b00      	cmp	r3, #0
 2c8:	d102      	bne.n	2d0 <pbuf_alloc+0x200>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
 2ca:	f04f 0300 	mov.w	r3, #0
 2ce:	e01e      	b.n	30e <pbuf_alloc+0x23e>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 2d0:	69fb      	ldr	r3, [r7, #28]
 2d2:	f04f 0200 	mov.w	r2, #0
 2d6:	605a      	str	r2, [r3, #4]
    p->len = p->tot_len = length;
 2d8:	69fb      	ldr	r3, [r7, #28]
 2da:	88ba      	ldrh	r2, [r7, #4]
 2dc:	811a      	strh	r2, [r3, #8]
 2de:	69fb      	ldr	r3, [r7, #28]
 2e0:	891a      	ldrh	r2, [r3, #8]
 2e2:	69fb      	ldr	r3, [r7, #28]
 2e4:	815a      	strh	r2, [r3, #10]
    p->next = NULL;
 2e6:	69fb      	ldr	r3, [r7, #28]
 2e8:	f04f 0200 	mov.w	r2, #0
 2ec:	601a      	str	r2, [r3, #0]
    p->type = type;
 2ee:	69fb      	ldr	r3, [r7, #28]
 2f0:	78fa      	ldrb	r2, [r7, #3]
 2f2:	731a      	strb	r2, [r3, #12]
    break;
 2f4:	e002      	b.n	2fc <pbuf_alloc+0x22c>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
 2f6:	f04f 0300 	mov.w	r3, #0
 2fa:	e008      	b.n	30e <pbuf_alloc+0x23e>
  }
  /* set reference count */
  p->ref = 1;
 2fc:	69fb      	ldr	r3, [r7, #28]
 2fe:	f04f 0201 	mov.w	r2, #1
 302:	81da      	strh	r2, [r3, #14]
  /* set flags */
  p->flags = 0;
 304:	69fb      	ldr	r3, [r7, #28]
 306:	f04f 0200 	mov.w	r2, #0
 30a:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 30c:	69fb      	ldr	r3, [r7, #28]
}
 30e:	4618      	mov	r0, r3
 310:	f107 0720 	add.w	r7, r7, #32
 314:	46bd      	mov	sp, r7
 316:	bd80      	pop	{r7, pc}

00000318 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 318:	b580      	push	{r7, lr}
 31a:	b086      	sub	sp, #24
 31c:	af00      	add	r7, sp, #0
 31e:	6078      	str	r0, [r7, #4]
 320:	460b      	mov	r3, r1
 322:	807b      	strh	r3, [r7, #2]
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 324:	687b      	ldr	r3, [r7, #4]
 326:	7b1b      	ldrb	r3, [r3, #12]
 328:	2b03      	cmp	r3, #3
 32a:	d006      	beq.n	33a <pbuf_realloc+0x22>
 32c:	687b      	ldr	r3, [r7, #4]
 32e:	7b1b      	ldrb	r3, [r3, #12]
 330:	2b01      	cmp	r3, #1
 332:	d002      	beq.n	33a <pbuf_realloc+0x22>
 334:	687b      	ldr	r3, [r7, #4]
 336:	7b1b      	ldrb	r3, [r3, #12]
 338:	2b00      	cmp	r3, #0
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 33a:	687b      	ldr	r3, [r7, #4]
 33c:	891b      	ldrh	r3, [r3, #8]
 33e:	887a      	ldrh	r2, [r7, #2]
 340:	429a      	cmp	r2, r3
 342:	d24c      	bcs.n	3de <pbuf_realloc+0xc6>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 344:	887a      	ldrh	r2, [r7, #2]
 346:	687b      	ldr	r3, [r7, #4]
 348:	891b      	ldrh	r3, [r3, #8]
 34a:	1ad3      	subs	r3, r2, r3
 34c:	60fb      	str	r3, [r7, #12]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
 34e:	887b      	ldrh	r3, [r7, #2]
 350:	827b      	strh	r3, [r7, #18]
  q = p;
 352:	687b      	ldr	r3, [r7, #4]
 354:	617b      	str	r3, [r7, #20]
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 356:	e00f      	b.n	378 <pbuf_realloc+0x60>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 358:	697b      	ldr	r3, [r7, #20]
 35a:	895b      	ldrh	r3, [r3, #10]
 35c:	8a7a      	ldrh	r2, [r7, #18]
 35e:	1ad3      	subs	r3, r2, r3
 360:	827b      	strh	r3, [r7, #18]
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 362:	697b      	ldr	r3, [r7, #20]
 364:	891a      	ldrh	r2, [r3, #8]
 366:	68fb      	ldr	r3, [r7, #12]
 368:	b29b      	uxth	r3, r3
 36a:	18d3      	adds	r3, r2, r3
 36c:	b29a      	uxth	r2, r3
 36e:	697b      	ldr	r3, [r7, #20]
 370:	811a      	strh	r2, [r3, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 372:	697b      	ldr	r3, [r7, #20]
 374:	681b      	ldr	r3, [r3, #0]
 376:	617b      	str	r3, [r7, #20]

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 378:	697b      	ldr	r3, [r7, #20]
 37a:	895b      	ldrh	r3, [r3, #10]
 37c:	8a7a      	ldrh	r2, [r7, #18]
 37e:	429a      	cmp	r2, r3
 380:	d8ea      	bhi.n	358 <pbuf_realloc+0x40>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 382:	697b      	ldr	r3, [r7, #20]
 384:	7b1b      	ldrb	r3, [r3, #12]
 386:	2b00      	cmp	r3, #0
 388:	d114      	bne.n	3b4 <pbuf_realloc+0x9c>
 38a:	697b      	ldr	r3, [r7, #20]
 38c:	895b      	ldrh	r3, [r3, #10]
 38e:	8a7a      	ldrh	r2, [r7, #18]
 390:	429a      	cmp	r2, r3
 392:	d00f      	beq.n	3b4 <pbuf_realloc+0x9c>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 394:	697b      	ldr	r3, [r7, #20]
 396:	685b      	ldr	r3, [r3, #4]
 398:	b29a      	uxth	r2, r3
 39a:	697b      	ldr	r3, [r7, #20]
 39c:	b29b      	uxth	r3, r3
 39e:	1ad3      	subs	r3, r2, r3
 3a0:	b29a      	uxth	r2, r3
 3a2:	8a7b      	ldrh	r3, [r7, #18]
 3a4:	18d3      	adds	r3, r2, r3
 3a6:	b29b      	uxth	r3, r3
 3a8:	6978      	ldr	r0, [r7, #20]
 3aa:	4619      	mov	r1, r3
 3ac:	f7ff fffe 	bl	0 <mem_trim>
			3ac: R_ARM_THM_CALL	mem_trim
 3b0:	4603      	mov	r3, r0
 3b2:	617b      	str	r3, [r7, #20]
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 3b4:	697b      	ldr	r3, [r7, #20]
 3b6:	8a7a      	ldrh	r2, [r7, #18]
 3b8:	815a      	strh	r2, [r3, #10]
  q->tot_len = q->len;
 3ba:	697b      	ldr	r3, [r7, #20]
 3bc:	895a      	ldrh	r2, [r3, #10]
 3be:	697b      	ldr	r3, [r7, #20]
 3c0:	811a      	strh	r2, [r3, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 3c2:	697b      	ldr	r3, [r7, #20]
 3c4:	681b      	ldr	r3, [r3, #0]
 3c6:	2b00      	cmp	r3, #0
 3c8:	d004      	beq.n	3d4 <pbuf_realloc+0xbc>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 3ca:	697b      	ldr	r3, [r7, #20]
 3cc:	681b      	ldr	r3, [r3, #0]
 3ce:	4618      	mov	r0, r3
 3d0:	f7ff fffe 	bl	4dc <pbuf_free>
			3d0: R_ARM_THM_CALL	pbuf_free
  }
  /* q is last packet in chain */
  q->next = NULL;
 3d4:	697b      	ldr	r3, [r7, #20]
 3d6:	f04f 0200 	mov.w	r2, #0
 3da:	601a      	str	r2, [r3, #0]
 3dc:	e000      	b.n	3e0 <pbuf_realloc+0xc8>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
 3de:	bf00      	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
 3e0:	f107 0718 	add.w	r7, r7, #24
 3e4:	46bd      	mov	sp, r7
 3e6:	bd80      	pop	{r7, pc}

000003e8 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 3e8:	b480      	push	{r7}
 3ea:	b085      	sub	sp, #20
 3ec:	af00      	add	r7, sp, #0
 3ee:	6078      	str	r0, [r7, #4]
 3f0:	460b      	mov	r3, r1
 3f2:	807b      	strh	r3, [r7, #2]
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
 3f4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 3f8:	2b00      	cmp	r3, #0
 3fa:	d002      	beq.n	402 <pbuf_header+0x1a>
 3fc:	687b      	ldr	r3, [r7, #4]
 3fe:	2b00      	cmp	r3, #0
 400:	d102      	bne.n	408 <pbuf_header+0x20>
    return 0;
 402:	f04f 0300 	mov.w	r3, #0
 406:	e063      	b.n	4d0 <pbuf_header+0xe8>
  }
 
  if (header_size_increment < 0){
 408:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 40c:	2b00      	cmp	r3, #0
 40e:	da0b      	bge.n	428 <pbuf_header+0x40>
    increment_magnitude = -header_size_increment;
 410:	887b      	ldrh	r3, [r7, #2]
 412:	f1c3 0300 	rsb	r3, r3, #0
 416:	81fb      	strh	r3, [r7, #14]
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 418:	687b      	ldr	r3, [r7, #4]
 41a:	895b      	ldrh	r3, [r3, #10]
 41c:	89fa      	ldrh	r2, [r7, #14]
 41e:	429a      	cmp	r2, r3
 420:	d904      	bls.n	42c <pbuf_header+0x44>
 422:	f04f 0301 	mov.w	r3, #1
 426:	e053      	b.n	4d0 <pbuf_header+0xe8>
  } else {
    increment_magnitude = header_size_increment;
 428:	887b      	ldrh	r3, [r7, #2]
 42a:	81fb      	strh	r3, [r7, #14]
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 42c:	687b      	ldr	r3, [r7, #4]
 42e:	7b1b      	ldrb	r3, [r3, #12]
 430:	81bb      	strh	r3, [r7, #12]
  /* remember current payload pointer */
  payload = p->payload;
 432:	687b      	ldr	r3, [r7, #4]
 434:	685b      	ldr	r3, [r3, #4]
 436:	60bb      	str	r3, [r7, #8]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 438:	89bb      	ldrh	r3, [r7, #12]
 43a:	2b00      	cmp	r3, #0
 43c:	d002      	beq.n	444 <pbuf_header+0x5c>
 43e:	89bb      	ldrh	r3, [r7, #12]
 440:	2b03      	cmp	r3, #3
 442:	d116      	bne.n	472 <pbuf_header+0x8a>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 444:	687b      	ldr	r3, [r7, #4]
 446:	685a      	ldr	r2, [r3, #4]
 448:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 44c:	f1c3 0300 	rsb	r3, r3, #0
 450:	18d2      	adds	r2, r2, r3
 452:	687b      	ldr	r3, [r7, #4]
 454:	605a      	str	r2, [r3, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 456:	687b      	ldr	r3, [r7, #4]
 458:	685b      	ldr	r3, [r3, #4]
 45a:	461a      	mov	r2, r3
 45c:	687b      	ldr	r3, [r7, #4]
 45e:	f103 0310 	add.w	r3, r3, #16
 462:	429a      	cmp	r2, r3
 464:	d224      	bcs.n	4b0 <pbuf_header+0xc8>
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 466:	687b      	ldr	r3, [r7, #4]
 468:	68ba      	ldr	r2, [r7, #8]
 46a:	605a      	str	r2, [r3, #4]
      /* bail out unsuccesfully */
      return 1;
 46c:	f04f 0301 	mov.w	r3, #1
 470:	e02e      	b.n	4d0 <pbuf_header+0xe8>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 472:	89bb      	ldrh	r3, [r7, #12]
 474:	2b02      	cmp	r3, #2
 476:	d002      	beq.n	47e <pbuf_header+0x96>
 478:	89bb      	ldrh	r3, [r7, #12]
 47a:	2b01      	cmp	r3, #1
 47c:	d115      	bne.n	4aa <pbuf_header+0xc2>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 47e:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 482:	2b00      	cmp	r3, #0
 484:	da0e      	bge.n	4a4 <pbuf_header+0xbc>
 486:	687b      	ldr	r3, [r7, #4]
 488:	895b      	ldrh	r3, [r3, #10]
 48a:	89fa      	ldrh	r2, [r7, #14]
 48c:	429a      	cmp	r2, r3
 48e:	d809      	bhi.n	4a4 <pbuf_header+0xbc>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 490:	687b      	ldr	r3, [r7, #4]
 492:	685a      	ldr	r2, [r3, #4]
 494:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 498:	f1c3 0300 	rsb	r3, r3, #0
 49c:	18d2      	adds	r2, r2, r3
 49e:	687b      	ldr	r3, [r7, #4]
 4a0:	605a      	str	r2, [r3, #4]
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 4a2:	e005      	b.n	4b0 <pbuf_header+0xc8>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 4a4:	f04f 0301 	mov.w	r3, #1
 4a8:	e012      	b.n	4d0 <pbuf_header+0xe8>
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
 4aa:	f04f 0301 	mov.w	r3, #1
 4ae:	e00f      	b.n	4d0 <pbuf_header+0xe8>
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 4b0:	687b      	ldr	r3, [r7, #4]
 4b2:	895a      	ldrh	r2, [r3, #10]
 4b4:	887b      	ldrh	r3, [r7, #2]
 4b6:	18d3      	adds	r3, r2, r3
 4b8:	b29a      	uxth	r2, r3
 4ba:	687b      	ldr	r3, [r7, #4]
 4bc:	815a      	strh	r2, [r3, #10]
  p->tot_len += header_size_increment;
 4be:	687b      	ldr	r3, [r7, #4]
 4c0:	891a      	ldrh	r2, [r3, #8]
 4c2:	887b      	ldrh	r3, [r7, #2]
 4c4:	18d3      	adds	r3, r2, r3
 4c6:	b29a      	uxth	r2, r3
 4c8:	687b      	ldr	r3, [r7, #4]
 4ca:	811a      	strh	r2, [r3, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 4cc:	f04f 0300 	mov.w	r3, #0
}
 4d0:	4618      	mov	r0, r3
 4d2:	f107 0714 	add.w	r7, r7, #20
 4d6:	46bd      	mov	sp, r7
 4d8:	bc80      	pop	{r7}
 4da:	4770      	bx	lr

000004dc <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 4dc:	b580      	push	{r7, lr}
 4de:	b088      	sub	sp, #32
 4e0:	af00      	add	r7, sp, #0
 4e2:	6078      	str	r0, [r7, #4]
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 4e4:	687b      	ldr	r3, [r7, #4]
 4e6:	2b00      	cmp	r3, #0
 4e8:	d102      	bne.n	4f0 <pbuf_free+0x14>
    LWIP_ASSERT("p != NULL", p != NULL);
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 4ea:	f04f 0300 	mov.w	r3, #0
 4ee:	e04d      	b.n	58c <pbuf_free+0xb0>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 4f0:	687b      	ldr	r3, [r7, #4]
 4f2:	7b1b      	ldrb	r3, [r3, #12]
 4f4:	2b00      	cmp	r3, #0
 4f6:	d006      	beq.n	506 <pbuf_free+0x2a>
 4f8:	687b      	ldr	r3, [r7, #4]
 4fa:	7b1b      	ldrb	r3, [r3, #12]
 4fc:	2b01      	cmp	r3, #1
 4fe:	d002      	beq.n	506 <pbuf_free+0x2a>
 500:	687b      	ldr	r3, [r7, #4]
 502:	7b1b      	ldrb	r3, [r3, #12]
 504:	2b02      	cmp	r3, #2
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
 506:	f04f 0300 	mov.w	r3, #0
 50a:	77fb      	strb	r3, [r7, #31]
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 50c:	e03a      	b.n	584 <pbuf_free+0xa8>
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
 50e:	f7ff fffe 	bl	0 <sys_arch_protect>
			50e: R_ARM_THM_CALL	sys_arch_protect
 512:	61b8      	str	r0, [r7, #24]
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 514:	687b      	ldr	r3, [r7, #4]
 516:	89db      	ldrh	r3, [r3, #14]
 518:	f103 33ff 	add.w	r3, r3, #4294967295
 51c:	b29a      	uxth	r2, r3
 51e:	687b      	ldr	r3, [r7, #4]
 520:	81da      	strh	r2, [r3, #14]
 522:	687b      	ldr	r3, [r7, #4]
 524:	89db      	ldrh	r3, [r3, #14]
 526:	82fb      	strh	r3, [r7, #22]
    SYS_ARCH_UNPROTECT(old_level);
 528:	69b8      	ldr	r0, [r7, #24]
 52a:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			52a: R_ARM_THM_CALL	sys_arch_unprotect
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 52e:	8afb      	ldrh	r3, [r7, #22]
 530:	2b00      	cmp	r3, #0
 532:	d124      	bne.n	57e <pbuf_free+0xa2>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 534:	687b      	ldr	r3, [r7, #4]
 536:	681b      	ldr	r3, [r3, #0]
 538:	613b      	str	r3, [r7, #16]
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 53a:	687b      	ldr	r3, [r7, #4]
 53c:	7b1b      	ldrb	r3, [r3, #12]
 53e:	81fb      	strh	r3, [r7, #14]
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 540:	89fb      	ldrh	r3, [r7, #14]
 542:	2b03      	cmp	r3, #3
 544:	d105      	bne.n	552 <pbuf_free+0x76>
          memp_free(MEMP_PBUF_POOL, p);
 546:	f04f 000f 	mov.w	r0, #15
 54a:	6879      	ldr	r1, [r7, #4]
 54c:	f7ff fffe 	bl	0 <memp_free>
			54c: R_ARM_THM_CALL	memp_free
 550:	e00e      	b.n	570 <pbuf_free+0x94>
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 552:	89fb      	ldrh	r3, [r7, #14]
 554:	2b01      	cmp	r3, #1
 556:	d002      	beq.n	55e <pbuf_free+0x82>
 558:	89fb      	ldrh	r3, [r7, #14]
 55a:	2b02      	cmp	r3, #2
 55c:	d105      	bne.n	56a <pbuf_free+0x8e>
          memp_free(MEMP_PBUF, p);
 55e:	f04f 000e 	mov.w	r0, #14
 562:	6879      	ldr	r1, [r7, #4]
 564:	f7ff fffe 	bl	0 <memp_free>
			564: R_ARM_THM_CALL	memp_free
 568:	e002      	b.n	570 <pbuf_free+0x94>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 56a:	6878      	ldr	r0, [r7, #4]
 56c:	f7ff fffe 	bl	0 <mem_free>
			56c: R_ARM_THM_CALL	mem_free
        }
      }
      count++;
 570:	7ffb      	ldrb	r3, [r7, #31]
 572:	f103 0301 	add.w	r3, r3, #1
 576:	77fb      	strb	r3, [r7, #31]
      /* proceed to next pbuf */
      p = q;
 578:	693b      	ldr	r3, [r7, #16]
 57a:	607b      	str	r3, [r7, #4]
 57c:	e002      	b.n	584 <pbuf_free+0xa8>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
 57e:	f04f 0300 	mov.w	r3, #0
 582:	607b      	str	r3, [r7, #4]
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 584:	687b      	ldr	r3, [r7, #4]
 586:	2b00      	cmp	r3, #0
 588:	d1c1      	bne.n	50e <pbuf_free+0x32>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
 58a:	7ffb      	ldrb	r3, [r7, #31]
}
 58c:	4618      	mov	r0, r3
 58e:	f107 0720 	add.w	r7, r7, #32
 592:	46bd      	mov	sp, r7
 594:	bd80      	pop	{r7, pc}
 596:	bf00      	nop

00000598 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
 598:	b480      	push	{r7}
 59a:	b085      	sub	sp, #20
 59c:	af00      	add	r7, sp, #0
 59e:	6078      	str	r0, [r7, #4]
  u8_t len;

  len = 0;
 5a0:	f04f 0300 	mov.w	r3, #0
 5a4:	73fb      	strb	r3, [r7, #15]
  while (p != NULL) {
 5a6:	e006      	b.n	5b6 <pbuf_clen+0x1e>
    ++len;
 5a8:	7bfb      	ldrb	r3, [r7, #15]
 5aa:	f103 0301 	add.w	r3, r3, #1
 5ae:	73fb      	strb	r3, [r7, #15]
    p = p->next;
 5b0:	687b      	ldr	r3, [r7, #4]
 5b2:	681b      	ldr	r3, [r3, #0]
 5b4:	607b      	str	r3, [r7, #4]
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 5b6:	687b      	ldr	r3, [r7, #4]
 5b8:	2b00      	cmp	r3, #0
 5ba:	d1f5      	bne.n	5a8 <pbuf_clen+0x10>
    ++len;
    p = p->next;
  }
  return len;
 5bc:	7bfb      	ldrb	r3, [r7, #15]
}
 5be:	4618      	mov	r0, r3
 5c0:	f107 0714 	add.w	r7, r7, #20
 5c4:	46bd      	mov	sp, r7
 5c6:	bc80      	pop	{r7}
 5c8:	4770      	bx	lr
 5ca:	bf00      	nop

000005cc <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 5cc:	b580      	push	{r7, lr}
 5ce:	b084      	sub	sp, #16
 5d0:	af00      	add	r7, sp, #0
 5d2:	6078      	str	r0, [r7, #4]
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 5d4:	687b      	ldr	r3, [r7, #4]
 5d6:	2b00      	cmp	r3, #0
 5d8:	d00c      	beq.n	5f4 <pbuf_ref+0x28>
    SYS_ARCH_PROTECT(old_level);
 5da:	f7ff fffe 	bl	0 <sys_arch_protect>
			5da: R_ARM_THM_CALL	sys_arch_protect
 5de:	60f8      	str	r0, [r7, #12]
    ++(p->ref);
 5e0:	687b      	ldr	r3, [r7, #4]
 5e2:	89db      	ldrh	r3, [r3, #14]
 5e4:	f103 0301 	add.w	r3, r3, #1
 5e8:	b29a      	uxth	r2, r3
 5ea:	687b      	ldr	r3, [r7, #4]
 5ec:	81da      	strh	r2, [r3, #14]
    SYS_ARCH_UNPROTECT(old_level);
 5ee:	68f8      	ldr	r0, [r7, #12]
 5f0:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			5f0: R_ARM_THM_CALL	sys_arch_unprotect
  }
}
 5f4:	f107 0710 	add.w	r7, r7, #16
 5f8:	46bd      	mov	sp, r7
 5fa:	bd80      	pop	{r7, pc}

000005fc <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 5fc:	b480      	push	{r7}
 5fe:	b085      	sub	sp, #20
 600:	af00      	add	r7, sp, #0
 602:	6078      	str	r0, [r7, #4]
 604:	6039      	str	r1, [r7, #0]
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 606:	687b      	ldr	r3, [r7, #4]
 608:	2b00      	cmp	r3, #0
 60a:	d01f      	beq.n	64c <pbuf_cat+0x50>
 60c:	683b      	ldr	r3, [r7, #0]
 60e:	2b00      	cmp	r3, #0
 610:	d01c      	beq.n	64c <pbuf_cat+0x50>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 612:	687b      	ldr	r3, [r7, #4]
 614:	60fb      	str	r3, [r7, #12]
 616:	e00a      	b.n	62e <pbuf_cat+0x32>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 618:	68fb      	ldr	r3, [r7, #12]
 61a:	891a      	ldrh	r2, [r3, #8]
 61c:	683b      	ldr	r3, [r7, #0]
 61e:	891b      	ldrh	r3, [r3, #8]
 620:	18d3      	adds	r3, r2, r3
 622:	b29a      	uxth	r2, r3
 624:	68fb      	ldr	r3, [r7, #12]
 626:	811a      	strh	r2, [r3, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 628:	68fb      	ldr	r3, [r7, #12]
 62a:	681b      	ldr	r3, [r3, #0]
 62c:	60fb      	str	r3, [r7, #12]
 62e:	68fb      	ldr	r3, [r7, #12]
 630:	681b      	ldr	r3, [r3, #0]
 632:	2b00      	cmp	r3, #0
 634:	d1f0      	bne.n	618 <pbuf_cat+0x1c>
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 636:	68fb      	ldr	r3, [r7, #12]
 638:	891a      	ldrh	r2, [r3, #8]
 63a:	683b      	ldr	r3, [r7, #0]
 63c:	891b      	ldrh	r3, [r3, #8]
 63e:	18d3      	adds	r3, r2, r3
 640:	b29a      	uxth	r2, r3
 642:	68fb      	ldr	r3, [r7, #12]
 644:	811a      	strh	r2, [r3, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 646:	68fb      	ldr	r3, [r7, #12]
 648:	683a      	ldr	r2, [r7, #0]
 64a:	601a      	str	r2, [r3, #0]
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 64c:	f107 0714 	add.w	r7, r7, #20
 650:	46bd      	mov	sp, r7
 652:	bc80      	pop	{r7}
 654:	4770      	bx	lr
 656:	bf00      	nop

00000658 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 658:	b580      	push	{r7, lr}
 65a:	b082      	sub	sp, #8
 65c:	af00      	add	r7, sp, #0
 65e:	6078      	str	r0, [r7, #4]
 660:	6039      	str	r1, [r7, #0]
  pbuf_cat(h, t);
 662:	6878      	ldr	r0, [r7, #4]
 664:	6839      	ldr	r1, [r7, #0]
 666:	f7ff fffe 	bl	5fc <pbuf_cat>
			666: R_ARM_THM_CALL	pbuf_cat
  /* t is now referenced by h */
  pbuf_ref(t);
 66a:	6838      	ldr	r0, [r7, #0]
 66c:	f7ff fffe 	bl	5cc <pbuf_ref>
			66c: R_ARM_THM_CALL	pbuf_ref
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 670:	f107 0708 	add.w	r7, r7, #8
 674:	46bd      	mov	sp, r7
 676:	bd80      	pop	{r7, pc}

00000678 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 678:	b580      	push	{r7, lr}
 67a:	b084      	sub	sp, #16
 67c:	af00      	add	r7, sp, #0
 67e:	6078      	str	r0, [r7, #4]
  struct pbuf *q;
  u8_t tail_gone = 1;
 680:	f04f 0301 	mov.w	r3, #1
 684:	73fb      	strb	r3, [r7, #15]
  /* tail */
  q = p->next;
 686:	687b      	ldr	r3, [r7, #4]
 688:	681b      	ldr	r3, [r3, #0]
 68a:	60bb      	str	r3, [r7, #8]
  /* pbuf has successor in chain? */
  if (q != NULL) {
 68c:	68bb      	ldr	r3, [r7, #8]
 68e:	2b00      	cmp	r3, #0
 690:	d014      	beq.n	6bc <pbuf_dechain+0x44>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
 692:	687b      	ldr	r3, [r7, #4]
 694:	891a      	ldrh	r2, [r3, #8]
 696:	687b      	ldr	r3, [r7, #4]
 698:	895b      	ldrh	r3, [r3, #10]
 69a:	1ad3      	subs	r3, r2, r3
 69c:	b29a      	uxth	r2, r3
 69e:	68bb      	ldr	r3, [r7, #8]
 6a0:	811a      	strh	r2, [r3, #8]
    /* decouple pbuf from remainder */
    p->next = NULL;
 6a2:	687b      	ldr	r3, [r7, #4]
 6a4:	f04f 0200 	mov.w	r2, #0
 6a8:	601a      	str	r2, [r3, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 6aa:	687b      	ldr	r3, [r7, #4]
 6ac:	895a      	ldrh	r2, [r3, #10]
 6ae:	687b      	ldr	r3, [r7, #4]
 6b0:	811a      	strh	r2, [r3, #8]
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 6b2:	68b8      	ldr	r0, [r7, #8]
 6b4:	f7ff fffe 	bl	4dc <pbuf_free>
			6b4: R_ARM_THM_CALL	pbuf_free
 6b8:	4603      	mov	r3, r0
 6ba:	73fb      	strb	r3, [r7, #15]
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 6bc:	7bfb      	ldrb	r3, [r7, #15]
 6be:	2b00      	cmp	r3, #0
 6c0:	d101      	bne.n	6c6 <pbuf_dechain+0x4e>
 6c2:	68bb      	ldr	r3, [r7, #8]
 6c4:	e001      	b.n	6ca <pbuf_dechain+0x52>
 6c6:	f04f 0300 	mov.w	r3, #0
}
 6ca:	4618      	mov	r0, r3
 6cc:	f107 0710 	add.w	r7, r7, #16
 6d0:	46bd      	mov	sp, r7
 6d2:	bd80      	pop	{r7, pc}

000006d4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 6d4:	b580      	push	{r7, lr}
 6d6:	b084      	sub	sp, #16
 6d8:	af00      	add	r7, sp, #0
 6da:	6078      	str	r0, [r7, #4]
 6dc:	6039      	str	r1, [r7, #0]
  u16_t offset_to=0, offset_from=0, len;
 6de:	f04f 0300 	mov.w	r3, #0
 6e2:	81fb      	strh	r3, [r7, #14]
 6e4:	f04f 0300 	mov.w	r3, #0
 6e8:	81bb      	strh	r3, [r7, #12]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 6ea:	687b      	ldr	r3, [r7, #4]
 6ec:	2b00      	cmp	r3, #0
 6ee:	d008      	beq.n	702 <pbuf_copy+0x2e>
 6f0:	683b      	ldr	r3, [r7, #0]
 6f2:	2b00      	cmp	r3, #0
 6f4:	d005      	beq.n	702 <pbuf_copy+0x2e>
 6f6:	687b      	ldr	r3, [r7, #4]
 6f8:	891a      	ldrh	r2, [r3, #8]
 6fa:	683b      	ldr	r3, [r7, #0]
 6fc:	891b      	ldrh	r3, [r3, #8]
 6fe:	429a      	cmp	r2, r3
 700:	d202      	bcs.n	708 <pbuf_copy+0x34>
 702:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 706:	e070      	b.n	7ea <pbuf_copy+0x116>

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 708:	687b      	ldr	r3, [r7, #4]
 70a:	895b      	ldrh	r3, [r3, #10]
 70c:	461a      	mov	r2, r3
 70e:	89fb      	ldrh	r3, [r7, #14]
 710:	1ad2      	subs	r2, r2, r3
 712:	683b      	ldr	r3, [r7, #0]
 714:	895b      	ldrh	r3, [r3, #10]
 716:	4619      	mov	r1, r3
 718:	89bb      	ldrh	r3, [r7, #12]
 71a:	1acb      	subs	r3, r1, r3
 71c:	429a      	cmp	r2, r3
 71e:	db05      	blt.n	72c <pbuf_copy+0x58>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 720:	683b      	ldr	r3, [r7, #0]
 722:	895a      	ldrh	r2, [r3, #10]
 724:	89bb      	ldrh	r3, [r7, #12]
 726:	1ad3      	subs	r3, r2, r3
 728:	817b      	strh	r3, [r7, #10]
 72a:	e004      	b.n	736 <pbuf_copy+0x62>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 72c:	687b      	ldr	r3, [r7, #4]
 72e:	895a      	ldrh	r2, [r3, #10]
 730:	89fb      	ldrh	r3, [r7, #14]
 732:	1ad3      	subs	r3, r2, r3
 734:	817b      	strh	r3, [r7, #10]
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 736:	687b      	ldr	r3, [r7, #4]
 738:	685a      	ldr	r2, [r3, #4]
 73a:	89fb      	ldrh	r3, [r7, #14]
 73c:	18d1      	adds	r1, r2, r3
 73e:	683b      	ldr	r3, [r7, #0]
 740:	685a      	ldr	r2, [r3, #4]
 742:	89bb      	ldrh	r3, [r7, #12]
 744:	18d2      	adds	r2, r2, r3
 746:	897b      	ldrh	r3, [r7, #10]
 748:	4608      	mov	r0, r1
 74a:	4611      	mov	r1, r2
 74c:	461a      	mov	r2, r3
 74e:	f7ff fffe 	bl	0 <memcpy>
			74e: R_ARM_THM_CALL	memcpy
    offset_to += len;
 752:	89fa      	ldrh	r2, [r7, #14]
 754:	897b      	ldrh	r3, [r7, #10]
 756:	18d3      	adds	r3, r2, r3
 758:	81fb      	strh	r3, [r7, #14]
    offset_from += len;
 75a:	89ba      	ldrh	r2, [r7, #12]
 75c:	897b      	ldrh	r3, [r7, #10]
 75e:	18d3      	adds	r3, r2, r3
 760:	81bb      	strh	r3, [r7, #12]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
 762:	683b      	ldr	r3, [r7, #0]
 764:	895b      	ldrh	r3, [r3, #10]
 766:	89ba      	ldrh	r2, [r7, #12]
 768:	429a      	cmp	r2, r3
 76a:	d305      	bcc.n	778 <pbuf_copy+0xa4>
      /* on to next p_from (if any) */
      offset_from = 0;
 76c:	f04f 0300 	mov.w	r3, #0
 770:	81bb      	strh	r3, [r7, #12]
      p_from = p_from->next;
 772:	683b      	ldr	r3, [r7, #0]
 774:	681b      	ldr	r3, [r3, #0]
 776:	603b      	str	r3, [r7, #0]
    }
    if (offset_to == p_to->len) {
 778:	687b      	ldr	r3, [r7, #4]
 77a:	895b      	ldrh	r3, [r3, #10]
 77c:	89fa      	ldrh	r2, [r7, #14]
 77e:	429a      	cmp	r2, r3
 780:	d10e      	bne.n	7a0 <pbuf_copy+0xcc>
      /* on to next p_to (if any) */
      offset_to = 0;
 782:	f04f 0300 	mov.w	r3, #0
 786:	81fb      	strh	r3, [r7, #14]
      p_to = p_to->next;
 788:	687b      	ldr	r3, [r7, #4]
 78a:	681b      	ldr	r3, [r3, #0]
 78c:	607b      	str	r3, [r7, #4]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 78e:	687b      	ldr	r3, [r7, #4]
 790:	2b00      	cmp	r3, #0
 792:	d105      	bne.n	7a0 <pbuf_copy+0xcc>
 794:	683b      	ldr	r3, [r7, #0]
 796:	2b00      	cmp	r3, #0
 798:	d002      	beq.n	7a0 <pbuf_copy+0xcc>
 79a:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 79e:	e024      	b.n	7ea <pbuf_copy+0x116>
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 7a0:	683b      	ldr	r3, [r7, #0]
 7a2:	2b00      	cmp	r3, #0
 7a4:	d00c      	beq.n	7c0 <pbuf_copy+0xec>
 7a6:	683b      	ldr	r3, [r7, #0]
 7a8:	895a      	ldrh	r2, [r3, #10]
 7aa:	683b      	ldr	r3, [r7, #0]
 7ac:	891b      	ldrh	r3, [r3, #8]
 7ae:	429a      	cmp	r2, r3
 7b0:	d106      	bne.n	7c0 <pbuf_copy+0xec>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 7b2:	683b      	ldr	r3, [r7, #0]
 7b4:	681b      	ldr	r3, [r3, #0]
 7b6:	2b00      	cmp	r3, #0
 7b8:	d002      	beq.n	7c0 <pbuf_copy+0xec>
 7ba:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 7be:	e014      	b.n	7ea <pbuf_copy+0x116>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 7c0:	687b      	ldr	r3, [r7, #4]
 7c2:	2b00      	cmp	r3, #0
 7c4:	d00c      	beq.n	7e0 <pbuf_copy+0x10c>
 7c6:	687b      	ldr	r3, [r7, #4]
 7c8:	895a      	ldrh	r2, [r3, #10]
 7ca:	687b      	ldr	r3, [r7, #4]
 7cc:	891b      	ldrh	r3, [r3, #8]
 7ce:	429a      	cmp	r2, r3
 7d0:	d106      	bne.n	7e0 <pbuf_copy+0x10c>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 7d2:	687b      	ldr	r3, [r7, #4]
 7d4:	681b      	ldr	r3, [r3, #0]
 7d6:	2b00      	cmp	r3, #0
 7d8:	d002      	beq.n	7e0 <pbuf_copy+0x10c>
 7da:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 7de:	e004      	b.n	7ea <pbuf_copy+0x116>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 7e0:	683b      	ldr	r3, [r7, #0]
 7e2:	2b00      	cmp	r3, #0
 7e4:	d190      	bne.n	708 <pbuf_copy+0x34>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 7e6:	f04f 0300 	mov.w	r3, #0
 7ea:	b25b      	sxtb	r3, r3
}
 7ec:	4618      	mov	r0, r3
 7ee:	f107 0710 	add.w	r7, r7, #16
 7f2:	46bd      	mov	sp, r7
 7f4:	bd80      	pop	{r7, pc}
 7f6:	bf00      	nop

000007f8 <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 7f8:	b580      	push	{r7, lr}
 7fa:	b088      	sub	sp, #32
 7fc:	af00      	add	r7, sp, #0
 7fe:	60f8      	str	r0, [r7, #12]
 800:	60b9      	str	r1, [r7, #8]
 802:	80fa      	strh	r2, [r7, #6]
 804:	80bb      	strh	r3, [r7, #4]
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
 806:	f04f 0300 	mov.w	r3, #0
 80a:	82fb      	strh	r3, [r7, #22]

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80c:	68fb      	ldr	r3, [r7, #12]
 80e:	2b00      	cmp	r3, #0
 810:	d102      	bne.n	818 <pbuf_copy_partial+0x20>
 812:	f04f 0300 	mov.w	r3, #0
 816:	e053      	b.n	8c0 <pbuf_copy_partial+0xc8>
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 818:	68bb      	ldr	r3, [r7, #8]
 81a:	2b00      	cmp	r3, #0
 81c:	d102      	bne.n	824 <pbuf_copy_partial+0x2c>
 81e:	f04f 0300 	mov.w	r3, #0
 822:	e04d      	b.n	8c0 <pbuf_copy_partial+0xc8>

  left = 0;
 824:	f04f 0300 	mov.w	r3, #0
 828:	837b      	strh	r3, [r7, #26]

  if((buf == NULL) || (dataptr == NULL)) {
 82a:	68fb      	ldr	r3, [r7, #12]
 82c:	2b00      	cmp	r3, #0
 82e:	d002      	beq.n	836 <pbuf_copy_partial+0x3e>
 830:	68bb      	ldr	r3, [r7, #8]
 832:	2b00      	cmp	r3, #0
 834:	d102      	bne.n	83c <pbuf_copy_partial+0x44>
    return 0;
 836:	f04f 0300 	mov.w	r3, #0
 83a:	e041      	b.n	8c0 <pbuf_copy_partial+0xc8>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 83c:	68fb      	ldr	r3, [r7, #12]
 83e:	61fb      	str	r3, [r7, #28]
 840:	e037      	b.n	8b2 <pbuf_copy_partial+0xba>
    if ((offset != 0) && (offset >= p->len)) {
 842:	88bb      	ldrh	r3, [r7, #4]
 844:	2b00      	cmp	r3, #0
 846:	d00a      	beq.n	85e <pbuf_copy_partial+0x66>
 848:	69fb      	ldr	r3, [r7, #28]
 84a:	895b      	ldrh	r3, [r3, #10]
 84c:	88ba      	ldrh	r2, [r7, #4]
 84e:	429a      	cmp	r2, r3
 850:	d305      	bcc.n	85e <pbuf_copy_partial+0x66>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 852:	69fb      	ldr	r3, [r7, #28]
 854:	895b      	ldrh	r3, [r3, #10]
 856:	88ba      	ldrh	r2, [r7, #4]
 858:	1ad3      	subs	r3, r2, r3
 85a:	80bb      	strh	r3, [r7, #4]
 85c:	e026      	b.n	8ac <pbuf_copy_partial+0xb4>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 85e:	69fb      	ldr	r3, [r7, #28]
 860:	895a      	ldrh	r2, [r3, #10]
 862:	88bb      	ldrh	r3, [r7, #4]
 864:	1ad3      	subs	r3, r2, r3
 866:	833b      	strh	r3, [r7, #24]
      if (buf_copy_len > len)
 868:	8b3a      	ldrh	r2, [r7, #24]
 86a:	88fb      	ldrh	r3, [r7, #6]
 86c:	429a      	cmp	r2, r3
 86e:	d901      	bls.n	874 <pbuf_copy_partial+0x7c>
          buf_copy_len = len;
 870:	88fb      	ldrh	r3, [r7, #6]
 872:	833b      	strh	r3, [r7, #24]
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 874:	8b7b      	ldrh	r3, [r7, #26]
 876:	68ba      	ldr	r2, [r7, #8]
 878:	18d1      	adds	r1, r2, r3
 87a:	69fb      	ldr	r3, [r7, #28]
 87c:	685a      	ldr	r2, [r3, #4]
 87e:	88bb      	ldrh	r3, [r7, #4]
 880:	18d2      	adds	r2, r2, r3
 882:	8b3b      	ldrh	r3, [r7, #24]
 884:	4608      	mov	r0, r1
 886:	4611      	mov	r1, r2
 888:	461a      	mov	r2, r3
 88a:	f7ff fffe 	bl	0 <memcpy>
			88a: R_ARM_THM_CALL	memcpy
      copied_total += buf_copy_len;
 88e:	8afa      	ldrh	r2, [r7, #22]
 890:	8b3b      	ldrh	r3, [r7, #24]
 892:	18d3      	adds	r3, r2, r3
 894:	82fb      	strh	r3, [r7, #22]
      left += buf_copy_len;
 896:	8b7a      	ldrh	r2, [r7, #26]
 898:	8b3b      	ldrh	r3, [r7, #24]
 89a:	18d3      	adds	r3, r2, r3
 89c:	837b      	strh	r3, [r7, #26]
      len -= buf_copy_len;
 89e:	88fa      	ldrh	r2, [r7, #6]
 8a0:	8b3b      	ldrh	r3, [r7, #24]
 8a2:	1ad3      	subs	r3, r2, r3
 8a4:	80fb      	strh	r3, [r7, #6]
      offset = 0;
 8a6:	f04f 0300 	mov.w	r3, #0
 8aa:	80bb      	strh	r3, [r7, #4]
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8ac:	69fb      	ldr	r3, [r7, #28]
 8ae:	681b      	ldr	r3, [r3, #0]
 8b0:	61fb      	str	r3, [r7, #28]
 8b2:	88fb      	ldrh	r3, [r7, #6]
 8b4:	2b00      	cmp	r3, #0
 8b6:	d002      	beq.n	8be <pbuf_copy_partial+0xc6>
 8b8:	69fb      	ldr	r3, [r7, #28]
 8ba:	2b00      	cmp	r3, #0
 8bc:	d1c1      	bne.n	842 <pbuf_copy_partial+0x4a>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
 8be:	8afb      	ldrh	r3, [r7, #22]
}
 8c0:	4618      	mov	r0, r3
 8c2:	f107 0720 	add.w	r7, r7, #32
 8c6:	46bd      	mov	sp, r7
 8c8:	bd80      	pop	{r7, pc}
 8ca:	bf00      	nop

000008cc <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 8cc:	b580      	push	{r7, lr}
 8ce:	b088      	sub	sp, #32
 8d0:	af00      	add	r7, sp, #0
 8d2:	60f8      	str	r0, [r7, #12]
 8d4:	60b9      	str	r1, [r7, #8]
 8d6:	4613      	mov	r3, r2
 8d8:	80fb      	strh	r3, [r7, #6]
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
 8da:	88fb      	ldrh	r3, [r7, #6]
 8dc:	833b      	strh	r3, [r7, #24]
  u16_t copied_total = 0;
 8de:	f04f 0300 	mov.w	r3, #0
 8e2:	82fb      	strh	r3, [r7, #22]

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 8e4:	68fb      	ldr	r3, [r7, #12]
 8e6:	2b00      	cmp	r3, #0
 8e8:	d102      	bne.n	8f0 <pbuf_take+0x24>
 8ea:	f04f 0300 	mov.w	r3, #0
 8ee:	e03b      	b.n	968 <pbuf_take+0x9c>
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 8f0:	68bb      	ldr	r3, [r7, #8]
 8f2:	2b00      	cmp	r3, #0
 8f4:	d102      	bne.n	8fc <pbuf_take+0x30>
 8f6:	f04f 0300 	mov.w	r3, #0
 8fa:	e035      	b.n	968 <pbuf_take+0x9c>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 8fc:	68fb      	ldr	r3, [r7, #12]
 8fe:	2b00      	cmp	r3, #0
 900:	d007      	beq.n	912 <pbuf_take+0x46>
 902:	68bb      	ldr	r3, [r7, #8]
 904:	2b00      	cmp	r3, #0
 906:	d004      	beq.n	912 <pbuf_take+0x46>
 908:	68fb      	ldr	r3, [r7, #12]
 90a:	891b      	ldrh	r3, [r3, #8]
 90c:	88fa      	ldrh	r2, [r7, #6]
 90e:	429a      	cmp	r2, r3
 910:	d902      	bls.n	918 <pbuf_take+0x4c>
    return ERR_ARG;
 912:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 916:	e027      	b.n	968 <pbuf_take+0x9c>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 918:	68fb      	ldr	r3, [r7, #12]
 91a:	61fb      	str	r3, [r7, #28]
 91c:	e01f      	b.n	95e <pbuf_take+0x92>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
    buf_copy_len = total_copy_len;
 91e:	8b3b      	ldrh	r3, [r7, #24]
 920:	837b      	strh	r3, [r7, #26]
    if (buf_copy_len > p->len) {
 922:	69fb      	ldr	r3, [r7, #28]
 924:	895b      	ldrh	r3, [r3, #10]
 926:	8b7a      	ldrh	r2, [r7, #26]
 928:	429a      	cmp	r2, r3
 92a:	d902      	bls.n	932 <pbuf_take+0x66>
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
 92c:	69fb      	ldr	r3, [r7, #28]
 92e:	895b      	ldrh	r3, [r3, #10]
 930:	837b      	strh	r3, [r7, #26]
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 932:	69fb      	ldr	r3, [r7, #28]
 934:	6859      	ldr	r1, [r3, #4]
 936:	8afb      	ldrh	r3, [r7, #22]
 938:	68ba      	ldr	r2, [r7, #8]
 93a:	18d2      	adds	r2, r2, r3
 93c:	8b7b      	ldrh	r3, [r7, #26]
 93e:	4608      	mov	r0, r1
 940:	4611      	mov	r1, r2
 942:	461a      	mov	r2, r3
 944:	f7ff fffe 	bl	0 <memcpy>
			944: R_ARM_THM_CALL	memcpy
    total_copy_len -= buf_copy_len;
 948:	8b3a      	ldrh	r2, [r7, #24]
 94a:	8b7b      	ldrh	r3, [r7, #26]
 94c:	1ad3      	subs	r3, r2, r3
 94e:	833b      	strh	r3, [r7, #24]
    copied_total += buf_copy_len;
 950:	8afa      	ldrh	r2, [r7, #22]
 952:	8b7b      	ldrh	r3, [r7, #26]
 954:	18d3      	adds	r3, r2, r3
 956:	82fb      	strh	r3, [r7, #22]
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 958:	69fb      	ldr	r3, [r7, #28]
 95a:	681b      	ldr	r3, [r3, #0]
 95c:	61fb      	str	r3, [r7, #28]
 95e:	8b3b      	ldrh	r3, [r7, #24]
 960:	2b00      	cmp	r3, #0
 962:	d1dc      	bne.n	91e <pbuf_take+0x52>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
 964:	f04f 0300 	mov.w	r3, #0
 968:	b25b      	sxtb	r3, r3
}
 96a:	4618      	mov	r0, r3
 96c:	f107 0720 	add.w	r7, r7, #32
 970:	46bd      	mov	sp, r7
 972:	bd80      	pop	{r7, pc}

00000974 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 974:	b580      	push	{r7, lr}
 976:	b084      	sub	sp, #16
 978:	af00      	add	r7, sp, #0
 97a:	6078      	str	r0, [r7, #4]
 97c:	460b      	mov	r3, r1
 97e:	70fb      	strb	r3, [r7, #3]
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
 980:	687b      	ldr	r3, [r7, #4]
 982:	681b      	ldr	r3, [r3, #0]
 984:	2b00      	cmp	r3, #0
 986:	d101      	bne.n	98c <pbuf_coalesce+0x18>
    return p;
 988:	687b      	ldr	r3, [r7, #4]
 98a:	e018      	b.n	9be <pbuf_coalesce+0x4a>
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 98c:	687b      	ldr	r3, [r7, #4]
 98e:	891b      	ldrh	r3, [r3, #8]
 990:	78fa      	ldrb	r2, [r7, #3]
 992:	4610      	mov	r0, r2
 994:	4619      	mov	r1, r3
 996:	f04f 0200 	mov.w	r2, #0
 99a:	f7ff fffe 	bl	d0 <pbuf_alloc>
			99a: R_ARM_THM_CALL	pbuf_alloc
 99e:	60f8      	str	r0, [r7, #12]
  if (q == NULL) {
 9a0:	68fb      	ldr	r3, [r7, #12]
 9a2:	2b00      	cmp	r3, #0
 9a4:	d101      	bne.n	9aa <pbuf_coalesce+0x36>
    /* @todo: what do we do now? */
    return p;
 9a6:	687b      	ldr	r3, [r7, #4]
 9a8:	e009      	b.n	9be <pbuf_coalesce+0x4a>
  }
  err = pbuf_copy(q, p);
 9aa:	68f8      	ldr	r0, [r7, #12]
 9ac:	6879      	ldr	r1, [r7, #4]
 9ae:	f7ff fffe 	bl	6d4 <pbuf_copy>
			9ae: R_ARM_THM_CALL	pbuf_copy
 9b2:	4603      	mov	r3, r0
 9b4:	72fb      	strb	r3, [r7, #11]
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
  pbuf_free(p);
 9b6:	6878      	ldr	r0, [r7, #4]
 9b8:	f7ff fffe 	bl	4dc <pbuf_free>
			9b8: R_ARM_THM_CALL	pbuf_free
  return q;
 9bc:	68fb      	ldr	r3, [r7, #12]
}
 9be:	4618      	mov	r0, r3
 9c0:	f107 0710 	add.w	r7, r7, #16
 9c4:	46bd      	mov	sp, r7
 9c6:	bd80      	pop	{r7, pc}

000009c8 <pbuf_get_at>:
 * @param offset offset into p of the byte to return
 * @return byte at an offset into p OR ZERO IF 'offset' >= p->tot_len
 */
u8_t
pbuf_get_at(struct pbuf* p, u16_t offset)
{
 9c8:	b480      	push	{r7}
 9ca:	b085      	sub	sp, #20
 9cc:	af00      	add	r7, sp, #0
 9ce:	6078      	str	r0, [r7, #4]
 9d0:	460b      	mov	r3, r1
 9d2:	807b      	strh	r3, [r7, #2]
  u16_t copy_from = offset;
 9d4:	887b      	ldrh	r3, [r7, #2]
 9d6:	81fb      	strh	r3, [r7, #14]
  struct pbuf* q = p;
 9d8:	687b      	ldr	r3, [r7, #4]
 9da:	60bb      	str	r3, [r7, #8]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 9dc:	e007      	b.n	9ee <pbuf_get_at+0x26>
    copy_from -= q->len;
 9de:	68bb      	ldr	r3, [r7, #8]
 9e0:	895b      	ldrh	r3, [r3, #10]
 9e2:	89fa      	ldrh	r2, [r7, #14]
 9e4:	1ad3      	subs	r3, r2, r3
 9e6:	81fb      	strh	r3, [r7, #14]
    q = q->next;
 9e8:	68bb      	ldr	r3, [r7, #8]
 9ea:	681b      	ldr	r3, [r3, #0]
 9ec:	60bb      	str	r3, [r7, #8]
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 9ee:	68bb      	ldr	r3, [r7, #8]
 9f0:	2b00      	cmp	r3, #0
 9f2:	d004      	beq.n	9fe <pbuf_get_at+0x36>
 9f4:	68bb      	ldr	r3, [r7, #8]
 9f6:	895b      	ldrh	r3, [r3, #10]
 9f8:	89fa      	ldrh	r2, [r7, #14]
 9fa:	429a      	cmp	r2, r3
 9fc:	d2ef      	bcs.n	9de <pbuf_get_at+0x16>
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
 9fe:	68bb      	ldr	r3, [r7, #8]
 a00:	2b00      	cmp	r3, #0
 a02:	d00b      	beq.n	a1c <pbuf_get_at+0x54>
 a04:	68bb      	ldr	r3, [r7, #8]
 a06:	895b      	ldrh	r3, [r3, #10]
 a08:	89fa      	ldrh	r2, [r7, #14]
 a0a:	429a      	cmp	r2, r3
 a0c:	d206      	bcs.n	a1c <pbuf_get_at+0x54>
    return ((u8_t*)q->payload)[copy_from];
 a0e:	68bb      	ldr	r3, [r7, #8]
 a10:	685b      	ldr	r3, [r3, #4]
 a12:	461a      	mov	r2, r3
 a14:	89fb      	ldrh	r3, [r7, #14]
 a16:	18d3      	adds	r3, r2, r3
 a18:	781b      	ldrb	r3, [r3, #0]
 a1a:	e001      	b.n	a20 <pbuf_get_at+0x58>
  }
  return 0;
 a1c:	f04f 0300 	mov.w	r3, #0
}
 a20:	4618      	mov	r0, r3
 a22:	f107 0714 	add.w	r7, r7, #20
 a26:	46bd      	mov	sp, r7
 a28:	bc80      	pop	{r7}
 a2a:	4770      	bx	lr

00000a2c <pbuf_memcmp>:
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
 a2c:	b580      	push	{r7, lr}
 a2e:	b088      	sub	sp, #32
 a30:	af00      	add	r7, sp, #0
 a32:	60f8      	str	r0, [r7, #12]
 a34:	607a      	str	r2, [r7, #4]
 a36:	460a      	mov	r2, r1
 a38:	817a      	strh	r2, [r7, #10]
 a3a:	807b      	strh	r3, [r7, #2]
  u16_t start = offset;
 a3c:	897b      	ldrh	r3, [r7, #10]
 a3e:	83fb      	strh	r3, [r7, #30]
  struct pbuf* q = p;
 a40:	68fb      	ldr	r3, [r7, #12]
 a42:	61bb      	str	r3, [r7, #24]

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 a44:	e007      	b.n	a56 <pbuf_memcmp+0x2a>
    start -= q->len;
 a46:	69bb      	ldr	r3, [r7, #24]
 a48:	895b      	ldrh	r3, [r3, #10]
 a4a:	8bfa      	ldrh	r2, [r7, #30]
 a4c:	1ad3      	subs	r3, r2, r3
 a4e:	83fb      	strh	r3, [r7, #30]
    q = q->next;
 a50:	69bb      	ldr	r3, [r7, #24]
 a52:	681b      	ldr	r3, [r3, #0]
 a54:	61bb      	str	r3, [r7, #24]
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 a56:	69bb      	ldr	r3, [r7, #24]
 a58:	2b00      	cmp	r3, #0
 a5a:	d004      	beq.n	a66 <pbuf_memcmp+0x3a>
 a5c:	69bb      	ldr	r3, [r7, #24]
 a5e:	895b      	ldrh	r3, [r3, #10]
 a60:	8bfa      	ldrh	r2, [r7, #30]
 a62:	429a      	cmp	r2, r3
 a64:	d2ef      	bcs.n	a46 <pbuf_memcmp+0x1a>
    start -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
 a66:	69bb      	ldr	r3, [r7, #24]
 a68:	2b00      	cmp	r3, #0
 a6a:	d02b      	beq.n	ac4 <pbuf_memcmp+0x98>
 a6c:	69bb      	ldr	r3, [r7, #24]
 a6e:	895b      	ldrh	r3, [r3, #10]
 a70:	8bfa      	ldrh	r2, [r7, #30]
 a72:	429a      	cmp	r2, r3
 a74:	d226      	bcs.n	ac4 <pbuf_memcmp+0x98>
    u16_t i;
    for(i = 0; i < n; i++) {
 a76:	f04f 0300 	mov.w	r3, #0
 a7a:	82fb      	strh	r3, [r7, #22]
 a7c:	e01b      	b.n	ab6 <pbuf_memcmp+0x8a>
      u8_t a = pbuf_get_at(q, start + i);
 a7e:	8bfa      	ldrh	r2, [r7, #30]
 a80:	8afb      	ldrh	r3, [r7, #22]
 a82:	18d3      	adds	r3, r2, r3
 a84:	b29b      	uxth	r3, r3
 a86:	69b8      	ldr	r0, [r7, #24]
 a88:	4619      	mov	r1, r3
 a8a:	f7ff fffe 	bl	9c8 <pbuf_get_at>
			a8a: R_ARM_THM_CALL	pbuf_get_at
 a8e:	4603      	mov	r3, r0
 a90:	757b      	strb	r3, [r7, #21]
      u8_t b = ((u8_t*)s2)[i];
 a92:	687a      	ldr	r2, [r7, #4]
 a94:	8afb      	ldrh	r3, [r7, #22]
 a96:	18d3      	adds	r3, r2, r3
 a98:	781b      	ldrb	r3, [r3, #0]
 a9a:	753b      	strb	r3, [r7, #20]
      if (a != b) {
 a9c:	7d7a      	ldrb	r2, [r7, #21]
 a9e:	7d3b      	ldrb	r3, [r7, #20]
 aa0:	429a      	cmp	r2, r3
 aa2:	d004      	beq.n	aae <pbuf_memcmp+0x82>
        return i+1;
 aa4:	8afb      	ldrh	r3, [r7, #22]
 aa6:	f103 0301 	add.w	r3, r3, #1
 aaa:	b29b      	uxth	r3, r3
 aac:	e00c      	b.n	ac8 <pbuf_memcmp+0x9c>
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
 aae:	8afb      	ldrh	r3, [r7, #22]
 ab0:	f103 0301 	add.w	r3, r3, #1
 ab4:	82fb      	strh	r3, [r7, #22]
 ab6:	8afa      	ldrh	r2, [r7, #22]
 ab8:	887b      	ldrh	r3, [r7, #2]
 aba:	429a      	cmp	r2, r3
 abc:	d3df      	bcc.n	a7e <pbuf_memcmp+0x52>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
 abe:	f04f 0300 	mov.w	r3, #0
 ac2:	e001      	b.n	ac8 <pbuf_memcmp+0x9c>
  }
  return 0xffff;
 ac4:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 ac8:	4618      	mov	r0, r3
 aca:	f107 0720 	add.w	r7, r7, #32
 ace:	46bd      	mov	sp, r7
 ad0:	bd80      	pop	{r7, pc}
 ad2:	bf00      	nop

00000ad4 <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
 ad4:	b580      	push	{r7, lr}
 ad6:	b086      	sub	sp, #24
 ad8:	af00      	add	r7, sp, #0
 ada:	60f8      	str	r0, [r7, #12]
 adc:	60b9      	str	r1, [r7, #8]
 ade:	80fa      	strh	r2, [r7, #6]
 ae0:	80bb      	strh	r3, [r7, #4]
  u16_t i;
  u16_t max = p->tot_len - mem_len;
 ae2:	68fb      	ldr	r3, [r7, #12]
 ae4:	891a      	ldrh	r2, [r3, #8]
 ae6:	88fb      	ldrh	r3, [r7, #6]
 ae8:	1ad3      	subs	r3, r2, r3
 aea:	82bb      	strh	r3, [r7, #20]
  if (p->tot_len >= mem_len + start_offset) {
 aec:	68fb      	ldr	r3, [r7, #12]
 aee:	891b      	ldrh	r3, [r3, #8]
 af0:	461a      	mov	r2, r3
 af2:	88f9      	ldrh	r1, [r7, #6]
 af4:	88bb      	ldrh	r3, [r7, #4]
 af6:	18cb      	adds	r3, r1, r3
 af8:	429a      	cmp	r2, r3
 afa:	db18      	blt.n	b2e <pbuf_memfind+0x5a>
    for(i = start_offset; i <= max; ) {
 afc:	88bb      	ldrh	r3, [r7, #4]
 afe:	82fb      	strh	r3, [r7, #22]
 b00:	e011      	b.n	b26 <pbuf_memfind+0x52>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 b02:	8afa      	ldrh	r2, [r7, #22]
 b04:	88fb      	ldrh	r3, [r7, #6]
 b06:	68f8      	ldr	r0, [r7, #12]
 b08:	4611      	mov	r1, r2
 b0a:	68ba      	ldr	r2, [r7, #8]
 b0c:	f7ff fffe 	bl	a2c <pbuf_memcmp>
			b0c: R_ARM_THM_CALL	pbuf_memcmp
 b10:	4603      	mov	r3, r0
 b12:	827b      	strh	r3, [r7, #18]
      if (plus == 0) {
 b14:	8a7b      	ldrh	r3, [r7, #18]
 b16:	2b00      	cmp	r3, #0
 b18:	d101      	bne.n	b1e <pbuf_memfind+0x4a>
        return i;
 b1a:	8afb      	ldrh	r3, [r7, #22]
 b1c:	e009      	b.n	b32 <pbuf_memfind+0x5e>
      } else {
        i += plus;
 b1e:	8afa      	ldrh	r2, [r7, #22]
 b20:	8a7b      	ldrh	r3, [r7, #18]
 b22:	18d3      	adds	r3, r2, r3
 b24:	82fb      	strh	r3, [r7, #22]
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
 b26:	8afa      	ldrh	r2, [r7, #22]
 b28:	8abb      	ldrh	r3, [r7, #20]
 b2a:	429a      	cmp	r2, r3
 b2c:	d9e9      	bls.n	b02 <pbuf_memfind+0x2e>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
 b2e:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
 b32:	4618      	mov	r0, r3
 b34:	f107 0718 	add.w	r7, r7, #24
 b38:	46bd      	mov	sp, r7
 b3a:	bd80      	pop	{r7, pc}

00000b3c <pbuf_strstr>:
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
 b3c:	b580      	push	{r7, lr}
 b3e:	b084      	sub	sp, #16
 b40:	af00      	add	r7, sp, #0
 b42:	6078      	str	r0, [r7, #4]
 b44:	6039      	str	r1, [r7, #0]
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 b46:	683b      	ldr	r3, [r7, #0]
 b48:	2b00      	cmp	r3, #0
 b4a:	d009      	beq.n	b60 <pbuf_strstr+0x24>
 b4c:	683b      	ldr	r3, [r7, #0]
 b4e:	781b      	ldrb	r3, [r3, #0]
 b50:	2b00      	cmp	r3, #0
 b52:	d005      	beq.n	b60 <pbuf_strstr+0x24>
 b54:	687b      	ldr	r3, [r7, #4]
 b56:	891a      	ldrh	r2, [r3, #8]
 b58:	f64f 73ff 	movw	r3, #65535	; 0xffff
 b5c:	429a      	cmp	r2, r3
 b5e:	d102      	bne.n	b66 <pbuf_strstr+0x2a>
    return 0xFFFF;
 b60:	f64f 73ff 	movw	r3, #65535	; 0xffff
 b64:	e016      	b.n	b94 <pbuf_strstr+0x58>
  }
  substr_len = strlen(substr);
 b66:	6838      	ldr	r0, [r7, #0]
 b68:	f7ff fffe 	bl	0 <strlen>
			b68: R_ARM_THM_CALL	strlen
 b6c:	4603      	mov	r3, r0
 b6e:	60fb      	str	r3, [r7, #12]
  if (substr_len >= 0xFFFF) {
 b70:	68fa      	ldr	r2, [r7, #12]
 b72:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 b76:	429a      	cmp	r2, r3
 b78:	d902      	bls.n	b80 <pbuf_strstr+0x44>
    return 0xFFFF;
 b7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 b7e:	e009      	b.n	b94 <pbuf_strstr+0x58>
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 b80:	68fb      	ldr	r3, [r7, #12]
 b82:	b29b      	uxth	r3, r3
 b84:	6878      	ldr	r0, [r7, #4]
 b86:	6839      	ldr	r1, [r7, #0]
 b88:	461a      	mov	r2, r3
 b8a:	f04f 0300 	mov.w	r3, #0
 b8e:	f7ff fffe 	bl	ad4 <pbuf_memfind>
			b8e: R_ARM_THM_CALL	pbuf_memfind
 b92:	4603      	mov	r3, r0
}
 b94:	4618      	mov	r0, r3
 b96:	f107 0710 	add.w	r7, r7, #16
 b9a:	46bd      	mov	sp, r7
 b9c:	bd80      	pop	{r7, pc}
 b9e:	bf00      	nop

raw.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  45212 Jul 30 19:07 2021 raw.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000314  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000348  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  00000348  2**2
                  ALLOC
  3 .debug_abbrev 000001a9  00000000  00000000  00000348  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000830  00000000  00000000  000004f1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000573  00000000  00000000  00000d21  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 000085c4  00000000  00000000  00001294  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000001c0  00000000  00000000  00009858  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000081  00000000  00000000  00009a18  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000013c  00000000  00000000  00009a99  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00009bd5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000004a9  00000000  00000000  00009bf5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000a09e  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000a0c9  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000104  00000000  00000000  0000a0fc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 raw.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 raw_pcbs
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	000000c8 raw_input
00000000         *UND*	00000000 current_iphdr_dest
00000000         *UND*	00000000 current_iphdr_src
000000c8 g     F .text	00000030 raw_bind
000000f8 g     F .text	00000030 raw_connect
00000128 g     F .text	00000022 raw_recv
0000014c g     F .text	000000e2 raw_sendto
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 pbuf_chain
00000000         *UND*	00000000 ip_route
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 ip_output_if
00000230 g     F .text	00000026 raw_send
00000258 g     F .text	00000064 raw_remove
00000000         *UND*	00000000 memp_free
000002bc g     F .text	00000058 raw_new
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 memset



Disassembly of section .text:

00000000 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
   0:	b590      	push	{r4, r7, lr}
   2:	b089      	sub	sp, #36	; 0x24
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
   a:	f04f 0300 	mov.w	r3, #0
   e:	75fb      	strb	r3, [r7, #23]

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  10:	687b      	ldr	r3, [r7, #4]
  12:	685b      	ldr	r3, [r3, #4]
  14:	613b      	str	r3, [r7, #16]
  proto = IPH_PROTO(iphdr);
  16:	693b      	ldr	r3, [r7, #16]
  18:	7a5b      	ldrb	r3, [r3, #9]
  1a:	81fb      	strh	r3, [r7, #14]

  prev = NULL;
  1c:	f04f 0300 	mov.w	r3, #0
  20:	61bb      	str	r3, [r7, #24]
  pcb = raw_pcbs;
  22:	4b26      	ldr	r3, [pc, #152]	; (bc <raw_input+0xbc>)
  24:	681b      	ldr	r3, [r3, #0]
  26:	61fb      	str	r3, [r7, #28]
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  28:	e03c      	b.n	a4 <raw_input+0xa4>
    if ((pcb->protocol == proto) &&
  2a:	69fb      	ldr	r3, [r7, #28]
  2c:	7c1b      	ldrb	r3, [r3, #16]
  2e:	461a      	mov	r2, r3
  30:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
  34:	429a      	cmp	r2, r3
  36:	d130      	bne.n	9a <raw_input+0x9a>
        (ip_addr_isany(&pcb->local_ip) ||
  38:	69fb      	ldr	r3, [r7, #28]
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
  3a:	2b00      	cmp	r3, #0
  3c:	d009      	beq.n	52 <raw_input+0x52>
        (ip_addr_isany(&pcb->local_ip) ||
  3e:	69fb      	ldr	r3, [r7, #28]
  40:	681b      	ldr	r3, [r3, #0]
  42:	2b00      	cmp	r3, #0
  44:	d005      	beq.n	52 <raw_input+0x52>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
  46:	69fb      	ldr	r3, [r7, #28]
  48:	681a      	ldr	r2, [r3, #0]
  4a:	4b1d      	ldr	r3, [pc, #116]	; (c0 <raw_input+0xc0>)
  4c:	681b      	ldr	r3, [r3, #0]
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
  4e:	429a      	cmp	r2, r3
  50:	d123      	bne.n	9a <raw_input+0x9a>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
  52:	69fb      	ldr	r3, [r7, #28]
  54:	695b      	ldr	r3, [r3, #20]
  56:	2b00      	cmp	r3, #0
  58:	d01f      	beq.n	9a <raw_input+0x9a>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
  5a:	69fb      	ldr	r3, [r7, #28]
  5c:	695c      	ldr	r4, [r3, #20]
  5e:	69fb      	ldr	r3, [r7, #28]
  60:	699b      	ldr	r3, [r3, #24]
  62:	4618      	mov	r0, r3
  64:	69f9      	ldr	r1, [r7, #28]
  66:	687a      	ldr	r2, [r7, #4]
  68:	4b16      	ldr	r3, [pc, #88]	; (c4 <raw_input+0xc4>)
  6a:	47a0      	blx	r4
  6c:	4603      	mov	r3, r0
  6e:	2b00      	cmp	r3, #0
  70:	d013      	beq.n	9a <raw_input+0x9a>
            /* receive function ate the packet */
            p = NULL;
  72:	f04f 0300 	mov.w	r3, #0
  76:	607b      	str	r3, [r7, #4]
            eaten = 1;
  78:	f04f 0301 	mov.w	r3, #1
  7c:	75fb      	strb	r3, [r7, #23]
            if (prev != NULL) {
  7e:	69bb      	ldr	r3, [r7, #24]
  80:	2b00      	cmp	r3, #0
  82:	d00a      	beq.n	9a <raw_input+0x9a>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
  84:	69fb      	ldr	r3, [r7, #28]
  86:	68da      	ldr	r2, [r3, #12]
  88:	69bb      	ldr	r3, [r7, #24]
  8a:	60da      	str	r2, [r3, #12]
              pcb->next = raw_pcbs;
  8c:	4b0b      	ldr	r3, [pc, #44]	; (bc <raw_input+0xbc>)
  8e:	681a      	ldr	r2, [r3, #0]
  90:	69fb      	ldr	r3, [r7, #28]
  92:	60da      	str	r2, [r3, #12]
              raw_pcbs = pcb;
  94:	4b09      	ldr	r3, [pc, #36]	; (bc <raw_input+0xbc>)
  96:	69fa      	ldr	r2, [r7, #28]
  98:	601a      	str	r2, [r3, #0]
        }
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
  9a:	69fb      	ldr	r3, [r7, #28]
  9c:	61bb      	str	r3, [r7, #24]
    pcb = pcb->next;
  9e:	69fb      	ldr	r3, [r7, #28]
  a0:	68db      	ldr	r3, [r3, #12]
  a2:	61fb      	str	r3, [r7, #28]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  a4:	7dfb      	ldrb	r3, [r7, #23]
  a6:	2b00      	cmp	r3, #0
  a8:	d102      	bne.n	b0 <raw_input+0xb0>
  aa:	69fb      	ldr	r3, [r7, #28]
  ac:	2b00      	cmp	r3, #0
  ae:	d1bc      	bne.n	2a <raw_input+0x2a>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  b0:	7dfb      	ldrb	r3, [r7, #23]
}
  b2:	4618      	mov	r0, r3
  b4:	f107 0724 	add.w	r7, r7, #36	; 0x24
  b8:	46bd      	mov	sp, r7
  ba:	bd90      	pop	{r4, r7, pc}
	...
			bc: R_ARM_ABS32	.bss
			c0: R_ARM_ABS32	current_iphdr_dest
			c4: R_ARM_ABS32	current_iphdr_src

000000c8 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  c8:	b480      	push	{r7}
  ca:	b083      	sub	sp, #12
  cc:	af00      	add	r7, sp, #0
  ce:	6078      	str	r0, [r7, #4]
  d0:	6039      	str	r1, [r7, #0]
  ip_addr_set(&pcb->local_ip, ipaddr);
  d2:	683b      	ldr	r3, [r7, #0]
  d4:	2b00      	cmp	r3, #0
  d6:	d002      	beq.n	de <raw_bind+0x16>
  d8:	683b      	ldr	r3, [r7, #0]
  da:	681b      	ldr	r3, [r3, #0]
  dc:	e001      	b.n	e2 <raw_bind+0x1a>
  de:	f04f 0300 	mov.w	r3, #0
  e2:	687a      	ldr	r2, [r7, #4]
  e4:	6013      	str	r3, [r2, #0]
  return ERR_OK;
  e6:	f04f 0300 	mov.w	r3, #0
  ea:	b25b      	sxtb	r3, r3
}
  ec:	4618      	mov	r0, r3
  ee:	f107 070c 	add.w	r7, r7, #12
  f2:	46bd      	mov	sp, r7
  f4:	bc80      	pop	{r7}
  f6:	4770      	bx	lr

000000f8 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  f8:	b480      	push	{r7}
  fa:	b083      	sub	sp, #12
  fc:	af00      	add	r7, sp, #0
  fe:	6078      	str	r0, [r7, #4]
 100:	6039      	str	r1, [r7, #0]
  ip_addr_set(&pcb->remote_ip, ipaddr);
 102:	683b      	ldr	r3, [r7, #0]
 104:	2b00      	cmp	r3, #0
 106:	d002      	beq.n	10e <raw_connect+0x16>
 108:	683b      	ldr	r3, [r7, #0]
 10a:	681b      	ldr	r3, [r3, #0]
 10c:	e001      	b.n	112 <raw_connect+0x1a>
 10e:	f04f 0300 	mov.w	r3, #0
 112:	687a      	ldr	r2, [r7, #4]
 114:	6053      	str	r3, [r2, #4]
  return ERR_OK;
 116:	f04f 0300 	mov.w	r3, #0
 11a:	b25b      	sxtb	r3, r3
}
 11c:	4618      	mov	r0, r3
 11e:	f107 070c 	add.w	r7, r7, #12
 122:	46bd      	mov	sp, r7
 124:	bc80      	pop	{r7}
 126:	4770      	bx	lr

00000128 <raw_recv>:
 * @return non-zero if the packet was free()d, zero if the packet remains
 * available for others.
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
 128:	b480      	push	{r7}
 12a:	b085      	sub	sp, #20
 12c:	af00      	add	r7, sp, #0
 12e:	60f8      	str	r0, [r7, #12]
 130:	60b9      	str	r1, [r7, #8]
 132:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
 134:	68fb      	ldr	r3, [r7, #12]
 136:	68ba      	ldr	r2, [r7, #8]
 138:	615a      	str	r2, [r3, #20]
  pcb->recv_arg = recv_arg;
 13a:	68fb      	ldr	r3, [r7, #12]
 13c:	687a      	ldr	r2, [r7, #4]
 13e:	619a      	str	r2, [r3, #24]
}
 140:	f107 0714 	add.w	r7, r7, #20
 144:	46bd      	mov	sp, r7
 146:	bc80      	pop	{r7}
 148:	4770      	bx	lr
 14a:	bf00      	nop

0000014c <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
 14c:	b580      	push	{r7, lr}
 14e:	b08c      	sub	sp, #48	; 0x30
 150:	af04      	add	r7, sp, #16
 152:	60f8      	str	r0, [r7, #12]
 154:	60b9      	str	r1, [r7, #8]
 156:	607a      	str	r2, [r7, #4]
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
 158:	68b8      	ldr	r0, [r7, #8]
 15a:	f04f 0114 	mov.w	r1, #20
 15e:	f7ff fffe 	bl	0 <pbuf_header>
			15e: R_ARM_THM_CALL	pbuf_header
 162:	4603      	mov	r3, r0
 164:	2b00      	cmp	r3, #0
 166:	d017      	beq.n	198 <raw_sendto+0x4c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 168:	f04f 0001 	mov.w	r0, #1
 16c:	f04f 0100 	mov.w	r1, #0
 170:	f04f 0200 	mov.w	r2, #0
 174:	f7ff fffe 	bl	0 <pbuf_alloc>
			174: R_ARM_THM_CALL	pbuf_alloc
 178:	61b8      	str	r0, [r7, #24]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 17a:	69bb      	ldr	r3, [r7, #24]
 17c:	2b00      	cmp	r3, #0
 17e:	d102      	bne.n	186 <raw_sendto+0x3a>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
 180:	f04f 03ff 	mov.w	r3, #255	; 0xff
 184:	e04d      	b.n	222 <raw_sendto+0xd6>
    }
    if (p->tot_len != 0) {
 186:	68bb      	ldr	r3, [r7, #8]
 188:	891b      	ldrh	r3, [r3, #8]
 18a:	2b00      	cmp	r3, #0
 18c:	d011      	beq.n	1b2 <raw_sendto+0x66>
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
 18e:	69b8      	ldr	r0, [r7, #24]
 190:	68b9      	ldr	r1, [r7, #8]
 192:	f7ff fffe 	bl	0 <pbuf_chain>
			192: R_ARM_THM_CALL	pbuf_chain
 196:	e00c      	b.n	1b2 <raw_sendto+0x66>
    }
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
 198:	68bb      	ldr	r3, [r7, #8]
 19a:	61bb      	str	r3, [r7, #24]
    if(pbuf_header(q, -IP_HLEN)) {
 19c:	69b8      	ldr	r0, [r7, #24]
 19e:	f06f 0113 	mvn.w	r1, #19
 1a2:	f7ff fffe 	bl	0 <pbuf_header>
			1a2: R_ARM_THM_CALL	pbuf_header
 1a6:	4603      	mov	r3, r0
 1a8:	2b00      	cmp	r3, #0
 1aa:	d002      	beq.n	1b2 <raw_sendto+0x66>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
 1ac:	f04f 03ff 	mov.w	r3, #255	; 0xff
 1b0:	e037      	b.n	222 <raw_sendto+0xd6>
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
 1b2:	6878      	ldr	r0, [r7, #4]
 1b4:	f7ff fffe 	bl	0 <ip_route>
			1b4: R_ARM_THM_CALL	ip_route
 1b8:	6178      	str	r0, [r7, #20]
 1ba:	697b      	ldr	r3, [r7, #20]
 1bc:	2b00      	cmp	r3, #0
 1be:	d109      	bne.n	1d4 <raw_sendto+0x88>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
 1c0:	69ba      	ldr	r2, [r7, #24]
 1c2:	68bb      	ldr	r3, [r7, #8]
 1c4:	429a      	cmp	r2, r3
 1c6:	d002      	beq.n	1ce <raw_sendto+0x82>
      pbuf_free(q);
 1c8:	69b8      	ldr	r0, [r7, #24]
 1ca:	f7ff fffe 	bl	0 <pbuf_free>
			1ca: R_ARM_THM_CALL	pbuf_free
    }
    return ERR_RTE;
 1ce:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 1d2:	e026      	b.n	222 <raw_sendto+0xd6>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
 1d4:	68fb      	ldr	r3, [r7, #12]
 1d6:	2b00      	cmp	r3, #0
 1d8:	d003      	beq.n	1e2 <raw_sendto+0x96>
 1da:	68fb      	ldr	r3, [r7, #12]
 1dc:	681b      	ldr	r3, [r3, #0]
 1de:	2b00      	cmp	r3, #0
 1e0:	d104      	bne.n	1ec <raw_sendto+0xa0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 1e2:	697b      	ldr	r3, [r7, #20]
 1e4:	f103 0304 	add.w	r3, r3, #4
 1e8:	61fb      	str	r3, [r7, #28]
 1ea:	e001      	b.n	1f0 <raw_sendto+0xa4>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 1ec:	68fb      	ldr	r3, [r7, #12]
 1ee:	61fb      	str	r3, [r7, #28]
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 1f0:	68fb      	ldr	r3, [r7, #12]
 1f2:	7a9b      	ldrb	r3, [r3, #10]
 1f4:	68fa      	ldr	r2, [r7, #12]
 1f6:	7a51      	ldrb	r1, [r2, #9]
 1f8:	68fa      	ldr	r2, [r7, #12]
 1fa:	7c12      	ldrb	r2, [r2, #16]
 1fc:	9100      	str	r1, [sp, #0]
 1fe:	9201      	str	r2, [sp, #4]
 200:	697a      	ldr	r2, [r7, #20]
 202:	9202      	str	r2, [sp, #8]
 204:	69b8      	ldr	r0, [r7, #24]
 206:	69f9      	ldr	r1, [r7, #28]
 208:	687a      	ldr	r2, [r7, #4]
 20a:	f7ff fffe 	bl	0 <ip_output_if>
			20a: R_ARM_THM_CALL	ip_output_if
 20e:	4603      	mov	r3, r0
 210:	74fb      	strb	r3, [r7, #19]
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* did we chain a header earlier? */
  if (q != p) {
 212:	69ba      	ldr	r2, [r7, #24]
 214:	68bb      	ldr	r3, [r7, #8]
 216:	429a      	cmp	r2, r3
 218:	d002      	beq.n	220 <raw_sendto+0xd4>
    /* free the header */
    pbuf_free(q);
 21a:	69b8      	ldr	r0, [r7, #24]
 21c:	f7ff fffe 	bl	0 <pbuf_free>
			21c: R_ARM_THM_CALL	pbuf_free
  }
  return err;
 220:	7cfb      	ldrb	r3, [r7, #19]
 222:	b25b      	sxtb	r3, r3
}
 224:	4618      	mov	r0, r3
 226:	f107 0720 	add.w	r7, r7, #32
 22a:	46bd      	mov	sp, r7
 22c:	bd80      	pop	{r7, pc}
 22e:	bf00      	nop

00000230 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
 230:	b580      	push	{r7, lr}
 232:	b082      	sub	sp, #8
 234:	af00      	add	r7, sp, #0
 236:	6078      	str	r0, [r7, #4]
 238:	6039      	str	r1, [r7, #0]
  return raw_sendto(pcb, p, &pcb->remote_ip);
 23a:	687b      	ldr	r3, [r7, #4]
 23c:	f103 0304 	add.w	r3, r3, #4
 240:	6878      	ldr	r0, [r7, #4]
 242:	6839      	ldr	r1, [r7, #0]
 244:	461a      	mov	r2, r3
 246:	f7ff fffe 	bl	14c <raw_sendto>
			246: R_ARM_THM_CALL	raw_sendto
 24a:	4603      	mov	r3, r0
}
 24c:	4618      	mov	r0, r3
 24e:	f107 0708 	add.w	r7, r7, #8
 252:	46bd      	mov	sp, r7
 254:	bd80      	pop	{r7, pc}
 256:	bf00      	nop

00000258 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 258:	b580      	push	{r7, lr}
 25a:	b084      	sub	sp, #16
 25c:	af00      	add	r7, sp, #0
 25e:	6078      	str	r0, [r7, #4]
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 260:	4b15      	ldr	r3, [pc, #84]	; (2b8 <raw_remove+0x60>)
 262:	681a      	ldr	r2, [r3, #0]
 264:	687b      	ldr	r3, [r7, #4]
 266:	429a      	cmp	r2, r3
 268:	d105      	bne.n	276 <raw_remove+0x1e>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 26a:	4b13      	ldr	r3, [pc, #76]	; (2b8 <raw_remove+0x60>)
 26c:	681b      	ldr	r3, [r3, #0]
 26e:	68da      	ldr	r2, [r3, #12]
 270:	4b11      	ldr	r3, [pc, #68]	; (2b8 <raw_remove+0x60>)
 272:	601a      	str	r2, [r3, #0]
 274:	e016      	b.n	2a4 <raw_remove+0x4c>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 276:	4b10      	ldr	r3, [pc, #64]	; (2b8 <raw_remove+0x60>)
 278:	681b      	ldr	r3, [r3, #0]
 27a:	60fb      	str	r3, [r7, #12]
 27c:	e00f      	b.n	29e <raw_remove+0x46>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 27e:	68fb      	ldr	r3, [r7, #12]
 280:	68db      	ldr	r3, [r3, #12]
 282:	2b00      	cmp	r3, #0
 284:	d008      	beq.n	298 <raw_remove+0x40>
 286:	68fb      	ldr	r3, [r7, #12]
 288:	68da      	ldr	r2, [r3, #12]
 28a:	687b      	ldr	r3, [r7, #4]
 28c:	429a      	cmp	r2, r3
 28e:	d103      	bne.n	298 <raw_remove+0x40>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 290:	687b      	ldr	r3, [r7, #4]
 292:	68da      	ldr	r2, [r3, #12]
 294:	68fb      	ldr	r3, [r7, #12]
 296:	60da      	str	r2, [r3, #12]
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 298:	68fb      	ldr	r3, [r7, #12]
 29a:	68db      	ldr	r3, [r3, #12]
 29c:	60fb      	str	r3, [r7, #12]
 29e:	68fb      	ldr	r3, [r7, #12]
 2a0:	2b00      	cmp	r3, #0
 2a2:	d1ec      	bne.n	27e <raw_remove+0x26>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 2a4:	f04f 0000 	mov.w	r0, #0
 2a8:	6879      	ldr	r1, [r7, #4]
 2aa:	f7ff fffe 	bl	0 <memp_free>
			2aa: R_ARM_THM_CALL	memp_free
}
 2ae:	f107 0710 	add.w	r7, r7, #16
 2b2:	46bd      	mov	sp, r7
 2b4:	bd80      	pop	{r7, pc}
 2b6:	bf00      	nop
 2b8:	00000000 	.word	0x00000000
			2b8: R_ARM_ABS32	.bss

000002bc <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
 2bc:	b580      	push	{r7, lr}
 2be:	b084      	sub	sp, #16
 2c0:	af00      	add	r7, sp, #0
 2c2:	4603      	mov	r3, r0
 2c4:	71fb      	strb	r3, [r7, #7]
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 2c6:	f04f 0000 	mov.w	r0, #0
 2ca:	f7ff fffe 	bl	0 <memp_malloc>
			2ca: R_ARM_THM_CALL	memp_malloc
 2ce:	4603      	mov	r3, r0
 2d0:	60fb      	str	r3, [r7, #12]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 2d2:	68fb      	ldr	r3, [r7, #12]
 2d4:	2b00      	cmp	r3, #0
 2d6:	d014      	beq.n	302 <raw_new+0x46>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 2d8:	68f8      	ldr	r0, [r7, #12]
 2da:	f04f 0100 	mov.w	r1, #0
 2de:	f04f 021c 	mov.w	r2, #28
 2e2:	f7ff fffe 	bl	0 <memset>
			2e2: R_ARM_THM_CALL	memset
    pcb->protocol = proto;
 2e6:	68fb      	ldr	r3, [r7, #12]
 2e8:	79fa      	ldrb	r2, [r7, #7]
 2ea:	741a      	strb	r2, [r3, #16]
    pcb->ttl = RAW_TTL;
 2ec:	68fb      	ldr	r3, [r7, #12]
 2ee:	f04f 02ff 	mov.w	r2, #255	; 0xff
 2f2:	729a      	strb	r2, [r3, #10]
    pcb->next = raw_pcbs;
 2f4:	4b06      	ldr	r3, [pc, #24]	; (310 <raw_new+0x54>)
 2f6:	681a      	ldr	r2, [r3, #0]
 2f8:	68fb      	ldr	r3, [r7, #12]
 2fa:	60da      	str	r2, [r3, #12]
    raw_pcbs = pcb;
 2fc:	4b04      	ldr	r3, [pc, #16]	; (310 <raw_new+0x54>)
 2fe:	68fa      	ldr	r2, [r7, #12]
 300:	601a      	str	r2, [r3, #0]
  }
  return pcb;
 302:	68fb      	ldr	r3, [r7, #12]
}
 304:	4618      	mov	r0, r3
 306:	f107 0710 	add.w	r7, r7, #16
 30a:	46bd      	mov	sp, r7
 30c:	bd80      	pop	{r7, pc}
 30e:	bf00      	nop
 310:	00000000 	.word	0x00000000
			310: R_ARM_ABS32	.bss

stats.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  19984 Jul 30 19:07 2021 stats.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 0000002a  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000057  00000000  00000000  0000005e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000018d  00000000  00000000  000000b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0000461b  00000000  00000000  00000242  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubtypes 00000012  00000000  00000000  0000485d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000b4  00000000  00000000  0000486f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002b  00000000  00000000  00004923  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  0000494e  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 stats.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes



sys.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  35932 Jul 30 19:07 2021 sys.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000048  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000007c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000007c  2**0
                  ALLOC
  3 .debug_abbrev 000000a5  00000000  00000000  0000007c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000117  00000000  00000000  00000121  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000003a7  00000000  00000000  00000238  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00007c09  00000000  00000000  000005df  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000038  00000000  00000000  000081e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000021  00000000  00000000  00008220  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000063  00000000  00000000  00008241  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  000082a4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    0000011e  00000000  00000000  000082c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  000083e2  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000840d  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000030  00000000  00000000  00008440  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 sys.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000046 sys_msleep
00000000         *UND*	00000000 sys_sem_new
00000000         *UND*	00000000 sys_arch_sem_wait
00000000         *UND*	00000000 sys_sem_free



Disassembly of section .text:

00000000 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
   0:	b580      	push	{r7, lr}
   2:	b086      	sub	sp, #24
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
  if (ms > 0) {
   8:	687b      	ldr	r3, [r7, #4]
   a:	2b00      	cmp	r3, #0
   c:	d017      	beq.n	3e <sys_msleep+0x3e>
    sys_sem_t delaysem;
    err_t err = sys_sem_new(&delaysem, 0);
   e:	f107 030c 	add.w	r3, r7, #12
  12:	4618      	mov	r0, r3
  14:	f04f 0100 	mov.w	r1, #0
  18:	f7ff fffe 	bl	0 <sys_sem_new>
			18: R_ARM_THM_CALL	sys_sem_new
  1c:	4603      	mov	r3, r0
  1e:	75fb      	strb	r3, [r7, #23]
    if (err == ERR_OK) {
  20:	f997 3017 	ldrsb.w	r3, [r7, #23]
  24:	2b00      	cmp	r3, #0
  26:	d10a      	bne.n	3e <sys_msleep+0x3e>
      sys_arch_sem_wait(&delaysem, ms);
  28:	f107 030c 	add.w	r3, r7, #12
  2c:	4618      	mov	r0, r3
  2e:	6879      	ldr	r1, [r7, #4]
  30:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			30: R_ARM_THM_CALL	sys_arch_sem_wait
      sys_sem_free(&delaysem);
  34:	f107 030c 	add.w	r3, r7, #12
  38:	4618      	mov	r0, r3
  3a:	f7ff fffe 	bl	0 <sys_sem_free>
			3a: R_ARM_THM_CALL	sys_sem_free
    }
  }
}
  3e:	f107 0718 	add.w	r7, r7, #24
  42:	46bd      	mov	sp, r7
  44:	bd80      	pop	{r7, pc}
  46:	bf00      	nop

tcp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  75200 Jul 30 19:07 2021 tcp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001618  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000008  00000000  00000000  0000164c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  00001654  2**0
                  ALLOC
  3 .debug_abbrev 00000291  00000000  00000000  00001654  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000165d  00000000  00000000  000018e5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000923  00000000  00000000  00002f42  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000ac08  00000000  00000000  00003865  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       000000cc  00000000  00000000  0000e470  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  8 .debug_loc    000007e8  00000000  00000000  0000e53c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000002fa  00000000  00000000  0000ed24  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 000001bd  00000000  00000000  0000f01e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  0000f1db  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  0000f1fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000009fd  00000000  00000000  0000f213  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .comment      0000002b  00000000  00000000  0000fc10  2**0
                  CONTENTS, READONLY
 15 .ARM.attributes 00000031  00000000  00000000  0000fc3b  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00000474  00000000  00000000  0000fc6c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 tcp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .rodata	00000000 .rodata
00000000 l     O .data	00000002 tcp_port
00000000 l       .bss	00000000 tcp_timer
00000001 l       .bss	00000000 tcp_timer_ctr
0000003c l     F .text	0000027c tcp_close_shutdown
00000794 l     F .text	000000a4 tcp_new_port
00000568 l     F .text	00000020 tcp_accept_null
0000115c l     F .text	00000088 tcp_kill_prio
000011e4 l     F .text	00000064 tcp_kill_timewait
00000004 l     O .data	00000004 iss.5120
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000078 g     O .rodata	0000002c tcp_state_str
00000004       O *COM*	00000004 tcp_ticks
000000a4 g     O .rodata	0000000d tcp_backoff
000000b4 g     O .rodata	00000007 tcp_persist_backoff
00000004       O *COM*	00000004 tcp_bound_pcbs
00000004       O *COM*	00000004 tcp_listen_pcbs
00000004       O *COM*	00000004 tcp_active_pcbs
00000004       O *COM*	00000004 tcp_tw_pcbs
000000bc g     O .rodata	00000010 tcp_pcb_lists
00000004       O *COM*	00000004 tcp_tmp_pcb
00000001       O *COM*	00000001 tcp_active_pcbs_changed
00000000 g     F .text	0000000a tcp_init
0000000c g     F .text	00000030 tcp_tmr
00000ec0 g     F .text	000000ac tcp_fasttmr
00000a10 g     F .text	000004b0 tcp_slowtmr
00000000         *UND*	00000000 tcp_rst
0000144c g     F .text	0000008a tcp_pcb_purge
00000000         *UND*	00000000 tcp_timer_needed
00000000         *UND*	00000000 memp_free
000014d8 g     F .text	000000b0 tcp_pcb_remove
00000000         *UND*	00000000 tcp_send_fin
00000000         *UND*	00000000 tcp_output
000002b8 g     F .text	00000034 tcp_close
000002ec g     F .text	0000009c tcp_shutdown
00000000         *UND*	00000000 pbuf_free
00000388 g     F .text	000000d8 tcp_abandon
00001054 g     F .text	00000028 tcp_segs_free
00000460 g     F .text	0000001a tcp_abort
0000047c g     F .text	000000ec tcp_bind
00000588 g     F .text	00000124 tcp_listen_with_backlog
00000000         *UND*	00000000 memp_malloc
000006ac g     F .text	00000086 tcp_update_rcv_ann_wnd
00000734 g     F .text	0000005e tcp_recved
00000838 g     F .text	000001d8 tcp_connect
00000000         *UND*	00000000 ip_route
00001588 g     F .text	00000028 tcp_next_iss
000015b0 g     F .text	00000044 tcp_eff_send_mss
00000000         *UND*	00000000 tcp_enqueue_flags
00000000         *UND*	00000000 tcp_zero_window_probe
00000000         *UND*	00000000 tcp_rexmit_rto
00000000         *UND*	00000000 tcp_keepalive
00000f6c g     F .text	000000e8 tcp_process_refused_data
00001110 g     F .text	0000004a tcp_recv_null
0000107c g     F .text	00000032 tcp_seg_free
000010b0 g     F .text	0000001c tcp_setprio
000010cc g     F .text	00000042 tcp_seg_copy
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 pbuf_ref
00001248 g     F .text	0000013c tcp_alloc
00000000         *UND*	00000000 memset
00001384 g     F .text	00000012 tcp_new
00001398 g     F .text	0000001a tcp_arg
000013b4 g     F .text	0000001c tcp_recv
000013d0 g     F .text	0000001a tcp_sent
000013ec g     F .text	0000001c tcp_err
00001408 g     F .text	0000001a tcp_accept
00001424 g     F .text	00000028 tcp_poll
000015f4 g     F .text	00000024 tcp_debug_state_str



Disassembly of section .text:

00000000 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
       0:	b480      	push	{r7}
       2:	af00      	add	r7, sp, #0
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
       4:	46bd      	mov	sp, r7
       6:	bc80      	pop	{r7}
       8:	4770      	bx	lr
       a:	bf00      	nop

0000000c <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
       c:	b580      	push	{r7, lr}
       e:	af00      	add	r7, sp, #0
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
      10:	f7ff fffe 	bl	ec0 <tcp_fasttmr>
			10: R_ARM_THM_CALL	tcp_fasttmr

  if (++tcp_timer & 1) {
      14:	4b08      	ldr	r3, [pc, #32]	; (38 <tcp_tmr+0x2c>)
      16:	781b      	ldrb	r3, [r3, #0]
      18:	f103 0301 	add.w	r3, r3, #1
      1c:	b2da      	uxtb	r2, r3
      1e:	4b06      	ldr	r3, [pc, #24]	; (38 <tcp_tmr+0x2c>)
      20:	701a      	strb	r2, [r3, #0]
      22:	4b05      	ldr	r3, [pc, #20]	; (38 <tcp_tmr+0x2c>)
      24:	781b      	ldrb	r3, [r3, #0]
      26:	f003 0301 	and.w	r3, r3, #1
      2a:	b2db      	uxtb	r3, r3
      2c:	2b00      	cmp	r3, #0
      2e:	d001      	beq.n	34 <tcp_tmr+0x28>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
      30:	f7ff fffe 	bl	a10 <tcp_slowtmr>
			30: R_ARM_THM_CALL	tcp_slowtmr
  }
}
      34:	bd80      	pop	{r7, pc}
      36:	bf00      	nop
      38:	00000000 	.word	0x00000000
			38: R_ARM_ABS32	.bss

0000003c <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
      3c:	b5b0      	push	{r4, r5, r7, lr}
      3e:	b086      	sub	sp, #24
      40:	af02      	add	r7, sp, #8
      42:	6078      	str	r0, [r7, #4]
      44:	460b      	mov	r3, r1
      46:	70fb      	strb	r3, [r7, #3]
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
      48:	78fb      	ldrb	r3, [r7, #3]
      4a:	2b00      	cmp	r3, #0
      4c:	d06b      	beq.n	126 <tcp_close_shutdown+0xea>
      4e:	687b      	ldr	r3, [r7, #4]
      50:	7e1b      	ldrb	r3, [r3, #24]
      52:	2b04      	cmp	r3, #4
      54:	d003      	beq.n	5e <tcp_close_shutdown+0x22>
      56:	687b      	ldr	r3, [r7, #4]
      58:	7e1b      	ldrb	r3, [r3, #24]
      5a:	2b07      	cmp	r3, #7
      5c:	d163      	bne.n	126 <tcp_close_shutdown+0xea>
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
      5e:	687b      	ldr	r3, [r7, #4]
      60:	6f9b      	ldr	r3, [r3, #120]	; 0x78
      62:	2b00      	cmp	r3, #0
      64:	d105      	bne.n	72 <tcp_close_shutdown+0x36>
      66:	687b      	ldr	r3, [r7, #4]
      68:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
      6a:	f241 7370 	movw	r3, #6000	; 0x1770
      6e:	429a      	cmp	r2, r3
      70:	d059      	beq.n	126 <tcp_close_shutdown+0xea>
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
      72:	687b      	ldr	r3, [r7, #4]
      74:	6d18      	ldr	r0, [r3, #80]	; 0x50
      76:	687b      	ldr	r3, [r7, #4]
      78:	6a99      	ldr	r1, [r3, #40]	; 0x28
      7a:	687a      	ldr	r2, [r7, #4]
      7c:	687b      	ldr	r3, [r7, #4]
      7e:	f103 0304 	add.w	r3, r3, #4
        pcb->local_port, pcb->remote_port);
      82:	687c      	ldr	r4, [r7, #4]
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
      84:	8b65      	ldrh	r5, [r4, #26]
        pcb->local_port, pcb->remote_port);
      86:	687c      	ldr	r4, [r7, #4]
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
      88:	8ba4      	ldrh	r4, [r4, #28]
      8a:	9500      	str	r5, [sp, #0]
      8c:	9401      	str	r4, [sp, #4]
      8e:	f7ff fffe 	bl	0 <tcp_rst>
			8e: R_ARM_THM_CALL	tcp_rst
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      92:	6878      	ldr	r0, [r7, #4]
      94:	f7ff fffe 	bl	144c <tcp_pcb_purge>
			94: R_ARM_THM_CALL	tcp_pcb_purge
      TCP_RMV_ACTIVE(pcb);
      98:	4b81      	ldr	r3, [pc, #516]	; (2a0 <tcp_close_shutdown+0x264>)
      9a:	681a      	ldr	r2, [r3, #0]
      9c:	687b      	ldr	r3, [r7, #4]
      9e:	429a      	cmp	r2, r3
      a0:	d105      	bne.n	ae <tcp_close_shutdown+0x72>
      a2:	4b7f      	ldr	r3, [pc, #508]	; (2a0 <tcp_close_shutdown+0x264>)
      a4:	681b      	ldr	r3, [r3, #0]
      a6:	68da      	ldr	r2, [r3, #12]
      a8:	4b7d      	ldr	r3, [pc, #500]	; (2a0 <tcp_close_shutdown+0x264>)
      aa:	601a      	str	r2, [r3, #0]
      ac:	e019      	b.n	e2 <tcp_close_shutdown+0xa6>
      ae:	4b7c      	ldr	r3, [pc, #496]	; (2a0 <tcp_close_shutdown+0x264>)
      b0:	681a      	ldr	r2, [r3, #0]
      b2:	4b7c      	ldr	r3, [pc, #496]	; (2a4 <tcp_close_shutdown+0x268>)
      b4:	601a      	str	r2, [r3, #0]
      b6:	e010      	b.n	da <tcp_close_shutdown+0x9e>
      b8:	4b7a      	ldr	r3, [pc, #488]	; (2a4 <tcp_close_shutdown+0x268>)
      ba:	681b      	ldr	r3, [r3, #0]
      bc:	68da      	ldr	r2, [r3, #12]
      be:	687b      	ldr	r3, [r7, #4]
      c0:	429a      	cmp	r2, r3
      c2:	d105      	bne.n	d0 <tcp_close_shutdown+0x94>
      c4:	4b77      	ldr	r3, [pc, #476]	; (2a4 <tcp_close_shutdown+0x268>)
      c6:	681b      	ldr	r3, [r3, #0]
      c8:	687a      	ldr	r2, [r7, #4]
      ca:	68d2      	ldr	r2, [r2, #12]
      cc:	60da      	str	r2, [r3, #12]
      ce:	e008      	b.n	e2 <tcp_close_shutdown+0xa6>
      d0:	4b74      	ldr	r3, [pc, #464]	; (2a4 <tcp_close_shutdown+0x268>)
      d2:	681b      	ldr	r3, [r3, #0]
      d4:	68da      	ldr	r2, [r3, #12]
      d6:	4b73      	ldr	r3, [pc, #460]	; (2a4 <tcp_close_shutdown+0x268>)
      d8:	601a      	str	r2, [r3, #0]
      da:	4b72      	ldr	r3, [pc, #456]	; (2a4 <tcp_close_shutdown+0x268>)
      dc:	681b      	ldr	r3, [r3, #0]
      de:	2b00      	cmp	r3, #0
      e0:	d1ea      	bne.n	b8 <tcp_close_shutdown+0x7c>
      e2:	687b      	ldr	r3, [r7, #4]
      e4:	f04f 0200 	mov.w	r2, #0
      e8:	60da      	str	r2, [r3, #12]
      ea:	4b6f      	ldr	r3, [pc, #444]	; (2a8 <tcp_close_shutdown+0x26c>)
      ec:	f04f 0201 	mov.w	r2, #1
      f0:	701a      	strb	r2, [r3, #0]
      if (pcb->state == ESTABLISHED) {
      f2:	687b      	ldr	r3, [r7, #4]
      f4:	7e1b      	ldrb	r3, [r3, #24]
      f6:	2b04      	cmp	r3, #4
      f8:	d10d      	bne.n	116 <tcp_close_shutdown+0xda>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
      fa:	687b      	ldr	r3, [r7, #4]
      fc:	f04f 020a 	mov.w	r2, #10
     100:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
     102:	4b6a      	ldr	r3, [pc, #424]	; (2ac <tcp_close_shutdown+0x270>)
     104:	681a      	ldr	r2, [r3, #0]
     106:	687b      	ldr	r3, [r7, #4]
     108:	60da      	str	r2, [r3, #12]
     10a:	4b68      	ldr	r3, [pc, #416]	; (2ac <tcp_close_shutdown+0x270>)
     10c:	687a      	ldr	r2, [r7, #4]
     10e:	601a      	str	r2, [r3, #0]
     110:	f7ff fffe 	bl	0 <tcp_timer_needed>
			110: R_ARM_THM_CALL	tcp_timer_needed
     114:	e004      	b.n	120 <tcp_close_shutdown+0xe4>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
     116:	f04f 0002 	mov.w	r0, #2
     11a:	6879      	ldr	r1, [r7, #4]
     11c:	f7ff fffe 	bl	0 <memp_free>
			11c: R_ARM_THM_CALL	memp_free
      }
      return ERR_OK;
     120:	f04f 0300 	mov.w	r3, #0
     124:	e0b6      	b.n	294 <tcp_close_shutdown+0x258>
    }
  }

  switch (pcb->state) {
     126:	687b      	ldr	r3, [r7, #4]
     128:	7e1b      	ldrb	r3, [r3, #24]
     12a:	2b07      	cmp	r3, #7
     12c:	f200 809b 	bhi.w	266 <tcp_close_shutdown+0x22a>
     130:	a201      	add	r2, pc, #4	; (adr r2, 138 <tcp_close_shutdown+0xfc>)
     132:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     136:	bf00      	nop
     138:	00000159 	.word	0x00000159
			138: R_ARM_ABS32	.text
     13c:	000001cb 	.word	0x000001cb
			13c: R_ARM_ABS32	.text
     140:	000001eb 	.word	0x000001eb
			140: R_ARM_ABS32	.text
     144:	00000213 	.word	0x00000213
			144: R_ARM_ABS32	.text
     148:	0000022f 	.word	0x0000022f
			148: R_ARM_ABS32	.text
     14c:	00000267 	.word	0x00000267
			14c: R_ARM_ABS32	.text
     150:	00000267 	.word	0x00000267
			150: R_ARM_ABS32	.text
     154:	0000024b 	.word	0x0000024b
			154: R_ARM_ABS32	.text
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
     158:	f04f 0300 	mov.w	r3, #0
     15c:	73fb      	strb	r3, [r7, #15]
    if (pcb->local_port != 0) {
     15e:	687b      	ldr	r3, [r7, #4]
     160:	8b5b      	ldrh	r3, [r3, #26]
     162:	2b00      	cmp	r3, #0
     164:	d028      	beq.n	1b8 <tcp_close_shutdown+0x17c>
      TCP_RMV(&tcp_bound_pcbs, pcb);
     166:	4b52      	ldr	r3, [pc, #328]	; (2b0 <tcp_close_shutdown+0x274>)
     168:	681a      	ldr	r2, [r3, #0]
     16a:	687b      	ldr	r3, [r7, #4]
     16c:	429a      	cmp	r2, r3
     16e:	d105      	bne.n	17c <tcp_close_shutdown+0x140>
     170:	4b4f      	ldr	r3, [pc, #316]	; (2b0 <tcp_close_shutdown+0x274>)
     172:	681b      	ldr	r3, [r3, #0]
     174:	68da      	ldr	r2, [r3, #12]
     176:	4b4e      	ldr	r3, [pc, #312]	; (2b0 <tcp_close_shutdown+0x274>)
     178:	601a      	str	r2, [r3, #0]
     17a:	e019      	b.n	1b0 <tcp_close_shutdown+0x174>
     17c:	4b4c      	ldr	r3, [pc, #304]	; (2b0 <tcp_close_shutdown+0x274>)
     17e:	681a      	ldr	r2, [r3, #0]
     180:	4b48      	ldr	r3, [pc, #288]	; (2a4 <tcp_close_shutdown+0x268>)
     182:	601a      	str	r2, [r3, #0]
     184:	e010      	b.n	1a8 <tcp_close_shutdown+0x16c>
     186:	4b47      	ldr	r3, [pc, #284]	; (2a4 <tcp_close_shutdown+0x268>)
     188:	681b      	ldr	r3, [r3, #0]
     18a:	68da      	ldr	r2, [r3, #12]
     18c:	687b      	ldr	r3, [r7, #4]
     18e:	429a      	cmp	r2, r3
     190:	d105      	bne.n	19e <tcp_close_shutdown+0x162>
     192:	4b44      	ldr	r3, [pc, #272]	; (2a4 <tcp_close_shutdown+0x268>)
     194:	681b      	ldr	r3, [r3, #0]
     196:	687a      	ldr	r2, [r7, #4]
     198:	68d2      	ldr	r2, [r2, #12]
     19a:	60da      	str	r2, [r3, #12]
     19c:	e008      	b.n	1b0 <tcp_close_shutdown+0x174>
     19e:	4b41      	ldr	r3, [pc, #260]	; (2a4 <tcp_close_shutdown+0x268>)
     1a0:	681b      	ldr	r3, [r3, #0]
     1a2:	68da      	ldr	r2, [r3, #12]
     1a4:	4b3f      	ldr	r3, [pc, #252]	; (2a4 <tcp_close_shutdown+0x268>)
     1a6:	601a      	str	r2, [r3, #0]
     1a8:	4b3e      	ldr	r3, [pc, #248]	; (2a4 <tcp_close_shutdown+0x268>)
     1aa:	681b      	ldr	r3, [r3, #0]
     1ac:	2b00      	cmp	r3, #0
     1ae:	d1ea      	bne.n	186 <tcp_close_shutdown+0x14a>
     1b0:	687b      	ldr	r3, [r7, #4]
     1b2:	f04f 0200 	mov.w	r2, #0
     1b6:	60da      	str	r2, [r3, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
     1b8:	f04f 0002 	mov.w	r0, #2
     1bc:	6879      	ldr	r1, [r7, #4]
     1be:	f7ff fffe 	bl	0 <memp_free>
			1be: R_ARM_THM_CALL	memp_free
    pcb = NULL;
     1c2:	f04f 0300 	mov.w	r3, #0
     1c6:	607b      	str	r3, [r7, #4]
    break;
     1c8:	e059      	b.n	27e <tcp_close_shutdown+0x242>
  case LISTEN:
    err = ERR_OK;
     1ca:	f04f 0300 	mov.w	r3, #0
     1ce:	73fb      	strb	r3, [r7, #15]
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
     1d0:	4838      	ldr	r0, [pc, #224]	; (2b4 <tcp_close_shutdown+0x278>)
     1d2:	6879      	ldr	r1, [r7, #4]
     1d4:	f7ff fffe 	bl	14d8 <tcp_pcb_remove>
			1d4: R_ARM_THM_CALL	tcp_pcb_remove
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
     1d8:	f04f 0003 	mov.w	r0, #3
     1dc:	6879      	ldr	r1, [r7, #4]
     1de:	f7ff fffe 	bl	0 <memp_free>
			1de: R_ARM_THM_CALL	memp_free
    pcb = NULL;
     1e2:	f04f 0300 	mov.w	r3, #0
     1e6:	607b      	str	r3, [r7, #4]
    break;
     1e8:	e049      	b.n	27e <tcp_close_shutdown+0x242>
  case SYN_SENT:
    err = ERR_OK;
     1ea:	f04f 0300 	mov.w	r3, #0
     1ee:	73fb      	strb	r3, [r7, #15]
    TCP_PCB_REMOVE_ACTIVE(pcb);
     1f0:	482b      	ldr	r0, [pc, #172]	; (2a0 <tcp_close_shutdown+0x264>)
     1f2:	6879      	ldr	r1, [r7, #4]
     1f4:	f7ff fffe 	bl	14d8 <tcp_pcb_remove>
			1f4: R_ARM_THM_CALL	tcp_pcb_remove
     1f8:	4b2b      	ldr	r3, [pc, #172]	; (2a8 <tcp_close_shutdown+0x26c>)
     1fa:	f04f 0201 	mov.w	r2, #1
     1fe:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
     200:	f04f 0002 	mov.w	r0, #2
     204:	6879      	ldr	r1, [r7, #4]
     206:	f7ff fffe 	bl	0 <memp_free>
			206: R_ARM_THM_CALL	memp_free
    pcb = NULL;
     20a:	f04f 0300 	mov.w	r3, #0
     20e:	607b      	str	r3, [r7, #4]
    snmp_inc_tcpattemptfails();
    break;
     210:	e035      	b.n	27e <tcp_close_shutdown+0x242>
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
     212:	6878      	ldr	r0, [r7, #4]
     214:	f7ff fffe 	bl	0 <tcp_send_fin>
			214: R_ARM_THM_CALL	tcp_send_fin
     218:	4603      	mov	r3, r0
     21a:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
     21c:	f997 300f 	ldrsb.w	r3, [r7, #15]
     220:	2b00      	cmp	r3, #0
     222:	d127      	bne.n	274 <tcp_close_shutdown+0x238>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
     224:	687b      	ldr	r3, [r7, #4]
     226:	f04f 0205 	mov.w	r2, #5
     22a:	761a      	strb	r2, [r3, #24]
    }
    break;
     22c:	e027      	b.n	27e <tcp_close_shutdown+0x242>
  case ESTABLISHED:
    err = tcp_send_fin(pcb);
     22e:	6878      	ldr	r0, [r7, #4]
     230:	f7ff fffe 	bl	0 <tcp_send_fin>
			230: R_ARM_THM_CALL	tcp_send_fin
     234:	4603      	mov	r3, r0
     236:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
     238:	f997 300f 	ldrsb.w	r3, [r7, #15]
     23c:	2b00      	cmp	r3, #0
     23e:	d11b      	bne.n	278 <tcp_close_shutdown+0x23c>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
     240:	687b      	ldr	r3, [r7, #4]
     242:	f04f 0205 	mov.w	r2, #5
     246:	761a      	strb	r2, [r3, #24]
    }
    break;
     248:	e019      	b.n	27e <tcp_close_shutdown+0x242>
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
     24a:	6878      	ldr	r0, [r7, #4]
     24c:	f7ff fffe 	bl	0 <tcp_send_fin>
			24c: R_ARM_THM_CALL	tcp_send_fin
     250:	4603      	mov	r3, r0
     252:	73fb      	strb	r3, [r7, #15]
    if (err == ERR_OK) {
     254:	f997 300f 	ldrsb.w	r3, [r7, #15]
     258:	2b00      	cmp	r3, #0
     25a:	d10f      	bne.n	27c <tcp_close_shutdown+0x240>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
     25c:	687b      	ldr	r3, [r7, #4]
     25e:	f04f 0209 	mov.w	r2, #9
     262:	761a      	strb	r2, [r3, #24]
    }
    break;
     264:	e00b      	b.n	27e <tcp_close_shutdown+0x242>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
     266:	f04f 0300 	mov.w	r3, #0
     26a:	73fb      	strb	r3, [r7, #15]
    pcb = NULL;
     26c:	f04f 0300 	mov.w	r3, #0
     270:	607b      	str	r3, [r7, #4]
    break;
     272:	e004      	b.n	27e <tcp_close_shutdown+0x242>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
     274:	bf00      	nop
     276:	e002      	b.n	27e <tcp_close_shutdown+0x242>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
     278:	bf00      	nop
     27a:	e000      	b.n	27e <tcp_close_shutdown+0x242>
    err = tcp_send_fin(pcb);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
     27c:	bf00      	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
     27e:	687b      	ldr	r3, [r7, #4]
     280:	2b00      	cmp	r3, #0
     282:	d006      	beq.n	292 <tcp_close_shutdown+0x256>
     284:	f997 300f 	ldrsb.w	r3, [r7, #15]
     288:	2b00      	cmp	r3, #0
     28a:	d102      	bne.n	292 <tcp_close_shutdown+0x256>
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
     28c:	6878      	ldr	r0, [r7, #4]
     28e:	f7ff fffe 	bl	0 <tcp_output>
			28e: R_ARM_THM_CALL	tcp_output
  }
  return err;
     292:	7bfb      	ldrb	r3, [r7, #15]
     294:	b25b      	sxtb	r3, r3
}
     296:	4618      	mov	r0, r3
     298:	f107 0710 	add.w	r7, r7, #16
     29c:	46bd      	mov	sp, r7
     29e:	bdb0      	pop	{r4, r5, r7, pc}
	...
			2a0: R_ARM_ABS32	tcp_active_pcbs
			2a4: R_ARM_ABS32	tcp_tmp_pcb
			2a8: R_ARM_ABS32	tcp_active_pcbs_changed
			2ac: R_ARM_ABS32	tcp_tw_pcbs
			2b0: R_ARM_ABS32	tcp_bound_pcbs
			2b4: R_ARM_ABS32	tcp_listen_pcbs

000002b8 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
     2b8:	b580      	push	{r7, lr}
     2ba:	b082      	sub	sp, #8
     2bc:	af00      	add	r7, sp, #0
     2be:	6078      	str	r0, [r7, #4]
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
     2c0:	687b      	ldr	r3, [r7, #4]
     2c2:	7e1b      	ldrb	r3, [r3, #24]
     2c4:	2b01      	cmp	r3, #1
     2c6:	d006      	beq.n	2d6 <tcp_close+0x1e>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
     2c8:	687b      	ldr	r3, [r7, #4]
     2ca:	7f9b      	ldrb	r3, [r3, #30]
     2cc:	f043 0310 	orr.w	r3, r3, #16
     2d0:	b2da      	uxtb	r2, r3
     2d2:	687b      	ldr	r3, [r7, #4]
     2d4:	779a      	strb	r2, [r3, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
     2d6:	6878      	ldr	r0, [r7, #4]
     2d8:	f04f 0101 	mov.w	r1, #1
     2dc:	f7ff feae 	bl	3c <tcp_close_shutdown>
     2e0:	4603      	mov	r3, r0
}
     2e2:	4618      	mov	r0, r3
     2e4:	f107 0708 	add.w	r7, r7, #8
     2e8:	46bd      	mov	sp, r7
     2ea:	bd80      	pop	{r7, pc}

000002ec <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
     2ec:	b580      	push	{r7, lr}
     2ee:	b084      	sub	sp, #16
     2f0:	af00      	add	r7, sp, #0
     2f2:	60f8      	str	r0, [r7, #12]
     2f4:	60b9      	str	r1, [r7, #8]
     2f6:	607a      	str	r2, [r7, #4]
  if (pcb->state == LISTEN) {
     2f8:	68fb      	ldr	r3, [r7, #12]
     2fa:	7e1b      	ldrb	r3, [r3, #24]
     2fc:	2b01      	cmp	r3, #1
     2fe:	d102      	bne.n	306 <tcp_shutdown+0x1a>
    return ERR_CONN;
     300:	f04f 03f3 	mov.w	r3, #243	; 0xf3
     304:	e03a      	b.n	37c <tcp_shutdown+0x90>
  }
  if (shut_rx) {
     306:	68bb      	ldr	r3, [r7, #8]
     308:	2b00      	cmp	r3, #0
     30a:	d01d      	beq.n	348 <tcp_shutdown+0x5c>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
     30c:	68fb      	ldr	r3, [r7, #12]
     30e:	7f9b      	ldrb	r3, [r3, #30]
     310:	f043 0310 	orr.w	r3, r3, #16
     314:	b2da      	uxtb	r2, r3
     316:	68fb      	ldr	r3, [r7, #12]
     318:	779a      	strb	r2, [r3, #30]
    if (shut_tx) {
     31a:	687b      	ldr	r3, [r7, #4]
     31c:	2b00      	cmp	r3, #0
     31e:	d006      	beq.n	32e <tcp_shutdown+0x42>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
     320:	68f8      	ldr	r0, [r7, #12]
     322:	f04f 0101 	mov.w	r1, #1
     326:	f7ff fe89 	bl	3c <tcp_close_shutdown>
     32a:	4603      	mov	r3, r0
     32c:	e026      	b.n	37c <tcp_shutdown+0x90>
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
     32e:	68fb      	ldr	r3, [r7, #12]
     330:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     332:	2b00      	cmp	r3, #0
     334:	d008      	beq.n	348 <tcp_shutdown+0x5c>
      pbuf_free(pcb->refused_data);
     336:	68fb      	ldr	r3, [r7, #12]
     338:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     33a:	4618      	mov	r0, r3
     33c:	f7ff fffe 	bl	0 <pbuf_free>
			33c: R_ARM_THM_CALL	pbuf_free
      pcb->refused_data = NULL;
     340:	68fb      	ldr	r3, [r7, #12]
     342:	f04f 0200 	mov.w	r2, #0
     346:	679a      	str	r2, [r3, #120]	; 0x78
    }
  }
  if (shut_tx) {
     348:	687b      	ldr	r3, [r7, #4]
     34a:	2b00      	cmp	r3, #0
     34c:	d014      	beq.n	378 <tcp_shutdown+0x8c>
    /* This can't happen twice since if it succeeds, the pcb's state is changed.
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
     34e:	68fb      	ldr	r3, [r7, #12]
     350:	7e1b      	ldrb	r3, [r3, #24]
     352:	2b07      	cmp	r3, #7
     354:	d80d      	bhi.n	372 <tcp_shutdown+0x86>
     356:	f04f 52c8 	mov.w	r2, #419430400	; 0x19000000
     35a:	fa02 f303 	lsl.w	r3, r2, r3
     35e:	2b00      	cmp	r3, #0
     360:	da07      	bge.n	372 <tcp_shutdown+0x86>
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
     362:	68bb      	ldr	r3, [r7, #8]
     364:	b2db      	uxtb	r3, r3
     366:	68f8      	ldr	r0, [r7, #12]
     368:	4619      	mov	r1, r3
     36a:	f7ff fe67 	bl	3c <tcp_close_shutdown>
     36e:	4603      	mov	r3, r0
     370:	e004      	b.n	37c <tcp_shutdown+0x90>
    default:
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
     372:	f04f 03f3 	mov.w	r3, #243	; 0xf3
     376:	e001      	b.n	37c <tcp_shutdown+0x90>
    }
  }
  return ERR_OK;
     378:	f04f 0300 	mov.w	r3, #0
     37c:	b25b      	sxtb	r3, r3
}
     37e:	4618      	mov	r0, r3
     380:	f107 0710 	add.w	r7, r7, #16
     384:	46bd      	mov	sp, r7
     386:	bd80      	pop	{r7, pc}

00000388 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
     388:	b580      	push	{r7, lr}
     38a:	b088      	sub	sp, #32
     38c:	af02      	add	r7, sp, #8
     38e:	6078      	str	r0, [r7, #4]
     390:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
     392:	687b      	ldr	r3, [r7, #4]
     394:	7e1b      	ldrb	r3, [r3, #24]
     396:	2b0a      	cmp	r3, #10
     398:	d109      	bne.n	3ae <tcp_abandon+0x26>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
     39a:	482e      	ldr	r0, [pc, #184]	; (454 <tcp_abandon+0xcc>)
     39c:	6879      	ldr	r1, [r7, #4]
     39e:	f7ff fffe 	bl	14d8 <tcp_pcb_remove>
			39e: R_ARM_THM_CALL	tcp_pcb_remove
    memp_free(MEMP_TCP_PCB, pcb);
     3a2:	f04f 0002 	mov.w	r0, #2
     3a6:	6879      	ldr	r1, [r7, #4]
     3a8:	f7ff fffe 	bl	0 <memp_free>
			3a8: R_ARM_THM_CALL	memp_free
     3ac:	e04d      	b.n	44a <tcp_abandon+0xc2>
  } else {
    seqno = pcb->snd_nxt;
     3ae:	687b      	ldr	r3, [r7, #4]
     3b0:	6d1b      	ldr	r3, [r3, #80]	; 0x50
     3b2:	617b      	str	r3, [r7, #20]
    ackno = pcb->rcv_nxt;
     3b4:	687b      	ldr	r3, [r7, #4]
     3b6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     3b8:	613b      	str	r3, [r7, #16]
#if LWIP_CALLBACK_API
    errf = pcb->errf;
     3ba:	687b      	ldr	r3, [r7, #4]
     3bc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
     3c0:	60fb      	str	r3, [r7, #12]
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
     3c2:	687b      	ldr	r3, [r7, #4]
     3c4:	691b      	ldr	r3, [r3, #16]
     3c6:	60bb      	str	r3, [r7, #8]
    TCP_PCB_REMOVE_ACTIVE(pcb);
     3c8:	4823      	ldr	r0, [pc, #140]	; (458 <tcp_abandon+0xd0>)
     3ca:	6879      	ldr	r1, [r7, #4]
     3cc:	f7ff fffe 	bl	14d8 <tcp_pcb_remove>
			3cc: R_ARM_THM_CALL	tcp_pcb_remove
     3d0:	4b22      	ldr	r3, [pc, #136]	; (45c <tcp_abandon+0xd4>)
     3d2:	f04f 0201 	mov.w	r2, #1
     3d6:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
     3d8:	687b      	ldr	r3, [r7, #4]
     3da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     3dc:	2b00      	cmp	r3, #0
     3de:	d004      	beq.n	3ea <tcp_abandon+0x62>
      tcp_segs_free(pcb->unacked);
     3e0:	687b      	ldr	r3, [r7, #4]
     3e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     3e4:	4618      	mov	r0, r3
     3e6:	f7ff fffe 	bl	1054 <tcp_segs_free>
			3e6: R_ARM_THM_CALL	tcp_segs_free
    }
    if (pcb->unsent != NULL) {
     3ea:	687b      	ldr	r3, [r7, #4]
     3ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     3ee:	2b00      	cmp	r3, #0
     3f0:	d004      	beq.n	3fc <tcp_abandon+0x74>
      tcp_segs_free(pcb->unsent);
     3f2:	687b      	ldr	r3, [r7, #4]
     3f4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     3f6:	4618      	mov	r0, r3
     3f8:	f7ff fffe 	bl	1054 <tcp_segs_free>
			3f8: R_ARM_THM_CALL	tcp_segs_free
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
     3fc:	687b      	ldr	r3, [r7, #4]
     3fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
     400:	2b00      	cmp	r3, #0
     402:	d004      	beq.n	40e <tcp_abandon+0x86>
      tcp_segs_free(pcb->ooseq);
     404:	687b      	ldr	r3, [r7, #4]
     406:	6f5b      	ldr	r3, [r3, #116]	; 0x74
     408:	4618      	mov	r0, r3
     40a:	f7ff fffe 	bl	1054 <tcp_segs_free>
			40a: R_ARM_THM_CALL	tcp_segs_free
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
     40e:	683b      	ldr	r3, [r7, #0]
     410:	2b00      	cmp	r3, #0
     412:	d00d      	beq.n	430 <tcp_abandon+0xa8>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
     414:	687a      	ldr	r2, [r7, #4]
     416:	687b      	ldr	r3, [r7, #4]
     418:	f103 0304 	add.w	r3, r3, #4
     41c:	6879      	ldr	r1, [r7, #4]
     41e:	8b48      	ldrh	r0, [r1, #26]
     420:	6879      	ldr	r1, [r7, #4]
     422:	8b89      	ldrh	r1, [r1, #28]
     424:	9000      	str	r0, [sp, #0]
     426:	9101      	str	r1, [sp, #4]
     428:	6978      	ldr	r0, [r7, #20]
     42a:	6939      	ldr	r1, [r7, #16]
     42c:	f7ff fffe 	bl	0 <tcp_rst>
			42c: R_ARM_THM_CALL	tcp_rst
    }
    memp_free(MEMP_TCP_PCB, pcb);
     430:	f04f 0002 	mov.w	r0, #2
     434:	6879      	ldr	r1, [r7, #4]
     436:	f7ff fffe 	bl	0 <memp_free>
			436: R_ARM_THM_CALL	memp_free
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
     43a:	68fb      	ldr	r3, [r7, #12]
     43c:	2b00      	cmp	r3, #0
     43e:	d004      	beq.n	44a <tcp_abandon+0xc2>
     440:	68fb      	ldr	r3, [r7, #12]
     442:	68b8      	ldr	r0, [r7, #8]
     444:	f06f 0109 	mvn.w	r1, #9
     448:	4798      	blx	r3
  }
}
     44a:	f107 0718 	add.w	r7, r7, #24
     44e:	46bd      	mov	sp, r7
     450:	bd80      	pop	{r7, pc}
     452:	bf00      	nop
	...
			454: R_ARM_ABS32	tcp_tw_pcbs
			458: R_ARM_ABS32	tcp_active_pcbs
			45c: R_ARM_ABS32	tcp_active_pcbs_changed

00000460 <tcp_abort>:
 *
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
     460:	b580      	push	{r7, lr}
     462:	b082      	sub	sp, #8
     464:	af00      	add	r7, sp, #0
     466:	6078      	str	r0, [r7, #4]
  tcp_abandon(pcb, 1);
     468:	6878      	ldr	r0, [r7, #4]
     46a:	f04f 0101 	mov.w	r1, #1
     46e:	f7ff fffe 	bl	388 <tcp_abandon>
			46e: R_ARM_THM_CALL	tcp_abandon
}
     472:	f107 0708 	add.w	r7, r7, #8
     476:	46bd      	mov	sp, r7
     478:	bd80      	pop	{r7, pc}
     47a:	bf00      	nop

0000047c <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
     47c:	b580      	push	{r7, lr}
     47e:	b088      	sub	sp, #32
     480:	af00      	add	r7, sp, #0
     482:	60f8      	str	r0, [r7, #12]
     484:	60b9      	str	r1, [r7, #8]
     486:	4613      	mov	r3, r2
     488:	80fb      	strh	r3, [r7, #6]
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
     48a:	f04f 0304 	mov.w	r3, #4
     48e:	617b      	str	r3, [r7, #20]
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
     490:	68fb      	ldr	r3, [r7, #12]
     492:	7e1b      	ldrb	r3, [r3, #24]
     494:	2b00      	cmp	r3, #0
     496:	d002      	beq.n	49e <tcp_bind+0x22>
     498:	f04f 03fa 	mov.w	r3, #250	; 0xfa
     49c:	e05a      	b.n	554 <tcp_bind+0xd8>
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
     49e:	88fb      	ldrh	r3, [r7, #6]
     4a0:	2b00      	cmp	r3, #0
     4a2:	d109      	bne.n	4b8 <tcp_bind+0x3c>
    port = tcp_new_port();
     4a4:	f000 f976 	bl	794 <tcp_new_port>
     4a8:	4603      	mov	r3, r0
     4aa:	80fb      	strh	r3, [r7, #6]
    if (port == 0) {
     4ac:	88fb      	ldrh	r3, [r7, #6]
     4ae:	2b00      	cmp	r3, #0
     4b0:	d102      	bne.n	4b8 <tcp_bind+0x3c>
      return ERR_BUF;
     4b2:	f04f 03fe 	mov.w	r3, #254	; 0xfe
     4b6:	e04d      	b.n	554 <tcp_bind+0xd8>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
     4b8:	f04f 0300 	mov.w	r3, #0
     4bc:	61fb      	str	r3, [r7, #28]
     4be:	e02c      	b.n	51a <tcp_bind+0x9e>
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
     4c0:	4b27      	ldr	r3, [pc, #156]	; (560 <tcp_bind+0xe4>)
     4c2:	69fa      	ldr	r2, [r7, #28]
     4c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     4c8:	681b      	ldr	r3, [r3, #0]
     4ca:	61bb      	str	r3, [r7, #24]
     4cc:	e01e      	b.n	50c <tcp_bind+0x90>
      if (cpcb->local_port == port) {
     4ce:	69bb      	ldr	r3, [r7, #24]
     4d0:	8b5b      	ldrh	r3, [r3, #26]
     4d2:	88fa      	ldrh	r2, [r7, #6]
     4d4:	429a      	cmp	r2, r3
     4d6:	d116      	bne.n	506 <tcp_bind+0x8a>
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
     4d8:	69bb      	ldr	r3, [r7, #24]
     4da:	2b00      	cmp	r3, #0
     4dc:	d010      	beq.n	500 <tcp_bind+0x84>
     4de:	69bb      	ldr	r3, [r7, #24]
     4e0:	681b      	ldr	r3, [r3, #0]
     4e2:	2b00      	cmp	r3, #0
     4e4:	d00c      	beq.n	500 <tcp_bind+0x84>
     4e6:	68bb      	ldr	r3, [r7, #8]
     4e8:	2b00      	cmp	r3, #0
     4ea:	d009      	beq.n	500 <tcp_bind+0x84>
              ip_addr_isany(ipaddr) ||
     4ec:	68bb      	ldr	r3, [r7, #8]
     4ee:	681b      	ldr	r3, [r3, #0]
     4f0:	2b00      	cmp	r3, #0
     4f2:	d005      	beq.n	500 <tcp_bind+0x84>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
     4f4:	69bb      	ldr	r3, [r7, #24]
     4f6:	681a      	ldr	r2, [r3, #0]
     4f8:	68bb      	ldr	r3, [r7, #8]
     4fa:	681b      	ldr	r3, [r3, #0]
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
              ip_addr_isany(ipaddr) ||
     4fc:	429a      	cmp	r2, r3
     4fe:	d102      	bne.n	506 <tcp_bind+0x8a>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
     500:	f04f 03f8 	mov.w	r3, #248	; 0xf8
     504:	e026      	b.n	554 <tcp_bind+0xd8>
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
     506:	69bb      	ldr	r3, [r7, #24]
     508:	68db      	ldr	r3, [r3, #12]
     50a:	61bb      	str	r3, [r7, #24]
     50c:	69bb      	ldr	r3, [r7, #24]
     50e:	2b00      	cmp	r3, #0
     510:	d1dd      	bne.n	4ce <tcp_bind+0x52>
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
     512:	69fb      	ldr	r3, [r7, #28]
     514:	f103 0301 	add.w	r3, r3, #1
     518:	61fb      	str	r3, [r7, #28]
     51a:	69fa      	ldr	r2, [r7, #28]
     51c:	697b      	ldr	r3, [r7, #20]
     51e:	429a      	cmp	r2, r3
     520:	dbce      	blt.n	4c0 <tcp_bind+0x44>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
     522:	68bb      	ldr	r3, [r7, #8]
     524:	2b00      	cmp	r3, #0
     526:	d007      	beq.n	538 <tcp_bind+0xbc>
     528:	68bb      	ldr	r3, [r7, #8]
     52a:	681b      	ldr	r3, [r3, #0]
     52c:	2b00      	cmp	r3, #0
     52e:	d003      	beq.n	538 <tcp_bind+0xbc>
    pcb->local_ip = *ipaddr;
     530:	68fb      	ldr	r3, [r7, #12]
     532:	68ba      	ldr	r2, [r7, #8]
     534:	6812      	ldr	r2, [r2, #0]
     536:	601a      	str	r2, [r3, #0]
  }
  pcb->local_port = port;
     538:	68fb      	ldr	r3, [r7, #12]
     53a:	88fa      	ldrh	r2, [r7, #6]
     53c:	835a      	strh	r2, [r3, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
     53e:	4b09      	ldr	r3, [pc, #36]	; (564 <tcp_bind+0xe8>)
     540:	681a      	ldr	r2, [r3, #0]
     542:	68fb      	ldr	r3, [r7, #12]
     544:	60da      	str	r2, [r3, #12]
     546:	4b07      	ldr	r3, [pc, #28]	; (564 <tcp_bind+0xe8>)
     548:	68fa      	ldr	r2, [r7, #12]
     54a:	601a      	str	r2, [r3, #0]
     54c:	f7ff fffe 	bl	0 <tcp_timer_needed>
			54c: R_ARM_THM_CALL	tcp_timer_needed
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
     550:	f04f 0300 	mov.w	r3, #0
     554:	b25b      	sxtb	r3, r3
}
     556:	4618      	mov	r0, r3
     558:	f107 0720 	add.w	r7, r7, #32
     55c:	46bd      	mov	sp, r7
     55e:	bd80      	pop	{r7, pc}
	...
			560: R_ARM_ABS32	tcp_pcb_lists
			564: R_ARM_ABS32	tcp_bound_pcbs

00000568 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
     568:	b480      	push	{r7}
     56a:	b085      	sub	sp, #20
     56c:	af00      	add	r7, sp, #0
     56e:	60f8      	str	r0, [r7, #12]
     570:	60b9      	str	r1, [r7, #8]
     572:	4613      	mov	r3, r2
     574:	71fb      	strb	r3, [r7, #7]
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
     576:	f04f 03f6 	mov.w	r3, #246	; 0xf6
     57a:	b25b      	sxtb	r3, r3
}
     57c:	4618      	mov	r0, r3
     57e:	f107 0714 	add.w	r7, r7, #20
     582:	46bd      	mov	sp, r7
     584:	bc80      	pop	{r7}
     586:	4770      	bx	lr

00000588 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
     588:	b580      	push	{r7, lr}
     58a:	b084      	sub	sp, #16
     58c:	af00      	add	r7, sp, #0
     58e:	6078      	str	r0, [r7, #4]
     590:	460b      	mov	r3, r1
     592:	70fb      	strb	r3, [r7, #3]
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
     594:	687b      	ldr	r3, [r7, #4]
     596:	7e1b      	ldrb	r3, [r3, #24]
     598:	2b00      	cmp	r3, #0
     59a:	d002      	beq.n	5a2 <tcp_listen_with_backlog+0x1a>
     59c:	f04f 0300 	mov.w	r3, #0
     5a0:	e077      	b.n	692 <tcp_listen_with_backlog+0x10a>

  /* already listening? */
  if (pcb->state == LISTEN) {
     5a2:	687b      	ldr	r3, [r7, #4]
     5a4:	7e1b      	ldrb	r3, [r3, #24]
     5a6:	2b01      	cmp	r3, #1
     5a8:	d101      	bne.n	5ae <tcp_listen_with_backlog+0x26>
    return pcb;
     5aa:	687b      	ldr	r3, [r7, #4]
     5ac:	e071      	b.n	692 <tcp_listen_with_backlog+0x10a>
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
     5ae:	f04f 0003 	mov.w	r0, #3
     5b2:	f7ff fffe 	bl	0 <memp_malloc>
			5b2: R_ARM_THM_CALL	memp_malloc
     5b6:	4603      	mov	r3, r0
     5b8:	60fb      	str	r3, [r7, #12]
  if (lpcb == NULL) {
     5ba:	68fb      	ldr	r3, [r7, #12]
     5bc:	2b00      	cmp	r3, #0
     5be:	d102      	bne.n	5c6 <tcp_listen_with_backlog+0x3e>
    return NULL;
     5c0:	f04f 0300 	mov.w	r3, #0
     5c4:	e065      	b.n	692 <tcp_listen_with_backlog+0x10a>
  }
  lpcb->callback_arg = pcb->callback_arg;
     5c6:	687b      	ldr	r3, [r7, #4]
     5c8:	691a      	ldr	r2, [r3, #16]
     5ca:	68fb      	ldr	r3, [r7, #12]
     5cc:	611a      	str	r2, [r3, #16]
  lpcb->local_port = pcb->local_port;
     5ce:	687b      	ldr	r3, [r7, #4]
     5d0:	8b5a      	ldrh	r2, [r3, #26]
     5d2:	68fb      	ldr	r3, [r7, #12]
     5d4:	835a      	strh	r2, [r3, #26]
  lpcb->state = LISTEN;
     5d6:	68fb      	ldr	r3, [r7, #12]
     5d8:	f04f 0201 	mov.w	r2, #1
     5dc:	761a      	strb	r2, [r3, #24]
  lpcb->prio = pcb->prio;
     5de:	687b      	ldr	r3, [r7, #4]
     5e0:	7e5a      	ldrb	r2, [r3, #25]
     5e2:	68fb      	ldr	r3, [r7, #12]
     5e4:	765a      	strb	r2, [r3, #25]
  lpcb->so_options = pcb->so_options;
     5e6:	687b      	ldr	r3, [r7, #4]
     5e8:	7a1a      	ldrb	r2, [r3, #8]
     5ea:	68fb      	ldr	r3, [r7, #12]
     5ec:	721a      	strb	r2, [r3, #8]
  ip_set_option(lpcb, SOF_ACCEPTCONN);
     5ee:	68fb      	ldr	r3, [r7, #12]
     5f0:	7a1b      	ldrb	r3, [r3, #8]
     5f2:	f043 0302 	orr.w	r3, r3, #2
     5f6:	b2da      	uxtb	r2, r3
     5f8:	68fb      	ldr	r3, [r7, #12]
     5fa:	721a      	strb	r2, [r3, #8]
  lpcb->ttl = pcb->ttl;
     5fc:	687b      	ldr	r3, [r7, #4]
     5fe:	7a9a      	ldrb	r2, [r3, #10]
     600:	68fb      	ldr	r3, [r7, #12]
     602:	729a      	strb	r2, [r3, #10]
  lpcb->tos = pcb->tos;
     604:	687b      	ldr	r3, [r7, #4]
     606:	7a5a      	ldrb	r2, [r3, #9]
     608:	68fb      	ldr	r3, [r7, #12]
     60a:	725a      	strb	r2, [r3, #9]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
     60c:	687b      	ldr	r3, [r7, #4]
     60e:	681a      	ldr	r2, [r3, #0]
     610:	68fb      	ldr	r3, [r7, #12]
     612:	601a      	str	r2, [r3, #0]
  if (pcb->local_port != 0) {
     614:	687b      	ldr	r3, [r7, #4]
     616:	8b5b      	ldrh	r3, [r3, #26]
     618:	2b00      	cmp	r3, #0
     61a:	d028      	beq.n	66e <tcp_listen_with_backlog+0xe6>
    TCP_RMV(&tcp_bound_pcbs, pcb);
     61c:	4b1f      	ldr	r3, [pc, #124]	; (69c <tcp_listen_with_backlog+0x114>)
     61e:	681a      	ldr	r2, [r3, #0]
     620:	687b      	ldr	r3, [r7, #4]
     622:	429a      	cmp	r2, r3
     624:	d105      	bne.n	632 <tcp_listen_with_backlog+0xaa>
     626:	4b1d      	ldr	r3, [pc, #116]	; (69c <tcp_listen_with_backlog+0x114>)
     628:	681b      	ldr	r3, [r3, #0]
     62a:	68da      	ldr	r2, [r3, #12]
     62c:	4b1b      	ldr	r3, [pc, #108]	; (69c <tcp_listen_with_backlog+0x114>)
     62e:	601a      	str	r2, [r3, #0]
     630:	e019      	b.n	666 <tcp_listen_with_backlog+0xde>
     632:	4b1a      	ldr	r3, [pc, #104]	; (69c <tcp_listen_with_backlog+0x114>)
     634:	681a      	ldr	r2, [r3, #0]
     636:	4b1a      	ldr	r3, [pc, #104]	; (6a0 <tcp_listen_with_backlog+0x118>)
     638:	601a      	str	r2, [r3, #0]
     63a:	e010      	b.n	65e <tcp_listen_with_backlog+0xd6>
     63c:	4b18      	ldr	r3, [pc, #96]	; (6a0 <tcp_listen_with_backlog+0x118>)
     63e:	681b      	ldr	r3, [r3, #0]
     640:	68da      	ldr	r2, [r3, #12]
     642:	687b      	ldr	r3, [r7, #4]
     644:	429a      	cmp	r2, r3
     646:	d105      	bne.n	654 <tcp_listen_with_backlog+0xcc>
     648:	4b15      	ldr	r3, [pc, #84]	; (6a0 <tcp_listen_with_backlog+0x118>)
     64a:	681b      	ldr	r3, [r3, #0]
     64c:	687a      	ldr	r2, [r7, #4]
     64e:	68d2      	ldr	r2, [r2, #12]
     650:	60da      	str	r2, [r3, #12]
     652:	e008      	b.n	666 <tcp_listen_with_backlog+0xde>
     654:	4b12      	ldr	r3, [pc, #72]	; (6a0 <tcp_listen_with_backlog+0x118>)
     656:	681b      	ldr	r3, [r3, #0]
     658:	68da      	ldr	r2, [r3, #12]
     65a:	4b11      	ldr	r3, [pc, #68]	; (6a0 <tcp_listen_with_backlog+0x118>)
     65c:	601a      	str	r2, [r3, #0]
     65e:	4b10      	ldr	r3, [pc, #64]	; (6a0 <tcp_listen_with_backlog+0x118>)
     660:	681b      	ldr	r3, [r3, #0]
     662:	2b00      	cmp	r3, #0
     664:	d1ea      	bne.n	63c <tcp_listen_with_backlog+0xb4>
     666:	687b      	ldr	r3, [r7, #4]
     668:	f04f 0200 	mov.w	r2, #0
     66c:	60da      	str	r2, [r3, #12]
  }
  memp_free(MEMP_TCP_PCB, pcb);
     66e:	f04f 0002 	mov.w	r0, #2
     672:	6879      	ldr	r1, [r7, #4]
     674:	f7ff fffe 	bl	0 <memp_free>
			674: R_ARM_THM_CALL	memp_free
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
     678:	68fb      	ldr	r3, [r7, #12]
     67a:	4a0a      	ldr	r2, [pc, #40]	; (6a4 <tcp_listen_with_backlog+0x11c>)
     67c:	615a      	str	r2, [r3, #20]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
     67e:	68fb      	ldr	r3, [r7, #12]
     680:	4a09      	ldr	r2, [pc, #36]	; (6a8 <tcp_listen_with_backlog+0x120>)
     682:	6812      	ldr	r2, [r2, #0]
     684:	60da      	str	r2, [r3, #12]
     686:	68fa      	ldr	r2, [r7, #12]
     688:	4b07      	ldr	r3, [pc, #28]	; (6a8 <tcp_listen_with_backlog+0x120>)
     68a:	601a      	str	r2, [r3, #0]
     68c:	f7ff fffe 	bl	0 <tcp_timer_needed>
			68c: R_ARM_THM_CALL	tcp_timer_needed
  return (struct tcp_pcb *)lpcb;
     690:	68fb      	ldr	r3, [r7, #12]
}
     692:	4618      	mov	r0, r3
     694:	f107 0710 	add.w	r7, r7, #16
     698:	46bd      	mov	sp, r7
     69a:	bd80      	pop	{r7, pc}
	...
			69c: R_ARM_ABS32	tcp_bound_pcbs
			6a0: R_ARM_ABS32	tcp_tmp_pcb
			6a4: R_ARM_ABS32	tcp_accept_null
			6a8: R_ARM_ABS32	tcp_listen_pcbs

000006ac <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
     6ac:	b480      	push	{r7}
     6ae:	b085      	sub	sp, #20
     6b0:	af00      	add	r7, sp, #0
     6b2:	6078      	str	r0, [r7, #4]
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
     6b4:	687b      	ldr	r3, [r7, #4]
     6b6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     6b8:	687b      	ldr	r3, [r7, #4]
     6ba:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     6bc:	18d3      	adds	r3, r2, r3
     6be:	60fb      	str	r3, [r7, #12]

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
     6c0:	687b      	ldr	r3, [r7, #4]
     6c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     6c4:	687b      	ldr	r3, [r7, #4]
     6c6:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
     6c8:	f640 33b8 	movw	r3, #3000	; 0xbb8
     6cc:	4299      	cmp	r1, r3
     6ce:	d802      	bhi.n	6d6 <tcp_update_rcv_ann_wnd+0x2a>
     6d0:	687b      	ldr	r3, [r7, #4]
     6d2:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     6d4:	e001      	b.n	6da <tcp_update_rcv_ann_wnd+0x2e>
     6d6:	f640 33b8 	movw	r3, #3000	; 0xbb8
     6da:	18d3      	adds	r3, r2, r3
     6dc:	68fa      	ldr	r2, [r7, #12]
     6de:	1ad3      	subs	r3, r2, r3
     6e0:	2b00      	cmp	r3, #0
     6e2:	db08      	blt.n	6f6 <tcp_update_rcv_ann_wnd+0x4a>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
     6e4:	687b      	ldr	r3, [r7, #4]
     6e6:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
     6e8:	687b      	ldr	r3, [r7, #4]
     6ea:	85da      	strh	r2, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
     6ec:	687b      	ldr	r3, [r7, #4]
     6ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     6f0:	68fa      	ldr	r2, [r7, #12]
     6f2:	1ad3      	subs	r3, r2, r3
     6f4:	e017      	b.n	726 <tcp_update_rcv_ann_wnd+0x7a>
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
     6f6:	687b      	ldr	r3, [r7, #4]
     6f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     6fa:	687b      	ldr	r3, [r7, #4]
     6fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     6fe:	1ad3      	subs	r3, r2, r3
     700:	2b00      	cmp	r3, #0
     702:	dd04      	ble.n	70e <tcp_update_rcv_ann_wnd+0x62>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
     704:	687b      	ldr	r3, [r7, #4]
     706:	f04f 0200 	mov.w	r2, #0
     70a:	85da      	strh	r2, [r3, #46]	; 0x2e
     70c:	e009      	b.n	722 <tcp_update_rcv_ann_wnd+0x76>
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
     70e:	687b      	ldr	r3, [r7, #4]
     710:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     712:	687b      	ldr	r3, [r7, #4]
     714:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     716:	1ad3      	subs	r3, r2, r3
     718:	60bb      	str	r3, [r7, #8]
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
     71a:	68bb      	ldr	r3, [r7, #8]
     71c:	b29a      	uxth	r2, r3
     71e:	687b      	ldr	r3, [r7, #4]
     720:	85da      	strh	r2, [r3, #46]	; 0x2e
    }
    return 0;
     722:	f04f 0300 	mov.w	r3, #0
  }
}
     726:	4618      	mov	r0, r3
     728:	f107 0714 	add.w	r7, r7, #20
     72c:	46bd      	mov	sp, r7
     72e:	bc80      	pop	{r7}
     730:	4770      	bx	lr
     732:	bf00      	nop

00000734 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
     734:	b580      	push	{r7, lr}
     736:	b084      	sub	sp, #16
     738:	af00      	add	r7, sp, #0
     73a:	6078      	str	r0, [r7, #4]
     73c:	460b      	mov	r3, r1
     73e:	807b      	strh	r3, [r7, #2]
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
     740:	687b      	ldr	r3, [r7, #4]
     742:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
     744:	887b      	ldrh	r3, [r7, #2]
     746:	18d3      	adds	r3, r2, r3
     748:	b29a      	uxth	r2, r3
     74a:	687b      	ldr	r3, [r7, #4]
     74c:	859a      	strh	r2, [r3, #44]	; 0x2c
  if (pcb->rcv_wnd > TCP_WND) {
     74e:	687b      	ldr	r3, [r7, #4]
     750:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
     752:	f241 7370 	movw	r3, #6000	; 0x1770
     756:	429a      	cmp	r2, r3
     758:	d903      	bls.n	762 <tcp_recved+0x2e>
    pcb->rcv_wnd = TCP_WND;
     75a:	687b      	ldr	r3, [r7, #4]
     75c:	f241 7270 	movw	r2, #6000	; 0x1770
     760:	859a      	strh	r2, [r3, #44]	; 0x2c
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
     762:	6878      	ldr	r0, [r7, #4]
     764:	f7ff fffe 	bl	6ac <tcp_update_rcv_ann_wnd>
			764: R_ARM_THM_CALL	tcp_update_rcv_ann_wnd
     768:	4603      	mov	r3, r0
     76a:	60fb      	str	r3, [r7, #12]

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
     76c:	68fa      	ldr	r2, [r7, #12]
     76e:	f240 53db 	movw	r3, #1499	; 0x5db
     772:	429a      	cmp	r2, r3
     774:	dd09      	ble.n	78a <tcp_recved+0x56>
    tcp_ack_now(pcb);
     776:	687b      	ldr	r3, [r7, #4]
     778:	7f9b      	ldrb	r3, [r3, #30]
     77a:	f043 0302 	orr.w	r3, r3, #2
     77e:	b2da      	uxtb	r2, r3
     780:	687b      	ldr	r3, [r7, #4]
     782:	779a      	strb	r2, [r3, #30]
    tcp_output(pcb);
     784:	6878      	ldr	r0, [r7, #4]
     786:	f7ff fffe 	bl	0 <tcp_output>
			786: R_ARM_THM_CALL	tcp_output
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
     78a:	f107 0710 	add.w	r7, r7, #16
     78e:	46bd      	mov	sp, r7
     790:	bd80      	pop	{r7, pc}
     792:	bf00      	nop

00000794 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
     794:	b480      	push	{r7}
     796:	b083      	sub	sp, #12
     798:	af00      	add	r7, sp, #0
  u8_t i;
  u16_t n = 0;
     79a:	f04f 0300 	mov.w	r3, #0
     79e:	80bb      	strh	r3, [r7, #4]
     7a0:	e000      	b.n	7a4 <tcp_new_port+0x10>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
      if (pcb->local_port == tcp_port) {
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
          return 0;
        }
        goto again;
     7a2:	bf00      	nop
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
     7a4:	4b22      	ldr	r3, [pc, #136]	; (830 <tcp_new_port+0x9c>)
     7a6:	881b      	ldrh	r3, [r3, #0]
     7a8:	f64f 72ff 	movw	r2, #65535	; 0xffff
     7ac:	4293      	cmp	r3, r2
     7ae:	bf14      	ite	ne
     7b0:	2200      	movne	r2, #0
     7b2:	2201      	moveq	r2, #1
     7b4:	b2d2      	uxtb	r2, r2
     7b6:	f103 0301 	add.w	r3, r3, #1
     7ba:	b299      	uxth	r1, r3
     7bc:	4b1c      	ldr	r3, [pc, #112]	; (830 <tcp_new_port+0x9c>)
     7be:	8019      	strh	r1, [r3, #0]
     7c0:	2a00      	cmp	r2, #0
     7c2:	d003      	beq.n	7cc <tcp_new_port+0x38>
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
     7c4:	4b1a      	ldr	r3, [pc, #104]	; (830 <tcp_new_port+0x9c>)
     7c6:	f44f 4240 	mov.w	r2, #49152	; 0xc000
     7ca:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
     7cc:	f04f 0300 	mov.w	r3, #0
     7d0:	71fb      	strb	r3, [r7, #7]
     7d2:	e022      	b.n	81a <tcp_new_port+0x86>
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
     7d4:	79fa      	ldrb	r2, [r7, #7]
     7d6:	4b17      	ldr	r3, [pc, #92]	; (834 <tcp_new_port+0xa0>)
     7d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     7dc:	681b      	ldr	r3, [r3, #0]
     7de:	603b      	str	r3, [r7, #0]
     7e0:	e014      	b.n	80c <tcp_new_port+0x78>
      if (pcb->local_port == tcp_port) {
     7e2:	683b      	ldr	r3, [r7, #0]
     7e4:	8b5a      	ldrh	r2, [r3, #26]
     7e6:	4b12      	ldr	r3, [pc, #72]	; (830 <tcp_new_port+0x9c>)
     7e8:	881b      	ldrh	r3, [r3, #0]
     7ea:	429a      	cmp	r2, r3
     7ec:	d10b      	bne.n	806 <tcp_new_port+0x72>
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
     7ee:	88bb      	ldrh	r3, [r7, #4]
     7f0:	f103 0301 	add.w	r3, r3, #1
     7f4:	80bb      	strh	r3, [r7, #4]
     7f6:	88ba      	ldrh	r2, [r7, #4]
     7f8:	f643 73ff 	movw	r3, #16383	; 0x3fff
     7fc:	429a      	cmp	r2, r3
     7fe:	d9d0      	bls.n	7a2 <tcp_new_port+0xe>
          return 0;
     800:	f04f 0300 	mov.w	r3, #0
     804:	e00e      	b.n	824 <tcp_new_port+0x90>
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
     806:	683b      	ldr	r3, [r7, #0]
     808:	68db      	ldr	r3, [r3, #12]
     80a:	603b      	str	r3, [r7, #0]
     80c:	683b      	ldr	r3, [r7, #0]
     80e:	2b00      	cmp	r3, #0
     810:	d1e7      	bne.n	7e2 <tcp_new_port+0x4e>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
     812:	79fb      	ldrb	r3, [r7, #7]
     814:	f103 0301 	add.w	r3, r3, #1
     818:	71fb      	strb	r3, [r7, #7]
     81a:	79fb      	ldrb	r3, [r7, #7]
     81c:	2b03      	cmp	r3, #3
     81e:	d9d9      	bls.n	7d4 <tcp_new_port+0x40>
        }
        goto again;
      }
    }
  }
  return tcp_port;
     820:	4b03      	ldr	r3, [pc, #12]	; (830 <tcp_new_port+0x9c>)
     822:	881b      	ldrh	r3, [r3, #0]
}
     824:	4618      	mov	r0, r3
     826:	f107 070c 	add.w	r7, r7, #12
     82a:	46bd      	mov	sp, r7
     82c:	bc80      	pop	{r7}
     82e:	4770      	bx	lr
	...
			830: R_ARM_ABS32	.data
			834: R_ARM_ABS32	tcp_pcb_lists

00000838 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
     838:	b580      	push	{r7, lr}
     83a:	b088      	sub	sp, #32
     83c:	af00      	add	r7, sp, #0
     83e:	60f8      	str	r0, [r7, #12]
     840:	60b9      	str	r1, [r7, #8]
     842:	603b      	str	r3, [r7, #0]
     844:	4613      	mov	r3, r2
     846:	80fb      	strh	r3, [r7, #6]
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
     848:	68fb      	ldr	r3, [r7, #12]
     84a:	7e1b      	ldrb	r3, [r3, #24]
     84c:	2b00      	cmp	r3, #0
     84e:	d002      	beq.n	856 <tcp_connect+0x1e>
     850:	f04f 03f7 	mov.w	r3, #247	; 0xf7
     854:	e0cd      	b.n	9f2 <tcp_connect+0x1ba>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
     856:	68bb      	ldr	r3, [r7, #8]
     858:	2b00      	cmp	r3, #0
     85a:	d00a      	beq.n	872 <tcp_connect+0x3a>
    pcb->remote_ip = *ipaddr;
     85c:	68fb      	ldr	r3, [r7, #12]
     85e:	68ba      	ldr	r2, [r7, #8]
     860:	6812      	ldr	r2, [r2, #0]
     862:	605a      	str	r2, [r3, #4]
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
     864:	68fb      	ldr	r3, [r7, #12]
     866:	88fa      	ldrh	r2, [r7, #6]
     868:	839a      	strh	r2, [r3, #28]

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
     86a:	68fb      	ldr	r3, [r7, #12]
     86c:	2b00      	cmp	r3, #0
     86e:	d007      	beq.n	880 <tcp_connect+0x48>
     870:	e002      	b.n	878 <tcp_connect+0x40>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
     872:	f04f 03fa 	mov.w	r3, #250	; 0xfa
     876:	e0bc      	b.n	9f2 <tcp_connect+0x1ba>
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
     878:	68fb      	ldr	r3, [r7, #12]
     87a:	681b      	ldr	r3, [r3, #0]
     87c:	2b00      	cmp	r3, #0
     87e:	d110      	bne.n	8a2 <tcp_connect+0x6a>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->remote_ip));
     880:	68fb      	ldr	r3, [r7, #12]
     882:	f103 0304 	add.w	r3, r3, #4
     886:	4618      	mov	r0, r3
     888:	f7ff fffe 	bl	0 <ip_route>
			888: R_ARM_THM_CALL	ip_route
     88c:	61f8      	str	r0, [r7, #28]
    if (netif == NULL) {
     88e:	69fb      	ldr	r3, [r7, #28]
     890:	2b00      	cmp	r3, #0
     892:	d102      	bne.n	89a <tcp_connect+0x62>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
     894:	f04f 03fc 	mov.w	r3, #252	; 0xfc
     898:	e0ab      	b.n	9f2 <tcp_connect+0x1ba>
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
     89a:	69fb      	ldr	r3, [r7, #28]
     89c:	685a      	ldr	r2, [r3, #4]
     89e:	68fb      	ldr	r3, [r7, #12]
     8a0:	601a      	str	r2, [r3, #0]
  }

  old_local_port = pcb->local_port;
     8a2:	68fb      	ldr	r3, [r7, #12]
     8a4:	8b5b      	ldrh	r3, [r3, #26]
     8a6:	837b      	strh	r3, [r7, #26]
  if (pcb->local_port == 0) {
     8a8:	68fb      	ldr	r3, [r7, #12]
     8aa:	8b5b      	ldrh	r3, [r3, #26]
     8ac:	2b00      	cmp	r3, #0
     8ae:	d10c      	bne.n	8ca <tcp_connect+0x92>
    pcb->local_port = tcp_new_port();
     8b0:	f7ff ff70 	bl	794 <tcp_new_port>
     8b4:	4603      	mov	r3, r0
     8b6:	461a      	mov	r2, r3
     8b8:	68fb      	ldr	r3, [r7, #12]
     8ba:	835a      	strh	r2, [r3, #26]
    if (pcb->local_port == 0) {
     8bc:	68fb      	ldr	r3, [r7, #12]
     8be:	8b5b      	ldrh	r3, [r3, #26]
     8c0:	2b00      	cmp	r3, #0
     8c2:	d102      	bne.n	8ca <tcp_connect+0x92>
      return ERR_BUF;
     8c4:	f04f 03fe 	mov.w	r3, #254	; 0xfe
     8c8:	e093      	b.n	16b2 <tcp_debug_state_str+0xbe>
        }
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
     8ca:	f7ff fffe 	bl	1588 <tcp_next_iss>
			8ca: R_ARM_THM_CALL	tcp_next_iss
     8ce:	6178      	str	r0, [r7, #20]
  pcb->rcv_nxt = 0;
     8d0:	68fb      	ldr	r3, [r7, #12]
     8d2:	f04f 0200 	mov.w	r2, #0
     8d6:	629a      	str	r2, [r3, #40]	; 0x28
  pcb->snd_nxt = iss;
     8d8:	68fb      	ldr	r3, [r7, #12]
     8da:	697a      	ldr	r2, [r7, #20]
     8dc:	651a      	str	r2, [r3, #80]	; 0x50
  pcb->lastack = iss - 1;
     8de:	697b      	ldr	r3, [r7, #20]
     8e0:	f103 32ff 	add.w	r2, r3, #4294967295
     8e4:	68fb      	ldr	r3, [r7, #12]
     8e6:	649a      	str	r2, [r3, #72]	; 0x48
  pcb->snd_lbb = iss - 1;
     8e8:	697b      	ldr	r3, [r7, #20]
     8ea:	f103 32ff 	add.w	r2, r3, #4294967295
     8ee:	68fb      	ldr	r3, [r7, #12]
     8f0:	65da      	str	r2, [r3, #92]	; 0x5c
  pcb->rcv_wnd = TCP_WND;
     8f2:	68fb      	ldr	r3, [r7, #12]
     8f4:	f241 7270 	movw	r2, #6000	; 0x1770
     8f8:	859a      	strh	r2, [r3, #44]	; 0x2c
  pcb->rcv_ann_wnd = TCP_WND;
     8fa:	68fb      	ldr	r3, [r7, #12]
     8fc:	f241 7270 	movw	r2, #6000	; 0x1770
     900:	85da      	strh	r2, [r3, #46]	; 0x2e
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
     902:	68fb      	ldr	r3, [r7, #12]
     904:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     906:	68fb      	ldr	r3, [r7, #12]
     908:	631a      	str	r2, [r3, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
     90a:	68fb      	ldr	r3, [r7, #12]
     90c:	f241 7270 	movw	r2, #6000	; 0x1770
     910:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
     914:	68fb      	ldr	r3, [r7, #12]
     916:	f44f 7206 	mov.w	r2, #536	; 0x218
     91a:	86da      	strh	r2, [r3, #54]	; 0x36
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
     91c:	68fb      	ldr	r3, [r7, #12]
     91e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     920:	4618      	mov	r0, r3
     922:	68b9      	ldr	r1, [r7, #8]
     924:	f7ff fffe 	bl	15b0 <tcp_eff_send_mss>
			924: R_ARM_THM_CALL	tcp_eff_send_mss
     928:	4603      	mov	r3, r0
     92a:	461a      	mov	r2, r3
     92c:	68fb      	ldr	r3, [r7, #12]
     92e:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
     930:	68fb      	ldr	r3, [r7, #12]
     932:	f04f 0201 	mov.w	r2, #1
     936:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
  pcb->ssthresh = pcb->mss * 10;
     93a:	68fb      	ldr	r3, [r7, #12]
     93c:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     93e:	461a      	mov	r2, r3
     940:	ea4f 0282 	mov.w	r2, r2, lsl #2
     944:	18d3      	adds	r3, r2, r3
     946:	ea4f 0343 	mov.w	r3, r3, lsl #1
     94a:	b29a      	uxth	r2, r3
     94c:	68fb      	ldr	r3, [r7, #12]
     94e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
#if LWIP_CALLBACK_API
  pcb->connected = connected;
     952:	68fb      	ldr	r3, [r7, #12]
     954:	683a      	ldr	r2, [r7, #0]
     956:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
     95a:	68f8      	ldr	r0, [r7, #12]
     95c:	f04f 0102 	mov.w	r1, #2
     960:	f7ff fffe 	bl	0 <tcp_enqueue_flags>
			960: R_ARM_THM_CALL	tcp_enqueue_flags
     964:	4603      	mov	r3, r0
     966:	74fb      	strb	r3, [r7, #19]
  if (ret == ERR_OK) {
     968:	f997 3013 	ldrsb.w	r3, [r7, #19]
     96c:	2b00      	cmp	r3, #0
     96e:	d13f      	bne.n	9f0 <tcp_connect+0x1b8>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
     970:	68fb      	ldr	r3, [r7, #12]
     972:	f04f 0202 	mov.w	r2, #2
     976:	761a      	strb	r2, [r3, #24]
    if (old_local_port != 0) {
     978:	8b7b      	ldrh	r3, [r7, #26]
     97a:	2b00      	cmp	r3, #0
     97c:	d028      	beq.n	9d0 <tcp_connect+0x198>
      TCP_RMV(&tcp_bound_pcbs, pcb);
     97e:	4b20      	ldr	r3, [pc, #128]	; (a00 <tcp_connect+0x1c8>)
     980:	681a      	ldr	r2, [r3, #0]
     982:	68fb      	ldr	r3, [r7, #12]
     984:	429a      	cmp	r2, r3
     986:	d105      	bne.n	994 <tcp_connect+0x15c>
     988:	4b1d      	ldr	r3, [pc, #116]	; (a00 <tcp_connect+0x1c8>)
     98a:	681b      	ldr	r3, [r3, #0]
     98c:	68da      	ldr	r2, [r3, #12]
     98e:	4b1c      	ldr	r3, [pc, #112]	; (a00 <tcp_connect+0x1c8>)
     990:	601a      	str	r2, [r3, #0]
     992:	e019      	b.n	9c8 <tcp_connect+0x190>
     994:	4b1a      	ldr	r3, [pc, #104]	; (a00 <tcp_connect+0x1c8>)
     996:	681a      	ldr	r2, [r3, #0]
     998:	4b1a      	ldr	r3, [pc, #104]	; (a04 <tcp_connect+0x1cc>)
     99a:	601a      	str	r2, [r3, #0]
     99c:	e010      	b.n	9c0 <tcp_connect+0x188>
     99e:	4b19      	ldr	r3, [pc, #100]	; (a04 <tcp_connect+0x1cc>)
     9a0:	681b      	ldr	r3, [r3, #0]
     9a2:	68da      	ldr	r2, [r3, #12]
     9a4:	68fb      	ldr	r3, [r7, #12]
     9a6:	429a      	cmp	r2, r3
     9a8:	d105      	bne.n	9b6 <tcp_connect+0x17e>
     9aa:	4b16      	ldr	r3, [pc, #88]	; (a04 <tcp_connect+0x1cc>)
     9ac:	681b      	ldr	r3, [r3, #0]
     9ae:	68fa      	ldr	r2, [r7, #12]
     9b0:	68d2      	ldr	r2, [r2, #12]
     9b2:	60da      	str	r2, [r3, #12]
     9b4:	e008      	b.n	9c8 <tcp_connect+0x190>
     9b6:	4b13      	ldr	r3, [pc, #76]	; (a04 <tcp_connect+0x1cc>)
     9b8:	681b      	ldr	r3, [r3, #0]
     9ba:	68da      	ldr	r2, [r3, #12]
     9bc:	4b11      	ldr	r3, [pc, #68]	; (a04 <tcp_connect+0x1cc>)
     9be:	601a      	str	r2, [r3, #0]
     9c0:	4b10      	ldr	r3, [pc, #64]	; (a04 <tcp_connect+0x1cc>)
     9c2:	681b      	ldr	r3, [r3, #0]
     9c4:	2b00      	cmp	r3, #0
     9c6:	d1ea      	bne.n	99e <tcp_connect+0x166>
     9c8:	68fb      	ldr	r3, [r7, #12]
     9ca:	f04f 0200 	mov.w	r2, #0
     9ce:	60da      	str	r2, [r3, #12]
    }
    TCP_REG_ACTIVE(pcb);
     9d0:	4b0d      	ldr	r3, [pc, #52]	; (a08 <tcp_connect+0x1d0>)
     9d2:	681a      	ldr	r2, [r3, #0]
     9d4:	68fb      	ldr	r3, [r7, #12]
     9d6:	60da      	str	r2, [r3, #12]
     9d8:	4b0b      	ldr	r3, [pc, #44]	; (a08 <tcp_connect+0x1d0>)
     9da:	68fa      	ldr	r2, [r7, #12]
     9dc:	601a      	str	r2, [r3, #0]
     9de:	f7ff fffe 	bl	0 <tcp_timer_needed>
			9de: R_ARM_THM_CALL	tcp_timer_needed
     9e2:	4b0a      	ldr	r3, [pc, #40]	; (a0c <tcp_connect+0x1d4>)
     9e4:	f04f 0201 	mov.w	r2, #1
     9e8:	701a      	strb	r2, [r3, #0]
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
     9ea:	68f8      	ldr	r0, [r7, #12]
     9ec:	f7ff fffe 	bl	0 <tcp_output>
			9ec: R_ARM_THM_CALL	tcp_output
  }
  return ret;
     9f0:	7cfb      	ldrb	r3, [r7, #19]
     9f2:	b25b      	sxtb	r3, r3
}
     9f4:	4618      	mov	r0, r3
     9f6:	f107 0720 	add.w	r7, r7, #32
     9fa:	46bd      	mov	sp, r7
     9fc:	bd80      	pop	{r7, pc}
     9fe:	bf00      	nop
	...
			a00: R_ARM_ABS32	tcp_bound_pcbs
			a04: R_ARM_ABS32	tcp_tmp_pcb
			a08: R_ARM_ABS32	tcp_active_pcbs
			a0c: R_ARM_ABS32	tcp_active_pcbs_changed

00000a10 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
     a10:	b5b0      	push	{r4, r5, r7, lr}
     a12:	b08a      	sub	sp, #40	; 0x28
     a14:	af02      	add	r7, sp, #8
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;
     a16:	f04f 0300 	mov.w	r3, #0
     a1a:	757b      	strb	r3, [r7, #21]

  ++tcp_ticks;
     a1c:	4b8a      	ldr	r3, [pc, #552]	; (c48 <tcp_slowtmr+0x238>)
     a1e:	681b      	ldr	r3, [r3, #0]
     a20:	f103 0201 	add.w	r2, r3, #1
     a24:	4b88      	ldr	r3, [pc, #544]	; (c48 <tcp_slowtmr+0x238>)
     a26:	601a      	str	r2, [r3, #0]
  ++tcp_timer_ctr;
     a28:	4b88      	ldr	r3, [pc, #544]	; (c4c <tcp_slowtmr+0x23c>)
     a2a:	781b      	ldrb	r3, [r3, #0]
     a2c:	f103 0301 	add.w	r3, r3, #1
     a30:	b2da      	uxtb	r2, r3
     a32:	4b86      	ldr	r3, [pc, #536]	; (c4c <tcp_slowtmr+0x23c>)
     a34:	701a      	strb	r2, [r3, #0]
     a36:	e000      	b.n	a3a <tcp_slowtmr+0x2a>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
        TCP_EVENT_POLL(prev, err);
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
     a38:	bf00      	nop
  ++tcp_ticks;
  ++tcp_timer_ctr;

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
     a3a:	f04f 0300 	mov.w	r3, #0
     a3e:	61bb      	str	r3, [r7, #24]
  pcb = tcp_active_pcbs;
     a40:	4b83      	ldr	r3, [pc, #524]	; (c50 <tcp_slowtmr+0x240>)
     a42:	681b      	ldr	r3, [r3, #0]
     a44:	61fb      	str	r3, [r7, #28]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
     a46:	e1ec      	b.n	e22 <tcp_slowtmr+0x412>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
    if (pcb->last_timer == tcp_timer_ctr) {
     a48:	69fb      	ldr	r3, [r7, #28]
     a4a:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
     a4e:	4b7f      	ldr	r3, [pc, #508]	; (c4c <tcp_slowtmr+0x23c>)
     a50:	781b      	ldrb	r3, [r3, #0]
     a52:	429a      	cmp	r2, r3
     a54:	d103      	bne.n	a5e <tcp_slowtmr+0x4e>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
     a56:	69fb      	ldr	r3, [r7, #28]
     a58:	68db      	ldr	r3, [r3, #12]
     a5a:	61fb      	str	r3, [r7, #28]
      continue;
     a5c:	e1e1      	b.n	e22 <tcp_slowtmr+0x412>
    }
    pcb->last_timer = tcp_timer_ctr;
     a5e:	4b7b      	ldr	r3, [pc, #492]	; (c4c <tcp_slowtmr+0x23c>)
     a60:	781a      	ldrb	r2, [r3, #0]
     a62:	69fb      	ldr	r3, [r7, #28]
     a64:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    pcb_remove = 0;
     a68:	f04f 0300 	mov.w	r3, #0
     a6c:	75fb      	strb	r3, [r7, #23]
    pcb_reset = 0;
     a6e:	f04f 0300 	mov.w	r3, #0
     a72:	75bb      	strb	r3, [r7, #22]

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
     a74:	69fb      	ldr	r3, [r7, #28]
     a76:	7e1b      	ldrb	r3, [r3, #24]
     a78:	2b02      	cmp	r3, #2
     a7a:	d109      	bne.n	a90 <tcp_slowtmr+0x80>
     a7c:	69fb      	ldr	r3, [r7, #28]
     a7e:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
     a82:	2b06      	cmp	r3, #6
     a84:	d104      	bne.n	a90 <tcp_slowtmr+0x80>
      ++pcb_remove;
     a86:	7dfb      	ldrb	r3, [r7, #23]
     a88:	f103 0301 	add.w	r3, r3, #1
     a8c:	75fb      	strb	r3, [r7, #23]
     a8e:	e09e      	b.n	bce <tcp_slowtmr+0x1be>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
     a90:	69fb      	ldr	r3, [r7, #28]
     a92:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
     a96:	2b0c      	cmp	r3, #12
     a98:	d104      	bne.n	aa4 <tcp_slowtmr+0x94>
      ++pcb_remove;
     a9a:	7dfb      	ldrb	r3, [r7, #23]
     a9c:	f103 0301 	add.w	r3, r3, #1
     aa0:	75fb      	strb	r3, [r7, #23]
     aa2:	e094      	b.n	bce <tcp_slowtmr+0x1be>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
     aa4:	69fb      	ldr	r3, [r7, #28]
     aa6:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
     aaa:	2b00      	cmp	r3, #0
     aac:	d02b      	beq.n	b06 <tcp_slowtmr+0xf6>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
     aae:	69fb      	ldr	r3, [r7, #28]
     ab0:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
     ab4:	f103 0301 	add.w	r3, r3, #1
     ab8:	b2da      	uxtb	r2, r3
     aba:	69fb      	ldr	r3, [r7, #28]
     abc:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
     ac0:	69fb      	ldr	r3, [r7, #28]
     ac2:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
     ac6:	69fb      	ldr	r3, [r7, #28]
     ac8:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
     acc:	f103 33ff 	add.w	r3, r3, #4294967295
     ad0:	4960      	ldr	r1, [pc, #384]	; (c54 <tcp_slowtmr+0x244>)
     ad2:	5ccb      	ldrb	r3, [r1, r3]
     ad4:	429a      	cmp	r2, r3
     ad6:	d37a      	bcc.n	bce <tcp_slowtmr+0x1be>
          pcb->persist_cnt = 0;
     ad8:	69fb      	ldr	r3, [r7, #28]
     ada:	f04f 0200 	mov.w	r2, #0
     ade:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
     ae2:	69fb      	ldr	r3, [r7, #28]
     ae4:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
     ae8:	2b06      	cmp	r3, #6
     aea:	d808      	bhi.n	afe <tcp_slowtmr+0xee>
            pcb->persist_backoff++;
     aec:	69fb      	ldr	r3, [r7, #28]
     aee:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
     af2:	f103 0301 	add.w	r3, r3, #1
     af6:	b2da      	uxtb	r2, r3
     af8:	69fb      	ldr	r3, [r7, #28]
     afa:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
          }
          tcp_zero_window_probe(pcb);
     afe:	69f8      	ldr	r0, [r7, #28]
     b00:	f7ff fffe 	bl	0 <tcp_zero_window_probe>
			b00: R_ARM_THM_CALL	tcp_zero_window_probe
     b04:	e063      	b.n	bce <tcp_slowtmr+0x1be>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
     b06:	69fb      	ldr	r3, [r7, #28]
     b08:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
     b0a:	b21b      	sxth	r3, r3
     b0c:	2b00      	cmp	r3, #0
     b0e:	db06      	blt.n	b1e <tcp_slowtmr+0x10e>
          ++pcb->rtime;
     b10:	69fb      	ldr	r3, [r7, #28]
     b12:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
     b14:	f103 0301 	add.w	r3, r3, #1
     b18:	b29a      	uxth	r2, r3
     b1a:	69fb      	ldr	r3, [r7, #28]
     b1c:	869a      	strh	r2, [r3, #52]	; 0x34
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
     b1e:	69fb      	ldr	r3, [r7, #28]
     b20:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     b22:	2b00      	cmp	r3, #0
     b24:	d053      	beq.n	bce <tcp_slowtmr+0x1be>
     b26:	69fb      	ldr	r3, [r7, #28]
     b28:	8e9a      	ldrh	r2, [r3, #52]	; 0x34
     b2a:	69fb      	ldr	r3, [r7, #28]
     b2c:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
     b30:	b212      	sxth	r2, r2
     b32:	b21b      	sxth	r3, r3
     b34:	429a      	cmp	r2, r3
     b36:	db4a      	blt.n	bce <tcp_slowtmr+0x1be>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
     b38:	69fb      	ldr	r3, [r7, #28]
     b3a:	7e1b      	ldrb	r3, [r3, #24]
     b3c:	2b02      	cmp	r3, #2
     b3e:	d017      	beq.n	b70 <tcp_slowtmr+0x160>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
     b40:	69fb      	ldr	r3, [r7, #28]
     b42:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
     b46:	b21b      	sxth	r3, r3
     b48:	ea4f 03e3 	mov.w	r3, r3, asr #3
     b4c:	b29b      	uxth	r3, r3
     b4e:	b21a      	sxth	r2, r3
     b50:	69fb      	ldr	r3, [r7, #28]
     b52:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
     b56:	b21b      	sxth	r3, r3
     b58:	18d2      	adds	r2, r2, r3
     b5a:	69fb      	ldr	r3, [r7, #28]
     b5c:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
     b60:	493d      	ldr	r1, [pc, #244]	; (c58 <tcp_slowtmr+0x248>)
     b62:	5ccb      	ldrb	r3, [r1, r3]
     b64:	fa02 f303 	lsl.w	r3, r2, r3
     b68:	b29a      	uxth	r2, r3
     b6a:	69fb      	ldr	r3, [r7, #28]
     b6c:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
     b70:	69fb      	ldr	r3, [r7, #28]
     b72:	f04f 0200 	mov.w	r2, #0
     b76:	869a      	strh	r2, [r3, #52]	; 0x34

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
     b78:	69fb      	ldr	r3, [r7, #28]
     b7a:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
     b7e:	69fb      	ldr	r3, [r7, #28]
     b80:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
     b84:	429a      	cmp	r2, r3
     b86:	bf38      	it	cc
     b88:	4613      	movcc	r3, r2
     b8a:	827b      	strh	r3, [r7, #18]
          pcb->ssthresh = eff_wnd >> 1;
     b8c:	8a7b      	ldrh	r3, [r7, #18]
     b8e:	ea4f 0353 	mov.w	r3, r3, lsr #1
     b92:	b29a      	uxth	r2, r3
     b94:	69fb      	ldr	r3, [r7, #28]
     b96:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
          if (pcb->ssthresh < (pcb->mss << 1)) {
     b9a:	69fb      	ldr	r3, [r7, #28]
     b9c:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
     ba0:	461a      	mov	r2, r3
     ba2:	69fb      	ldr	r3, [r7, #28]
     ba4:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     ba6:	ea4f 0343 	mov.w	r3, r3, lsl #1
     baa:	429a      	cmp	r2, r3
     bac:	da07      	bge.n	bbe <tcp_slowtmr+0x1ae>
            pcb->ssthresh = (pcb->mss << 1);
     bae:	69fb      	ldr	r3, [r7, #28]
     bb0:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     bb2:	ea4f 0343 	mov.w	r3, r3, lsl #1
     bb6:	b29a      	uxth	r2, r3
     bb8:	69fb      	ldr	r3, [r7, #28]
     bba:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
          }
          pcb->cwnd = pcb->mss;
     bbe:	69fb      	ldr	r3, [r7, #28]
     bc0:	8eda      	ldrh	r2, [r3, #54]	; 0x36
     bc2:	69fb      	ldr	r3, [r7, #28]
     bc4:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
     bc8:	69f8      	ldr	r0, [r7, #28]
     bca:	f7ff fffe 	bl	0 <tcp_rexmit_rto>
			bca: R_ARM_THM_CALL	tcp_rexmit_rto
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
     bce:	69fb      	ldr	r3, [r7, #28]
     bd0:	7e1b      	ldrb	r3, [r3, #24]
     bd2:	2b06      	cmp	r3, #6
     bd4:	d110      	bne.n	bf8 <tcp_slowtmr+0x1e8>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
     bd6:	69fb      	ldr	r3, [r7, #28]
     bd8:	7f9b      	ldrb	r3, [r3, #30]
     bda:	f003 0310 	and.w	r3, r3, #16
     bde:	2b00      	cmp	r3, #0
     be0:	d00a      	beq.n	bf8 <tcp_slowtmr+0x1e8>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
     be2:	4b19      	ldr	r3, [pc, #100]	; (c48 <tcp_slowtmr+0x238>)
     be4:	681a      	ldr	r2, [r3, #0]
     be6:	69fb      	ldr	r3, [r7, #28]
     be8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     bea:	1ad3      	subs	r3, r2, r3
     bec:	2b28      	cmp	r3, #40	; 0x28
     bee:	d903      	bls.n	bf8 <tcp_slowtmr+0x1e8>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
     bf0:	7dfb      	ldrb	r3, [r7, #23]
     bf2:	f103 0301 	add.w	r3, r3, #1
     bf6:	75fb      	strb	r3, [r7, #23]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
     bf8:	69fb      	ldr	r3, [r7, #28]
     bfa:	7a1b      	ldrb	r3, [r3, #8]
     bfc:	f003 0308 	and.w	r3, r3, #8
     c00:	2b00      	cmp	r3, #0
     c02:	d051      	beq.n	ca8 <tcp_slowtmr+0x298>
       ((pcb->state == ESTABLISHED) ||
     c04:	69fb      	ldr	r3, [r7, #28]
     c06:	7e1b      	ldrb	r3, [r3, #24]
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
     c08:	2b04      	cmp	r3, #4
     c0a:	d003      	beq.n	c14 <tcp_slowtmr+0x204>
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
     c0c:	69fb      	ldr	r3, [r7, #28]
     c0e:	7e1b      	ldrb	r3, [r3, #24]
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
     c10:	2b07      	cmp	r3, #7
     c12:	d149      	bne.n	ca8 <tcp_slowtmr+0x298>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
     c14:	4b0c      	ldr	r3, [pc, #48]	; (c48 <tcp_slowtmr+0x238>)
     c16:	681a      	ldr	r2, [r3, #0]
     c18:	69fb      	ldr	r3, [r7, #28]
     c1a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c1c:	1ad2      	subs	r2, r2, r3
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
     c1e:	69fb      	ldr	r3, [r7, #28]
     c20:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
     c24:	4b0d      	ldr	r3, [pc, #52]	; (c5c <tcp_slowtmr+0x24c>)
     c26:	18cb      	adds	r3, r1, r3
     c28:	490d      	ldr	r1, [pc, #52]	; (c60 <tcp_slowtmr+0x250>)
     c2a:	fba1 0303 	umull	r0, r3, r1, r3
     c2e:	ea4f 1353 	mov.w	r3, r3, lsr #5

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
     c32:	429a      	cmp	r2, r3
     c34:	d916      	bls.n	c64 <tcp_slowtmr+0x254>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
     c36:	7dfb      	ldrb	r3, [r7, #23]
     c38:	f103 0301 	add.w	r3, r3, #1
     c3c:	75fb      	strb	r3, [r7, #23]
        ++pcb_reset;
     c3e:	7dbb      	ldrb	r3, [r7, #22]
     c40:	f103 0301 	add.w	r3, r3, #1
     c44:	75bb      	strb	r3, [r7, #22]
     c46:	e02f      	b.n	ca8 <tcp_slowtmr+0x298>
     c48:	00000000 	.word	0x00000000
			c48: R_ARM_ABS32	tcp_ticks
     c4c:	00000001 	.word	0x00000001
			c4c: R_ARM_ABS32	.bss
	...
			c50: R_ARM_ABS32	tcp_active_pcbs
			c54: R_ARM_ABS32	tcp_persist_backoff
			c58: R_ARM_ABS32	tcp_backoff
     c5c:	000a4cb8 	.word	0x000a4cb8
     c60:	10624dd3 	.word	0x10624dd3
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
     c64:	4b8a      	ldr	r3, [pc, #552]	; (e90 <tcp_slowtmr+0x480>)
     c66:	681a      	ldr	r2, [r3, #0]
     c68:	69fb      	ldr	r3, [r7, #28]
     c6a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c6c:	1ad2      	subs	r2, r2, r3
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
     c6e:	69fb      	ldr	r3, [r7, #28]
     c70:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
     c74:	69fb      	ldr	r3, [r7, #28]
     c76:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
     c7a:	4886      	ldr	r0, [pc, #536]	; (e94 <tcp_slowtmr+0x484>)
     c7c:	fb00 f303 	mul.w	r3, r0, r3
     c80:	18c9      	adds	r1, r1, r3
              / TCP_SLOW_INTERVAL)
     c82:	4b85      	ldr	r3, [pc, #532]	; (e98 <tcp_slowtmr+0x488>)
     c84:	fba3 0301 	umull	r0, r3, r3, r1
     c88:	ea4f 1353 	mov.w	r3, r3, lsr #5
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
     c8c:	429a      	cmp	r2, r3
     c8e:	d90b      	bls.n	ca8 <tcp_slowtmr+0x298>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
     c90:	69f8      	ldr	r0, [r7, #28]
     c92:	f7ff fffe 	bl	0 <tcp_keepalive>
			c92: R_ARM_THM_CALL	tcp_keepalive
        pcb->keep_cnt_sent++;
     c96:	69fb      	ldr	r3, [r7, #28]
     c98:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
     c9c:	f103 0301 	add.w	r3, r3, #1
     ca0:	b2da      	uxtb	r2, r3
     ca2:	69fb      	ldr	r3, [r7, #28]
     ca4:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
     ca8:	69fb      	ldr	r3, [r7, #28]
     caa:	6f5b      	ldr	r3, [r3, #116]	; 0x74
     cac:	2b00      	cmp	r3, #0
     cae:	d019      	beq.n	ce4 <tcp_slowtmr+0x2d4>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
     cb0:	4b77      	ldr	r3, [pc, #476]	; (e90 <tcp_slowtmr+0x480>)
     cb2:	681a      	ldr	r2, [r3, #0]
     cb4:	69fb      	ldr	r3, [r7, #28]
     cb6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     cb8:	1ad1      	subs	r1, r2, r3
     cba:	69fb      	ldr	r3, [r7, #28]
     cbc:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
     cc0:	b21a      	sxth	r2, r3
     cc2:	4613      	mov	r3, r2
     cc4:	ea4f 0343 	mov.w	r3, r3, lsl #1
     cc8:	189b      	adds	r3, r3, r2
     cca:	ea4f 0343 	mov.w	r3, r3, lsl #1

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL &&
     cce:	4299      	cmp	r1, r3
     cd0:	d308      	bcc.n	ce4 <tcp_slowtmr+0x2d4>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
     cd2:	69fb      	ldr	r3, [r7, #28]
     cd4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
     cd6:	4618      	mov	r0, r3
     cd8:	f7ff fffe 	bl	1054 <tcp_segs_free>
			cd8: R_ARM_THM_CALL	tcp_segs_free
      pcb->ooseq = NULL;
     cdc:	69fb      	ldr	r3, [r7, #28]
     cde:	f04f 0200 	mov.w	r2, #0
     ce2:	675a      	str	r2, [r3, #116]	; 0x74
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
     ce4:	69fb      	ldr	r3, [r7, #28]
     ce6:	7e1b      	ldrb	r3, [r3, #24]
     ce8:	2b03      	cmp	r3, #3
     cea:	d10a      	bne.n	d02 <tcp_slowtmr+0x2f2>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
     cec:	4b68      	ldr	r3, [pc, #416]	; (e90 <tcp_slowtmr+0x480>)
     cee:	681a      	ldr	r2, [r3, #0]
     cf0:	69fb      	ldr	r3, [r7, #28]
     cf2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     cf4:	1ad3      	subs	r3, r2, r3
     cf6:	2b28      	cmp	r3, #40	; 0x28
     cf8:	d903      	bls.n	d02 <tcp_slowtmr+0x2f2>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
     cfa:	7dfb      	ldrb	r3, [r7, #23]
     cfc:	f103 0301 	add.w	r3, r3, #1
     d00:	75fb      	strb	r3, [r7, #23]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
     d02:	69fb      	ldr	r3, [r7, #28]
     d04:	7e1b      	ldrb	r3, [r3, #24]
     d06:	2b09      	cmp	r3, #9
     d08:	d10a      	bne.n	d20 <tcp_slowtmr+0x310>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
     d0a:	4b61      	ldr	r3, [pc, #388]	; (e90 <tcp_slowtmr+0x480>)
     d0c:	681a      	ldr	r2, [r3, #0]
     d0e:	69fb      	ldr	r3, [r7, #28]
     d10:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     d12:	1ad3      	subs	r3, r2, r3
     d14:	2bf0      	cmp	r3, #240	; 0xf0
     d16:	d903      	bls.n	d20 <tcp_slowtmr+0x310>
        ++pcb_remove;
     d18:	7dfb      	ldrb	r3, [r7, #23]
     d1a:	f103 0301 	add.w	r3, r3, #1
     d1e:	75fb      	strb	r3, [r7, #23]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
     d20:	7dfb      	ldrb	r3, [r7, #23]
     d22:	2b00      	cmp	r3, #0
     d24:	d043      	beq.n	dae <tcp_slowtmr+0x39e>
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
     d26:	69f8      	ldr	r0, [r7, #28]
     d28:	f7ff fffe 	bl	144c <tcp_pcb_purge>
			d28: R_ARM_THM_CALL	tcp_pcb_purge
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
     d2c:	69bb      	ldr	r3, [r7, #24]
     d2e:	2b00      	cmp	r3, #0
     d30:	d004      	beq.n	d3c <tcp_slowtmr+0x32c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
     d32:	69fb      	ldr	r3, [r7, #28]
     d34:	68da      	ldr	r2, [r3, #12]
     d36:	69bb      	ldr	r3, [r7, #24]
     d38:	60da      	str	r2, [r3, #12]
     d3a:	e003      	b.n	d44 <tcp_slowtmr+0x334>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
     d3c:	69fb      	ldr	r3, [r7, #28]
     d3e:	68da      	ldr	r2, [r3, #12]
     d40:	4b56      	ldr	r3, [pc, #344]	; (e9c <tcp_slowtmr+0x48c>)
     d42:	601a      	str	r2, [r3, #0]
      }

      if (pcb_reset) {
     d44:	7dbb      	ldrb	r3, [r7, #22]
     d46:	2b00      	cmp	r3, #0
     d48:	d00f      	beq.n	d6a <tcp_slowtmr+0x35a>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
     d4a:	69fb      	ldr	r3, [r7, #28]
     d4c:	6d18      	ldr	r0, [r3, #80]	; 0x50
     d4e:	69fb      	ldr	r3, [r7, #28]
     d50:	6a99      	ldr	r1, [r3, #40]	; 0x28
     d52:	69fa      	ldr	r2, [r7, #28]
     d54:	69fb      	ldr	r3, [r7, #28]
     d56:	f103 0304 	add.w	r3, r3, #4
          pcb->local_port, pcb->remote_port);
     d5a:	69fc      	ldr	r4, [r7, #28]
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
     d5c:	8b65      	ldrh	r5, [r4, #26]
          pcb->local_port, pcb->remote_port);
     d5e:	69fc      	ldr	r4, [r7, #28]
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
     d60:	8ba4      	ldrh	r4, [r4, #28]
     d62:	9500      	str	r5, [sp, #0]
     d64:	9401      	str	r4, [sp, #4]
     d66:	f7ff fffe 	bl	0 <tcp_rst>
			d66: R_ARM_THM_CALL	tcp_rst
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
     d6a:	69fb      	ldr	r3, [r7, #28]
     d6c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
     d70:	60fb      	str	r3, [r7, #12]
      err_arg = pcb->callback_arg;
     d72:	69fb      	ldr	r3, [r7, #28]
     d74:	691b      	ldr	r3, [r3, #16]
     d76:	60bb      	str	r3, [r7, #8]
      pcb2 = pcb;
     d78:	69fb      	ldr	r3, [r7, #28]
     d7a:	607b      	str	r3, [r7, #4]
      pcb = pcb->next;
     d7c:	69fb      	ldr	r3, [r7, #28]
     d7e:	68db      	ldr	r3, [r3, #12]
     d80:	61fb      	str	r3, [r7, #28]
      memp_free(MEMP_TCP_PCB, pcb2);
     d82:	f04f 0002 	mov.w	r0, #2
     d86:	6879      	ldr	r1, [r7, #4]
     d88:	f7ff fffe 	bl	0 <memp_free>
			d88: R_ARM_THM_CALL	memp_free

      tcp_active_pcbs_changed = 0;
     d8c:	4b44      	ldr	r3, [pc, #272]	; (ea0 <tcp_slowtmr+0x490>)
     d8e:	f04f 0200 	mov.w	r2, #0
     d92:	701a      	strb	r2, [r3, #0]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
     d94:	68fb      	ldr	r3, [r7, #12]
     d96:	2b00      	cmp	r3, #0
     d98:	d004      	beq.n	da4 <tcp_slowtmr+0x394>
     d9a:	68fb      	ldr	r3, [r7, #12]
     d9c:	68b8      	ldr	r0, [r7, #8]
     d9e:	f06f 0109 	mvn.w	r1, #9
     da2:	4798      	blx	r3
      if (tcp_active_pcbs_changed) {
     da4:	4b3e      	ldr	r3, [pc, #248]	; (ea0 <tcp_slowtmr+0x490>)
     da6:	781b      	ldrb	r3, [r3, #0]
     da8:	2b00      	cmp	r3, #0
     daa:	d03a      	beq.n	e22 <tcp_slowtmr+0x412>
        goto tcp_slowtmr_start;
     dac:	e645      	b.n	a3a <tcp_slowtmr+0x2a>
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
     dae:	69fb      	ldr	r3, [r7, #28]
     db0:	61bb      	str	r3, [r7, #24]
      pcb = pcb->next;
     db2:	69fb      	ldr	r3, [r7, #28]
     db4:	68db      	ldr	r3, [r3, #12]
     db6:	61fb      	str	r3, [r7, #28]

      /* We check if we should poll the connection. */
      ++prev->polltmr;
     db8:	69bb      	ldr	r3, [r7, #24]
     dba:	7fdb      	ldrb	r3, [r3, #31]
     dbc:	f103 0301 	add.w	r3, r3, #1
     dc0:	b2da      	uxtb	r2, r3
     dc2:	69bb      	ldr	r3, [r7, #24]
     dc4:	77da      	strb	r2, [r3, #31]
      if (prev->polltmr >= prev->pollinterval) {
     dc6:	69bb      	ldr	r3, [r7, #24]
     dc8:	7fda      	ldrb	r2, [r3, #31]
     dca:	69bb      	ldr	r3, [r7, #24]
     dcc:	f893 3020 	ldrb.w	r3, [r3, #32]
     dd0:	429a      	cmp	r2, r3
     dd2:	d326      	bcc.n	e22 <tcp_slowtmr+0x412>
        prev->polltmr = 0;
     dd4:	69bb      	ldr	r3, [r7, #24]
     dd6:	f04f 0200 	mov.w	r2, #0
     dda:	77da      	strb	r2, [r3, #31]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
     ddc:	4b30      	ldr	r3, [pc, #192]	; (ea0 <tcp_slowtmr+0x490>)
     dde:	f04f 0200 	mov.w	r2, #0
     de2:	701a      	strb	r2, [r3, #0]
        TCP_EVENT_POLL(prev, err);
     de4:	69bb      	ldr	r3, [r7, #24]
     de6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     dea:	2b00      	cmp	r3, #0
     dec:	d00a      	beq.n	e04 <tcp_slowtmr+0x3f4>
     dee:	69bb      	ldr	r3, [r7, #24]
     df0:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
     df4:	69ba      	ldr	r2, [r7, #24]
     df6:	6912      	ldr	r2, [r2, #16]
     df8:	4610      	mov	r0, r2
     dfa:	69b9      	ldr	r1, [r7, #24]
     dfc:	4798      	blx	r3
     dfe:	4603      	mov	r3, r0
     e00:	757b      	strb	r3, [r7, #21]
     e02:	e002      	b.n	e0a <tcp_slowtmr+0x3fa>
     e04:	f04f 0300 	mov.w	r3, #0
     e08:	757b      	strb	r3, [r7, #21]
        if (tcp_active_pcbs_changed) {
     e0a:	4b25      	ldr	r3, [pc, #148]	; (ea0 <tcp_slowtmr+0x490>)
     e0c:	781b      	ldrb	r3, [r3, #0]
     e0e:	2b00      	cmp	r3, #0
     e10:	f47f ae12 	bne.w	a38 <tcp_slowtmr+0x28>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
     e14:	f997 3015 	ldrsb.w	r3, [r7, #21]
     e18:	2b00      	cmp	r3, #0
     e1a:	d102      	bne.n	e22 <tcp_slowtmr+0x412>
          tcp_output(prev);
     e1c:	69b8      	ldr	r0, [r7, #24]
     e1e:	f7ff fffe 	bl	0 <tcp_output>
			e1e: R_ARM_THM_CALL	tcp_output
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
     e22:	69fb      	ldr	r3, [r7, #28]
     e24:	2b00      	cmp	r3, #0
     e26:	f47f ae0f 	bne.w	a48 <tcp_slowtmr+0x38>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
     e2a:	f04f 0300 	mov.w	r3, #0
     e2e:	61bb      	str	r3, [r7, #24]
  pcb = tcp_tw_pcbs;
     e30:	4b1c      	ldr	r3, [pc, #112]	; (ea4 <tcp_slowtmr+0x494>)
     e32:	681b      	ldr	r3, [r3, #0]
     e34:	61fb      	str	r3, [r7, #28]
  while (pcb != NULL) {
     e36:	e03c      	b.n	eb2 <tcp_slowtmr+0x4a2>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;
     e38:	f04f 0300 	mov.w	r3, #0
     e3c:	75fb      	strb	r3, [r7, #23]

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
     e3e:	4b14      	ldr	r3, [pc, #80]	; (e90 <tcp_slowtmr+0x480>)
     e40:	681a      	ldr	r2, [r3, #0]
     e42:	69fb      	ldr	r3, [r7, #28]
     e44:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     e46:	1ad3      	subs	r3, r2, r3
     e48:	2bf0      	cmp	r3, #240	; 0xf0
     e4a:	d903      	bls.n	e54 <tcp_slowtmr+0x444>
      ++pcb_remove;
     e4c:	7dfb      	ldrb	r3, [r7, #23]
     e4e:	f103 0301 	add.w	r3, r3, #1
     e52:	75fb      	strb	r3, [r7, #23]
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
     e54:	7dfb      	ldrb	r3, [r7, #23]
     e56:	2b00      	cmp	r3, #0
     e58:	d026      	beq.n	ea8 <tcp_slowtmr+0x498>
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
     e5a:	69f8      	ldr	r0, [r7, #28]
     e5c:	f7ff fffe 	bl	144c <tcp_pcb_purge>
			e5c: R_ARM_THM_CALL	tcp_pcb_purge
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
     e60:	69bb      	ldr	r3, [r7, #24]
     e62:	2b00      	cmp	r3, #0
     e64:	d004      	beq.n	e70 <tcp_slowtmr+0x460>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
     e66:	69fb      	ldr	r3, [r7, #28]
     e68:	68da      	ldr	r2, [r3, #12]
     e6a:	69bb      	ldr	r3, [r7, #24]
     e6c:	60da      	str	r2, [r3, #12]
     e6e:	e003      	b.n	e78 <tcp_slowtmr+0x468>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
     e70:	69fb      	ldr	r3, [r7, #28]
     e72:	68da      	ldr	r2, [r3, #12]
     e74:	4b0b      	ldr	r3, [pc, #44]	; (ea4 <tcp_slowtmr+0x494>)
     e76:	601a      	str	r2, [r3, #0]
      }
      pcb2 = pcb;
     e78:	69fb      	ldr	r3, [r7, #28]
     e7a:	603b      	str	r3, [r7, #0]
      pcb = pcb->next;
     e7c:	69fb      	ldr	r3, [r7, #28]
     e7e:	68db      	ldr	r3, [r3, #12]
     e80:	61fb      	str	r3, [r7, #28]
      memp_free(MEMP_TCP_PCB, pcb2);
     e82:	f04f 0002 	mov.w	r0, #2
     e86:	6839      	ldr	r1, [r7, #0]
     e88:	f7ff fffe 	bl	0 <memp_free>
			e88: R_ARM_THM_CALL	memp_free
     e8c:	e011      	b.n	eb2 <tcp_slowtmr+0x4a2>
     e8e:	bf00      	nop
     e90:	00000000 	.word	0x00000000
			e90: R_ARM_ABS32	tcp_ticks
     e94:	000124f8 	.word	0x000124f8
     e98:	10624dd3 	.word	0x10624dd3
	...
			e9c: R_ARM_ABS32	tcp_active_pcbs
			ea0: R_ARM_ABS32	tcp_active_pcbs_changed
			ea4: R_ARM_ABS32	tcp_tw_pcbs
    } else {
      prev = pcb;
     ea8:	69fb      	ldr	r3, [r7, #28]
     eaa:	61bb      	str	r3, [r7, #24]
      pcb = pcb->next;
     eac:	69fb      	ldr	r3, [r7, #28]
     eae:	68db      	ldr	r3, [r3, #12]
     eb0:	61fb      	str	r3, [r7, #28]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
     eb2:	69fb      	ldr	r3, [r7, #28]
     eb4:	2b00      	cmp	r3, #0
     eb6:	d1bf      	bne.n	e38 <tcp_slowtmr+0x428>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
     eb8:	f107 0720 	add.w	r7, r7, #32
     ebc:	46bd      	mov	sp, r7
     ebe:	bdb0      	pop	{r4, r5, r7, pc}

00000ec0 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
     ec0:	b580      	push	{r7, lr}
     ec2:	b082      	sub	sp, #8
     ec4:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
     ec6:	4b26      	ldr	r3, [pc, #152]	; (f60 <tcp_fasttmr+0xa0>)
     ec8:	781b      	ldrb	r3, [r3, #0]
     eca:	f103 0301 	add.w	r3, r3, #1
     ece:	b2da      	uxtb	r2, r3
     ed0:	4b23      	ldr	r3, [pc, #140]	; (f60 <tcp_fasttmr+0xa0>)
     ed2:	701a      	strb	r2, [r3, #0]
     ed4:	e000      	b.n	ed8 <tcp_fasttmr+0x18>
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
        if (tcp_active_pcbs_changed) {
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
     ed6:	bf00      	nop
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
     ed8:	4b22      	ldr	r3, [pc, #136]	; (f64 <tcp_fasttmr+0xa4>)
     eda:	681b      	ldr	r3, [r3, #0]
     edc:	607b      	str	r3, [r7, #4]

  while(pcb != NULL) {
     ede:	e037      	b.n	f50 <tcp_fasttmr+0x90>
    if (pcb->last_timer != tcp_timer_ctr) {
     ee0:	687b      	ldr	r3, [r7, #4]
     ee2:	f893 2021 	ldrb.w	r2, [r3, #33]	; 0x21
     ee6:	4b1e      	ldr	r3, [pc, #120]	; (f60 <tcp_fasttmr+0xa0>)
     ee8:	781b      	ldrb	r3, [r3, #0]
     eea:	429a      	cmp	r2, r3
     eec:	d030      	beq.n	f50 <tcp_fasttmr+0x90>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
     eee:	4b1c      	ldr	r3, [pc, #112]	; (f60 <tcp_fasttmr+0xa0>)
     ef0:	781a      	ldrb	r2, [r3, #0]
     ef2:	687b      	ldr	r3, [r7, #4]
     ef4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
     ef8:	687b      	ldr	r3, [r7, #4]
     efa:	7f9b      	ldrb	r3, [r3, #30]
     efc:	f003 0301 	and.w	r3, r3, #1
     f00:	b2db      	uxtb	r3, r3
     f02:	2b00      	cmp	r3, #0
     f04:	d010      	beq.n	f28 <tcp_fasttmr+0x68>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
     f06:	687b      	ldr	r3, [r7, #4]
     f08:	7f9b      	ldrb	r3, [r3, #30]
     f0a:	f043 0302 	orr.w	r3, r3, #2
     f0e:	b2da      	uxtb	r2, r3
     f10:	687b      	ldr	r3, [r7, #4]
     f12:	779a      	strb	r2, [r3, #30]
        tcp_output(pcb);
     f14:	6878      	ldr	r0, [r7, #4]
     f16:	f7ff fffe 	bl	0 <tcp_output>
			f16: R_ARM_THM_CALL	tcp_output
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
     f1a:	687b      	ldr	r3, [r7, #4]
     f1c:	7f9b      	ldrb	r3, [r3, #30]
     f1e:	f023 0303 	bic.w	r3, r3, #3
     f22:	b2da      	uxtb	r2, r3
     f24:	687b      	ldr	r3, [r7, #4]
     f26:	779a      	strb	r2, [r3, #30]
      }

      next = pcb->next;
     f28:	687b      	ldr	r3, [r7, #4]
     f2a:	68db      	ldr	r3, [r3, #12]
     f2c:	603b      	str	r3, [r7, #0]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
     f2e:	687b      	ldr	r3, [r7, #4]
     f30:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     f32:	2b00      	cmp	r3, #0
     f34:	d00a      	beq.n	f4c <tcp_fasttmr+0x8c>
        tcp_active_pcbs_changed = 0;
     f36:	4b0c      	ldr	r3, [pc, #48]	; (f68 <tcp_fasttmr+0xa8>)
     f38:	f04f 0200 	mov.w	r2, #0
     f3c:	701a      	strb	r2, [r3, #0]
        tcp_process_refused_data(pcb);
     f3e:	6878      	ldr	r0, [r7, #4]
     f40:	f7ff fffe 	bl	f6c <tcp_process_refused_data>
			f40: R_ARM_THM_CALL	tcp_process_refused_data
        if (tcp_active_pcbs_changed) {
     f44:	4b08      	ldr	r3, [pc, #32]	; (f68 <tcp_fasttmr+0xa8>)
     f46:	781b      	ldrb	r3, [r3, #0]
     f48:	2b00      	cmp	r3, #0
     f4a:	d1c4      	bne.n	ed6 <tcp_fasttmr+0x16>
          /* application callback has changed the pcb list: restart the loop */
          goto tcp_fasttmr_start;
        }
      }
      pcb = next;
     f4c:	683b      	ldr	r3, [r7, #0]
     f4e:	607b      	str	r3, [r7, #4]
  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
     f50:	687b      	ldr	r3, [r7, #4]
     f52:	2b00      	cmp	r3, #0
     f54:	d1c4      	bne.n	ee0 <tcp_fasttmr+0x20>
        }
      }
      pcb = next;
    }
  }
}
     f56:	f107 0708 	add.w	r7, r7, #8
     f5a:	46bd      	mov	sp, r7
     f5c:	bd80      	pop	{r7, pc}
     f5e:	bf00      	nop
     f60:	00000001 	.word	0x00000001
			f60: R_ARM_ABS32	.bss
	...
			f64: R_ARM_ABS32	tcp_active_pcbs
			f68: R_ARM_ABS32	tcp_active_pcbs_changed

00000f6c <tcp_process_refused_data>:

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
     f6c:	b590      	push	{r4, r7, lr}
     f6e:	b085      	sub	sp, #20
     f70:	af00      	add	r7, sp, #0
     f72:	6078      	str	r0, [r7, #4]
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
     f74:	687b      	ldr	r3, [r7, #4]
     f76:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     f78:	7b5b      	ldrb	r3, [r3, #13]
     f7a:	73bb      	strb	r3, [r7, #14]
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
     f7c:	687b      	ldr	r3, [r7, #4]
     f7e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     f80:	60bb      	str	r3, [r7, #8]
  pcb->refused_data = NULL;
     f82:	687b      	ldr	r3, [r7, #4]
     f84:	f04f 0200 	mov.w	r2, #0
     f88:	679a      	str	r2, [r3, #120]	; 0x78
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
     f8a:	687b      	ldr	r3, [r7, #4]
     f8c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
     f90:	2b00      	cmp	r3, #0
     f92:	d00d      	beq.n	fb0 <tcp_process_refused_data+0x44>
     f94:	687b      	ldr	r3, [r7, #4]
     f96:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
     f9a:	687b      	ldr	r3, [r7, #4]
     f9c:	691b      	ldr	r3, [r3, #16]
     f9e:	4618      	mov	r0, r3
     fa0:	6879      	ldr	r1, [r7, #4]
     fa2:	68ba      	ldr	r2, [r7, #8]
     fa4:	f04f 0300 	mov.w	r3, #0
     fa8:	47a0      	blx	r4
     faa:	4603      	mov	r3, r0
     fac:	73fb      	strb	r3, [r7, #15]
     fae:	e009      	b.n	fc4 <tcp_process_refused_data+0x58>
     fb0:	f04f 0000 	mov.w	r0, #0
     fb4:	6879      	ldr	r1, [r7, #4]
     fb6:	68ba      	ldr	r2, [r7, #8]
     fb8:	f04f 0300 	mov.w	r3, #0
     fbc:	f7ff fffe 	bl	1110 <tcp_recv_null>
			fbc: R_ARM_THM_CALL	tcp_recv_null
     fc0:	4603      	mov	r3, r0
     fc2:	73fb      	strb	r3, [r7, #15]
  if (err == ERR_OK) {
     fc4:	f997 300f 	ldrsb.w	r3, [r7, #15]
     fc8:	2b00      	cmp	r3, #0
     fca:	d130      	bne.n	102e <tcp_process_refused_data+0xc2>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
     fcc:	7bbb      	ldrb	r3, [r7, #14]
     fce:	f003 0320 	and.w	r3, r3, #32
     fd2:	2b00      	cmp	r3, #0
     fd4:	d036      	beq.n	1044 <tcp_process_refused_data+0xd8>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
     fd6:	687b      	ldr	r3, [r7, #4]
     fd8:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
     fda:	f241 7370 	movw	r3, #6000	; 0x1770
     fde:	429a      	cmp	r2, r3
     fe0:	d006      	beq.n	ff0 <tcp_process_refused_data+0x84>
        pcb->rcv_wnd++;
     fe2:	687b      	ldr	r3, [r7, #4]
     fe4:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     fe6:	f103 0301 	add.w	r3, r3, #1
     fea:	b29a      	uxth	r2, r3
     fec:	687b      	ldr	r3, [r7, #4]
     fee:	859a      	strh	r2, [r3, #44]	; 0x2c
      }
      TCP_EVENT_CLOSED(pcb, err);
     ff0:	687b      	ldr	r3, [r7, #4]
     ff2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
     ff6:	2b00      	cmp	r3, #0
     ff8:	d00e      	beq.n	1018 <tcp_process_refused_data+0xac>
     ffa:	687b      	ldr	r3, [r7, #4]
     ffc:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
    1000:	687b      	ldr	r3, [r7, #4]
    1002:	691b      	ldr	r3, [r3, #16]
    1004:	4618      	mov	r0, r3
    1006:	6879      	ldr	r1, [r7, #4]
    1008:	f04f 0200 	mov.w	r2, #0
    100c:	f04f 0300 	mov.w	r3, #0
    1010:	47a0      	blx	r4
    1012:	4603      	mov	r3, r0
    1014:	73fb      	strb	r3, [r7, #15]
    1016:	e002      	b.n	101e <tcp_process_refused_data+0xb2>
    1018:	f04f 0300 	mov.w	r3, #0
    101c:	73fb      	strb	r3, [r7, #15]
      if (err == ERR_ABRT) {
    101e:	f997 300f 	ldrsb.w	r3, [r7, #15]
    1022:	f113 0f0a 	cmn.w	r3, #10
    1026:	d10d      	bne.n	1044 <tcp_process_refused_data+0xd8>
        return ERR_ABRT;
    1028:	f04f 03f6 	mov.w	r3, #246	; 0xf6
    102c:	e00c      	b.n	1048 <tcp_process_refused_data+0xdc>
      }
    }
  } else if (err == ERR_ABRT) {
    102e:	f997 300f 	ldrsb.w	r3, [r7, #15]
    1032:	f113 0f0a 	cmn.w	r3, #10
    1036:	d102      	bne.n	103e <tcp_process_refused_data+0xd2>
    /* if err == ERR_ABRT, 'pcb' is already deallocated */
    /* Drop incoming packets because pcb is "full" (only if the incoming
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
    1038:	f04f 03f6 	mov.w	r3, #246	; 0xf6
    103c:	e004      	b.n	1048 <tcp_process_refused_data+0xdc>
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
    103e:	687b      	ldr	r3, [r7, #4]
    1040:	68ba      	ldr	r2, [r7, #8]
    1042:	679a      	str	r2, [r3, #120]	; 0x78
  }
  return ERR_OK;
    1044:	f04f 0300 	mov.w	r3, #0
    1048:	b25b      	sxtb	r3, r3
}
    104a:	4618      	mov	r0, r3
    104c:	f107 0714 	add.w	r7, r7, #20
    1050:	46bd      	mov	sp, r7
    1052:	bd90      	pop	{r4, r7, pc}

00001054 <tcp_segs_free>:
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
    1054:	b580      	push	{r7, lr}
    1056:	b084      	sub	sp, #16
    1058:	af00      	add	r7, sp, #0
    105a:	6078      	str	r0, [r7, #4]
  while (seg != NULL) {
    105c:	e007      	b.n	106e <tcp_segs_free+0x1a>
    struct tcp_seg *next = seg->next;
    105e:	687b      	ldr	r3, [r7, #4]
    1060:	681b      	ldr	r3, [r3, #0]
    1062:	60fb      	str	r3, [r7, #12]
    tcp_seg_free(seg);
    1064:	6878      	ldr	r0, [r7, #4]
    1066:	f7ff fffe 	bl	107c <tcp_seg_free>
			1066: R_ARM_THM_CALL	tcp_seg_free
    seg = next;
    106a:	68fb      	ldr	r3, [r7, #12]
    106c:	607b      	str	r3, [r7, #4]
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    106e:	687b      	ldr	r3, [r7, #4]
    1070:	2b00      	cmp	r3, #0
    1072:	d1f4      	bne.n	105e <tcp_segs_free+0xa>
    struct tcp_seg *next = seg->next;
    tcp_seg_free(seg);
    seg = next;
  }
}
    1074:	f107 0710 	add.w	r7, r7, #16
    1078:	46bd      	mov	sp, r7
    107a:	bd80      	pop	{r7, pc}

0000107c <tcp_seg_free>:
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
    107c:	b580      	push	{r7, lr}
    107e:	b082      	sub	sp, #8
    1080:	af00      	add	r7, sp, #0
    1082:	6078      	str	r0, [r7, #4]
  if (seg != NULL) {
    1084:	687b      	ldr	r3, [r7, #4]
    1086:	2b00      	cmp	r3, #0
    1088:	d00d      	beq.n	10a6 <tcp_seg_free+0x2a>
    if (seg->p != NULL) {
    108a:	687b      	ldr	r3, [r7, #4]
    108c:	685b      	ldr	r3, [r3, #4]
    108e:	2b00      	cmp	r3, #0
    1090:	d004      	beq.n	109c <tcp_seg_free+0x20>
      pbuf_free(seg->p);
    1092:	687b      	ldr	r3, [r7, #4]
    1094:	685b      	ldr	r3, [r3, #4]
    1096:	4618      	mov	r0, r3
    1098:	f7ff fffe 	bl	0 <pbuf_free>
			1098: R_ARM_THM_CALL	pbuf_free
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
    109c:	f04f 0004 	mov.w	r0, #4
    10a0:	6879      	ldr	r1, [r7, #4]
    10a2:	f7ff fffe 	bl	0 <memp_free>
			10a2: R_ARM_THM_CALL	memp_free
  }
}
    10a6:	f107 0708 	add.w	r7, r7, #8
    10aa:	46bd      	mov	sp, r7
    10ac:	bd80      	pop	{r7, pc}
    10ae:	bf00      	nop

000010b0 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
    10b0:	b480      	push	{r7}
    10b2:	b083      	sub	sp, #12
    10b4:	af00      	add	r7, sp, #0
    10b6:	6078      	str	r0, [r7, #4]
    10b8:	460b      	mov	r3, r1
    10ba:	70fb      	strb	r3, [r7, #3]
  pcb->prio = prio;
    10bc:	687b      	ldr	r3, [r7, #4]
    10be:	78fa      	ldrb	r2, [r7, #3]
    10c0:	765a      	strb	r2, [r3, #25]
}
    10c2:	f107 070c 	add.w	r7, r7, #12
    10c6:	46bd      	mov	sp, r7
    10c8:	bc80      	pop	{r7}
    10ca:	4770      	bx	lr

000010cc <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
    10cc:	b580      	push	{r7, lr}
    10ce:	b084      	sub	sp, #16
    10d0:	af00      	add	r7, sp, #0
    10d2:	6078      	str	r0, [r7, #4]
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
    10d4:	f04f 0004 	mov.w	r0, #4
    10d8:	f7ff fffe 	bl	0 <memp_malloc>
			10d8: R_ARM_THM_CALL	memp_malloc
    10dc:	4603      	mov	r3, r0
    10de:	60fb      	str	r3, [r7, #12]
  if (cseg == NULL) {
    10e0:	68fb      	ldr	r3, [r7, #12]
    10e2:	2b00      	cmp	r3, #0
    10e4:	d102      	bne.n	10ec <tcp_seg_copy+0x20>
    return NULL;
    10e6:	f04f 0300 	mov.w	r3, #0
    10ea:	e00b      	b.n	1104 <tcp_seg_copy+0x38>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
    10ec:	68f8      	ldr	r0, [r7, #12]
    10ee:	6879      	ldr	r1, [r7, #4]
    10f0:	f04f 0210 	mov.w	r2, #16
    10f4:	f7ff fffe 	bl	0 <memcpy>
			10f4: R_ARM_THM_CALL	memcpy
  pbuf_ref(cseg->p);
    10f8:	68fb      	ldr	r3, [r7, #12]
    10fa:	685b      	ldr	r3, [r3, #4]
    10fc:	4618      	mov	r0, r3
    10fe:	f7ff fffe 	bl	0 <pbuf_ref>
			10fe: R_ARM_THM_CALL	pbuf_ref
  return cseg;
    1102:	68fb      	ldr	r3, [r7, #12]
}
    1104:	4618      	mov	r0, r3
    1106:	f107 0710 	add.w	r7, r7, #16
    110a:	46bd      	mov	sp, r7
    110c:	bd80      	pop	{r7, pc}
    110e:	bf00      	nop

00001110 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
    1110:	b580      	push	{r7, lr}
    1112:	b084      	sub	sp, #16
    1114:	af00      	add	r7, sp, #0
    1116:	60f8      	str	r0, [r7, #12]
    1118:	60b9      	str	r1, [r7, #8]
    111a:	607a      	str	r2, [r7, #4]
    111c:	70fb      	strb	r3, [r7, #3]
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    111e:	687b      	ldr	r3, [r7, #4]
    1120:	2b00      	cmp	r3, #0
    1122:	d009      	beq.n	1138 <tcp_recv_null+0x28>
    tcp_recved(pcb, p->tot_len);
    1124:	687b      	ldr	r3, [r7, #4]
    1126:	891b      	ldrh	r3, [r3, #8]
    1128:	68b8      	ldr	r0, [r7, #8]
    112a:	4619      	mov	r1, r3
    112c:	f7ff fffe 	bl	734 <tcp_recved>
			112c: R_ARM_THM_CALL	tcp_recved
    pbuf_free(p);
    1130:	6878      	ldr	r0, [r7, #4]
    1132:	f7ff fffe 	bl	0 <pbuf_free>
			1132: R_ARM_THM_CALL	pbuf_free
    1136:	e008      	b.n	114a <tcp_recv_null+0x3a>
  } else if (err == ERR_OK) {
    1138:	f997 3003 	ldrsb.w	r3, [r7, #3]
    113c:	2b00      	cmp	r3, #0
    113e:	d104      	bne.n	114a <tcp_recv_null+0x3a>
    return tcp_close(pcb);
    1140:	68b8      	ldr	r0, [r7, #8]
    1142:	f7ff fffe 	bl	2b8 <tcp_close>
			1142: R_ARM_THM_CALL	tcp_close
    1146:	4603      	mov	r3, r0
    1148:	e001      	b.n	114e <tcp_recv_null+0x3e>
  }
  return ERR_OK;
    114a:	f04f 0300 	mov.w	r3, #0
    114e:	b25b      	sxtb	r3, r3
}
    1150:	4618      	mov	r0, r3
    1152:	f107 0710 	add.w	r7, r7, #16
    1156:	46bd      	mov	sp, r7
    1158:	bd80      	pop	{r7, pc}
    115a:	bf00      	nop

0000115c <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
    115c:	b580      	push	{r7, lr}
    115e:	b086      	sub	sp, #24
    1160:	af00      	add	r7, sp, #0
    1162:	4603      	mov	r3, r0
    1164:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
    1166:	f04f 037f 	mov.w	r3, #127	; 0x7f
    116a:	72fb      	strb	r3, [r7, #11]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
    116c:	f04f 0300 	mov.w	r3, #0
    1170:	60fb      	str	r3, [r7, #12]
  inactive = NULL;
    1172:	f04f 0300 	mov.w	r3, #0
    1176:	613b      	str	r3, [r7, #16]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    1178:	4b18      	ldr	r3, [pc, #96]	; (11dc <tcp_kill_prio+0x80>)
    117a:	681b      	ldr	r3, [r3, #0]
    117c:	617b      	str	r3, [r7, #20]
    117e:	e01f      	b.n	11c0 <tcp_kill_prio+0x64>
    if (pcb->prio <= prio &&
    1180:	697b      	ldr	r3, [r7, #20]
    1182:	7e5b      	ldrb	r3, [r3, #25]
    1184:	79fa      	ldrb	r2, [r7, #7]
    1186:	429a      	cmp	r2, r3
    1188:	d317      	bcc.n	11ba <tcp_kill_prio+0x5e>
       pcb->prio <= mprio &&
    118a:	697b      	ldr	r3, [r7, #20]
    118c:	7e5b      	ldrb	r3, [r3, #25]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
    118e:	7afa      	ldrb	r2, [r7, #11]
    1190:	429a      	cmp	r2, r3
    1192:	d312      	bcc.n	11ba <tcp_kill_prio+0x5e>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    1194:	4b12      	ldr	r3, [pc, #72]	; (11e0 <tcp_kill_prio+0x84>)
    1196:	681a      	ldr	r2, [r3, #0]
    1198:	697b      	ldr	r3, [r7, #20]
    119a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    119c:	1ad2      	subs	r2, r2, r3
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
    119e:	68fb      	ldr	r3, [r7, #12]
    11a0:	429a      	cmp	r2, r3
    11a2:	d30a      	bcc.n	11ba <tcp_kill_prio+0x5e>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
    11a4:	4b0e      	ldr	r3, [pc, #56]	; (11e0 <tcp_kill_prio+0x84>)
    11a6:	681a      	ldr	r2, [r3, #0]
    11a8:	697b      	ldr	r3, [r7, #20]
    11aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    11ac:	1ad3      	subs	r3, r2, r3
    11ae:	60fb      	str	r3, [r7, #12]
      inactive = pcb;
    11b0:	697b      	ldr	r3, [r7, #20]
    11b2:	613b      	str	r3, [r7, #16]
      mprio = pcb->prio;
    11b4:	697b      	ldr	r3, [r7, #20]
    11b6:	7e5b      	ldrb	r3, [r3, #25]
    11b8:	72fb      	strb	r3, [r7, #11]
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    11ba:	697b      	ldr	r3, [r7, #20]
    11bc:	68db      	ldr	r3, [r3, #12]
    11be:	617b      	str	r3, [r7, #20]
    11c0:	697b      	ldr	r3, [r7, #20]
    11c2:	2b00      	cmp	r3, #0
    11c4:	d1dc      	bne.n	1180 <tcp_kill_prio+0x24>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
    11c6:	693b      	ldr	r3, [r7, #16]
    11c8:	2b00      	cmp	r3, #0
    11ca:	d002      	beq.n	11d2 <tcp_kill_prio+0x76>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    11cc:	6938      	ldr	r0, [r7, #16]
    11ce:	f7ff fffe 	bl	460 <tcp_abort>
			11ce: R_ARM_THM_CALL	tcp_abort
  }
}
    11d2:	f107 0718 	add.w	r7, r7, #24
    11d6:	46bd      	mov	sp, r7
    11d8:	bd80      	pop	{r7, pc}
    11da:	bf00      	nop
	...
			11dc: R_ARM_ABS32	tcp_active_pcbs
			11e0: R_ARM_ABS32	tcp_ticks

000011e4 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
    11e4:	b580      	push	{r7, lr}
    11e6:	b084      	sub	sp, #16
    11e8:	af00      	add	r7, sp, #0
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
    11ea:	f04f 0300 	mov.w	r3, #0
    11ee:	607b      	str	r3, [r7, #4]
  inactive = NULL;
    11f0:	f04f 0300 	mov.w	r3, #0
    11f4:	60bb      	str	r3, [r7, #8]
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    11f6:	4b12      	ldr	r3, [pc, #72]	; (1240 <tcp_kill_timewait+0x5c>)
    11f8:	681b      	ldr	r3, [r3, #0]
    11fa:	60fb      	str	r3, [r7, #12]
    11fc:	e012      	b.n	1224 <tcp_kill_timewait+0x40>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
    11fe:	4b11      	ldr	r3, [pc, #68]	; (1244 <tcp_kill_timewait+0x60>)
    1200:	681a      	ldr	r2, [r3, #0]
    1202:	68fb      	ldr	r3, [r7, #12]
    1204:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1206:	1ad2      	subs	r2, r2, r3
    1208:	687b      	ldr	r3, [r7, #4]
    120a:	429a      	cmp	r2, r3
    120c:	d307      	bcc.n	121e <tcp_kill_timewait+0x3a>
      inactivity = tcp_ticks - pcb->tmr;
    120e:	4b0d      	ldr	r3, [pc, #52]	; (1244 <tcp_kill_timewait+0x60>)
    1210:	681a      	ldr	r2, [r3, #0]
    1212:	68fb      	ldr	r3, [r7, #12]
    1214:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1216:	1ad3      	subs	r3, r2, r3
    1218:	607b      	str	r3, [r7, #4]
      inactive = pcb;
    121a:	68fb      	ldr	r3, [r7, #12]
    121c:	60bb      	str	r3, [r7, #8]
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    121e:	68fb      	ldr	r3, [r7, #12]
    1220:	68db      	ldr	r3, [r3, #12]
    1222:	60fb      	str	r3, [r7, #12]
    1224:	68fb      	ldr	r3, [r7, #12]
    1226:	2b00      	cmp	r3, #0
    1228:	d1e9      	bne.n	11fe <tcp_kill_timewait+0x1a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
    122a:	68bb      	ldr	r3, [r7, #8]
    122c:	2b00      	cmp	r3, #0
    122e:	d002      	beq.n	1236 <tcp_kill_timewait+0x52>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
    1230:	68b8      	ldr	r0, [r7, #8]
    1232:	f7ff fffe 	bl	460 <tcp_abort>
			1232: R_ARM_THM_CALL	tcp_abort
  }
}
    1236:	f107 0710 	add.w	r7, r7, #16
    123a:	46bd      	mov	sp, r7
    123c:	bd80      	pop	{r7, pc}
    123e:	bf00      	nop
	...
			1240: R_ARM_ABS32	tcp_tw_pcbs
			1244: R_ARM_ABS32	tcp_ticks

00001248 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
    1248:	b580      	push	{r7, lr}
    124a:	b084      	sub	sp, #16
    124c:	af00      	add	r7, sp, #0
    124e:	4603      	mov	r3, r0
    1250:	71fb      	strb	r3, [r7, #7]
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    1252:	f04f 0002 	mov.w	r0, #2
    1256:	f7ff fffe 	bl	0 <memp_malloc>
			1256: R_ARM_THM_CALL	memp_malloc
    125a:	4603      	mov	r3, r0
    125c:	60fb      	str	r3, [r7, #12]
  if (pcb == NULL) {
    125e:	68fb      	ldr	r3, [r7, #12]
    1260:	2b00      	cmp	r3, #0
    1262:	d114      	bne.n	128e <tcp_alloc+0x46>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    1264:	f7ff ffbe 	bl	11e4 <tcp_kill_timewait>
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    1268:	f04f 0002 	mov.w	r0, #2
    126c:	f7ff fffe 	bl	0 <memp_malloc>
			126c: R_ARM_THM_CALL	memp_malloc
    1270:	4603      	mov	r3, r0
    1272:	60fb      	str	r3, [r7, #12]
    if (pcb == NULL) {
    1274:	68fb      	ldr	r3, [r7, #12]
    1276:	2b00      	cmp	r3, #0
    1278:	d109      	bne.n	128e <tcp_alloc+0x46>
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
    127a:	79fb      	ldrb	r3, [r7, #7]
    127c:	4618      	mov	r0, r3
    127e:	f7ff ff6d 	bl	115c <tcp_kill_prio>
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
    1282:	f04f 0002 	mov.w	r0, #2
    1286:	f7ff fffe 	bl	0 <memp_malloc>
			1286: R_ARM_THM_CALL	memp_malloc
    128a:	4603      	mov	r3, r0
    128c:	60fb      	str	r3, [r7, #12]
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    128e:	68fb      	ldr	r3, [r7, #12]
    1290:	2b00      	cmp	r3, #0
    1292:	d068      	beq.n	1366 <tcp_alloc+0x11e>
    memset(pcb, 0, sizeof(struct tcp_pcb));
    1294:	68f8      	ldr	r0, [r7, #12]
    1296:	f04f 0100 	mov.w	r1, #0
    129a:	f04f 0298 	mov.w	r2, #152	; 0x98
    129e:	f7ff fffe 	bl	0 <memset>
			129e: R_ARM_THM_CALL	memset
    pcb->prio = prio;
    12a2:	68fb      	ldr	r3, [r7, #12]
    12a4:	79fa      	ldrb	r2, [r7, #7]
    12a6:	765a      	strb	r2, [r3, #25]
    pcb->snd_buf = TCP_SND_BUF;
    12a8:	68fb      	ldr	r3, [r7, #12]
    12aa:	f640 32b8 	movw	r2, #3000	; 0xbb8
    12ae:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    pcb->snd_queuelen = 0;
    12b2:	68fb      	ldr	r3, [r7, #12]
    12b4:	f04f 0200 	mov.w	r2, #0
    12b8:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
    12bc:	68fb      	ldr	r3, [r7, #12]
    12be:	f241 7270 	movw	r2, #6000	; 0x1770
    12c2:	859a      	strh	r2, [r3, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
    12c4:	68fb      	ldr	r3, [r7, #12]
    12c6:	f241 7270 	movw	r2, #6000	; 0x1770
    12ca:	85da      	strh	r2, [r3, #46]	; 0x2e
    pcb->tos = 0;
    12cc:	68fb      	ldr	r3, [r7, #12]
    12ce:	f04f 0200 	mov.w	r2, #0
    12d2:	725a      	strb	r2, [r3, #9]
    pcb->ttl = TCP_TTL;
    12d4:	68fb      	ldr	r3, [r7, #12]
    12d6:	f04f 02ff 	mov.w	r2, #255	; 0xff
    12da:	729a      	strb	r2, [r3, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    12dc:	68fb      	ldr	r3, [r7, #12]
    12de:	f44f 7206 	mov.w	r2, #536	; 0x218
    12e2:	86da      	strh	r2, [r3, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    12e4:	68fb      	ldr	r3, [r7, #12]
    12e6:	f04f 0206 	mov.w	r2, #6
    12ea:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    pcb->sa = 0;
    12ee:	68fb      	ldr	r3, [r7, #12]
    12f0:	f04f 0200 	mov.w	r2, #0
    12f4:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    12f8:	68fb      	ldr	r3, [r7, #12]
    12fa:	f04f 0206 	mov.w	r2, #6
    12fe:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
    pcb->rtime = -1;
    1302:	68fb      	ldr	r3, [r7, #12]
    1304:	f64f 72ff 	movw	r2, #65535	; 0xffff
    1308:	869a      	strh	r2, [r3, #52]	; 0x34
    pcb->cwnd = 1;
    130a:	68fb      	ldr	r3, [r7, #12]
    130c:	f04f 0201 	mov.w	r2, #1
    1310:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    iss = tcp_next_iss();
    1314:	f7ff fffe 	bl	1588 <tcp_next_iss>
			1314: R_ARM_THM_CALL	tcp_next_iss
    1318:	60b8      	str	r0, [r7, #8]
    pcb->snd_wl2 = iss;
    131a:	68fb      	ldr	r3, [r7, #12]
    131c:	68ba      	ldr	r2, [r7, #8]
    131e:	659a      	str	r2, [r3, #88]	; 0x58
    pcb->snd_nxt = iss;
    1320:	68fb      	ldr	r3, [r7, #12]
    1322:	68ba      	ldr	r2, [r7, #8]
    1324:	651a      	str	r2, [r3, #80]	; 0x50
    pcb->lastack = iss;
    1326:	68fb      	ldr	r3, [r7, #12]
    1328:	68ba      	ldr	r2, [r7, #8]
    132a:	649a      	str	r2, [r3, #72]	; 0x48
    pcb->snd_lbb = iss;   
    132c:	68fb      	ldr	r3, [r7, #12]
    132e:	68ba      	ldr	r2, [r7, #8]
    1330:	65da      	str	r2, [r3, #92]	; 0x5c
    pcb->tmr = tcp_ticks;
    1332:	4b10      	ldr	r3, [pc, #64]	; (1374 <tcp_alloc+0x12c>)
    1334:	681a      	ldr	r2, [r3, #0]
    1336:	68fb      	ldr	r3, [r7, #12]
    1338:	625a      	str	r2, [r3, #36]	; 0x24
    pcb->last_timer = tcp_timer_ctr;
    133a:	4b0f      	ldr	r3, [pc, #60]	; (1378 <tcp_alloc+0x130>)
    133c:	781a      	ldrb	r2, [r3, #0]
    133e:	68fb      	ldr	r3, [r7, #12]
    1340:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    pcb->polltmr = 0;
    1344:	68fb      	ldr	r3, [r7, #12]
    1346:	f04f 0200 	mov.w	r2, #0
    134a:	77da      	strb	r2, [r3, #31]

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
    134c:	68fb      	ldr	r3, [r7, #12]
    134e:	4a0b      	ldr	r2, [pc, #44]	; (137c <tcp_alloc+0x134>)
    1350:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
    1354:	68fb      	ldr	r3, [r7, #12]
    1356:	4a0a      	ldr	r2, [pc, #40]	; (1380 <tcp_alloc+0x138>)
    1358:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
    135c:	68fb      	ldr	r3, [r7, #12]
    135e:	f04f 0200 	mov.w	r2, #0
    1362:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
  }
  return pcb;
    1366:	68fb      	ldr	r3, [r7, #12]
}
    1368:	4618      	mov	r0, r3
    136a:	f107 0710 	add.w	r7, r7, #16
    136e:	46bd      	mov	sp, r7
    1370:	bd80      	pop	{r7, pc}
    1372:	bf00      	nop
    1374:	00000000 	.word	0x00000000
			1374: R_ARM_ABS32	tcp_ticks
    1378:	00000001 	.word	0x00000001
			1378: R_ARM_ABS32	.bss
    137c:	00000000 	.word	0x00000000
			137c: R_ARM_ABS32	tcp_recv_null
    1380:	006ddd00 	.word	0x006ddd00

00001384 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
    1384:	b580      	push	{r7, lr}
    1386:	af00      	add	r7, sp, #0
  return tcp_alloc(TCP_PRIO_NORMAL);
    1388:	f04f 0040 	mov.w	r0, #64	; 0x40
    138c:	f7ff fffe 	bl	1248 <tcp_alloc>
			138c: R_ARM_THM_CALL	tcp_alloc
    1390:	4603      	mov	r3, r0
}
    1392:	4618      	mov	r0, r3
    1394:	bd80      	pop	{r7, pc}
    1396:	bf00      	nop

00001398 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
    1398:	b480      	push	{r7}
    139a:	b083      	sub	sp, #12
    139c:	af00      	add	r7, sp, #0
    139e:	6078      	str	r0, [r7, #4]
    13a0:	6039      	str	r1, [r7, #0]
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
    13a2:	687b      	ldr	r3, [r7, #4]
    13a4:	683a      	ldr	r2, [r7, #0]
    13a6:	611a      	str	r2, [r3, #16]
}
    13a8:	f107 070c 	add.w	r7, r7, #12
    13ac:	46bd      	mov	sp, r7
    13ae:	bc80      	pop	{r7}
    13b0:	4770      	bx	lr
    13b2:	bf00      	nop

000013b4 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
    13b4:	b480      	push	{r7}
    13b6:	b083      	sub	sp, #12
    13b8:	af00      	add	r7, sp, #0
    13ba:	6078      	str	r0, [r7, #4]
    13bc:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
  pcb->recv = recv;
    13be:	687b      	ldr	r3, [r7, #4]
    13c0:	683a      	ldr	r2, [r7, #0]
    13c2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
    13c6:	f107 070c 	add.w	r7, r7, #12
    13ca:	46bd      	mov	sp, r7
    13cc:	bc80      	pop	{r7}
    13ce:	4770      	bx	lr

000013d0 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
    13d0:	b480      	push	{r7}
    13d2:	b083      	sub	sp, #12
    13d4:	af00      	add	r7, sp, #0
    13d6:	6078      	str	r0, [r7, #4]
    13d8:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
  pcb->sent = sent;
    13da:	687b      	ldr	r3, [r7, #4]
    13dc:	683a      	ldr	r2, [r7, #0]
    13de:	67da      	str	r2, [r3, #124]	; 0x7c
}
    13e0:	f107 070c 	add.w	r7, r7, #12
    13e4:	46bd      	mov	sp, r7
    13e6:	bc80      	pop	{r7}
    13e8:	4770      	bx	lr
    13ea:	bf00      	nop

000013ec <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
    13ec:	b480      	push	{r7}
    13ee:	b083      	sub	sp, #12
    13f0:	af00      	add	r7, sp, #0
    13f2:	6078      	str	r0, [r7, #4]
    13f4:	6039      	str	r1, [r7, #0]
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
  pcb->errf = err;
    13f6:	687b      	ldr	r3, [r7, #4]
    13f8:	683a      	ldr	r2, [r7, #0]
    13fa:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
    13fe:	f107 070c 	add.w	r7, r7, #12
    1402:	46bd      	mov	sp, r7
    1404:	bc80      	pop	{r7}
    1406:	4770      	bx	lr

00001408 <tcp_accept>:
 * @param accept callback function to call for this pcb when LISTENing
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
    1408:	b480      	push	{r7}
    140a:	b083      	sub	sp, #12
    140c:	af00      	add	r7, sp, #0
    140e:	6078      	str	r0, [r7, #4]
    1410:	6039      	str	r1, [r7, #0]
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
    1412:	687b      	ldr	r3, [r7, #4]
    1414:	683a      	ldr	r2, [r7, #0]
    1416:	615a      	str	r2, [r3, #20]
}
    1418:	f107 070c 	add.w	r7, r7, #12
    141c:	46bd      	mov	sp, r7
    141e:	bc80      	pop	{r7}
    1420:	4770      	bx	lr
    1422:	bf00      	nop

00001424 <tcp_poll>:
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
    1424:	b480      	push	{r7}
    1426:	b085      	sub	sp, #20
    1428:	af00      	add	r7, sp, #0
    142a:	60f8      	str	r0, [r7, #12]
    142c:	60b9      	str	r1, [r7, #8]
    142e:	4613      	mov	r3, r2
    1430:	71fb      	strb	r3, [r7, #7]
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
    1432:	68fb      	ldr	r3, [r7, #12]
    1434:	68ba      	ldr	r2, [r7, #8]
    1436:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
    143a:	68fb      	ldr	r3, [r7, #12]
    143c:	79fa      	ldrb	r2, [r7, #7]
    143e:	f883 2020 	strb.w	r2, [r3, #32]
}
    1442:	f107 0714 	add.w	r7, r7, #20
    1446:	46bd      	mov	sp, r7
    1448:	bc80      	pop	{r7}
    144a:	4770      	bx	lr

0000144c <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
    144c:	b580      	push	{r7, lr}
    144e:	b082      	sub	sp, #8
    1450:	af00      	add	r7, sp, #0
    1452:	6078      	str	r0, [r7, #4]
  if (pcb->state != CLOSED &&
    1454:	687b      	ldr	r3, [r7, #4]
    1456:	7e1b      	ldrb	r3, [r3, #24]
    1458:	2b00      	cmp	r3, #0
    145a:	d038      	beq.n	14ce <tcp_pcb_purge+0x82>
     pcb->state != TIME_WAIT &&
    145c:	687b      	ldr	r3, [r7, #4]
    145e:	7e1b      	ldrb	r3, [r3, #24]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
    1460:	2b0a      	cmp	r3, #10
    1462:	d034      	beq.n	14ce <tcp_pcb_purge+0x82>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
    1464:	687b      	ldr	r3, [r7, #4]
    1466:	7e1b      	ldrb	r3, [r3, #24]
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
    1468:	2b01      	cmp	r3, #1
    146a:	d030      	beq.n	14ce <tcp_pcb_purge+0x82>
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
    146c:	687b      	ldr	r3, [r7, #4]
    146e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    1470:	2b00      	cmp	r3, #0
    1472:	d008      	beq.n	1486 <tcp_pcb_purge+0x3a>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
    1474:	687b      	ldr	r3, [r7, #4]
    1476:	6f9b      	ldr	r3, [r3, #120]	; 0x78
    1478:	4618      	mov	r0, r3
    147a:	f7ff fffe 	bl	0 <pbuf_free>
			147a: R_ARM_THM_CALL	pbuf_free
      pcb->refused_data = NULL;
    147e:	687b      	ldr	r3, [r7, #4]
    1480:	f04f 0200 	mov.w	r2, #0
    1484:	679a      	str	r2, [r3, #120]	; 0x78
    }
#if TCP_QUEUE_OOSEQ
    if (pcb->ooseq != NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }
    tcp_segs_free(pcb->ooseq);
    1486:	687b      	ldr	r3, [r7, #4]
    1488:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    148a:	4618      	mov	r0, r3
    148c:	f7ff fffe 	bl	1054 <tcp_segs_free>
			148c: R_ARM_THM_CALL	tcp_segs_free
    pcb->ooseq = NULL;
    1490:	687b      	ldr	r3, [r7, #4]
    1492:	f04f 0200 	mov.w	r2, #0
    1496:	675a      	str	r2, [r3, #116]	; 0x74
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
    1498:	687b      	ldr	r3, [r7, #4]
    149a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    149e:	869a      	strh	r2, [r3, #52]	; 0x34

    tcp_segs_free(pcb->unsent);
    14a0:	687b      	ldr	r3, [r7, #4]
    14a2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    14a4:	4618      	mov	r0, r3
    14a6:	f7ff fffe 	bl	1054 <tcp_segs_free>
			14a6: R_ARM_THM_CALL	tcp_segs_free
    tcp_segs_free(pcb->unacked);
    14aa:	687b      	ldr	r3, [r7, #4]
    14ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14ae:	4618      	mov	r0, r3
    14b0:	f7ff fffe 	bl	1054 <tcp_segs_free>
			14b0: R_ARM_THM_CALL	tcp_segs_free
    pcb->unacked = pcb->unsent = NULL;
    14b4:	687b      	ldr	r3, [r7, #4]
    14b6:	f04f 0200 	mov.w	r2, #0
    14ba:	66da      	str	r2, [r3, #108]	; 0x6c
    14bc:	687b      	ldr	r3, [r7, #4]
    14be:	6eda      	ldr	r2, [r3, #108]	; 0x6c
    14c0:	687b      	ldr	r3, [r7, #4]
    14c2:	671a      	str	r2, [r3, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
    14c4:	687b      	ldr	r3, [r7, #4]
    14c6:	f04f 0200 	mov.w	r2, #0
    14ca:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
#endif /* TCP_OVERSIZE */
  }
}
    14ce:	f107 0708 	add.w	r7, r7, #8
    14d2:	46bd      	mov	sp, r7
    14d4:	bd80      	pop	{r7, pc}
    14d6:	bf00      	nop

000014d8 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
    14d8:	b580      	push	{r7, lr}
    14da:	b082      	sub	sp, #8
    14dc:	af00      	add	r7, sp, #0
    14de:	6078      	str	r0, [r7, #4]
    14e0:	6039      	str	r1, [r7, #0]
  TCP_RMV(pcblist, pcb);
    14e2:	687b      	ldr	r3, [r7, #4]
    14e4:	681a      	ldr	r2, [r3, #0]
    14e6:	683b      	ldr	r3, [r7, #0]
    14e8:	429a      	cmp	r2, r3
    14ea:	d105      	bne.n	14f8 <tcp_pcb_remove+0x20>
    14ec:	687b      	ldr	r3, [r7, #4]
    14ee:	681b      	ldr	r3, [r3, #0]
    14f0:	68da      	ldr	r2, [r3, #12]
    14f2:	687b      	ldr	r3, [r7, #4]
    14f4:	601a      	str	r2, [r3, #0]
    14f6:	e019      	b.n	152c <tcp_pcb_remove+0x54>
    14f8:	687b      	ldr	r3, [r7, #4]
    14fa:	681a      	ldr	r2, [r3, #0]
    14fc:	4b21      	ldr	r3, [pc, #132]	; (1584 <tcp_pcb_remove+0xac>)
    14fe:	601a      	str	r2, [r3, #0]
    1500:	e010      	b.n	1524 <tcp_pcb_remove+0x4c>
    1502:	4b20      	ldr	r3, [pc, #128]	; (1584 <tcp_pcb_remove+0xac>)
    1504:	681b      	ldr	r3, [r3, #0]
    1506:	68da      	ldr	r2, [r3, #12]
    1508:	683b      	ldr	r3, [r7, #0]
    150a:	429a      	cmp	r2, r3
    150c:	d105      	bne.n	151a <tcp_pcb_remove+0x42>
    150e:	4b1d      	ldr	r3, [pc, #116]	; (1584 <tcp_pcb_remove+0xac>)
    1510:	681b      	ldr	r3, [r3, #0]
    1512:	683a      	ldr	r2, [r7, #0]
    1514:	68d2      	ldr	r2, [r2, #12]
    1516:	60da      	str	r2, [r3, #12]
    1518:	e008      	b.n	152c <tcp_pcb_remove+0x54>
    151a:	4b1a      	ldr	r3, [pc, #104]	; (1584 <tcp_pcb_remove+0xac>)
    151c:	681b      	ldr	r3, [r3, #0]
    151e:	68da      	ldr	r2, [r3, #12]
    1520:	4b18      	ldr	r3, [pc, #96]	; (1584 <tcp_pcb_remove+0xac>)
    1522:	601a      	str	r2, [r3, #0]
    1524:	4b17      	ldr	r3, [pc, #92]	; (1584 <tcp_pcb_remove+0xac>)
    1526:	681b      	ldr	r3, [r3, #0]
    1528:	2b00      	cmp	r3, #0
    152a:	d1ea      	bne.n	1502 <tcp_pcb_remove+0x2a>
    152c:	683b      	ldr	r3, [r7, #0]
    152e:	f04f 0200 	mov.w	r2, #0
    1532:	60da      	str	r2, [r3, #12]

  tcp_pcb_purge(pcb);
    1534:	6838      	ldr	r0, [r7, #0]
    1536:	f7ff fffe 	bl	144c <tcp_pcb_purge>
			1536: R_ARM_THM_CALL	tcp_pcb_purge
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    153a:	683b      	ldr	r3, [r7, #0]
    153c:	7e1b      	ldrb	r3, [r3, #24]
    153e:	2b0a      	cmp	r3, #10
    1540:	d014      	beq.n	156c <tcp_pcb_remove+0x94>
     pcb->state != LISTEN &&
    1542:	683b      	ldr	r3, [r7, #0]
    1544:	7e1b      	ldrb	r3, [r3, #24]
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
    1546:	2b01      	cmp	r3, #1
    1548:	d010      	beq.n	156c <tcp_pcb_remove+0x94>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    154a:	683b      	ldr	r3, [r7, #0]
    154c:	7f9b      	ldrb	r3, [r3, #30]

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
    154e:	f003 0301 	and.w	r3, r3, #1
    1552:	b2db      	uxtb	r3, r3
    1554:	2b00      	cmp	r3, #0
    1556:	d009      	beq.n	156c <tcp_pcb_remove+0x94>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
    1558:	683b      	ldr	r3, [r7, #0]
    155a:	7f9b      	ldrb	r3, [r3, #30]
    155c:	f043 0302 	orr.w	r3, r3, #2
    1560:	b2da      	uxtb	r2, r3
    1562:	683b      	ldr	r3, [r7, #0]
    1564:	779a      	strb	r2, [r3, #30]
    tcp_output(pcb);
    1566:	6838      	ldr	r0, [r7, #0]
    1568:	f7ff fffe 	bl	0 <tcp_output>
			1568: R_ARM_THM_CALL	tcp_output
  }

  if (pcb->state != LISTEN) {
    156c:	683b      	ldr	r3, [r7, #0]
    156e:	7e1b      	ldrb	r3, [r3, #24]
    1570:	2b01      	cmp	r3, #1
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
    1572:	683b      	ldr	r3, [r7, #0]
    1574:	f04f 0200 	mov.w	r2, #0
    1578:	761a      	strb	r2, [r3, #24]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
    157a:	f107 0708 	add.w	r7, r7, #8
    157e:	46bd      	mov	sp, r7
    1580:	bd80      	pop	{r7, pc}
    1582:	bf00      	nop
    1584:	00000000 	.word	0x00000000
			1584: R_ARM_ABS32	tcp_tmp_pcb

00001588 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
    1588:	b480      	push	{r7}
    158a:	af00      	add	r7, sp, #0
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
    158c:	4b06      	ldr	r3, [pc, #24]	; (15a8 <tcp_next_iss+0x20>)
    158e:	681a      	ldr	r2, [r3, #0]
    1590:	4b06      	ldr	r3, [pc, #24]	; (15ac <tcp_next_iss+0x24>)
    1592:	681b      	ldr	r3, [r3, #0]
    1594:	18d2      	adds	r2, r2, r3
    1596:	4b04      	ldr	r3, [pc, #16]	; (15a8 <tcp_next_iss+0x20>)
    1598:	601a      	str	r2, [r3, #0]
  return iss;
    159a:	4b03      	ldr	r3, [pc, #12]	; (15a8 <tcp_next_iss+0x20>)
    159c:	681b      	ldr	r3, [r3, #0]
}
    159e:	4618      	mov	r0, r3
    15a0:	46bd      	mov	sp, r7
    15a2:	bc80      	pop	{r7}
    15a4:	4770      	bx	lr
    15a6:	bf00      	nop
    15a8:	00000004 	.word	0x00000004
			15a8: R_ARM_ABS32	.data
    15ac:	00000000 	.word	0x00000000
			15ac: R_ARM_ABS32	tcp_ticks

000015b0 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
    15b0:	b580      	push	{r7, lr}
    15b2:	b084      	sub	sp, #16
    15b4:	af00      	add	r7, sp, #0
    15b6:	4603      	mov	r3, r0
    15b8:	6039      	str	r1, [r7, #0]
    15ba:	80fb      	strh	r3, [r7, #6]
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
    15bc:	6838      	ldr	r0, [r7, #0]
    15be:	f7ff fffe 	bl	0 <ip_route>
			15be: R_ARM_THM_CALL	ip_route
    15c2:	60f8      	str	r0, [r7, #12]
  if ((outif != NULL) && (outif->mtu != 0)) {
    15c4:	68fb      	ldr	r3, [r7, #12]
    15c6:	2b00      	cmp	r3, #0
    15c8:	d00e      	beq.n	15e8 <tcp_eff_send_mss+0x38>
    15ca:	68fb      	ldr	r3, [r7, #12]
    15cc:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    15ce:	2b00      	cmp	r3, #0
    15d0:	d00a      	beq.n	15e8 <tcp_eff_send_mss+0x38>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    15d2:	68fb      	ldr	r3, [r7, #12]
    15d4:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    15d6:	f1a3 0328 	sub.w	r3, r3, #40	; 0x28
    15da:	817b      	strh	r3, [r7, #10]
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
    15dc:	897a      	ldrh	r2, [r7, #10]
    15de:	88fb      	ldrh	r3, [r7, #6]
    15e0:	429a      	cmp	r2, r3
    15e2:	bf38      	it	cc
    15e4:	4613      	movcc	r3, r2
    15e6:	80fb      	strh	r3, [r7, #6]
  }
  return sendmss;
    15e8:	88fb      	ldrh	r3, [r7, #6]
}
    15ea:	4618      	mov	r0, r3
    15ec:	f107 0710 	add.w	r7, r7, #16
    15f0:	46bd      	mov	sp, r7
    15f2:	bd80      	pop	{r7, pc}

000015f4 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
    15f4:	b480      	push	{r7}
    15f6:	b083      	sub	sp, #12
    15f8:	af00      	add	r7, sp, #0
    15fa:	4603      	mov	r3, r0
    15fc:	71fb      	strb	r3, [r7, #7]
  return tcp_state_str[s];
    15fe:	79fa      	ldrb	r2, [r7, #7]
    1600:	4b04      	ldr	r3, [pc, #16]	; (1614 <tcp_debug_state_str+0x20>)
    1602:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
}
    1606:	4618      	mov	r0, r3
    1608:	f107 070c 	add.w	r7, r7, #12
    160c:	46bd      	mov	sp, r7
    160e:	bc80      	pop	{r7}
    1610:	4770      	bx	lr
    1612:	bf00      	nop
    1614:	00000000 	.word	0x00000000
			1614: R_ARM_ABS32	tcp_state_str

tcp_in.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  62620 Jul 30 19:07 2021 tcp_in.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002114  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00002148  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002c  00000000  00000000  00002148  2**2
                  ALLOC
  3 .debug_abbrev 00000218  00000000  00000000  00002148  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000f4c  00000000  00000000  00002360  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000085e  00000000  00000000  000032ac  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00008df6  00000000  00000000  00003b0a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000018a  00000000  00000000  0000c900  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000032  00000000  00000000  0000ca8a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000001eb  00000000  00000000  0000cabc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000cca7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000007e1  00000000  00000000  0000ccc7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000d4a8  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000d4d3  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000f8  00000000  00000000  0000d504  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 inseg
00000010 l       .bss	00000000 tcphdr
00000014 l       .bss	00000000 iphdr
00000018 l       .bss	00000000 seqno
0000001c l       .bss	00000000 ackno
00000020 l       .bss	00000000 flags
00000022 l       .bss	00000000 tcplen
00000024 l       .bss	00000000 recv_flags
00000028 l       .bss	00000000 recv_data
000007f4 l     F .text	000000e4 tcp_timewait_input
00000648 l     F .text	000001ac tcp_listen_input
000008d8 l     F .text	0000073e tcp_process
00001fe8 l     F .text	0000012c tcp_parseopt
0000110c l     F .text	00000edc tcp_receive
00001018 l     F .text	000000f4 tcp_oos_insert_segment
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 tcp_input_pcb
00000000 g     F .text	00000648 tcp_input
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 ip4_addr_isbroadcast
00000000         *UND*	00000000 lwip_ntohs
00000000         *UND*	00000000 lwip_ntohl
00000000         *UND*	00000000 current_iphdr_dest
00000000         *UND*	00000000 tcp_active_pcbs
00000000         *UND*	00000000 current_iphdr_src
00000000         *UND*	00000000 tcp_tw_pcbs
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 tcp_process_refused_data
00000000         *UND*	00000000 tcp_pcb_remove
00000000         *UND*	00000000 memp_free
00000000         *UND*	00000000 tcp_listen_pcbs
00000000         *UND*	00000000 tcp_abort
00000000         *UND*	00000000 tcp_recv_null
00000000         *UND*	00000000 tcp_output
00000000         *UND*	00000000 tcp_rst
00000000         *UND*	00000000 tcp_alloc
00000000         *UND*	00000000 tcp_timer_needed
00000000         *UND*	00000000 tcp_eff_send_mss
00000000         *UND*	00000000 tcp_enqueue_flags
00000000         *UND*	00000000 tcp_abandon
00000000         *UND*	00000000 tcp_active_pcbs_changed
00000000         *UND*	00000000 tcp_ticks
00000000         *UND*	00000000 tcp_seg_free
00000000         *UND*	00000000 tcp_rexmit
00000000         *UND*	00000000 tcp_pcb_purge
00000000         *UND*	00000000 tcp_tmp_pcb
00000000         *UND*	00000000 tcp_segs_free
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 pbuf_realloc
00000000         *UND*	00000000 tcp_rexmit_fast
00000000         *UND*	00000000 pbuf_clen
00000000         *UND*	00000000 tcp_update_rcv_ann_wnd
00000000         *UND*	00000000 pbuf_cat
00000000         *UND*	00000000 tcp_send_empty_ack
00000000         *UND*	00000000 tcp_seg_copy



Disassembly of section .text:

00000000 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
       0:	b590      	push	{r4, r7, lr}
       2:	b089      	sub	sp, #36	; 0x24
       4:	af02      	add	r7, sp, #8
       6:	6078      	str	r0, [r7, #4]
       8:	6039      	str	r1, [r7, #0]
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
       a:	687b      	ldr	r3, [r7, #4]
       c:	685b      	ldr	r3, [r3, #4]
       e:	461a      	mov	r2, r3
      10:	4b7a      	ldr	r3, [pc, #488]	; (1fc <tcp_input+0x1fc>)
      12:	601a      	str	r2, [r3, #0]
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
      14:	687b      	ldr	r3, [r7, #4]
      16:	685b      	ldr	r3, [r3, #4]
      18:	461a      	mov	r2, r3
      1a:	4b78      	ldr	r3, [pc, #480]	; (1fc <tcp_input+0x1fc>)
      1c:	681b      	ldr	r3, [r3, #0]
      1e:	781b      	ldrb	r3, [r3, #0]
      20:	f003 030f 	and.w	r3, r3, #15
      24:	ea4f 0383 	mov.w	r3, r3, lsl #2
      28:	18d2      	adds	r2, r2, r3
      2a:	4b75      	ldr	r3, [pc, #468]	; (200 <tcp_input+0x200>)
      2c:	601a      	str	r2, [r3, #0]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
      2e:	4b73      	ldr	r3, [pc, #460]	; (1fc <tcp_input+0x1fc>)
      30:	681b      	ldr	r3, [r3, #0]
      32:	781b      	ldrb	r3, [r3, #0]
      34:	f003 030f 	and.w	r3, r3, #15
      38:	b29b      	uxth	r3, r3
      3a:	ea4f 0383 	mov.w	r3, r3, lsl #2
      3e:	b29b      	uxth	r3, r3
      40:	f1c3 0300 	rsb	r3, r3, #0
      44:	b29b      	uxth	r3, r3
      46:	b29b      	uxth	r3, r3
      48:	b21b      	sxth	r3, r3
      4a:	6878      	ldr	r0, [r7, #4]
      4c:	4619      	mov	r1, r3
      4e:	f7ff fffe 	bl	0 <pbuf_header>
			4e: R_ARM_THM_CALL	pbuf_header
      52:	4603      	mov	r3, r0
      54:	2b00      	cmp	r3, #0
      56:	f040 82da 	bne.w	60e <tcp_input+0x60e>
      5a:	687b      	ldr	r3, [r7, #4]
      5c:	891b      	ldrh	r3, [r3, #8]
      5e:	2b13      	cmp	r3, #19
      60:	f240 82d5 	bls.w	60e <tcp_input+0x60e>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
      64:	4b67      	ldr	r3, [pc, #412]	; (204 <tcp_input+0x204>)
      66:	681b      	ldr	r3, [r3, #0]
      68:	4618      	mov	r0, r3
      6a:	6839      	ldr	r1, [r7, #0]
      6c:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			6c: R_ARM_THM_CALL	ip4_addr_isbroadcast
      70:	4603      	mov	r3, r0
      72:	2b00      	cmp	r3, #0
      74:	f040 82cb 	bne.w	60e <tcp_input+0x60e>
      ip_addr_ismulticast(&current_iphdr_dest)) {
      78:	4b62      	ldr	r3, [pc, #392]	; (204 <tcp_input+0x204>)
      7a:	681b      	ldr	r3, [r3, #0]
      7c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
      80:	2be0      	cmp	r3, #224	; 0xe0
      82:	f000 82c4 	beq.w	60e <tcp_input+0x60e>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
      86:	4b5e      	ldr	r3, [pc, #376]	; (200 <tcp_input+0x200>)
      88:	681b      	ldr	r3, [r3, #0]
      8a:	899b      	ldrh	r3, [r3, #12]
      8c:	b29b      	uxth	r3, r3
      8e:	4618      	mov	r0, r3
      90:	f7ff fffe 	bl	0 <lwip_ntohs>
			90: R_ARM_THM_CALL	lwip_ntohs
      94:	4603      	mov	r3, r0
      96:	ea4f 3313 	mov.w	r3, r3, lsr #12
      9a:	b29b      	uxth	r3, r3
      9c:	72bb      	strb	r3, [r7, #10]
  if(pbuf_header(p, -(hdrlen * 4))){
      9e:	7abb      	ldrb	r3, [r7, #10]
      a0:	b29b      	uxth	r3, r3
      a2:	461a      	mov	r2, r3
      a4:	ea4f 3282 	mov.w	r2, r2, lsl #14
      a8:	1ad3      	subs	r3, r2, r3
      aa:	ea4f 0383 	mov.w	r3, r3, lsl #2
      ae:	b29b      	uxth	r3, r3
      b0:	b29b      	uxth	r3, r3
      b2:	b21b      	sxth	r3, r3
      b4:	6878      	ldr	r0, [r7, #4]
      b6:	4619      	mov	r1, r3
      b8:	f7ff fffe 	bl	0 <pbuf_header>
			b8: R_ARM_THM_CALL	pbuf_header
      bc:	4603      	mov	r3, r0
      be:	2b00      	cmp	r3, #0
      c0:	f040 82a4 	bne.w	60c <tcp_input+0x60c>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
      c4:	4b4e      	ldr	r3, [pc, #312]	; (200 <tcp_input+0x200>)
      c6:	681c      	ldr	r4, [r3, #0]
      c8:	4b4d      	ldr	r3, [pc, #308]	; (200 <tcp_input+0x200>)
      ca:	681b      	ldr	r3, [r3, #0]
      cc:	881b      	ldrh	r3, [r3, #0]
      ce:	b29b      	uxth	r3, r3
      d0:	4618      	mov	r0, r3
      d2:	f7ff fffe 	bl	0 <lwip_ntohs>
			d2: R_ARM_THM_CALL	lwip_ntohs
      d6:	4603      	mov	r3, r0
      d8:	8023      	strh	r3, [r4, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
      da:	4b49      	ldr	r3, [pc, #292]	; (200 <tcp_input+0x200>)
      dc:	681c      	ldr	r4, [r3, #0]
      de:	4b48      	ldr	r3, [pc, #288]	; (200 <tcp_input+0x200>)
      e0:	681b      	ldr	r3, [r3, #0]
      e2:	885b      	ldrh	r3, [r3, #2]
      e4:	b29b      	uxth	r3, r3
      e6:	4618      	mov	r0, r3
      e8:	f7ff fffe 	bl	0 <lwip_ntohs>
			e8: R_ARM_THM_CALL	lwip_ntohs
      ec:	4603      	mov	r3, r0
      ee:	8063      	strh	r3, [r4, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
      f0:	4b43      	ldr	r3, [pc, #268]	; (200 <tcp_input+0x200>)
      f2:	681c      	ldr	r4, [r3, #0]
      f4:	4b42      	ldr	r3, [pc, #264]	; (200 <tcp_input+0x200>)
      f6:	681b      	ldr	r3, [r3, #0]
      f8:	685b      	ldr	r3, [r3, #4]
      fa:	4618      	mov	r0, r3
      fc:	f7ff fffe 	bl	0 <lwip_ntohl>
			fc: R_ARM_THM_CALL	lwip_ntohl
     100:	4603      	mov	r3, r0
     102:	6063      	str	r3, [r4, #4]
     104:	6862      	ldr	r2, [r4, #4]
     106:	4b40      	ldr	r3, [pc, #256]	; (208 <tcp_input+0x208>)
     108:	601a      	str	r2, [r3, #0]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
     10a:	4b3d      	ldr	r3, [pc, #244]	; (200 <tcp_input+0x200>)
     10c:	681c      	ldr	r4, [r3, #0]
     10e:	4b3c      	ldr	r3, [pc, #240]	; (200 <tcp_input+0x200>)
     110:	681b      	ldr	r3, [r3, #0]
     112:	689b      	ldr	r3, [r3, #8]
     114:	4618      	mov	r0, r3
     116:	f7ff fffe 	bl	0 <lwip_ntohl>
			116: R_ARM_THM_CALL	lwip_ntohl
     11a:	4603      	mov	r3, r0
     11c:	60a3      	str	r3, [r4, #8]
     11e:	68a2      	ldr	r2, [r4, #8]
     120:	4b3a      	ldr	r3, [pc, #232]	; (20c <tcp_input+0x20c>)
     122:	601a      	str	r2, [r3, #0]
  tcphdr->wnd = ntohs(tcphdr->wnd);
     124:	4b36      	ldr	r3, [pc, #216]	; (200 <tcp_input+0x200>)
     126:	681c      	ldr	r4, [r3, #0]
     128:	4b35      	ldr	r3, [pc, #212]	; (200 <tcp_input+0x200>)
     12a:	681b      	ldr	r3, [r3, #0]
     12c:	89db      	ldrh	r3, [r3, #14]
     12e:	b29b      	uxth	r3, r3
     130:	4618      	mov	r0, r3
     132:	f7ff fffe 	bl	0 <lwip_ntohs>
			132: R_ARM_THM_CALL	lwip_ntohs
     136:	4603      	mov	r3, r0
     138:	81e3      	strh	r3, [r4, #14]

  flags = TCPH_FLAGS(tcphdr);
     13a:	4b31      	ldr	r3, [pc, #196]	; (200 <tcp_input+0x200>)
     13c:	681b      	ldr	r3, [r3, #0]
     13e:	899b      	ldrh	r3, [r3, #12]
     140:	b29b      	uxth	r3, r3
     142:	4618      	mov	r0, r3
     144:	f7ff fffe 	bl	0 <lwip_ntohs>
			144: R_ARM_THM_CALL	lwip_ntohs
     148:	4603      	mov	r3, r0
     14a:	b2db      	uxtb	r3, r3
     14c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
     150:	b2da      	uxtb	r2, r3
     152:	4b2f      	ldr	r3, [pc, #188]	; (210 <tcp_input+0x210>)
     154:	701a      	strb	r2, [r3, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
     156:	687b      	ldr	r3, [r7, #4]
     158:	891a      	ldrh	r2, [r3, #8]
     15a:	4b2d      	ldr	r3, [pc, #180]	; (210 <tcp_input+0x210>)
     15c:	781b      	ldrb	r3, [r3, #0]
     15e:	f003 0303 	and.w	r3, r3, #3
     162:	2b00      	cmp	r3, #0
     164:	bf0c      	ite	eq
     166:	2300      	moveq	r3, #0
     168:	2301      	movne	r3, #1
     16a:	b29b      	uxth	r3, r3
     16c:	18d3      	adds	r3, r2, r3
     16e:	b29a      	uxth	r2, r3
     170:	4b28      	ldr	r3, [pc, #160]	; (214 <tcp_input+0x214>)
     172:	801a      	strh	r2, [r3, #0]

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
     174:	f04f 0300 	mov.w	r3, #0
     178:	613b      	str	r3, [r7, #16]

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
     17a:	4b27      	ldr	r3, [pc, #156]	; (218 <tcp_input+0x218>)
     17c:	681b      	ldr	r3, [r3, #0]
     17e:	617b      	str	r3, [r7, #20]
     180:	e02f      	b.n	1e2 <tcp_input+0x1e2>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
     182:	697b      	ldr	r3, [r7, #20]
     184:	8b9a      	ldrh	r2, [r3, #28]
     186:	4b1e      	ldr	r3, [pc, #120]	; (200 <tcp_input+0x200>)
     188:	681b      	ldr	r3, [r3, #0]
     18a:	881b      	ldrh	r3, [r3, #0]
     18c:	b29b      	uxth	r3, r3
     18e:	429a      	cmp	r2, r3
     190:	d122      	bne.n	1d8 <tcp_input+0x1d8>
       pcb->local_port == tcphdr->dest &&
     192:	697b      	ldr	r3, [r7, #20]
     194:	8b5a      	ldrh	r2, [r3, #26]
     196:	4b1a      	ldr	r3, [pc, #104]	; (200 <tcp_input+0x200>)
     198:	681b      	ldr	r3, [r3, #0]
     19a:	885b      	ldrh	r3, [r3, #2]
     19c:	b29b      	uxth	r3, r3
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
     19e:	429a      	cmp	r2, r3
     1a0:	d11a      	bne.n	1d8 <tcp_input+0x1d8>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
     1a2:	697b      	ldr	r3, [r7, #20]
     1a4:	685a      	ldr	r2, [r3, #4]
     1a6:	4b1d      	ldr	r3, [pc, #116]	; (21c <tcp_input+0x21c>)
     1a8:	681b      	ldr	r3, [r3, #0]
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
     1aa:	429a      	cmp	r2, r3
     1ac:	d114      	bne.n	1d8 <tcp_input+0x1d8>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
     1ae:	697b      	ldr	r3, [r7, #20]
     1b0:	681a      	ldr	r2, [r3, #0]
     1b2:	4b14      	ldr	r3, [pc, #80]	; (204 <tcp_input+0x204>)
     1b4:	681b      	ldr	r3, [r3, #0]
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
     1b6:	429a      	cmp	r2, r3
     1b8:	d10e      	bne.n	1d8 <tcp_input+0x1d8>

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
     1ba:	693b      	ldr	r3, [r7, #16]
     1bc:	2b00      	cmp	r3, #0
     1be:	d014      	beq.n	1ea <tcp_input+0x1ea>
        prev->next = pcb->next;
     1c0:	697b      	ldr	r3, [r7, #20]
     1c2:	68da      	ldr	r2, [r3, #12]
     1c4:	693b      	ldr	r3, [r7, #16]
     1c6:	60da      	str	r2, [r3, #12]
        pcb->next = tcp_active_pcbs;
     1c8:	4b13      	ldr	r3, [pc, #76]	; (218 <tcp_input+0x218>)
     1ca:	681a      	ldr	r2, [r3, #0]
     1cc:	697b      	ldr	r3, [r7, #20]
     1ce:	60da      	str	r2, [r3, #12]
        tcp_active_pcbs = pcb;
     1d0:	4b11      	ldr	r3, [pc, #68]	; (218 <tcp_input+0x218>)
     1d2:	697a      	ldr	r2, [r7, #20]
     1d4:	601a      	str	r2, [r3, #0]
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
     1d6:	e009      	b.n	1ec <tcp_input+0x1ec>
    }
    prev = pcb;
     1d8:	697b      	ldr	r3, [r7, #20]
     1da:	613b      	str	r3, [r7, #16]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
     1dc:	697b      	ldr	r3, [r7, #20]
     1de:	68db      	ldr	r3, [r3, #12]
     1e0:	617b      	str	r3, [r7, #20]
     1e2:	697b      	ldr	r3, [r7, #20]
     1e4:	2b00      	cmp	r3, #0
     1e6:	d1cc      	bne.n	182 <tcp_input+0x182>
     1e8:	e000      	b.n	1ec <tcp_input+0x1ec>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
     1ea:	bf00      	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
     1ec:	697b      	ldr	r3, [r7, #20]
     1ee:	2b00      	cmp	r3, #0
     1f0:	d17d      	bne.n	2ee <tcp_input+0x2ee>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
     1f2:	4b0b      	ldr	r3, [pc, #44]	; (220 <tcp_input+0x220>)
     1f4:	681b      	ldr	r3, [r3, #0]
     1f6:	617b      	str	r3, [r7, #20]
     1f8:	e03a      	b.n	270 <tcp_input+0x270>
     1fa:	bf00      	nop
     1fc:	00000014 	.word	0x00000014
			1fc: R_ARM_ABS32	.bss
     200:	00000010 	.word	0x00000010
			200: R_ARM_ABS32	.bss
     204:	00000000 	.word	0x00000000
			204: R_ARM_ABS32	current_iphdr_dest
     208:	00000018 	.word	0x00000018
			208: R_ARM_ABS32	.bss
     20c:	0000001c 	.word	0x0000001c
			20c: R_ARM_ABS32	.bss
     210:	00000020 	.word	0x00000020
			210: R_ARM_ABS32	.bss
     214:	00000022 	.word	0x00000022
			214: R_ARM_ABS32	.bss
	...
			218: R_ARM_ABS32	tcp_active_pcbs
			21c: R_ARM_ABS32	current_iphdr_src
			220: R_ARM_ABS32	tcp_tw_pcbs
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
     224:	697b      	ldr	r3, [r7, #20]
     226:	8b9a      	ldrh	r2, [r3, #28]
     228:	4b84      	ldr	r3, [pc, #528]	; (43c <tcp_input+0x43c>)
     22a:	681b      	ldr	r3, [r3, #0]
     22c:	881b      	ldrh	r3, [r3, #0]
     22e:	b29b      	uxth	r3, r3
     230:	429a      	cmp	r2, r3
     232:	d11a      	bne.n	26a <tcp_input+0x26a>
         pcb->local_port == tcphdr->dest &&
     234:	697b      	ldr	r3, [r7, #20]
     236:	8b5a      	ldrh	r2, [r3, #26]
     238:	4b80      	ldr	r3, [pc, #512]	; (43c <tcp_input+0x43c>)
     23a:	681b      	ldr	r3, [r3, #0]
     23c:	885b      	ldrh	r3, [r3, #2]
     23e:	b29b      	uxth	r3, r3
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
     240:	429a      	cmp	r2, r3
     242:	d112      	bne.n	26a <tcp_input+0x26a>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
     244:	697b      	ldr	r3, [r7, #20]
     246:	685a      	ldr	r2, [r3, #4]
     248:	4b7d      	ldr	r3, [pc, #500]	; (440 <tcp_input+0x440>)
     24a:	681b      	ldr	r3, [r3, #0]
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
     24c:	429a      	cmp	r2, r3
     24e:	d10c      	bne.n	26a <tcp_input+0x26a>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
     250:	697b      	ldr	r3, [r7, #20]
     252:	681a      	ldr	r2, [r3, #0]
     254:	4b7b      	ldr	r3, [pc, #492]	; (444 <tcp_input+0x444>)
     256:	681b      	ldr	r3, [r3, #0]
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
     258:	429a      	cmp	r2, r3
     25a:	d106      	bne.n	26a <tcp_input+0x26a>
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
     25c:	6978      	ldr	r0, [r7, #20]
     25e:	f000 fac9 	bl	7f4 <tcp_timewait_input>
        pbuf_free(p);
     262:	6878      	ldr	r0, [r7, #4]
     264:	f7ff fffe 	bl	0 <pbuf_free>
			264: R_ARM_THM_CALL	pbuf_free
        return;
     268:	e1d6      	b.n	618 <tcp_input+0x618>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
     26a:	697b      	ldr	r3, [r7, #20]
     26c:	68db      	ldr	r3, [r3, #12]
     26e:	617b      	str	r3, [r7, #20]
     270:	697b      	ldr	r3, [r7, #20]
     272:	2b00      	cmp	r3, #0
     274:	d1d6      	bne.n	224 <tcp_input+0x224>
      }
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
     276:	f04f 0300 	mov.w	r3, #0
     27a:	613b      	str	r3, [r7, #16]
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
     27c:	4b72      	ldr	r3, [pc, #456]	; (448 <tcp_input+0x448>)
     27e:	681b      	ldr	r3, [r3, #0]
     280:	60fb      	str	r3, [r7, #12]
     282:	e019      	b.n	2b8 <tcp_input+0x2b8>
      if (lpcb->local_port == tcphdr->dest) {
     284:	68fb      	ldr	r3, [r7, #12]
     286:	8b5a      	ldrh	r2, [r3, #26]
     288:	4b6c      	ldr	r3, [pc, #432]	; (43c <tcp_input+0x43c>)
     28a:	681b      	ldr	r3, [r3, #0]
     28c:	885b      	ldrh	r3, [r3, #2]
     28e:	b29b      	uxth	r3, r3
     290:	429a      	cmp	r2, r3
     292:	d10c      	bne.n	2ae <tcp_input+0x2ae>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
     294:	68fb      	ldr	r3, [r7, #12]
     296:	681a      	ldr	r2, [r3, #0]
     298:	4b6a      	ldr	r3, [pc, #424]	; (444 <tcp_input+0x444>)
     29a:	681b      	ldr	r3, [r3, #0]
     29c:	429a      	cmp	r2, r3
     29e:	d00e      	beq.n	2be <tcp_input+0x2be>
            ip_addr_isany(&(lpcb->local_ip))) {
     2a0:	68fb      	ldr	r3, [r7, #12]
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
     2a2:	2b00      	cmp	r3, #0
     2a4:	d00b      	beq.n	2be <tcp_input+0x2be>
            ip_addr_isany(&(lpcb->local_ip))) {
     2a6:	68fb      	ldr	r3, [r7, #12]
     2a8:	681b      	ldr	r3, [r3, #0]
     2aa:	2b00      	cmp	r3, #0
     2ac:	d007      	beq.n	2be <tcp_input+0x2be>
          /* found a match */
          break;
        }
#endif /* SO_REUSE */
      }
      prev = (struct tcp_pcb *)lpcb;
     2ae:	68fb      	ldr	r3, [r7, #12]
     2b0:	613b      	str	r3, [r7, #16]
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
     2b2:	68fb      	ldr	r3, [r7, #12]
     2b4:	68db      	ldr	r3, [r3, #12]
     2b6:	60fb      	str	r3, [r7, #12]
     2b8:	68fb      	ldr	r3, [r7, #12]
     2ba:	2b00      	cmp	r3, #0
     2bc:	d1e2      	bne.n	284 <tcp_input+0x284>
      /* only pass to ANY if no specific local IP has been found */
      lpcb = lpcb_any;
      prev = lpcb_prev;
    }
#endif /* SO_REUSE */
    if (lpcb != NULL) {
     2be:	68fb      	ldr	r3, [r7, #12]
     2c0:	2b00      	cmp	r3, #0
     2c2:	d014      	beq.n	2ee <tcp_input+0x2ee>
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
     2c4:	693b      	ldr	r3, [r7, #16]
     2c6:	2b00      	cmp	r3, #0
     2c8:	d00a      	beq.n	2e0 <tcp_input+0x2e0>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
     2ca:	693b      	ldr	r3, [r7, #16]
     2cc:	68fa      	ldr	r2, [r7, #12]
     2ce:	68d2      	ldr	r2, [r2, #12]
     2d0:	60da      	str	r2, [r3, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
     2d2:	4b5d      	ldr	r3, [pc, #372]	; (448 <tcp_input+0x448>)
     2d4:	681a      	ldr	r2, [r3, #0]
     2d6:	68fb      	ldr	r3, [r7, #12]
     2d8:	60da      	str	r2, [r3, #12]
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
     2da:	4b5b      	ldr	r3, [pc, #364]	; (448 <tcp_input+0x448>)
     2dc:	68fa      	ldr	r2, [r7, #12]
     2de:	601a      	str	r2, [r3, #0]
      }
    
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
      tcp_listen_input(lpcb);
     2e0:	68f8      	ldr	r0, [r7, #12]
     2e2:	f000 f9b1 	bl	648 <tcp_listen_input>
      pbuf_free(p);
     2e6:	6878      	ldr	r0, [r7, #4]
     2e8:	f7ff fffe 	bl	0 <pbuf_free>
			2e8: R_ARM_THM_CALL	pbuf_free
      return;
     2ec:	e194      	b.n	618 <tcp_input+0x618>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
     2ee:	697b      	ldr	r3, [r7, #20]
     2f0:	2b00      	cmp	r3, #0
     2f2:	f000 8163 	beq.w	5bc <tcp_input+0x5bc>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
     2f6:	4b55      	ldr	r3, [pc, #340]	; (44c <tcp_input+0x44c>)
     2f8:	f04f 0200 	mov.w	r2, #0
     2fc:	601a      	str	r2, [r3, #0]
    inseg.len = p->tot_len;
     2fe:	687b      	ldr	r3, [r7, #4]
     300:	891a      	ldrh	r2, [r3, #8]
     302:	4b52      	ldr	r3, [pc, #328]	; (44c <tcp_input+0x44c>)
     304:	811a      	strh	r2, [r3, #8]
    inseg.p = p;
     306:	4b51      	ldr	r3, [pc, #324]	; (44c <tcp_input+0x44c>)
     308:	687a      	ldr	r2, [r7, #4]
     30a:	605a      	str	r2, [r3, #4]
    inseg.tcphdr = tcphdr;
     30c:	4b4b      	ldr	r3, [pc, #300]	; (43c <tcp_input+0x43c>)
     30e:	681a      	ldr	r2, [r3, #0]
     310:	4b4e      	ldr	r3, [pc, #312]	; (44c <tcp_input+0x44c>)
     312:	60da      	str	r2, [r3, #12]

    recv_data = NULL;
     314:	4b4e      	ldr	r3, [pc, #312]	; (450 <tcp_input+0x450>)
     316:	f04f 0200 	mov.w	r2, #0
     31a:	601a      	str	r2, [r3, #0]
    recv_flags = 0;
     31c:	4b4d      	ldr	r3, [pc, #308]	; (454 <tcp_input+0x454>)
     31e:	f04f 0200 	mov.w	r2, #0
     322:	701a      	strb	r2, [r3, #0]

    if (flags & TCP_PSH) {
     324:	4b4c      	ldr	r3, [pc, #304]	; (458 <tcp_input+0x458>)
     326:	781b      	ldrb	r3, [r3, #0]
     328:	f003 0308 	and.w	r3, r3, #8
     32c:	2b00      	cmp	r3, #0
     32e:	d006      	beq.n	33e <tcp_input+0x33e>
      p->flags |= PBUF_FLAG_PUSH;
     330:	687b      	ldr	r3, [r7, #4]
     332:	7b5b      	ldrb	r3, [r3, #13]
     334:	f043 0301 	orr.w	r3, r3, #1
     338:	b2da      	uxtb	r2, r3
     33a:	687b      	ldr	r3, [r7, #4]
     33c:	735a      	strb	r2, [r3, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
     33e:	697b      	ldr	r3, [r7, #20]
     340:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     342:	2b00      	cmp	r3, #0
     344:	d010      	beq.n	368 <tcp_input+0x368>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
     346:	6978      	ldr	r0, [r7, #20]
     348:	f7ff fffe 	bl	0 <tcp_process_refused_data>
			348: R_ARM_THM_CALL	tcp_process_refused_data
     34c:	4603      	mov	r3, r0
     34e:	f113 0f0a 	cmn.w	r3, #10
     352:	f000 811d 	beq.w	590 <tcp_input+0x590>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
     356:	697b      	ldr	r3, [r7, #20]
     358:	6f9b      	ldr	r3, [r3, #120]	; 0x78
      p->flags |= PBUF_FLAG_PUSH;
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
     35a:	2b00      	cmp	r3, #0
     35c:	d004      	beq.n	368 <tcp_input+0x368>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
     35e:	4b3f      	ldr	r3, [pc, #252]	; (45c <tcp_input+0x45c>)
     360:	881b      	ldrh	r3, [r3, #0]
     362:	2b00      	cmp	r3, #0
     364:	f040 8114 	bne.w	590 <tcp_input+0x590>
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
     368:	4b3d      	ldr	r3, [pc, #244]	; (460 <tcp_input+0x460>)
     36a:	697a      	ldr	r2, [r7, #20]
     36c:	601a      	str	r2, [r3, #0]
    err = tcp_process(pcb);
     36e:	6978      	ldr	r0, [r7, #20]
     370:	f000 fab2 	bl	8d8 <tcp_process>
     374:	4603      	mov	r3, r0
     376:	72fb      	strb	r3, [r7, #11]
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
     378:	f997 300b 	ldrsb.w	r3, [r7, #11]
     37c:	f113 0f0a 	cmn.w	r3, #10
     380:	f000 8106 	beq.w	590 <tcp_input+0x590>
      if (recv_flags & TF_RESET) {
     384:	4b33      	ldr	r3, [pc, #204]	; (454 <tcp_input+0x454>)
     386:	781b      	ldrb	r3, [r3, #0]
     388:	f003 0308 	and.w	r3, r3, #8
     38c:	2b00      	cmp	r3, #0
     38e:	d017      	beq.n	3c0 <tcp_input+0x3c0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
     390:	697b      	ldr	r3, [r7, #20]
     392:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
     396:	2b00      	cmp	r3, #0
     398:	d008      	beq.n	3ac <tcp_input+0x3ac>
     39a:	697b      	ldr	r3, [r7, #20]
     39c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
     3a0:	697a      	ldr	r2, [r7, #20]
     3a2:	6912      	ldr	r2, [r2, #16]
     3a4:	4610      	mov	r0, r2
     3a6:	f06f 010a 	mvn.w	r1, #10
     3aa:	4798      	blx	r3
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
     3ac:	482d      	ldr	r0, [pc, #180]	; (464 <tcp_input+0x464>)
     3ae:	6979      	ldr	r1, [r7, #20]
     3b0:	f7ff fffe 	bl	0 <tcp_pcb_remove>
			3b0: R_ARM_THM_CALL	tcp_pcb_remove
        memp_free(MEMP_TCP_PCB, pcb);
     3b4:	f04f 0002 	mov.w	r0, #2
     3b8:	6979      	ldr	r1, [r7, #20]
     3ba:	f7ff fffe 	bl	0 <memp_free>
			3ba: R_ARM_THM_CALL	memp_free
     3be:	e0e7      	b.n	590 <tcp_input+0x590>
      } else if (recv_flags & TF_CLOSED) {
     3c0:	4b24      	ldr	r3, [pc, #144]	; (454 <tcp_input+0x454>)
     3c2:	781b      	ldrb	r3, [r3, #0]
     3c4:	f003 0310 	and.w	r3, r3, #16
     3c8:	2b00      	cmp	r3, #0
     3ca:	d01d      	beq.n	408 <tcp_input+0x408>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
     3cc:	697b      	ldr	r3, [r7, #20]
     3ce:	7f9b      	ldrb	r3, [r3, #30]
     3d0:	f003 0310 	and.w	r3, r3, #16
     3d4:	2b00      	cmp	r3, #0
     3d6:	d10d      	bne.n	3f4 <tcp_input+0x3f4>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
     3d8:	697b      	ldr	r3, [r7, #20]
     3da:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
     3de:	2b00      	cmp	r3, #0
     3e0:	d008      	beq.n	3f4 <tcp_input+0x3f4>
     3e2:	697b      	ldr	r3, [r7, #20]
     3e4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
     3e8:	697a      	ldr	r2, [r7, #20]
     3ea:	6912      	ldr	r2, [r2, #16]
     3ec:	4610      	mov	r0, r2
     3ee:	f06f 010b 	mvn.w	r1, #11
     3f2:	4798      	blx	r3
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
     3f4:	481b      	ldr	r0, [pc, #108]	; (464 <tcp_input+0x464>)
     3f6:	6979      	ldr	r1, [r7, #20]
     3f8:	f7ff fffe 	bl	0 <tcp_pcb_remove>
			3f8: R_ARM_THM_CALL	tcp_pcb_remove
        memp_free(MEMP_TCP_PCB, pcb);
     3fc:	f04f 0002 	mov.w	r0, #2
     400:	6979      	ldr	r1, [r7, #20]
     402:	f7ff fffe 	bl	0 <memp_free>
			402: R_ARM_THM_CALL	memp_free
     406:	e0c3      	b.n	590 <tcp_input+0x590>
      } else {
        err = ERR_OK;
     408:	f04f 0300 	mov.w	r3, #0
     40c:	72fb      	strb	r3, [r7, #11]
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
     40e:	697b      	ldr	r3, [r7, #20]
     410:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
     414:	2b00      	cmp	r3, #0
     416:	d030      	beq.n	47a <tcp_input+0x47a>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
     418:	697b      	ldr	r3, [r7, #20]
     41a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
     41c:	2b00      	cmp	r3, #0
     41e:	d023      	beq.n	468 <tcp_input+0x468>
     420:	697b      	ldr	r3, [r7, #20]
     422:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
     424:	697a      	ldr	r2, [r7, #20]
     426:	6911      	ldr	r1, [r2, #16]
     428:	697a      	ldr	r2, [r7, #20]
     42a:	f8b2 2064 	ldrh.w	r2, [r2, #100]	; 0x64
     42e:	4608      	mov	r0, r1
     430:	6979      	ldr	r1, [r7, #20]
     432:	4798      	blx	r3
     434:	4603      	mov	r3, r0
     436:	72fb      	strb	r3, [r7, #11]
     438:	e019      	b.n	46e <tcp_input+0x46e>
     43a:	bf00      	nop
     43c:	00000010 	.word	0x00000010
			43c: R_ARM_ABS32	.bss
	...
			440: R_ARM_ABS32	current_iphdr_src
			444: R_ARM_ABS32	current_iphdr_dest
			448: R_ARM_ABS32	tcp_listen_pcbs
			44c: R_ARM_ABS32	.bss
     450:	00000028 	.word	0x00000028
			450: R_ARM_ABS32	.bss
     454:	00000024 	.word	0x00000024
			454: R_ARM_ABS32	.bss
     458:	00000020 	.word	0x00000020
			458: R_ARM_ABS32	.bss
     45c:	00000022 	.word	0x00000022
			45c: R_ARM_ABS32	.bss
	...
			460: R_ARM_ABS32	tcp_input_pcb
			464: R_ARM_ABS32	tcp_active_pcbs
     468:	f04f 0300 	mov.w	r3, #0
     46c:	72fb      	strb	r3, [r7, #11]
          if (err == ERR_ABRT) {
     46e:	f997 300b 	ldrsb.w	r3, [r7, #11]
     472:	f113 0f0a 	cmn.w	r3, #10
     476:	f000 8086 	beq.w	586 <tcp_input+0x586>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
     47a:	4b69      	ldr	r3, [pc, #420]	; (620 <tcp_input+0x620>)
     47c:	681b      	ldr	r3, [r3, #0]
     47e:	2b00      	cmp	r3, #0
     480:	d03c      	beq.n	4fc <tcp_input+0x4fc>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
     482:	697b      	ldr	r3, [r7, #20]
     484:	7f9b      	ldrb	r3, [r3, #30]
     486:	f003 0310 	and.w	r3, r3, #16
     48a:	2b00      	cmp	r3, #0
     48c:	d008      	beq.n	4a0 <tcp_input+0x4a0>
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
     48e:	4b64      	ldr	r3, [pc, #400]	; (620 <tcp_input+0x620>)
     490:	681b      	ldr	r3, [r3, #0]
     492:	4618      	mov	r0, r3
     494:	f7ff fffe 	bl	0 <pbuf_free>
			494: R_ARM_THM_CALL	pbuf_free
            tcp_abort(pcb);
     498:	6978      	ldr	r0, [r7, #20]
     49a:	f7ff fffe 	bl	0 <tcp_abort>
			49a: R_ARM_THM_CALL	tcp_abort
            goto aborted;
     49e:	e077      	b.n	590 <tcp_input+0x590>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
     4a0:	697b      	ldr	r3, [r7, #20]
     4a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
     4a6:	2b00      	cmp	r3, #0
     4a8:	d00f      	beq.n	4ca <tcp_input+0x4ca>
     4aa:	697b      	ldr	r3, [r7, #20]
     4ac:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
     4b0:	697b      	ldr	r3, [r7, #20]
     4b2:	691a      	ldr	r2, [r3, #16]
     4b4:	4b5a      	ldr	r3, [pc, #360]	; (620 <tcp_input+0x620>)
     4b6:	681b      	ldr	r3, [r3, #0]
     4b8:	4610      	mov	r0, r2
     4ba:	6979      	ldr	r1, [r7, #20]
     4bc:	461a      	mov	r2, r3
     4be:	f04f 0300 	mov.w	r3, #0
     4c2:	47a0      	blx	r4
     4c4:	4603      	mov	r3, r0
     4c6:	72fb      	strb	r3, [r7, #11]
     4c8:	e00b      	b.n	4e2 <tcp_input+0x4e2>
     4ca:	4b55      	ldr	r3, [pc, #340]	; (620 <tcp_input+0x620>)
     4cc:	681b      	ldr	r3, [r3, #0]
     4ce:	f04f 0000 	mov.w	r0, #0
     4d2:	6979      	ldr	r1, [r7, #20]
     4d4:	461a      	mov	r2, r3
     4d6:	f04f 0300 	mov.w	r3, #0
     4da:	f7ff fffe 	bl	0 <tcp_recv_null>
			4da: R_ARM_THM_CALL	tcp_recv_null
     4de:	4603      	mov	r3, r0
     4e0:	72fb      	strb	r3, [r7, #11]
          if (err == ERR_ABRT) {
     4e2:	f997 300b 	ldrsb.w	r3, [r7, #11]
     4e6:	f113 0f0a 	cmn.w	r3, #10
     4ea:	d04e      	beq.n	58a <tcp_input+0x58a>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
     4ec:	f997 300b 	ldrsb.w	r3, [r7, #11]
     4f0:	2b00      	cmp	r3, #0
     4f2:	d003      	beq.n	4fc <tcp_input+0x4fc>
            pcb->refused_data = recv_data;
     4f4:	4b4a      	ldr	r3, [pc, #296]	; (620 <tcp_input+0x620>)
     4f6:	681a      	ldr	r2, [r3, #0]
     4f8:	697b      	ldr	r3, [r7, #20]
     4fa:	679a      	str	r2, [r3, #120]	; 0x78
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
     4fc:	4b49      	ldr	r3, [pc, #292]	; (624 <tcp_input+0x624>)
     4fe:	781b      	ldrb	r3, [r3, #0]
     500:	f003 0320 	and.w	r3, r3, #32
     504:	2b00      	cmp	r3, #0
     506:	d036      	beq.n	576 <tcp_input+0x576>
          if (pcb->refused_data != NULL) {
     508:	697b      	ldr	r3, [r7, #20]
     50a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     50c:	2b00      	cmp	r3, #0
     50e:	d009      	beq.n	524 <tcp_input+0x524>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
     510:	697b      	ldr	r3, [r7, #20]
     512:	6f9b      	ldr	r3, [r3, #120]	; 0x78
     514:	697a      	ldr	r2, [r7, #20]
     516:	6f92      	ldr	r2, [r2, #120]	; 0x78
     518:	7b52      	ldrb	r2, [r2, #13]
     51a:	f042 0220 	orr.w	r2, r2, #32
     51e:	b2d2      	uxtb	r2, r2
     520:	735a      	strb	r2, [r3, #13]
     522:	e028      	b.n	576 <tcp_input+0x576>
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
     524:	697b      	ldr	r3, [r7, #20]
     526:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
     528:	f241 7370 	movw	r3, #6000	; 0x1770
     52c:	429a      	cmp	r2, r3
     52e:	d006      	beq.n	53e <tcp_input+0x53e>
              pcb->rcv_wnd++;
     530:	697b      	ldr	r3, [r7, #20]
     532:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     534:	f103 0301 	add.w	r3, r3, #1
     538:	b29a      	uxth	r2, r3
     53a:	697b      	ldr	r3, [r7, #20]
     53c:	859a      	strh	r2, [r3, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
     53e:	697b      	ldr	r3, [r7, #20]
     540:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
     544:	2b00      	cmp	r3, #0
     546:	d00e      	beq.n	566 <tcp_input+0x566>
     548:	697b      	ldr	r3, [r7, #20]
     54a:	f8d3 4080 	ldr.w	r4, [r3, #128]	; 0x80
     54e:	697b      	ldr	r3, [r7, #20]
     550:	691b      	ldr	r3, [r3, #16]
     552:	4618      	mov	r0, r3
     554:	6979      	ldr	r1, [r7, #20]
     556:	f04f 0200 	mov.w	r2, #0
     55a:	f04f 0300 	mov.w	r3, #0
     55e:	47a0      	blx	r4
     560:	4603      	mov	r3, r0
     562:	72fb      	strb	r3, [r7, #11]
     564:	e002      	b.n	56c <tcp_input+0x56c>
     566:	f04f 0300 	mov.w	r3, #0
     56a:	72fb      	strb	r3, [r7, #11]
            if (err == ERR_ABRT) {
     56c:	f997 300b 	ldrsb.w	r3, [r7, #11]
     570:	f113 0f0a 	cmn.w	r3, #10
     574:	d00b      	beq.n	58e <tcp_input+0x58e>
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
     576:	4b2c      	ldr	r3, [pc, #176]	; (628 <tcp_input+0x628>)
     578:	f04f 0200 	mov.w	r2, #0
     57c:	601a      	str	r2, [r3, #0]
        /* Try to send something out. */
        tcp_output(pcb);
     57e:	6978      	ldr	r0, [r7, #20]
     580:	f7ff fffe 	bl	0 <tcp_output>
			580: R_ARM_THM_CALL	tcp_output
     584:	e004      	b.n	590 <tcp_input+0x590>
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
          TCP_EVENT_SENT(pcb, pcb->acked, err);
          if (err == ERR_ABRT) {
            goto aborted;
     586:	bf00      	nop
     588:	e002      	b.n	590 <tcp_input+0x590>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
          if (err == ERR_ABRT) {
            goto aborted;
     58a:	bf00      	nop
     58c:	e000      	b.n	590 <tcp_input+0x590>
            if (pcb->rcv_wnd != TCP_WND) {
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
            if (err == ERR_ABRT) {
              goto aborted;
     58e:	bf00      	nop
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
     590:	4b25      	ldr	r3, [pc, #148]	; (628 <tcp_input+0x628>)
     592:	f04f 0200 	mov.w	r2, #0
     596:	601a      	str	r2, [r3, #0]
    recv_data = NULL;
     598:	4b21      	ldr	r3, [pc, #132]	; (620 <tcp_input+0x620>)
     59a:	f04f 0200 	mov.w	r2, #0
     59e:	601a      	str	r2, [r3, #0]

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
     5a0:	4b22      	ldr	r3, [pc, #136]	; (62c <tcp_input+0x62c>)
     5a2:	685b      	ldr	r3, [r3, #4]
     5a4:	2b00      	cmp	r3, #0
     5a6:	d036      	beq.n	616 <tcp_input+0x616>
    {
      pbuf_free(inseg.p);
     5a8:	4b20      	ldr	r3, [pc, #128]	; (62c <tcp_input+0x62c>)
     5aa:	685b      	ldr	r3, [r3, #4]
     5ac:	4618      	mov	r0, r3
     5ae:	f7ff fffe 	bl	0 <pbuf_free>
			5ae: R_ARM_THM_CALL	pbuf_free
      inseg.p = NULL;
     5b2:	4b1e      	ldr	r3, [pc, #120]	; (62c <tcp_input+0x62c>)
     5b4:	f04f 0200 	mov.w	r2, #0
     5b8:	605a      	str	r2, [r3, #4]
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
     5ba:	e02d      	b.n	618 <tcp_input+0x618>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
     5bc:	4b1c      	ldr	r3, [pc, #112]	; (630 <tcp_input+0x630>)
     5be:	681b      	ldr	r3, [r3, #0]
     5c0:	899b      	ldrh	r3, [r3, #12]
     5c2:	b29b      	uxth	r3, r3
     5c4:	4618      	mov	r0, r3
     5c6:	f7ff fffe 	bl	0 <lwip_ntohs>
			5c6: R_ARM_THM_CALL	lwip_ntohs
     5ca:	4603      	mov	r3, r0
     5cc:	f003 0304 	and.w	r3, r3, #4
     5d0:	2b00      	cmp	r3, #0
     5d2:	d117      	bne.n	604 <tcp_input+0x604>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
     5d4:	4b17      	ldr	r3, [pc, #92]	; (634 <tcp_input+0x634>)
     5d6:	681a      	ldr	r2, [r3, #0]
     5d8:	4b17      	ldr	r3, [pc, #92]	; (638 <tcp_input+0x638>)
     5da:	881b      	ldrh	r3, [r3, #0]
     5dc:	4619      	mov	r1, r3
     5de:	4b17      	ldr	r3, [pc, #92]	; (63c <tcp_input+0x63c>)
     5e0:	681b      	ldr	r3, [r3, #0]
     5e2:	18cb      	adds	r3, r1, r3
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
     5e4:	4912      	ldr	r1, [pc, #72]	; (630 <tcp_input+0x630>)
     5e6:	6809      	ldr	r1, [r1, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
     5e8:	8849      	ldrh	r1, [r1, #2]
     5ea:	b288      	uxth	r0, r1
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
     5ec:	4910      	ldr	r1, [pc, #64]	; (630 <tcp_input+0x630>)
     5ee:	6809      	ldr	r1, [r1, #0]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
     5f0:	8809      	ldrh	r1, [r1, #0]
     5f2:	b289      	uxth	r1, r1
     5f4:	9000      	str	r0, [sp, #0]
     5f6:	9101      	str	r1, [sp, #4]
     5f8:	4610      	mov	r0, r2
     5fa:	4619      	mov	r1, r3
     5fc:	4a10      	ldr	r2, [pc, #64]	; (640 <tcp_input+0x640>)
     5fe:	4b11      	ldr	r3, [pc, #68]	; (644 <tcp_input+0x644>)
     600:	f7ff fffe 	bl	0 <tcp_rst>
			600: R_ARM_THM_CALL	tcp_rst
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
     604:	6878      	ldr	r0, [r7, #4]
     606:	f7ff fffe 	bl	0 <pbuf_free>
			606: R_ARM_THM_CALL	pbuf_free
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
     60a:	e005      	b.n	618 <tcp_input+0x618>
  hdrlen = TCPH_HDRLEN(tcphdr);
  if(pbuf_header(p, -(hdrlen * 4))){
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
     60c:	bf00      	nop
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
     60e:	6878      	ldr	r0, [r7, #4]
     610:	f7ff fffe 	bl	0 <pbuf_free>
			610: R_ARM_THM_CALL	pbuf_free
     614:	e000      	b.n	618 <tcp_input+0x618>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
  return;
     616:	bf00      	nop
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
     618:	f107 071c 	add.w	r7, r7, #28
     61c:	46bd      	mov	sp, r7
     61e:	bd90      	pop	{r4, r7, pc}
     620:	00000028 	.word	0x00000028
			620: R_ARM_ABS32	.bss
     624:	00000024 	.word	0x00000024
			624: R_ARM_ABS32	.bss
	...
			628: R_ARM_ABS32	tcp_input_pcb
			62c: R_ARM_ABS32	.bss
     630:	00000010 	.word	0x00000010
			630: R_ARM_ABS32	.bss
     634:	0000001c 	.word	0x0000001c
			634: R_ARM_ABS32	.bss
     638:	00000022 	.word	0x00000022
			638: R_ARM_ABS32	.bss
     63c:	00000018 	.word	0x00000018
			63c: R_ARM_ABS32	.bss
	...
			640: R_ARM_ABS32	current_iphdr_dest
			644: R_ARM_ABS32	current_iphdr_src

00000648 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
     648:	b580      	push	{r7, lr}
     64a:	b086      	sub	sp, #24
     64c:	af02      	add	r7, sp, #8
     64e:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
     650:	4b5f      	ldr	r3, [pc, #380]	; (7d0 <tcp_listen_input+0x188>)
     652:	781b      	ldrb	r3, [r3, #0]
     654:	f003 0304 	and.w	r3, r3, #4
     658:	2b00      	cmp	r3, #0
     65a:	d002      	beq.n	662 <tcp_listen_input+0x1a>
    /* An incoming RST should be ignored. Return. */
    return ERR_OK;
     65c:	f04f 0300 	mov.w	r3, #0
     660:	e0b0      	b.n	7c4 <tcp_listen_input+0x17c>
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
     662:	4b5b      	ldr	r3, [pc, #364]	; (7d0 <tcp_listen_input+0x188>)
     664:	781b      	ldrb	r3, [r3, #0]
     666:	f003 0310 	and.w	r3, r3, #16
     66a:	2b00      	cmp	r3, #0
     66c:	d018      	beq.n	6a0 <tcp_listen_input+0x58>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
     66e:	4b59      	ldr	r3, [pc, #356]	; (7d4 <tcp_listen_input+0x18c>)
     670:	681a      	ldr	r2, [r3, #0]
     672:	4b59      	ldr	r3, [pc, #356]	; (7d8 <tcp_listen_input+0x190>)
     674:	881b      	ldrh	r3, [r3, #0]
     676:	4619      	mov	r1, r3
     678:	4b58      	ldr	r3, [pc, #352]	; (7dc <tcp_listen_input+0x194>)
     67a:	681b      	ldr	r3, [r3, #0]
     67c:	18cb      	adds	r3, r1, r3
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
     67e:	4958      	ldr	r1, [pc, #352]	; (7e0 <tcp_listen_input+0x198>)
     680:	6809      	ldr	r1, [r1, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
     682:	8849      	ldrh	r1, [r1, #2]
     684:	b288      	uxth	r0, r1
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
     686:	4956      	ldr	r1, [pc, #344]	; (7e0 <tcp_listen_input+0x198>)
     688:	6809      	ldr	r1, [r1, #0]
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
     68a:	8809      	ldrh	r1, [r1, #0]
     68c:	b289      	uxth	r1, r1
     68e:	9000      	str	r0, [sp, #0]
     690:	9101      	str	r1, [sp, #4]
     692:	4610      	mov	r0, r2
     694:	4619      	mov	r1, r3
     696:	4a53      	ldr	r2, [pc, #332]	; (7e4 <tcp_listen_input+0x19c>)
     698:	4b53      	ldr	r3, [pc, #332]	; (7e8 <tcp_listen_input+0x1a0>)
     69a:	f7ff fffe 	bl	0 <tcp_rst>
			69a: R_ARM_THM_CALL	tcp_rst
     69e:	e08f      	b.n	7c0 <tcp_listen_input+0x178>
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
     6a0:	4b4b      	ldr	r3, [pc, #300]	; (7d0 <tcp_listen_input+0x188>)
     6a2:	781b      	ldrb	r3, [r3, #0]
     6a4:	f003 0302 	and.w	r3, r3, #2
     6a8:	2b00      	cmp	r3, #0
     6aa:	f000 8089 	beq.w	7c0 <tcp_listen_input+0x178>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
     6ae:	687b      	ldr	r3, [r7, #4]
     6b0:	7e5b      	ldrb	r3, [r3, #25]
     6b2:	4618      	mov	r0, r3
     6b4:	f7ff fffe 	bl	0 <tcp_alloc>
			6b4: R_ARM_THM_CALL	tcp_alloc
     6b8:	60f8      	str	r0, [r7, #12]
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
     6ba:	68fb      	ldr	r3, [r7, #12]
     6bc:	2b00      	cmp	r3, #0
     6be:	d102      	bne.n	6c6 <tcp_listen_input+0x7e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
     6c0:	f04f 03ff 	mov.w	r3, #255	; 0xff
     6c4:	e07e      	b.n	7c4 <tcp_listen_input+0x17c>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
     6c6:	4b47      	ldr	r3, [pc, #284]	; (7e4 <tcp_listen_input+0x19c>)
     6c8:	681a      	ldr	r2, [r3, #0]
     6ca:	68fb      	ldr	r3, [r7, #12]
     6cc:	601a      	str	r2, [r3, #0]
    npcb->local_port = pcb->local_port;
     6ce:	687b      	ldr	r3, [r7, #4]
     6d0:	8b5a      	ldrh	r2, [r3, #26]
     6d2:	68fb      	ldr	r3, [r7, #12]
     6d4:	835a      	strh	r2, [r3, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
     6d6:	4b44      	ldr	r3, [pc, #272]	; (7e8 <tcp_listen_input+0x1a0>)
     6d8:	681a      	ldr	r2, [r3, #0]
     6da:	68fb      	ldr	r3, [r7, #12]
     6dc:	605a      	str	r2, [r3, #4]
    npcb->remote_port = tcphdr->src;
     6de:	4b40      	ldr	r3, [pc, #256]	; (7e0 <tcp_listen_input+0x198>)
     6e0:	681b      	ldr	r3, [r3, #0]
     6e2:	881b      	ldrh	r3, [r3, #0]
     6e4:	b29a      	uxth	r2, r3
     6e6:	68fb      	ldr	r3, [r7, #12]
     6e8:	839a      	strh	r2, [r3, #28]
    npcb->state = SYN_RCVD;
     6ea:	68fb      	ldr	r3, [r7, #12]
     6ec:	f04f 0203 	mov.w	r2, #3
     6f0:	761a      	strb	r2, [r3, #24]
    npcb->rcv_nxt = seqno + 1;
     6f2:	4b3a      	ldr	r3, [pc, #232]	; (7dc <tcp_listen_input+0x194>)
     6f4:	681b      	ldr	r3, [r3, #0]
     6f6:	f103 0201 	add.w	r2, r3, #1
     6fa:	68fb      	ldr	r3, [r7, #12]
     6fc:	629a      	str	r2, [r3, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
     6fe:	68fb      	ldr	r3, [r7, #12]
     700:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     702:	68fb      	ldr	r3, [r7, #12]
     704:	631a      	str	r2, [r3, #48]	; 0x30
    npcb->snd_wnd = tcphdr->wnd;
     706:	4b36      	ldr	r3, [pc, #216]	; (7e0 <tcp_listen_input+0x198>)
     708:	681b      	ldr	r3, [r3, #0]
     70a:	89db      	ldrh	r3, [r3, #14]
     70c:	b29a      	uxth	r2, r3
     70e:	68fb      	ldr	r3, [r7, #12]
     710:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
     714:	4b32      	ldr	r3, [pc, #200]	; (7e0 <tcp_listen_input+0x198>)
     716:	681b      	ldr	r3, [r3, #0]
     718:	89db      	ldrh	r3, [r3, #14]
     71a:	b29a      	uxth	r2, r3
     71c:	68fb      	ldr	r3, [r7, #12]
     71e:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
     722:	68fb      	ldr	r3, [r7, #12]
     724:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
     728:	68fb      	ldr	r3, [r7, #12]
     72a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
     72e:	4b2b      	ldr	r3, [pc, #172]	; (7dc <tcp_listen_input+0x194>)
     730:	681b      	ldr	r3, [r3, #0]
     732:	f103 32ff 	add.w	r2, r3, #4294967295
     736:	68fb      	ldr	r3, [r7, #12]
     738:	655a      	str	r2, [r3, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
     73a:	687b      	ldr	r3, [r7, #4]
     73c:	691a      	ldr	r2, [r3, #16]
     73e:	68fb      	ldr	r3, [r7, #12]
     740:	611a      	str	r2, [r3, #16]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
     742:	687b      	ldr	r3, [r7, #4]
     744:	695a      	ldr	r2, [r3, #20]
     746:	68fb      	ldr	r3, [r7, #12]
     748:	615a      	str	r2, [r3, #20]
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
     74a:	687b      	ldr	r3, [r7, #4]
     74c:	7a1b      	ldrb	r3, [r3, #8]
     74e:	f023 0373 	bic.w	r3, r3, #115	; 0x73
     752:	b2da      	uxtb	r2, r3
     754:	68fb      	ldr	r3, [r7, #12]
     756:	721a      	strb	r2, [r3, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
     758:	4b24      	ldr	r3, [pc, #144]	; (7ec <tcp_listen_input+0x1a4>)
     75a:	681a      	ldr	r2, [r3, #0]
     75c:	68fb      	ldr	r3, [r7, #12]
     75e:	60da      	str	r2, [r3, #12]
     760:	4b22      	ldr	r3, [pc, #136]	; (7ec <tcp_listen_input+0x1a4>)
     762:	68fa      	ldr	r2, [r7, #12]
     764:	601a      	str	r2, [r3, #0]
     766:	f7ff fffe 	bl	0 <tcp_timer_needed>
			766: R_ARM_THM_CALL	tcp_timer_needed
     76a:	4b21      	ldr	r3, [pc, #132]	; (7f0 <tcp_listen_input+0x1a8>)
     76c:	f04f 0201 	mov.w	r2, #1
     770:	701a      	strb	r2, [r3, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
     772:	68f8      	ldr	r0, [r7, #12]
     774:	f001 fc38 	bl	1fe8 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
     778:	68fb      	ldr	r3, [r7, #12]
     77a:	8eda      	ldrh	r2, [r3, #54]	; 0x36
     77c:	68fb      	ldr	r3, [r7, #12]
     77e:	f103 0304 	add.w	r3, r3, #4
     782:	4610      	mov	r0, r2
     784:	4619      	mov	r1, r3
     786:	f7ff fffe 	bl	0 <tcp_eff_send_mss>
			786: R_ARM_THM_CALL	tcp_eff_send_mss
     78a:	4603      	mov	r3, r0
     78c:	461a      	mov	r2, r3
     78e:	68fb      	ldr	r3, [r7, #12]
     790:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
     792:	68f8      	ldr	r0, [r7, #12]
     794:	f04f 0112 	mov.w	r1, #18
     798:	f7ff fffe 	bl	0 <tcp_enqueue_flags>
			798: R_ARM_THM_CALL	tcp_enqueue_flags
     79c:	4603      	mov	r3, r0
     79e:	72fb      	strb	r3, [r7, #11]
    if (rc != ERR_OK) {
     7a0:	f997 300b 	ldrsb.w	r3, [r7, #11]
     7a4:	2b00      	cmp	r3, #0
     7a6:	d006      	beq.n	7b6 <tcp_listen_input+0x16e>
      tcp_abandon(npcb, 0);
     7a8:	68f8      	ldr	r0, [r7, #12]
     7aa:	f04f 0100 	mov.w	r1, #0
     7ae:	f7ff fffe 	bl	0 <tcp_abandon>
			7ae: R_ARM_THM_CALL	tcp_abandon
      return rc;
     7b2:	7afb      	ldrb	r3, [r7, #11]
     7b4:	e006      	b.n	7c4 <tcp_listen_input+0x17c>
    }
    return tcp_output(npcb);
     7b6:	68f8      	ldr	r0, [r7, #12]
     7b8:	f7ff fffe 	bl	0 <tcp_output>
			7b8: R_ARM_THM_CALL	tcp_output
     7bc:	4603      	mov	r3, r0
     7be:	e001      	b.n	7c4 <tcp_listen_input+0x17c>
  }
  return ERR_OK;
     7c0:	f04f 0300 	mov.w	r3, #0
     7c4:	b25b      	sxtb	r3, r3
}
     7c6:	4618      	mov	r0, r3
     7c8:	f107 0710 	add.w	r7, r7, #16
     7cc:	46bd      	mov	sp, r7
     7ce:	bd80      	pop	{r7, pc}
     7d0:	00000020 	.word	0x00000020
			7d0: R_ARM_ABS32	.bss
     7d4:	0000001c 	.word	0x0000001c
			7d4: R_ARM_ABS32	.bss
     7d8:	00000022 	.word	0x00000022
			7d8: R_ARM_ABS32	.bss
     7dc:	00000018 	.word	0x00000018
			7dc: R_ARM_ABS32	.bss
     7e0:	00000010 	.word	0x00000010
			7e0: R_ARM_ABS32	.bss
	...
			7e4: R_ARM_ABS32	current_iphdr_dest
			7e8: R_ARM_ABS32	current_iphdr_src
			7ec: R_ARM_ABS32	tcp_active_pcbs
			7f0: R_ARM_ABS32	tcp_active_pcbs_changed

000007f4 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
     7f4:	b580      	push	{r7, lr}
     7f6:	b084      	sub	sp, #16
     7f8:	af02      	add	r7, sp, #8
     7fa:	6078      	str	r0, [r7, #4]
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
     7fc:	4b2e      	ldr	r3, [pc, #184]	; (8b8 <tcp_timewait_input+0xc4>)
     7fe:	781b      	ldrb	r3, [r3, #0]
     800:	f003 0304 	and.w	r3, r3, #4
     804:	2b00      	cmp	r3, #0
     806:	d002      	beq.n	80e <tcp_timewait_input+0x1a>
    return ERR_OK;
     808:	f04f 0300 	mov.w	r3, #0
     80c:	e04e      	b.n	8ac <tcp_timewait_input+0xb8>
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
     80e:	4b2a      	ldr	r3, [pc, #168]	; (8b8 <tcp_timewait_input+0xc4>)
     810:	781b      	ldrb	r3, [r3, #0]
     812:	f003 0302 	and.w	r3, r3, #2
     816:	2b00      	cmp	r3, #0
     818:	d02b      	beq.n	872 <tcp_timewait_input+0x7e>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
     81a:	4b28      	ldr	r3, [pc, #160]	; (8bc <tcp_timewait_input+0xc8>)
     81c:	681a      	ldr	r2, [r3, #0]
     81e:	687b      	ldr	r3, [r7, #4]
     820:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     822:	1ad3      	subs	r3, r2, r3
     824:	2b00      	cmp	r3, #0
     826:	db2f      	blt.n	888 <tcp_timewait_input+0x94>
     828:	4b24      	ldr	r3, [pc, #144]	; (8bc <tcp_timewait_input+0xc8>)
     82a:	681a      	ldr	r2, [r3, #0]
     82c:	687b      	ldr	r3, [r7, #4]
     82e:	6a99      	ldr	r1, [r3, #40]	; 0x28
     830:	687b      	ldr	r3, [r7, #4]
     832:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     834:	18cb      	adds	r3, r1, r3
     836:	1ad3      	subs	r3, r2, r3
     838:	2b00      	cmp	r3, #0
     83a:	dc25      	bgt.n	888 <tcp_timewait_input+0x94>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     83c:	4b20      	ldr	r3, [pc, #128]	; (8c0 <tcp_timewait_input+0xcc>)
     83e:	681a      	ldr	r2, [r3, #0]
     840:	4b20      	ldr	r3, [pc, #128]	; (8c4 <tcp_timewait_input+0xd0>)
     842:	881b      	ldrh	r3, [r3, #0]
     844:	4619      	mov	r1, r3
     846:	4b1d      	ldr	r3, [pc, #116]	; (8bc <tcp_timewait_input+0xc8>)
     848:	681b      	ldr	r3, [r3, #0]
     84a:	18cb      	adds	r3, r1, r3
        tcphdr->dest, tcphdr->src);
     84c:	491e      	ldr	r1, [pc, #120]	; (8c8 <tcp_timewait_input+0xd4>)
     84e:	6809      	ldr	r1, [r1, #0]
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     850:	8849      	ldrh	r1, [r1, #2]
     852:	b288      	uxth	r0, r1
        tcphdr->dest, tcphdr->src);
     854:	491c      	ldr	r1, [pc, #112]	; (8c8 <tcp_timewait_input+0xd4>)
     856:	6809      	ldr	r1, [r1, #0]
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     858:	8809      	ldrh	r1, [r1, #0]
     85a:	b289      	uxth	r1, r1
     85c:	9000      	str	r0, [sp, #0]
     85e:	9101      	str	r1, [sp, #4]
     860:	4610      	mov	r0, r2
     862:	4619      	mov	r1, r3
     864:	4a19      	ldr	r2, [pc, #100]	; (8cc <tcp_timewait_input+0xd8>)
     866:	4b1a      	ldr	r3, [pc, #104]	; (8d0 <tcp_timewait_input+0xdc>)
     868:	f7ff fffe 	bl	0 <tcp_rst>
			868: R_ARM_THM_CALL	tcp_rst
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
     86c:	f04f 0300 	mov.w	r3, #0
     870:	e01c      	b.n	8ac <tcp_timewait_input+0xb8>
    }
  } else if (flags & TCP_FIN) {
     872:	4b11      	ldr	r3, [pc, #68]	; (8b8 <tcp_timewait_input+0xc4>)
     874:	781b      	ldrb	r3, [r3, #0]
     876:	f003 0301 	and.w	r3, r3, #1
     87a:	b2db      	uxtb	r3, r3
     87c:	2b00      	cmp	r3, #0
     87e:	d003      	beq.n	888 <tcp_timewait_input+0x94>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
     880:	4b14      	ldr	r3, [pc, #80]	; (8d4 <tcp_timewait_input+0xe0>)
     882:	681a      	ldr	r2, [r3, #0]
     884:	687b      	ldr	r3, [r7, #4]
     886:	625a      	str	r2, [r3, #36]	; 0x24
  }

  if ((tcplen > 0))  {
     888:	4b0e      	ldr	r3, [pc, #56]	; (8c4 <tcp_timewait_input+0xd0>)
     88a:	881b      	ldrh	r3, [r3, #0]
     88c:	2b00      	cmp	r3, #0
     88e:	d00b      	beq.n	8a8 <tcp_timewait_input+0xb4>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
     890:	687b      	ldr	r3, [r7, #4]
     892:	7f9b      	ldrb	r3, [r3, #30]
     894:	f043 0302 	orr.w	r3, r3, #2
     898:	b2da      	uxtb	r2, r3
     89a:	687b      	ldr	r3, [r7, #4]
     89c:	779a      	strb	r2, [r3, #30]
    return tcp_output(pcb);
     89e:	6878      	ldr	r0, [r7, #4]
     8a0:	f7ff fffe 	bl	0 <tcp_output>
			8a0: R_ARM_THM_CALL	tcp_output
     8a4:	4603      	mov	r3, r0
     8a6:	e001      	b.n	8ac <tcp_timewait_input+0xb8>
  }
  return ERR_OK;
     8a8:	f04f 0300 	mov.w	r3, #0
     8ac:	b25b      	sxtb	r3, r3
}
     8ae:	4618      	mov	r0, r3
     8b0:	f107 0708 	add.w	r7, r7, #8
     8b4:	46bd      	mov	sp, r7
     8b6:	bd80      	pop	{r7, pc}
     8b8:	00000020 	.word	0x00000020
			8b8: R_ARM_ABS32	.bss
     8bc:	00000018 	.word	0x00000018
			8bc: R_ARM_ABS32	.bss
     8c0:	0000001c 	.word	0x0000001c
			8c0: R_ARM_ABS32	.bss
     8c4:	00000022 	.word	0x00000022
			8c4: R_ARM_ABS32	.bss
     8c8:	00000010 	.word	0x00000010
			8c8: R_ARM_ABS32	.bss
	...
			8cc: R_ARM_ABS32	current_iphdr_dest
			8d0: R_ARM_ABS32	current_iphdr_src
			8d4: R_ARM_ABS32	tcp_ticks

000008d8 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
     8d8:	b580      	push	{r7, lr}
     8da:	b088      	sub	sp, #32
     8dc:	af02      	add	r7, sp, #8
     8de:	6078      	str	r0, [r7, #4]
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
     8e0:	f04f 0300 	mov.w	r3, #0
     8e4:	75fb      	strb	r3, [r7, #23]
  err_t err;

  err = ERR_OK;
     8e6:	f04f 0300 	mov.w	r3, #0
     8ea:	75bb      	strb	r3, [r7, #22]

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
     8ec:	4b8a      	ldr	r3, [pc, #552]	; (b18 <tcp_process+0x240>)
     8ee:	781b      	ldrb	r3, [r3, #0]
     8f0:	f003 0304 	and.w	r3, r3, #4
     8f4:	2b00      	cmp	r3, #0
     8f6:	d038      	beq.n	96a <tcp_process+0x92>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
     8f8:	687b      	ldr	r3, [r7, #4]
     8fa:	7e1b      	ldrb	r3, [r3, #24]
     8fc:	2b02      	cmp	r3, #2
     8fe:	d109      	bne.n	914 <tcp_process+0x3c>
      if (ackno == pcb->snd_nxt) {
     900:	687b      	ldr	r3, [r7, #4]
     902:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     904:	4b85      	ldr	r3, [pc, #532]	; (b1c <tcp_process+0x244>)
     906:	681b      	ldr	r3, [r3, #0]
     908:	429a      	cmp	r2, r3
     90a:	d117      	bne.n	93c <tcp_process+0x64>
        acceptable = 1;
     90c:	f04f 0301 	mov.w	r3, #1
     910:	75fb      	strb	r3, [r7, #23]
     912:	e013      	b.n	93c <tcp_process+0x64>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
     914:	4b82      	ldr	r3, [pc, #520]	; (b20 <tcp_process+0x248>)
     916:	681a      	ldr	r2, [r3, #0]
     918:	687b      	ldr	r3, [r7, #4]
     91a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     91c:	1ad3      	subs	r3, r2, r3
     91e:	2b00      	cmp	r3, #0
     920:	db0c      	blt.n	93c <tcp_process+0x64>
     922:	4b7f      	ldr	r3, [pc, #508]	; (b20 <tcp_process+0x248>)
     924:	681a      	ldr	r2, [r3, #0]
     926:	687b      	ldr	r3, [r7, #4]
     928:	6a99      	ldr	r1, [r3, #40]	; 0x28
     92a:	687b      	ldr	r3, [r7, #4]
     92c:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     92e:	18cb      	adds	r3, r1, r3
     930:	1ad3      	subs	r3, r2, r3
     932:	2b00      	cmp	r3, #0
     934:	dc02      	bgt.n	93c <tcp_process+0x64>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
     936:	f04f 0301 	mov.w	r3, #1
     93a:	75fb      	strb	r3, [r7, #23]
      }
    }

    if (acceptable) {
     93c:	7dfb      	ldrb	r3, [r7, #23]
     93e:	2b00      	cmp	r3, #0
     940:	d010      	beq.n	964 <tcp_process+0x8c>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
     942:	4b78      	ldr	r3, [pc, #480]	; (b24 <tcp_process+0x24c>)
     944:	781b      	ldrb	r3, [r3, #0]
     946:	f043 0308 	orr.w	r3, r3, #8
     94a:	b2da      	uxtb	r2, r3
     94c:	4b75      	ldr	r3, [pc, #468]	; (b24 <tcp_process+0x24c>)
     94e:	701a      	strb	r2, [r3, #0]
      pcb->flags &= ~TF_ACK_DELAY;
     950:	687b      	ldr	r3, [r7, #4]
     952:	7f9b      	ldrb	r3, [r3, #30]
     954:	f023 0301 	bic.w	r3, r3, #1
     958:	b2da      	uxtb	r2, r3
     95a:	687b      	ldr	r3, [r7, #4]
     95c:	779a      	strb	r2, [r3, #30]
      return ERR_RST;
     95e:	f04f 03f5 	mov.w	r3, #245	; 0xf5
     962:	e352      	b.n	100a <tcp_process+0x732>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
     964:	f04f 0300 	mov.w	r3, #0
     968:	e34f      	b.n	100a <tcp_process+0x732>
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
     96a:	4b6b      	ldr	r3, [pc, #428]	; (b18 <tcp_process+0x240>)
     96c:	781b      	ldrb	r3, [r3, #0]
     96e:	f003 0302 	and.w	r3, r3, #2
     972:	2b00      	cmp	r3, #0
     974:	d011      	beq.n	99a <tcp_process+0xc2>
     976:	687b      	ldr	r3, [r7, #4]
     978:	7e1b      	ldrb	r3, [r3, #24]
     97a:	2b02      	cmp	r3, #2
     97c:	d00d      	beq.n	99a <tcp_process+0xc2>
     97e:	687b      	ldr	r3, [r7, #4]
     980:	7e1b      	ldrb	r3, [r3, #24]
     982:	2b03      	cmp	r3, #3
     984:	d009      	beq.n	99a <tcp_process+0xc2>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
     986:	687b      	ldr	r3, [r7, #4]
     988:	7f9b      	ldrb	r3, [r3, #30]
     98a:	f043 0302 	orr.w	r3, r3, #2
     98e:	b2da      	uxtb	r2, r3
     990:	687b      	ldr	r3, [r7, #4]
     992:	779a      	strb	r2, [r3, #30]
    return ERR_OK;
     994:	f04f 0300 	mov.w	r3, #0
     998:	e337      	b.n	100a <tcp_process+0x732>
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
     99a:	687b      	ldr	r3, [r7, #4]
     99c:	7f9b      	ldrb	r3, [r3, #30]
     99e:	f003 0310 	and.w	r3, r3, #16
     9a2:	2b00      	cmp	r3, #0
     9a4:	d103      	bne.n	9ae <tcp_process+0xd6>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
     9a6:	4b60      	ldr	r3, [pc, #384]	; (b28 <tcp_process+0x250>)
     9a8:	681a      	ldr	r2, [r3, #0]
     9aa:	687b      	ldr	r3, [r7, #4]
     9ac:	625a      	str	r2, [r3, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
     9ae:	687b      	ldr	r3, [r7, #4]
     9b0:	f04f 0200 	mov.w	r2, #0
     9b4:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96

  tcp_parseopt(pcb);
     9b8:	6878      	ldr	r0, [r7, #4]
     9ba:	f001 fb15 	bl	1fe8 <tcp_parseopt>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
     9be:	687b      	ldr	r3, [r7, #4]
     9c0:	7e1b      	ldrb	r3, [r3, #24]
     9c2:	f1a3 0302 	sub.w	r3, r3, #2
     9c6:	2b07      	cmp	r3, #7
     9c8:	f200 82f7 	bhi.w	fba <tcp_process+0x6e2>
     9cc:	a201      	add	r2, pc, #4	; (adr r2, 9d4 <tcp_process+0xfc>)
     9ce:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     9d2:	bf00      	nop
     9d4:	000009f5 	.word	0x000009f5
			9d4: R_ARM_ABS32	.text
     9d8:	00000bcd 	.word	0x00000bcd
			9d8: R_ARM_ABS32	.text
     9dc:	00000d0d 	.word	0x00000d0d
			9dc: R_ARM_ABS32	.text
     9e0:	00000d39 	.word	0x00000d39
			9e0: R_ARM_ABS32	.text
     9e4:	00000e55 	.word	0x00000e55
			9e4: R_ARM_ABS32	.text
     9e8:	00000d0d 	.word	0x00000d0d
			9e8: R_ARM_ABS32	.text
     9ec:	00000ef3 	.word	0x00000ef3
			9ec: R_ARM_ABS32	.text
     9f0:	00000f8d 	.word	0x00000f8d
			9f0: R_ARM_ABS32	.text
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
     9f4:	4b48      	ldr	r3, [pc, #288]	; (b18 <tcp_process+0x240>)
     9f6:	781b      	ldrb	r3, [r3, #0]
     9f8:	f003 0310 	and.w	r3, r3, #16
     9fc:	2b00      	cmp	r3, #0
     9fe:	f000 80c5 	beq.w	b8c <tcp_process+0x2b4>
     a02:	4b45      	ldr	r3, [pc, #276]	; (b18 <tcp_process+0x240>)
     a04:	781b      	ldrb	r3, [r3, #0]
     a06:	f003 0302 	and.w	r3, r3, #2
     a0a:	2b00      	cmp	r3, #0
     a0c:	f000 80be 	beq.w	b8c <tcp_process+0x2b4>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
     a10:	687b      	ldr	r3, [r7, #4]
     a12:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     a14:	68db      	ldr	r3, [r3, #12]
     a16:	685b      	ldr	r3, [r3, #4]
     a18:	4618      	mov	r0, r3
     a1a:	f7ff fffe 	bl	0 <lwip_ntohl>
			a1a: R_ARM_THM_CALL	lwip_ntohl
     a1e:	4603      	mov	r3, r0
     a20:	f103 0201 	add.w	r2, r3, #1
     a24:	4b3d      	ldr	r3, [pc, #244]	; (b1c <tcp_process+0x244>)
     a26:	681b      	ldr	r3, [r3, #0]
     a28:	429a      	cmp	r2, r3
     a2a:	f040 80af 	bne.w	b8c <tcp_process+0x2b4>
      pcb->snd_buf++;
     a2e:	687b      	ldr	r3, [r7, #4]
     a30:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
     a34:	f103 0301 	add.w	r3, r3, #1
     a38:	b29a      	uxth	r2, r3
     a3a:	687b      	ldr	r3, [r7, #4]
     a3c:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
     a40:	4b37      	ldr	r3, [pc, #220]	; (b20 <tcp_process+0x248>)
     a42:	681b      	ldr	r3, [r3, #0]
     a44:	f103 0201 	add.w	r2, r3, #1
     a48:	687b      	ldr	r3, [r7, #4]
     a4a:	629a      	str	r2, [r3, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
     a4c:	687b      	ldr	r3, [r7, #4]
     a4e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     a50:	687b      	ldr	r3, [r7, #4]
     a52:	631a      	str	r2, [r3, #48]	; 0x30
      pcb->lastack = ackno;
     a54:	4b31      	ldr	r3, [pc, #196]	; (b1c <tcp_process+0x244>)
     a56:	681a      	ldr	r2, [r3, #0]
     a58:	687b      	ldr	r3, [r7, #4]
     a5a:	649a      	str	r2, [r3, #72]	; 0x48
      pcb->snd_wnd = tcphdr->wnd;
     a5c:	4b33      	ldr	r3, [pc, #204]	; (b2c <tcp_process+0x254>)
     a5e:	681b      	ldr	r3, [r3, #0]
     a60:	89db      	ldrh	r3, [r3, #14]
     a62:	b29a      	uxth	r2, r3
     a64:	687b      	ldr	r3, [r7, #4]
     a66:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
     a6a:	4b30      	ldr	r3, [pc, #192]	; (b2c <tcp_process+0x254>)
     a6c:	681b      	ldr	r3, [r3, #0]
     a6e:	89db      	ldrh	r3, [r3, #14]
     a70:	b29a      	uxth	r2, r3
     a72:	687b      	ldr	r3, [r7, #4]
     a74:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
     a78:	4b29      	ldr	r3, [pc, #164]	; (b20 <tcp_process+0x248>)
     a7a:	681b      	ldr	r3, [r3, #0]
     a7c:	f103 32ff 	add.w	r2, r3, #4294967295
     a80:	687b      	ldr	r3, [r7, #4]
     a82:	655a      	str	r2, [r3, #84]	; 0x54
      pcb->state = ESTABLISHED;
     a84:	687b      	ldr	r3, [r7, #4]
     a86:	f04f 0204 	mov.w	r2, #4
     a8a:	761a      	strb	r2, [r3, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
     a8c:	687b      	ldr	r3, [r7, #4]
     a8e:	8eda      	ldrh	r2, [r3, #54]	; 0x36
     a90:	687b      	ldr	r3, [r7, #4]
     a92:	f103 0304 	add.w	r3, r3, #4
     a96:	4610      	mov	r0, r2
     a98:	4619      	mov	r1, r3
     a9a:	f7ff fffe 	bl	0 <tcp_eff_send_mss>
			a9a: R_ARM_THM_CALL	tcp_eff_send_mss
     a9e:	4603      	mov	r3, r0
     aa0:	461a      	mov	r2, r3
     aa2:	687b      	ldr	r3, [r7, #4]
     aa4:	86da      	strh	r2, [r3, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
     aa6:	687b      	ldr	r3, [r7, #4]
     aa8:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     aaa:	461a      	mov	r2, r3
     aac:	ea4f 0282 	mov.w	r2, r2, lsl #2
     ab0:	18d3      	adds	r3, r2, r3
     ab2:	ea4f 0343 	mov.w	r3, r3, lsl #1
     ab6:	b29a      	uxth	r2, r3
     ab8:	687b      	ldr	r3, [r7, #4]
     aba:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
     abe:	687b      	ldr	r3, [r7, #4]
     ac0:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
     ac4:	2b01      	cmp	r3, #1
     ac6:	d105      	bne.n	ad4 <tcp_process+0x1fc>
     ac8:	687b      	ldr	r3, [r7, #4]
     aca:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     acc:	ea4f 0343 	mov.w	r3, r3, lsl #1
     ad0:	b29b      	uxth	r3, r3
     ad2:	e001      	b.n	ad8 <tcp_process+0x200>
     ad4:	687b      	ldr	r3, [r7, #4]
     ad6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     ad8:	687a      	ldr	r2, [r7, #4]
     ada:	f8a2 304c 	strh.w	r3, [r2, #76]	; 0x4c
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
     ade:	687b      	ldr	r3, [r7, #4]
     ae0:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     ae4:	f103 33ff 	add.w	r3, r3, #4294967295
     ae8:	b29a      	uxth	r2, r3
     aea:	687b      	ldr	r3, [r7, #4]
     aec:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
     af0:	687b      	ldr	r3, [r7, #4]
     af2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     af4:	613b      	str	r3, [r7, #16]
      pcb->unacked = rseg->next;
     af6:	693b      	ldr	r3, [r7, #16]
     af8:	681a      	ldr	r2, [r3, #0]
     afa:	687b      	ldr	r3, [r7, #4]
     afc:	671a      	str	r2, [r3, #112]	; 0x70
      tcp_seg_free(rseg);
     afe:	6938      	ldr	r0, [r7, #16]
     b00:	f7ff fffe 	bl	0 <tcp_seg_free>
			b00: R_ARM_THM_CALL	tcp_seg_free

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
     b04:	687b      	ldr	r3, [r7, #4]
     b06:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     b08:	2b00      	cmp	r3, #0
     b0a:	d111      	bne.n	b30 <tcp_process+0x258>
        pcb->rtime = -1;
     b0c:	687b      	ldr	r3, [r7, #4]
     b0e:	f64f 72ff 	movw	r2, #65535	; 0xffff
     b12:	869a      	strh	r2, [r3, #52]	; 0x34
     b14:	e015      	b.n	b42 <tcp_process+0x26a>
     b16:	bf00      	nop
     b18:	00000020 	.word	0x00000020
			b18: R_ARM_ABS32	.bss
     b1c:	0000001c 	.word	0x0000001c
			b1c: R_ARM_ABS32	.bss
     b20:	00000018 	.word	0x00000018
			b20: R_ARM_ABS32	.bss
     b24:	00000024 	.word	0x00000024
			b24: R_ARM_ABS32	.bss
     b28:	00000000 	.word	0x00000000
			b28: R_ARM_ABS32	tcp_ticks
     b2c:	00000010 	.word	0x00000010
			b2c: R_ARM_ABS32	.bss
      else {
        pcb->rtime = 0;
     b30:	687b      	ldr	r3, [r7, #4]
     b32:	f04f 0200 	mov.w	r2, #0
     b36:	869a      	strh	r2, [r3, #52]	; 0x34
        pcb->nrtx = 0;
     b38:	687b      	ldr	r3, [r7, #4]
     b3a:	f04f 0200 	mov.w	r2, #0
     b3e:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
     b42:	687b      	ldr	r3, [r7, #4]
     b44:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
     b48:	2b00      	cmp	r3, #0
     b4a:	d00c      	beq.n	b66 <tcp_process+0x28e>
     b4c:	687b      	ldr	r3, [r7, #4]
     b4e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
     b52:	687a      	ldr	r2, [r7, #4]
     b54:	6912      	ldr	r2, [r2, #16]
     b56:	4610      	mov	r0, r2
     b58:	6879      	ldr	r1, [r7, #4]
     b5a:	f04f 0200 	mov.w	r2, #0
     b5e:	4798      	blx	r3
     b60:	4603      	mov	r3, r0
     b62:	75bb      	strb	r3, [r7, #22]
     b64:	e002      	b.n	b6c <tcp_process+0x294>
     b66:	f04f 0300 	mov.w	r3, #0
     b6a:	75bb      	strb	r3, [r7, #22]
      if (err == ERR_ABRT) {
     b6c:	f997 3016 	ldrsb.w	r3, [r7, #22]
     b70:	f113 0f0a 	cmn.w	r3, #10
     b74:	d102      	bne.n	b7c <tcp_process+0x2a4>
        return ERR_ABRT;
     b76:	f04f 03f6 	mov.w	r3, #246	; 0xf6
     b7a:	e246      	b.n	100a <tcp_process+0x732>
      }
      tcp_ack_now(pcb);
     b7c:	687b      	ldr	r3, [r7, #4]
     b7e:	7f9b      	ldrb	r3, [r3, #30]
     b80:	f043 0302 	orr.w	r3, r3, #2
     b84:	b2da      	uxtb	r2, r3
     b86:	687b      	ldr	r3, [r7, #4]
     b88:	779a      	strb	r2, [r3, #30]
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
     b8a:	e23c      	b.n	1006 <tcp_process+0x72e>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
     b8c:	4b88      	ldr	r3, [pc, #544]	; (db0 <tcp_process+0x4d8>)
     b8e:	781b      	ldrb	r3, [r3, #0]
     b90:	f003 0310 	and.w	r3, r3, #16
     b94:	2b00      	cmp	r3, #0
     b96:	f000 8212 	beq.w	fbe <tcp_process+0x6e6>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     b9a:	4b86      	ldr	r3, [pc, #536]	; (db4 <tcp_process+0x4dc>)
     b9c:	681a      	ldr	r2, [r3, #0]
     b9e:	4b86      	ldr	r3, [pc, #536]	; (db8 <tcp_process+0x4e0>)
     ba0:	881b      	ldrh	r3, [r3, #0]
     ba2:	4619      	mov	r1, r3
     ba4:	4b85      	ldr	r3, [pc, #532]	; (dbc <tcp_process+0x4e4>)
     ba6:	681b      	ldr	r3, [r3, #0]
     ba8:	18cb      	adds	r3, r1, r3
        tcphdr->dest, tcphdr->src);
     baa:	4985      	ldr	r1, [pc, #532]	; (dc0 <tcp_process+0x4e8>)
     bac:	6809      	ldr	r1, [r1, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     bae:	8849      	ldrh	r1, [r1, #2]
     bb0:	b288      	uxth	r0, r1
        tcphdr->dest, tcphdr->src);
     bb2:	4983      	ldr	r1, [pc, #524]	; (dc0 <tcp_process+0x4e8>)
     bb4:	6809      	ldr	r1, [r1, #0]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     bb6:	8809      	ldrh	r1, [r1, #0]
     bb8:	b289      	uxth	r1, r1
     bba:	9000      	str	r0, [sp, #0]
     bbc:	9101      	str	r1, [sp, #4]
     bbe:	4610      	mov	r0, r2
     bc0:	4619      	mov	r1, r3
     bc2:	4a80      	ldr	r2, [pc, #512]	; (dc4 <tcp_process+0x4ec>)
     bc4:	4b80      	ldr	r3, [pc, #512]	; (dc8 <tcp_process+0x4f0>)
     bc6:	f7ff fffe 	bl	0 <tcp_rst>
			bc6: R_ARM_THM_CALL	tcp_rst
        tcphdr->dest, tcphdr->src);
    }
    break;
     bca:	e21c      	b.n	1006 <tcp_process+0x72e>
  case SYN_RCVD:
    if (flags & TCP_ACK) {
     bcc:	4b78      	ldr	r3, [pc, #480]	; (db0 <tcp_process+0x4d8>)
     bce:	781b      	ldrb	r3, [r3, #0]
     bd0:	f003 0310 	and.w	r3, r3, #16
     bd4:	2b00      	cmp	r3, #0
     bd6:	f000 8085 	beq.w	ce4 <tcp_process+0x40c>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
     bda:	687b      	ldr	r3, [r7, #4]
     bdc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     bde:	ea6f 0203 	mvn.w	r2, r3
     be2:	4b74      	ldr	r3, [pc, #464]	; (db4 <tcp_process+0x4dc>)
     be4:	681b      	ldr	r3, [r3, #0]
     be6:	18d3      	adds	r3, r2, r3
     be8:	2b00      	cmp	r3, #0
     bea:	db62      	blt.n	cb2 <tcp_process+0x3da>
     bec:	4b71      	ldr	r3, [pc, #452]	; (db4 <tcp_process+0x4dc>)
     bee:	681a      	ldr	r2, [r3, #0]
     bf0:	687b      	ldr	r3, [r7, #4]
     bf2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
     bf4:	1ad3      	subs	r3, r2, r3
     bf6:	2b00      	cmp	r3, #0
     bf8:	dc5b      	bgt.n	cb2 <tcp_process+0x3da>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
     bfa:	687b      	ldr	r3, [r7, #4]
     bfc:	f04f 0204 	mov.w	r2, #4
     c00:	761a      	strb	r2, [r3, #24]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
     c02:	687b      	ldr	r3, [r7, #4]
     c04:	695b      	ldr	r3, [r3, #20]
     c06:	2b00      	cmp	r3, #0
     c08:	d00b      	beq.n	c22 <tcp_process+0x34a>
     c0a:	687b      	ldr	r3, [r7, #4]
     c0c:	695b      	ldr	r3, [r3, #20]
     c0e:	687a      	ldr	r2, [r7, #4]
     c10:	6912      	ldr	r2, [r2, #16]
     c12:	4610      	mov	r0, r2
     c14:	6879      	ldr	r1, [r7, #4]
     c16:	f04f 0200 	mov.w	r2, #0
     c1a:	4798      	blx	r3
     c1c:	4603      	mov	r3, r0
     c1e:	75bb      	strb	r3, [r7, #22]
     c20:	e002      	b.n	c28 <tcp_process+0x350>
     c22:	f04f 03f2 	mov.w	r3, #242	; 0xf2
     c26:	75bb      	strb	r3, [r7, #22]
        if (err != ERR_OK) {
     c28:	f997 3016 	ldrsb.w	r3, [r7, #22]
     c2c:	2b00      	cmp	r3, #0
     c2e:	d00a      	beq.n	c46 <tcp_process+0x36e>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
     c30:	f997 3016 	ldrsb.w	r3, [r7, #22]
     c34:	f113 0f0a 	cmn.w	r3, #10
     c38:	d002      	beq.n	c40 <tcp_process+0x368>
            tcp_abort(pcb);
     c3a:	6878      	ldr	r0, [r7, #4]
     c3c:	f7ff fffe 	bl	0 <tcp_abort>
			c3c: R_ARM_THM_CALL	tcp_abort
          }
          return ERR_ABRT;
     c40:	f04f 03f6 	mov.w	r3, #246	; 0xf6
     c44:	e1e1      	b.n	100a <tcp_process+0x732>
        }
        old_cwnd = pcb->cwnd;
     c46:	687b      	ldr	r3, [r7, #4]
     c48:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
     c4c:	81fb      	strh	r3, [r7, #14]
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
     c4e:	6878      	ldr	r0, [r7, #4]
     c50:	f000 fa5c 	bl	110c <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
     c54:	687b      	ldr	r3, [r7, #4]
     c56:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
     c5a:	2b00      	cmp	r3, #0
     c5c:	d008      	beq.n	c70 <tcp_process+0x398>
          pcb->acked--;
     c5e:	687b      	ldr	r3, [r7, #4]
     c60:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
     c64:	f103 33ff 	add.w	r3, r3, #4294967295
     c68:	b29a      	uxth	r2, r3
     c6a:	687b      	ldr	r3, [r7, #4]
     c6c:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
     c70:	89fb      	ldrh	r3, [r7, #14]
     c72:	2b01      	cmp	r3, #1
     c74:	d105      	bne.n	c82 <tcp_process+0x3aa>
     c76:	687b      	ldr	r3, [r7, #4]
     c78:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     c7a:	ea4f 0343 	mov.w	r3, r3, lsl #1
     c7e:	b29b      	uxth	r3, r3
     c80:	e001      	b.n	c86 <tcp_process+0x3ae>
     c82:	687b      	ldr	r3, [r7, #4]
     c84:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     c86:	687a      	ldr	r2, [r7, #4]
     c88:	f8a2 304c 	strh.w	r3, [r2, #76]	; 0x4c

        if (recv_flags & TF_GOT_FIN) {
     c8c:	4b4f      	ldr	r3, [pc, #316]	; (dcc <tcp_process+0x4f4>)
     c8e:	781b      	ldrb	r3, [r3, #0]
     c90:	f003 0320 	and.w	r3, r3, #32
     c94:	2b00      	cmp	r3, #0
     c96:	d00a      	beq.n	cae <tcp_process+0x3d6>
          tcp_ack_now(pcb);
     c98:	687b      	ldr	r3, [r7, #4]
     c9a:	7f9b      	ldrb	r3, [r3, #30]
     c9c:	f043 0302 	orr.w	r3, r3, #2
     ca0:	b2da      	uxtb	r2, r3
     ca2:	687b      	ldr	r3, [r7, #4]
     ca4:	779a      	strb	r2, [r3, #30]
          pcb->state = CLOSE_WAIT;
     ca6:	687b      	ldr	r3, [r7, #4]
     ca8:	f04f 0207 	mov.w	r2, #7
     cac:	761a      	strb	r2, [r3, #24]
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
     cae:	bf00      	nop
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
     cb0:	e1a9      	b.n	1006 <tcp_process+0x72e>
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     cb2:	4b40      	ldr	r3, [pc, #256]	; (db4 <tcp_process+0x4dc>)
     cb4:	681a      	ldr	r2, [r3, #0]
     cb6:	4b40      	ldr	r3, [pc, #256]	; (db8 <tcp_process+0x4e0>)
     cb8:	881b      	ldrh	r3, [r3, #0]
     cba:	4619      	mov	r1, r3
     cbc:	4b3f      	ldr	r3, [pc, #252]	; (dbc <tcp_process+0x4e4>)
     cbe:	681b      	ldr	r3, [r3, #0]
     cc0:	18cb      	adds	r3, r1, r3
                tcphdr->dest, tcphdr->src);
     cc2:	493f      	ldr	r1, [pc, #252]	; (dc0 <tcp_process+0x4e8>)
     cc4:	6809      	ldr	r1, [r1, #0]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     cc6:	8849      	ldrh	r1, [r1, #2]
     cc8:	b288      	uxth	r0, r1
                tcphdr->dest, tcphdr->src);
     cca:	493d      	ldr	r1, [pc, #244]	; (dc0 <tcp_process+0x4e8>)
     ccc:	6809      	ldr	r1, [r1, #0]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
     cce:	8809      	ldrh	r1, [r1, #0]
     cd0:	b289      	uxth	r1, r1
     cd2:	9000      	str	r0, [sp, #0]
     cd4:	9101      	str	r1, [sp, #4]
     cd6:	4610      	mov	r0, r2
     cd8:	4619      	mov	r1, r3
     cda:	4a3a      	ldr	r2, [pc, #232]	; (dc4 <tcp_process+0x4ec>)
     cdc:	4b3a      	ldr	r3, [pc, #232]	; (dc8 <tcp_process+0x4f0>)
     cde:	f7ff fffe 	bl	0 <tcp_rst>
			cde: R_ARM_THM_CALL	tcp_rst
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
     ce2:	e190      	b.n	1006 <tcp_process+0x72e>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
     ce4:	4b32      	ldr	r3, [pc, #200]	; (db0 <tcp_process+0x4d8>)
     ce6:	781b      	ldrb	r3, [r3, #0]
     ce8:	f003 0302 	and.w	r3, r3, #2
     cec:	2b00      	cmp	r3, #0
     cee:	f000 8168 	beq.w	fc2 <tcp_process+0x6ea>
     cf2:	687b      	ldr	r3, [r7, #4]
     cf4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     cf6:	f103 32ff 	add.w	r2, r3, #4294967295
     cfa:	4b30      	ldr	r3, [pc, #192]	; (dbc <tcp_process+0x4e4>)
     cfc:	681b      	ldr	r3, [r3, #0]
     cfe:	429a      	cmp	r2, r3
     d00:	f040 8161 	bne.w	fc6 <tcp_process+0x6ee>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
     d04:	6878      	ldr	r0, [r7, #4]
     d06:	f7ff fffe 	bl	0 <tcp_rexmit>
			d06: R_ARM_THM_CALL	tcp_rexmit
    }
    break;
     d0a:	e17c      	b.n	1006 <tcp_process+0x72e>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
     d0c:	6878      	ldr	r0, [r7, #4]
     d0e:	f000 f9fd 	bl	110c <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
     d12:	4b2e      	ldr	r3, [pc, #184]	; (dcc <tcp_process+0x4f4>)
     d14:	781b      	ldrb	r3, [r3, #0]
     d16:	f003 0320 	and.w	r3, r3, #32
     d1a:	2b00      	cmp	r3, #0
     d1c:	f000 8155 	beq.w	fca <tcp_process+0x6f2>
      tcp_ack_now(pcb);
     d20:	687b      	ldr	r3, [r7, #4]
     d22:	7f9b      	ldrb	r3, [r3, #30]
     d24:	f043 0302 	orr.w	r3, r3, #2
     d28:	b2da      	uxtb	r2, r3
     d2a:	687b      	ldr	r3, [r7, #4]
     d2c:	779a      	strb	r2, [r3, #30]
      pcb->state = CLOSE_WAIT;
     d2e:	687b      	ldr	r3, [r7, #4]
     d30:	f04f 0207 	mov.w	r2, #7
     d34:	761a      	strb	r2, [r3, #24]
    }
    break;
     d36:	e166      	b.n	1006 <tcp_process+0x72e>
  case FIN_WAIT_1:
    tcp_receive(pcb);
     d38:	6878      	ldr	r0, [r7, #4]
     d3a:	f000 f9e7 	bl	110c <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
     d3e:	4b23      	ldr	r3, [pc, #140]	; (dcc <tcp_process+0x4f4>)
     d40:	781b      	ldrb	r3, [r3, #0]
     d42:	f003 0320 	and.w	r3, r3, #32
     d46:	2b00      	cmp	r3, #0
     d48:	d071      	beq.n	e2e <tcp_process+0x556>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
     d4a:	4b19      	ldr	r3, [pc, #100]	; (db0 <tcp_process+0x4d8>)
     d4c:	781b      	ldrb	r3, [r3, #0]
     d4e:	f003 0310 	and.w	r3, r3, #16
     d52:	2b00      	cmp	r3, #0
     d54:	d05f      	beq.n	e16 <tcp_process+0x53e>
     d56:	687b      	ldr	r3, [r7, #4]
     d58:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     d5a:	4b16      	ldr	r3, [pc, #88]	; (db4 <tcp_process+0x4dc>)
     d5c:	681b      	ldr	r3, [r3, #0]
     d5e:	429a      	cmp	r2, r3
     d60:	d159      	bne.n	e16 <tcp_process+0x53e>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
     d62:	687b      	ldr	r3, [r7, #4]
     d64:	7f9b      	ldrb	r3, [r3, #30]
     d66:	f043 0302 	orr.w	r3, r3, #2
     d6a:	b2da      	uxtb	r2, r3
     d6c:	687b      	ldr	r3, [r7, #4]
     d6e:	779a      	strb	r2, [r3, #30]
        tcp_pcb_purge(pcb);
     d70:	6878      	ldr	r0, [r7, #4]
     d72:	f7ff fffe 	bl	0 <tcp_pcb_purge>
			d72: R_ARM_THM_CALL	tcp_pcb_purge
        TCP_RMV_ACTIVE(pcb);
     d76:	4b16      	ldr	r3, [pc, #88]	; (dd0 <tcp_process+0x4f8>)
     d78:	681a      	ldr	r2, [r3, #0]
     d7a:	687b      	ldr	r3, [r7, #4]
     d7c:	429a      	cmp	r2, r3
     d7e:	d105      	bne.n	d8c <tcp_process+0x4b4>
     d80:	4b13      	ldr	r3, [pc, #76]	; (dd0 <tcp_process+0x4f8>)
     d82:	681b      	ldr	r3, [r3, #0]
     d84:	68da      	ldr	r2, [r3, #12]
     d86:	4b12      	ldr	r3, [pc, #72]	; (dd0 <tcp_process+0x4f8>)
     d88:	601a      	str	r2, [r3, #0]
     d8a:	e02e      	b.n	dea <tcp_process+0x512>
     d8c:	4b10      	ldr	r3, [pc, #64]	; (dd0 <tcp_process+0x4f8>)
     d8e:	681a      	ldr	r2, [r3, #0]
     d90:	4b10      	ldr	r3, [pc, #64]	; (dd4 <tcp_process+0x4fc>)
     d92:	601a      	str	r2, [r3, #0]
     d94:	e025      	b.n	de2 <tcp_process+0x50a>
     d96:	4b0f      	ldr	r3, [pc, #60]	; (dd4 <tcp_process+0x4fc>)
     d98:	681b      	ldr	r3, [r3, #0]
     d9a:	68da      	ldr	r2, [r3, #12]
     d9c:	687b      	ldr	r3, [r7, #4]
     d9e:	429a      	cmp	r2, r3
     da0:	d11a      	bne.n	dd8 <tcp_process+0x500>
     da2:	4b0c      	ldr	r3, [pc, #48]	; (dd4 <tcp_process+0x4fc>)
     da4:	681b      	ldr	r3, [r3, #0]
     da6:	687a      	ldr	r2, [r7, #4]
     da8:	68d2      	ldr	r2, [r2, #12]
     daa:	60da      	str	r2, [r3, #12]
     dac:	e01d      	b.n	dea <tcp_process+0x512>
     dae:	bf00      	nop
     db0:	00000020 	.word	0x00000020
			db0: R_ARM_ABS32	.bss
     db4:	0000001c 	.word	0x0000001c
			db4: R_ARM_ABS32	.bss
     db8:	00000022 	.word	0x00000022
			db8: R_ARM_ABS32	.bss
     dbc:	00000018 	.word	0x00000018
			dbc: R_ARM_ABS32	.bss
     dc0:	00000010 	.word	0x00000010
			dc0: R_ARM_ABS32	.bss
	...
			dc4: R_ARM_ABS32	current_iphdr_dest
			dc8: R_ARM_ABS32	current_iphdr_src
     dcc:	00000024 	.word	0x00000024
			dcc: R_ARM_ABS32	.bss
	...
			dd0: R_ARM_ABS32	tcp_active_pcbs
			dd4: R_ARM_ABS32	tcp_tmp_pcb
     dd8:	4b83      	ldr	r3, [pc, #524]	; (fe8 <tcp_process+0x710>)
     dda:	681b      	ldr	r3, [r3, #0]
     ddc:	68da      	ldr	r2, [r3, #12]
     dde:	4b82      	ldr	r3, [pc, #520]	; (fe8 <tcp_process+0x710>)
     de0:	601a      	str	r2, [r3, #0]
     de2:	4b81      	ldr	r3, [pc, #516]	; (fe8 <tcp_process+0x710>)
     de4:	681b      	ldr	r3, [r3, #0]
     de6:	2b00      	cmp	r3, #0
     de8:	d1d5      	bne.n	d96 <tcp_process+0x4be>
     dea:	687b      	ldr	r3, [r7, #4]
     dec:	f04f 0200 	mov.w	r2, #0
     df0:	60da      	str	r2, [r3, #12]
     df2:	4b7e      	ldr	r3, [pc, #504]	; (fec <tcp_process+0x714>)
     df4:	f04f 0201 	mov.w	r2, #1
     df8:	701a      	strb	r2, [r3, #0]
        pcb->state = TIME_WAIT;
     dfa:	687b      	ldr	r3, [r7, #4]
     dfc:	f04f 020a 	mov.w	r2, #10
     e00:	761a      	strb	r2, [r3, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
     e02:	4b7b      	ldr	r3, [pc, #492]	; (ff0 <tcp_process+0x718>)
     e04:	681a      	ldr	r2, [r3, #0]
     e06:	687b      	ldr	r3, [r7, #4]
     e08:	60da      	str	r2, [r3, #12]
     e0a:	4b79      	ldr	r3, [pc, #484]	; (ff0 <tcp_process+0x718>)
     e0c:	687a      	ldr	r2, [r7, #4]
     e0e:	601a      	str	r2, [r3, #0]
     e10:	f7ff fffe 	bl	0 <tcp_timer_needed>
			e10: R_ARM_THM_CALL	tcp_timer_needed
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
     e14:	e0f7      	b.n	1006 <tcp_process+0x72e>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
     e16:	687b      	ldr	r3, [r7, #4]
     e18:	7f9b      	ldrb	r3, [r3, #30]
     e1a:	f043 0302 	orr.w	r3, r3, #2
     e1e:	b2da      	uxtb	r2, r3
     e20:	687b      	ldr	r3, [r7, #4]
     e22:	779a      	strb	r2, [r3, #30]
        pcb->state = CLOSING;
     e24:	687b      	ldr	r3, [r7, #4]
     e26:	f04f 0208 	mov.w	r2, #8
     e2a:	761a      	strb	r2, [r3, #24]
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
     e2c:	e0eb      	b.n	1006 <tcp_process+0x72e>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
     e2e:	4b71      	ldr	r3, [pc, #452]	; (ff4 <tcp_process+0x71c>)
     e30:	781b      	ldrb	r3, [r3, #0]
     e32:	f003 0310 	and.w	r3, r3, #16
     e36:	2b00      	cmp	r3, #0
     e38:	f000 80c9 	beq.w	fce <tcp_process+0x6f6>
     e3c:	687b      	ldr	r3, [r7, #4]
     e3e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     e40:	4b6d      	ldr	r3, [pc, #436]	; (ff8 <tcp_process+0x720>)
     e42:	681b      	ldr	r3, [r3, #0]
     e44:	429a      	cmp	r2, r3
     e46:	f040 80c4 	bne.w	fd2 <tcp_process+0x6fa>
      pcb->state = FIN_WAIT_2;
     e4a:	687b      	ldr	r3, [r7, #4]
     e4c:	f04f 0206 	mov.w	r2, #6
     e50:	761a      	strb	r2, [r3, #24]
    }
    break;
     e52:	e0d8      	b.n	1006 <tcp_process+0x72e>
  case FIN_WAIT_2:
    tcp_receive(pcb);
     e54:	6878      	ldr	r0, [r7, #4]
     e56:	f000 f959 	bl	110c <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
     e5a:	4b68      	ldr	r3, [pc, #416]	; (ffc <tcp_process+0x724>)
     e5c:	781b      	ldrb	r3, [r3, #0]
     e5e:	f003 0320 	and.w	r3, r3, #32
     e62:	2b00      	cmp	r3, #0
     e64:	f000 80b7 	beq.w	fd6 <tcp_process+0x6fe>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
     e68:	687b      	ldr	r3, [r7, #4]
     e6a:	7f9b      	ldrb	r3, [r3, #30]
     e6c:	f043 0302 	orr.w	r3, r3, #2
     e70:	b2da      	uxtb	r2, r3
     e72:	687b      	ldr	r3, [r7, #4]
     e74:	779a      	strb	r2, [r3, #30]
      tcp_pcb_purge(pcb);
     e76:	6878      	ldr	r0, [r7, #4]
     e78:	f7ff fffe 	bl	0 <tcp_pcb_purge>
			e78: R_ARM_THM_CALL	tcp_pcb_purge
      TCP_RMV_ACTIVE(pcb);
     e7c:	4b60      	ldr	r3, [pc, #384]	; (1000 <tcp_process+0x728>)
     e7e:	681a      	ldr	r2, [r3, #0]
     e80:	687b      	ldr	r3, [r7, #4]
     e82:	429a      	cmp	r2, r3
     e84:	d105      	bne.n	e92 <tcp_process+0x5ba>
     e86:	4b5e      	ldr	r3, [pc, #376]	; (1000 <tcp_process+0x728>)
     e88:	681b      	ldr	r3, [r3, #0]
     e8a:	68da      	ldr	r2, [r3, #12]
     e8c:	4b5c      	ldr	r3, [pc, #368]	; (1000 <tcp_process+0x728>)
     e8e:	601a      	str	r2, [r3, #0]
     e90:	e019      	b.n	ec6 <tcp_process+0x5ee>
     e92:	4b5b      	ldr	r3, [pc, #364]	; (1000 <tcp_process+0x728>)
     e94:	681a      	ldr	r2, [r3, #0]
     e96:	4b54      	ldr	r3, [pc, #336]	; (fe8 <tcp_process+0x710>)
     e98:	601a      	str	r2, [r3, #0]
     e9a:	e010      	b.n	ebe <tcp_process+0x5e6>
     e9c:	4b52      	ldr	r3, [pc, #328]	; (fe8 <tcp_process+0x710>)
     e9e:	681b      	ldr	r3, [r3, #0]
     ea0:	68da      	ldr	r2, [r3, #12]
     ea2:	687b      	ldr	r3, [r7, #4]
     ea4:	429a      	cmp	r2, r3
     ea6:	d105      	bne.n	eb4 <tcp_process+0x5dc>
     ea8:	4b4f      	ldr	r3, [pc, #316]	; (fe8 <tcp_process+0x710>)
     eaa:	681b      	ldr	r3, [r3, #0]
     eac:	687a      	ldr	r2, [r7, #4]
     eae:	68d2      	ldr	r2, [r2, #12]
     eb0:	60da      	str	r2, [r3, #12]
     eb2:	e008      	b.n	ec6 <tcp_process+0x5ee>
     eb4:	4b4c      	ldr	r3, [pc, #304]	; (fe8 <tcp_process+0x710>)
     eb6:	681b      	ldr	r3, [r3, #0]
     eb8:	68da      	ldr	r2, [r3, #12]
     eba:	4b4b      	ldr	r3, [pc, #300]	; (fe8 <tcp_process+0x710>)
     ebc:	601a      	str	r2, [r3, #0]
     ebe:	4b4a      	ldr	r3, [pc, #296]	; (fe8 <tcp_process+0x710>)
     ec0:	681b      	ldr	r3, [r3, #0]
     ec2:	2b00      	cmp	r3, #0
     ec4:	d1ea      	bne.n	e9c <tcp_process+0x5c4>
     ec6:	687b      	ldr	r3, [r7, #4]
     ec8:	f04f 0200 	mov.w	r2, #0
     ecc:	60da      	str	r2, [r3, #12]
     ece:	4b47      	ldr	r3, [pc, #284]	; (fec <tcp_process+0x714>)
     ed0:	f04f 0201 	mov.w	r2, #1
     ed4:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
     ed6:	687b      	ldr	r3, [r7, #4]
     ed8:	f04f 020a 	mov.w	r2, #10
     edc:	761a      	strb	r2, [r3, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
     ede:	4b44      	ldr	r3, [pc, #272]	; (ff0 <tcp_process+0x718>)
     ee0:	681a      	ldr	r2, [r3, #0]
     ee2:	687b      	ldr	r3, [r7, #4]
     ee4:	60da      	str	r2, [r3, #12]
     ee6:	4b42      	ldr	r3, [pc, #264]	; (ff0 <tcp_process+0x718>)
     ee8:	687a      	ldr	r2, [r7, #4]
     eea:	601a      	str	r2, [r3, #0]
     eec:	f7ff fffe 	bl	0 <tcp_timer_needed>
			eec: R_ARM_THM_CALL	tcp_timer_needed
    }
    break;
     ef0:	e089      	b.n	1006 <tcp_process+0x72e>
  case CLOSING:
    tcp_receive(pcb);
     ef2:	6878      	ldr	r0, [r7, #4]
     ef4:	f000 f90a 	bl	110c <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
     ef8:	4b3e      	ldr	r3, [pc, #248]	; (ff4 <tcp_process+0x71c>)
     efa:	781b      	ldrb	r3, [r3, #0]
     efc:	f003 0310 	and.w	r3, r3, #16
     f00:	2b00      	cmp	r3, #0
     f02:	d06a      	beq.n	fda <tcp_process+0x702>
     f04:	687b      	ldr	r3, [r7, #4]
     f06:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     f08:	4b3b      	ldr	r3, [pc, #236]	; (ff8 <tcp_process+0x720>)
     f0a:	681b      	ldr	r3, [r3, #0]
     f0c:	429a      	cmp	r2, r3
     f0e:	d166      	bne.n	fde <tcp_process+0x706>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
     f10:	6878      	ldr	r0, [r7, #4]
     f12:	f7ff fffe 	bl	0 <tcp_pcb_purge>
			f12: R_ARM_THM_CALL	tcp_pcb_purge
      TCP_RMV_ACTIVE(pcb);
     f16:	4b3a      	ldr	r3, [pc, #232]	; (1000 <tcp_process+0x728>)
     f18:	681a      	ldr	r2, [r3, #0]
     f1a:	687b      	ldr	r3, [r7, #4]
     f1c:	429a      	cmp	r2, r3
     f1e:	d105      	bne.n	f2c <tcp_process+0x654>
     f20:	4b37      	ldr	r3, [pc, #220]	; (1000 <tcp_process+0x728>)
     f22:	681b      	ldr	r3, [r3, #0]
     f24:	68da      	ldr	r2, [r3, #12]
     f26:	4b36      	ldr	r3, [pc, #216]	; (1000 <tcp_process+0x728>)
     f28:	601a      	str	r2, [r3, #0]
     f2a:	e019      	b.n	f60 <tcp_process+0x688>
     f2c:	4b34      	ldr	r3, [pc, #208]	; (1000 <tcp_process+0x728>)
     f2e:	681a      	ldr	r2, [r3, #0]
     f30:	4b2d      	ldr	r3, [pc, #180]	; (fe8 <tcp_process+0x710>)
     f32:	601a      	str	r2, [r3, #0]
     f34:	e010      	b.n	f58 <tcp_process+0x680>
     f36:	4b2c      	ldr	r3, [pc, #176]	; (fe8 <tcp_process+0x710>)
     f38:	681b      	ldr	r3, [r3, #0]
     f3a:	68da      	ldr	r2, [r3, #12]
     f3c:	687b      	ldr	r3, [r7, #4]
     f3e:	429a      	cmp	r2, r3
     f40:	d105      	bne.n	f4e <tcp_process+0x676>
     f42:	4b29      	ldr	r3, [pc, #164]	; (fe8 <tcp_process+0x710>)
     f44:	681b      	ldr	r3, [r3, #0]
     f46:	687a      	ldr	r2, [r7, #4]
     f48:	68d2      	ldr	r2, [r2, #12]
     f4a:	60da      	str	r2, [r3, #12]
     f4c:	e008      	b.n	f60 <tcp_process+0x688>
     f4e:	4b26      	ldr	r3, [pc, #152]	; (fe8 <tcp_process+0x710>)
     f50:	681b      	ldr	r3, [r3, #0]
     f52:	68da      	ldr	r2, [r3, #12]
     f54:	4b24      	ldr	r3, [pc, #144]	; (fe8 <tcp_process+0x710>)
     f56:	601a      	str	r2, [r3, #0]
     f58:	4b23      	ldr	r3, [pc, #140]	; (fe8 <tcp_process+0x710>)
     f5a:	681b      	ldr	r3, [r3, #0]
     f5c:	2b00      	cmp	r3, #0
     f5e:	d1ea      	bne.n	f36 <tcp_process+0x65e>
     f60:	687b      	ldr	r3, [r7, #4]
     f62:	f04f 0200 	mov.w	r2, #0
     f66:	60da      	str	r2, [r3, #12]
     f68:	4b20      	ldr	r3, [pc, #128]	; (fec <tcp_process+0x714>)
     f6a:	f04f 0201 	mov.w	r2, #1
     f6e:	701a      	strb	r2, [r3, #0]
      pcb->state = TIME_WAIT;
     f70:	687b      	ldr	r3, [r7, #4]
     f72:	f04f 020a 	mov.w	r2, #10
     f76:	761a      	strb	r2, [r3, #24]
      TCP_REG(&tcp_tw_pcbs, pcb);
     f78:	4b1d      	ldr	r3, [pc, #116]	; (ff0 <tcp_process+0x718>)
     f7a:	681a      	ldr	r2, [r3, #0]
     f7c:	687b      	ldr	r3, [r7, #4]
     f7e:	60da      	str	r2, [r3, #12]
     f80:	4b1b      	ldr	r3, [pc, #108]	; (ff0 <tcp_process+0x718>)
     f82:	687a      	ldr	r2, [r7, #4]
     f84:	601a      	str	r2, [r3, #0]
     f86:	f7ff fffe 	bl	0 <tcp_timer_needed>
			f86: R_ARM_THM_CALL	tcp_timer_needed
    }
    break;
     f8a:	e03c      	b.n	1006 <tcp_process+0x72e>
  case LAST_ACK:
    tcp_receive(pcb);
     f8c:	6878      	ldr	r0, [r7, #4]
     f8e:	f000 f8bd 	bl	110c <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
     f92:	4b18      	ldr	r3, [pc, #96]	; (ff4 <tcp_process+0x71c>)
     f94:	781b      	ldrb	r3, [r3, #0]
     f96:	f003 0310 	and.w	r3, r3, #16
     f9a:	2b00      	cmp	r3, #0
     f9c:	d021      	beq.n	fe2 <tcp_process+0x70a>
     f9e:	687b      	ldr	r3, [r7, #4]
     fa0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     fa2:	4b15      	ldr	r3, [pc, #84]	; (ff8 <tcp_process+0x720>)
     fa4:	681b      	ldr	r3, [r3, #0]
     fa6:	429a      	cmp	r2, r3
     fa8:	d12c      	bne.n	1004 <tcp_process+0x72c>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
     faa:	4b14      	ldr	r3, [pc, #80]	; (ffc <tcp_process+0x724>)
     fac:	781b      	ldrb	r3, [r3, #0]
     fae:	f043 0310 	orr.w	r3, r3, #16
     fb2:	b2da      	uxtb	r2, r3
     fb4:	4b11      	ldr	r3, [pc, #68]	; (ffc <tcp_process+0x724>)
     fb6:	701a      	strb	r2, [r3, #0]
    }
    break;
     fb8:	e025      	b.n	1006 <tcp_process+0x72e>
  default:
    break;
     fba:	bf00      	nop
     fbc:	e023      	b.n	1006 <tcp_process+0x72e>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
     fbe:	bf00      	nop
     fc0:	e021      	b.n	1006 <tcp_process+0x72e>
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
    }
    break;
     fc2:	bf00      	nop
     fc4:	e01f      	b.n	1006 <tcp_process+0x72e>
     fc6:	bf00      	nop
     fc8:	e01d      	b.n	1006 <tcp_process+0x72e>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
     fca:	bf00      	nop
     fcc:	e01b      	b.n	1006 <tcp_process+0x72e>
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
     fce:	bf00      	nop
     fd0:	e019      	b.n	1006 <tcp_process+0x72e>
     fd2:	bf00      	nop
     fd4:	e017      	b.n	1006 <tcp_process+0x72e>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
     fd6:	bf00      	nop
     fd8:	e015      	b.n	1006 <tcp_process+0x72e>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
     fda:	bf00      	nop
     fdc:	e013      	b.n	1006 <tcp_process+0x72e>
     fde:	bf00      	nop
     fe0:	e011      	b.n	1006 <tcp_process+0x72e>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
    }
    break;
     fe2:	bf00      	nop
     fe4:	e00f      	b.n	1006 <tcp_process+0x72e>
     fe6:	bf00      	nop
	...
			fe8: R_ARM_ABS32	tcp_tmp_pcb
			fec: R_ARM_ABS32	tcp_active_pcbs_changed
			ff0: R_ARM_ABS32	tcp_tw_pcbs
     ff4:	00000020 	.word	0x00000020
			ff4: R_ARM_ABS32	.bss
     ff8:	0000001c 	.word	0x0000001c
			ff8: R_ARM_ABS32	.bss
     ffc:	00000024 	.word	0x00000024
			ffc: R_ARM_ABS32	.bss
    1000:	00000000 	.word	0x00000000
			1000: R_ARM_ABS32	tcp_active_pcbs
    1004:	bf00      	nop
  default:
    break;
  }
  return ERR_OK;
    1006:	f04f 0300 	mov.w	r3, #0
    100a:	b25b      	sxtb	r3, r3
}
    100c:	4618      	mov	r0, r3
    100e:	f107 0718 	add.w	r7, r7, #24
    1012:	46bd      	mov	sp, r7
    1014:	bd80      	pop	{r7, pc}
    1016:	bf00      	nop

00001018 <tcp_oos_insert_segment>:
 *
 * Called from tcp_receive()
 */
static void
tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
{
    1018:	b5b0      	push	{r4, r5, r7, lr}
    101a:	b084      	sub	sp, #16
    101c:	af00      	add	r7, sp, #0
    101e:	6078      	str	r0, [r7, #4]
    1020:	6039      	str	r1, [r7, #0]
  struct tcp_seg *old_seg;

  if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    1022:	687b      	ldr	r3, [r7, #4]
    1024:	68db      	ldr	r3, [r3, #12]
    1026:	899b      	ldrh	r3, [r3, #12]
    1028:	b29b      	uxth	r3, r3
    102a:	4618      	mov	r0, r3
    102c:	f7ff fffe 	bl	0 <lwip_ntohs>
			102c: R_ARM_THM_CALL	lwip_ntohs
    1030:	4603      	mov	r3, r0
    1032:	f003 0301 	and.w	r3, r3, #1
    1036:	b2db      	uxtb	r3, r3
    1038:	2b00      	cmp	r3, #0
    103a:	d02a      	beq.n	1092 <tcp_oos_insert_segment+0x7a>
    /* received segment overlaps all following segments */
    tcp_segs_free(next);
    103c:	6838      	ldr	r0, [r7, #0]
    103e:	f7ff fffe 	bl	0 <tcp_segs_free>
			103e: R_ARM_THM_CALL	tcp_segs_free
    next = NULL;
    1042:	f04f 0300 	mov.w	r3, #0
    1046:	603b      	str	r3, [r7, #0]
    1048:	e057      	b.n	10fa <tcp_oos_insert_segment+0xe2>
       oos queue may have segments with FIN flag */
    while (next &&
           TCP_SEQ_GEQ((seqno + cseg->len),
                      (next->tcphdr->seqno + next->len))) {
      /* cseg with FIN already processed */
      if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    104a:	683b      	ldr	r3, [r7, #0]
    104c:	68db      	ldr	r3, [r3, #12]
    104e:	899b      	ldrh	r3, [r3, #12]
    1050:	b29b      	uxth	r3, r3
    1052:	4618      	mov	r0, r3
    1054:	f7ff fffe 	bl	0 <lwip_ntohs>
			1054: R_ARM_THM_CALL	lwip_ntohs
    1058:	4603      	mov	r3, r0
    105a:	f003 0301 	and.w	r3, r3, #1
    105e:	b2db      	uxtb	r3, r3
    1060:	2b00      	cmp	r3, #0
    1062:	d00e      	beq.n	1082 <tcp_oos_insert_segment+0x6a>
        TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
    1064:	687b      	ldr	r3, [r7, #4]
    1066:	68dc      	ldr	r4, [r3, #12]
    1068:	687b      	ldr	r3, [r7, #4]
    106a:	68db      	ldr	r3, [r3, #12]
    106c:	899b      	ldrh	r3, [r3, #12]
    106e:	b29d      	uxth	r5, r3
    1070:	f04f 0001 	mov.w	r0, #1
    1074:	f7ff fffe 	bl	0 <lwip_htons>
			1074: R_ARM_THM_CALL	lwip_htons
    1078:	4603      	mov	r3, r0
    107a:	ea45 0303 	orr.w	r3, r5, r3
    107e:	b29b      	uxth	r3, r3
    1080:	81a3      	strh	r3, [r4, #12]
      }
      old_seg = next;
    1082:	683b      	ldr	r3, [r7, #0]
    1084:	60fb      	str	r3, [r7, #12]
      next = next->next;
    1086:	683b      	ldr	r3, [r7, #0]
    1088:	681b      	ldr	r3, [r3, #0]
    108a:	603b      	str	r3, [r7, #0]
      tcp_seg_free(old_seg);
    108c:	68f8      	ldr	r0, [r7, #12]
    108e:	f7ff fffe 	bl	0 <tcp_seg_free>
			108e: R_ARM_THM_CALL	tcp_seg_free
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    1092:	683b      	ldr	r3, [r7, #0]
    1094:	2b00      	cmp	r3, #0
    1096:	d00e      	beq.n	10b6 <tcp_oos_insert_segment+0x9e>
           TCP_SEQ_GEQ((seqno + cseg->len),
    1098:	687b      	ldr	r3, [r7, #4]
    109a:	891b      	ldrh	r3, [r3, #8]
    109c:	461a      	mov	r2, r3
    109e:	4b1a      	ldr	r3, [pc, #104]	; (1108 <tcp_oos_insert_segment+0xf0>)
    10a0:	681b      	ldr	r3, [r3, #0]
    10a2:	18d2      	adds	r2, r2, r3
    10a4:	683b      	ldr	r3, [r7, #0]
    10a6:	68db      	ldr	r3, [r3, #12]
    10a8:	6859      	ldr	r1, [r3, #4]
    10aa:	683b      	ldr	r3, [r7, #0]
    10ac:	891b      	ldrh	r3, [r3, #8]
    10ae:	18cb      	adds	r3, r1, r3
    10b0:	1ad3      	subs	r3, r2, r3
    next = NULL;
  }
  else {
    /* delete some following segments
       oos queue may have segments with FIN flag */
    while (next &&
    10b2:	2b00      	cmp	r3, #0
    10b4:	dac9      	bge.n	104a <tcp_oos_insert_segment+0x32>
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    10b6:	683b      	ldr	r3, [r7, #0]
    10b8:	2b00      	cmp	r3, #0
    10ba:	d01e      	beq.n	10fa <tcp_oos_insert_segment+0xe2>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
    10bc:	687b      	ldr	r3, [r7, #4]
    10be:	891b      	ldrh	r3, [r3, #8]
    10c0:	461a      	mov	r2, r3
    10c2:	4b11      	ldr	r3, [pc, #68]	; (1108 <tcp_oos_insert_segment+0xf0>)
    10c4:	681b      	ldr	r3, [r3, #0]
    10c6:	18d2      	adds	r2, r2, r3
    10c8:	683b      	ldr	r3, [r7, #0]
    10ca:	68db      	ldr	r3, [r3, #12]
    10cc:	685b      	ldr	r3, [r3, #4]
    10ce:	1ad3      	subs	r3, r2, r3
      }
      old_seg = next;
      next = next->next;
      tcp_seg_free(old_seg);
    }
    if (next &&
    10d0:	2b00      	cmp	r3, #0
    10d2:	dd12      	ble.n	10fa <tcp_oos_insert_segment+0xe2>
        TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
      /* We need to trim the incoming segment. */
      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
    10d4:	683b      	ldr	r3, [r7, #0]
    10d6:	68db      	ldr	r3, [r3, #12]
    10d8:	685b      	ldr	r3, [r3, #4]
    10da:	b29a      	uxth	r2, r3
    10dc:	4b0a      	ldr	r3, [pc, #40]	; (1108 <tcp_oos_insert_segment+0xf0>)
    10de:	681b      	ldr	r3, [r3, #0]
    10e0:	b29b      	uxth	r3, r3
    10e2:	1ad3      	subs	r3, r2, r3
    10e4:	b29a      	uxth	r2, r3
    10e6:	687b      	ldr	r3, [r7, #4]
    10e8:	811a      	strh	r2, [r3, #8]
      pbuf_realloc(cseg->p, cseg->len);
    10ea:	687b      	ldr	r3, [r7, #4]
    10ec:	685a      	ldr	r2, [r3, #4]
    10ee:	687b      	ldr	r3, [r7, #4]
    10f0:	891b      	ldrh	r3, [r3, #8]
    10f2:	4610      	mov	r0, r2
    10f4:	4619      	mov	r1, r3
    10f6:	f7ff fffe 	bl	0 <pbuf_realloc>
			10f6: R_ARM_THM_CALL	pbuf_realloc
    }
  }
  cseg->next = next;
    10fa:	687b      	ldr	r3, [r7, #4]
    10fc:	683a      	ldr	r2, [r7, #0]
    10fe:	601a      	str	r2, [r3, #0]
}
    1100:	f107 0710 	add.w	r7, r7, #16
    1104:	46bd      	mov	sp, r7
    1106:	bdb0      	pop	{r4, r5, r7, pc}
    1108:	00000018 	.word	0x00000018
			1108: R_ARM_ABS32	.bss

0000110c <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
    110c:	b5f0      	push	{r4, r5, r6, r7, lr}
    110e:	b08d      	sub	sp, #52	; 0x34
    1110:	af00      	add	r7, sp, #0
    1112:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  int found_dupack = 0;
    1114:	f04f 0300 	mov.w	r3, #0
    1118:	61bb      	str	r3, [r7, #24]
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    111a:	4b6c      	ldr	r3, [pc, #432]	; (12cc <tcp_receive+0x1c0>)
    111c:	781b      	ldrb	r3, [r3, #0]
    111e:	f003 0310 	and.w	r3, r3, #16
    1122:	2b00      	cmp	r3, #0
    1124:	f000 82d8 	beq.w	16d8 <tcp_receive+0x5cc>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
    1128:	687b      	ldr	r3, [r7, #4]
    112a:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    112e:	461a      	mov	r2, r3
    1130:	687b      	ldr	r3, [r7, #4]
    1132:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    1134:	18d3      	adds	r3, r2, r3
    1136:	617b      	str	r3, [r7, #20]

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    1138:	687b      	ldr	r3, [r7, #4]
    113a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    113c:	4b64      	ldr	r3, [pc, #400]	; (12d0 <tcp_receive+0x1c4>)
    113e:	681b      	ldr	r3, [r3, #0]
    1140:	1ad3      	subs	r3, r2, r3
    1142:	2b00      	cmp	r3, #0
    1144:	db1b      	blt.n	117e <tcp_receive+0x72>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    1146:	687b      	ldr	r3, [r7, #4]
    1148:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    114a:	4b61      	ldr	r3, [pc, #388]	; (12d0 <tcp_receive+0x1c4>)
    114c:	681b      	ldr	r3, [r3, #0]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
    114e:	429a      	cmp	r2, r3
    1150:	d106      	bne.n	1160 <tcp_receive+0x54>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    1152:	687b      	ldr	r3, [r7, #4]
    1154:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    1156:	4b5f      	ldr	r3, [pc, #380]	; (12d4 <tcp_receive+0x1c8>)
    1158:	681b      	ldr	r3, [r3, #0]
    115a:	1ad3      	subs	r3, r2, r3
    115c:	2b00      	cmp	r3, #0
    115e:	db0e      	blt.n	117e <tcp_receive+0x72>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    1160:	687b      	ldr	r3, [r7, #4]
    1162:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    1164:	4b5b      	ldr	r3, [pc, #364]	; (12d4 <tcp_receive+0x1c8>)
    1166:	681b      	ldr	r3, [r3, #0]
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
    1168:	429a      	cmp	r2, r3
    116a:	d146      	bne.n	11fa <tcp_receive+0xee>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
    116c:	4b5a      	ldr	r3, [pc, #360]	; (12d8 <tcp_receive+0x1cc>)
    116e:	681b      	ldr	r3, [r3, #0]
    1170:	89db      	ldrh	r3, [r3, #14]
    1172:	b29a      	uxth	r2, r3
    1174:	687b      	ldr	r3, [r7, #4]
    1176:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    117a:	429a      	cmp	r2, r3
    117c:	d93d      	bls.n	11fa <tcp_receive+0xee>
      pcb->snd_wnd = tcphdr->wnd;
    117e:	4b56      	ldr	r3, [pc, #344]	; (12d8 <tcp_receive+0x1cc>)
    1180:	681b      	ldr	r3, [r3, #0]
    1182:	89db      	ldrh	r3, [r3, #14]
    1184:	b29a      	uxth	r2, r3
    1186:	687b      	ldr	r3, [r7, #4]
    1188:	f8a3 2060 	strh.w	r2, [r3, #96]	; 0x60
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
    118c:	687b      	ldr	r3, [r7, #4]
    118e:	f8b3 2062 	ldrh.w	r2, [r3, #98]	; 0x62
    1192:	4b51      	ldr	r3, [pc, #324]	; (12d8 <tcp_receive+0x1cc>)
    1194:	681b      	ldr	r3, [r3, #0]
    1196:	89db      	ldrh	r3, [r3, #14]
    1198:	b29b      	uxth	r3, r3
    119a:	429a      	cmp	r2, r3
    119c:	d206      	bcs.n	11ac <tcp_receive+0xa0>
        pcb->snd_wnd_max = tcphdr->wnd;
    119e:	4b4e      	ldr	r3, [pc, #312]	; (12d8 <tcp_receive+0x1cc>)
    11a0:	681b      	ldr	r3, [r3, #0]
    11a2:	89db      	ldrh	r3, [r3, #14]
    11a4:	b29a      	uxth	r2, r3
    11a6:	687b      	ldr	r3, [r7, #4]
    11a8:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
      }
      pcb->snd_wl1 = seqno;
    11ac:	4b48      	ldr	r3, [pc, #288]	; (12d0 <tcp_receive+0x1c4>)
    11ae:	681a      	ldr	r2, [r3, #0]
    11b0:	687b      	ldr	r3, [r7, #4]
    11b2:	655a      	str	r2, [r3, #84]	; 0x54
      pcb->snd_wl2 = ackno;
    11b4:	4b47      	ldr	r3, [pc, #284]	; (12d4 <tcp_receive+0x1c8>)
    11b6:	681a      	ldr	r2, [r3, #0]
    11b8:	687b      	ldr	r3, [r7, #4]
    11ba:	659a      	str	r2, [r3, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
    11bc:	687b      	ldr	r3, [r7, #4]
    11be:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    11c2:	2b00      	cmp	r3, #0
    11c4:	d10f      	bne.n	11e6 <tcp_receive+0xda>
        if (pcb->persist_backoff == 0) {
    11c6:	687b      	ldr	r3, [r7, #4]
    11c8:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
    11cc:	2b00      	cmp	r3, #0
    11ce:	d114      	bne.n	11fa <tcp_receive+0xee>
          /* start persist timer */
          pcb->persist_cnt = 0;
    11d0:	687b      	ldr	r3, [r7, #4]
    11d2:	f04f 0200 	mov.w	r2, #0
    11d6:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
          pcb->persist_backoff = 1;
    11da:	687b      	ldr	r3, [r7, #4]
    11dc:	f04f 0201 	mov.w	r2, #1
    11e0:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
    11e4:	e009      	b.n	11fa <tcp_receive+0xee>
        }
      } else if (pcb->persist_backoff > 0) {
    11e6:	687b      	ldr	r3, [r7, #4]
    11e8:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
    11ec:	2b00      	cmp	r3, #0
    11ee:	d004      	beq.n	11fa <tcp_receive+0xee>
        /* stop persist timer */
          pcb->persist_backoff = 0;
    11f0:	687b      	ldr	r3, [r7, #4]
    11f2:	f04f 0200 	mov.w	r2, #0
    11f6:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
    11fa:	4b36      	ldr	r3, [pc, #216]	; (12d4 <tcp_receive+0x1c8>)
    11fc:	681a      	ldr	r2, [r3, #0]
    11fe:	687b      	ldr	r3, [r7, #4]
    1200:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1202:	1ad3      	subs	r3, r2, r3
    1204:	2b00      	cmp	r3, #0
    1206:	dc6b      	bgt.n	12e0 <tcp_receive+0x1d4>
      pcb->acked = 0;
    1208:	687b      	ldr	r3, [r7, #4]
    120a:	f04f 0200 	mov.w	r2, #0
    120e:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      /* Clause 2 */
      if (tcplen == 0) {
    1212:	4b32      	ldr	r3, [pc, #200]	; (12dc <tcp_receive+0x1d0>)
    1214:	881b      	ldrh	r3, [r3, #0]
    1216:	2b00      	cmp	r3, #0
    1218:	d14e      	bne.n	12b8 <tcp_receive+0x1ac>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
    121a:	687b      	ldr	r3, [r7, #4]
    121c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    121e:	687b      	ldr	r3, [r7, #4]
    1220:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    1224:	18d2      	adds	r2, r2, r3
    1226:	697b      	ldr	r3, [r7, #20]
    1228:	429a      	cmp	r2, r3
    122a:	d145      	bne.n	12b8 <tcp_receive+0x1ac>
          /* Clause 4 */
          if (pcb->rtime >= 0) {
    122c:	687b      	ldr	r3, [r7, #4]
    122e:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
    1230:	b21b      	sxth	r3, r3
    1232:	2b00      	cmp	r3, #0
    1234:	db40      	blt.n	12b8 <tcp_receive+0x1ac>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
    1236:	687b      	ldr	r3, [r7, #4]
    1238:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    123a:	4b26      	ldr	r3, [pc, #152]	; (12d4 <tcp_receive+0x1c8>)
    123c:	681b      	ldr	r3, [r3, #0]
    123e:	429a      	cmp	r2, r3
    1240:	d13a      	bne.n	12b8 <tcp_receive+0x1ac>
              found_dupack = 1;
    1242:	f04f 0301 	mov.w	r3, #1
    1246:	61bb      	str	r3, [r7, #24]
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
    1248:	687b      	ldr	r3, [r7, #4]
    124a:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
    124e:	f103 0301 	add.w	r3, r3, #1
    1252:	b2da      	uxtb	r2, r3
    1254:	687b      	ldr	r3, [r7, #4]
    1256:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
    125a:	429a      	cmp	r2, r3
    125c:	d908      	bls.n	1270 <tcp_receive+0x164>
                ++pcb->dupacks;
    125e:	687b      	ldr	r3, [r7, #4]
    1260:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
    1264:	f103 0301 	add.w	r3, r3, #1
    1268:	b2da      	uxtb	r2, r3
    126a:	687b      	ldr	r3, [r7, #4]
    126c:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
              }
              if (pcb->dupacks > 3) {
    1270:	687b      	ldr	r3, [r7, #4]
    1272:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
    1276:	2b03      	cmp	r3, #3
    1278:	d916      	bls.n	12a8 <tcp_receive+0x19c>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    127a:	687b      	ldr	r3, [r7, #4]
    127c:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    1280:	687b      	ldr	r3, [r7, #4]
    1282:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    1284:	18d3      	adds	r3, r2, r3
    1286:	b29a      	uxth	r2, r3
    1288:	687b      	ldr	r3, [r7, #4]
    128a:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    128e:	429a      	cmp	r2, r3
    1290:	d912      	bls.n	12b8 <tcp_receive+0x1ac>
                  pcb->cwnd += pcb->mss;
    1292:	687b      	ldr	r3, [r7, #4]
    1294:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    1298:	687b      	ldr	r3, [r7, #4]
    129a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    129c:	18d3      	adds	r3, r2, r3
    129e:	b29a      	uxth	r2, r3
    12a0:	687b      	ldr	r3, [r7, #4]
    12a2:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    12a6:	e007      	b.n	12b8 <tcp_receive+0x1ac>
                }
              } else if (pcb->dupacks == 3) {
    12a8:	687b      	ldr	r3, [r7, #4]
    12aa:	f893 3047 	ldrb.w	r3, [r3, #71]	; 0x47
    12ae:	2b03      	cmp	r3, #3
    12b0:	d102      	bne.n	12b8 <tcp_receive+0x1ac>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
    12b2:	6878      	ldr	r0, [r7, #4]
    12b4:	f7ff fffe 	bl	0 <tcp_rexmit_fast>
			12b4: R_ARM_THM_CALL	tcp_rexmit_fast
          }
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
    12b8:	69bb      	ldr	r3, [r7, #24]
    12ba:	2b00      	cmp	r3, #0
    12bc:	f040 817d 	bne.w	15ba <tcp_receive+0x4ae>
        pcb->dupacks = 0;
    12c0:	687b      	ldr	r3, [r7, #4]
    12c2:	f04f 0200 	mov.w	r2, #0
    12c6:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    12ca:	e177      	b.n	2f2 <tcp_input+0x2f2>
    12cc:	00000020 	.word	0x00000020
			12cc: R_ARM_ABS32	.bss
    12d0:	00000018 	.word	0x00000018
			12d0: R_ARM_ABS32	.bss
    12d4:	0000001c 	.word	0x0000001c
			12d4: R_ARM_ABS32	.bss
    12d8:	00000010 	.word	0x00000010
			12d8: R_ARM_ABS32	.bss
    12dc:	00000022 	.word	0x00000022
			12dc: R_ARM_ABS32	.bss
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
    12e0:	687b      	ldr	r3, [r7, #4]
    12e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    12e4:	ea6f 0203 	mvn.w	r2, r3
    12e8:	4b8d      	ldr	r3, [pc, #564]	; (1520 <tcp_receive+0x414>)
    12ea:	681b      	ldr	r3, [r3, #0]
    12ec:	18d3      	adds	r3, r2, r3
    12ee:	2b00      	cmp	r3, #0
    12f0:	f2c0 810f 	blt.w	1512 <tcp_receive+0x406>
    12f4:	4b8a      	ldr	r3, [pc, #552]	; (1520 <tcp_receive+0x414>)
    12f6:	681a      	ldr	r2, [r3, #0]
    12f8:	687b      	ldr	r3, [r7, #4]
    12fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    12fc:	1ad3      	subs	r3, r2, r3
    12fe:	2b00      	cmp	r3, #0
    1300:	f300 8107 	bgt.w	1512 <tcp_receive+0x406>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
    1304:	687b      	ldr	r3, [r7, #4]
    1306:	7f9b      	ldrb	r3, [r3, #30]
    1308:	f003 0304 	and.w	r3, r3, #4
    130c:	2b00      	cmp	r3, #0
    130e:	d00c      	beq.n	132a <tcp_receive+0x21e>
        pcb->flags &= ~TF_INFR;
    1310:	687b      	ldr	r3, [r7, #4]
    1312:	7f9b      	ldrb	r3, [r3, #30]
    1314:	f023 0304 	bic.w	r3, r3, #4
    1318:	b2da      	uxtb	r2, r3
    131a:	687b      	ldr	r3, [r7, #4]
    131c:	779a      	strb	r2, [r3, #30]
        pcb->cwnd = pcb->ssthresh;
    131e:	687b      	ldr	r3, [r7, #4]
    1320:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
    1324:	687b      	ldr	r3, [r7, #4]
    1326:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
    132a:	687b      	ldr	r3, [r7, #4]
    132c:	f04f 0200 	mov.w	r2, #0
    1330:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    1334:	687b      	ldr	r3, [r7, #4]
    1336:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
    133a:	b21b      	sxth	r3, r3
    133c:	ea4f 03e3 	mov.w	r3, r3, asr #3
    1340:	b29b      	uxth	r3, r3
    1342:	b29a      	uxth	r2, r3
    1344:	687b      	ldr	r3, [r7, #4]
    1346:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
    134a:	b29b      	uxth	r3, r3
    134c:	18d3      	adds	r3, r2, r3
    134e:	b29b      	uxth	r3, r3
    1350:	b29a      	uxth	r2, r3
    1352:	687b      	ldr	r3, [r7, #4]
    1354:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
    1358:	4b71      	ldr	r3, [pc, #452]	; (1520 <tcp_receive+0x414>)
    135a:	681b      	ldr	r3, [r3, #0]
    135c:	b29a      	uxth	r2, r3
    135e:	687b      	ldr	r3, [r7, #4]
    1360:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    1362:	b29b      	uxth	r3, r3
    1364:	1ad3      	subs	r3, r2, r3
    1366:	b29a      	uxth	r2, r3
    1368:	687b      	ldr	r3, [r7, #4]
    136a:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64

      pcb->snd_buf += pcb->acked;
    136e:	687b      	ldr	r3, [r7, #4]
    1370:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
    1374:	687b      	ldr	r3, [r7, #4]
    1376:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
    137a:	18d3      	adds	r3, r2, r3
    137c:	b29a      	uxth	r2, r3
    137e:	687b      	ldr	r3, [r7, #4]
    1380:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
    1384:	687b      	ldr	r3, [r7, #4]
    1386:	f04f 0200 	mov.w	r2, #0
    138a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
      pcb->lastack = ackno;
    138e:	4b64      	ldr	r3, [pc, #400]	; (1520 <tcp_receive+0x414>)
    1390:	681a      	ldr	r2, [r3, #0]
    1392:	687b      	ldr	r3, [r7, #4]
    1394:	649a      	str	r2, [r3, #72]	; 0x48

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
    1396:	687b      	ldr	r3, [r7, #4]
    1398:	7e1b      	ldrb	r3, [r3, #24]
    139a:	2b03      	cmp	r3, #3
    139c:	d97c      	bls.n	1498 <tcp_receive+0x38c>
        if (pcb->cwnd < pcb->ssthresh) {
    139e:	687b      	ldr	r3, [r7, #4]
    13a0:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    13a4:	687b      	ldr	r3, [r7, #4]
    13a6:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    13aa:	429a      	cmp	r2, r3
    13ac:	d216      	bcs.n	13dc <tcp_receive+0x2d0>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
    13ae:	687b      	ldr	r3, [r7, #4]
    13b0:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    13b4:	687b      	ldr	r3, [r7, #4]
    13b6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    13b8:	18d3      	adds	r3, r2, r3
    13ba:	b29a      	uxth	r2, r3
    13bc:	687b      	ldr	r3, [r7, #4]
    13be:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    13c2:	429a      	cmp	r2, r3
    13c4:	d96a      	bls.n	149c <tcp_receive+0x390>
            pcb->cwnd += pcb->mss;
    13c6:	687b      	ldr	r3, [r7, #4]
    13c8:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    13cc:	687b      	ldr	r3, [r7, #4]
    13ce:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    13d0:	18d3      	adds	r3, r2, r3
    13d2:	b29a      	uxth	r2, r3
    13d4:	687b      	ldr	r3, [r7, #4]
    13d6:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    13da:	e062      	b.n	14a2 <tcp_receive+0x396>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
    13dc:	687b      	ldr	r3, [r7, #4]
    13de:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    13e2:	687b      	ldr	r3, [r7, #4]
    13e4:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    13e6:	6879      	ldr	r1, [r7, #4]
    13e8:	8ec9      	ldrh	r1, [r1, #54]	; 0x36
    13ea:	fb01 f103 	mul.w	r1, r1, r3
    13ee:	687b      	ldr	r3, [r7, #4]
    13f0:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    13f4:	fb91 f3f3 	sdiv	r3, r1, r3
    13f8:	b29b      	uxth	r3, r3
    13fa:	18d3      	adds	r3, r2, r3
    13fc:	827b      	strh	r3, [r7, #18]
          if (new_cwnd > pcb->cwnd) {
    13fe:	687b      	ldr	r3, [r7, #4]
    1400:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    1404:	8a7a      	ldrh	r2, [r7, #18]
    1406:	429a      	cmp	r2, r3
    1408:	d94a      	bls.n	14a0 <tcp_receive+0x394>
            pcb->cwnd = new_cwnd;
    140a:	687b      	ldr	r3, [r7, #4]
    140c:	8a7a      	ldrh	r2, [r7, #18]
    140e:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    1412:	e046      	b.n	14a2 <tcp_receive+0x396>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
    1414:	687b      	ldr	r3, [r7, #4]
    1416:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1418:	62fb      	str	r3, [r7, #44]	; 0x2c
        pcb->unacked = pcb->unacked->next;
    141a:	687b      	ldr	r3, [r7, #4]
    141c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    141e:	681a      	ldr	r2, [r3, #0]
    1420:	687b      	ldr	r3, [r7, #4]
    1422:	671a      	str	r2, [r3, #112]	; 0x70

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    1424:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1426:	685b      	ldr	r3, [r3, #4]
    1428:	4618      	mov	r0, r3
    142a:	f7ff fffe 	bl	0 <pbuf_clen>
			142a: R_ARM_THM_CALL	pbuf_clen
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    142e:	687b      	ldr	r3, [r7, #4]
    1430:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
    1434:	2b00      	cmp	r3, #0
    1436:	d015      	beq.n	1464 <tcp_receive+0x358>
    1438:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    143a:	68db      	ldr	r3, [r3, #12]
    143c:	899b      	ldrh	r3, [r3, #12]
    143e:	b29b      	uxth	r3, r3
    1440:	4618      	mov	r0, r3
    1442:	f7ff fffe 	bl	0 <lwip_ntohs>
			1442: R_ARM_THM_CALL	lwip_ntohs
    1446:	4603      	mov	r3, r0
    1448:	f003 0301 	and.w	r3, r3, #1
    144c:	b2db      	uxtb	r3, r3
    144e:	2b00      	cmp	r3, #0
    1450:	d008      	beq.n	1464 <tcp_receive+0x358>
          pcb->acked--;
    1452:	687b      	ldr	r3, [r7, #4]
    1454:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
    1458:	f103 33ff 	add.w	r3, r3, #4294967295
    145c:	b29a      	uxth	r2, r3
    145e:	687b      	ldr	r3, [r7, #4]
    1460:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
    1464:	687b      	ldr	r3, [r7, #4]
    1466:	f8b3 4068 	ldrh.w	r4, [r3, #104]	; 0x68
    146a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    146c:	685b      	ldr	r3, [r3, #4]
    146e:	4618      	mov	r0, r3
    1470:	f7ff fffe 	bl	0 <pbuf_clen>
			1470: R_ARM_THM_CALL	pbuf_clen
    1474:	4603      	mov	r3, r0
    1476:	1ae3      	subs	r3, r4, r3
    1478:	b29a      	uxth	r2, r3
    147a:	687b      	ldr	r3, [r7, #4]
    147c:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
        tcp_seg_free(next);
    1480:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    1482:	f7ff fffe 	bl	0 <tcp_seg_free>
			1482: R_ARM_THM_CALL	tcp_seg_free

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
    1486:	687b      	ldr	r3, [r7, #4]
    1488:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    148c:	2b00      	cmp	r3, #0
    148e:	d008      	beq.n	14a2 <tcp_receive+0x396>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
    1490:	687b      	ldr	r3, [r7, #4]
    1492:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1494:	2b00      	cmp	r3, #0
    1496:	e004      	b.n	14a2 <tcp_receive+0x396>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    1498:	bf00      	nop
    149a:	e002      	b.n	14a2 <tcp_receive+0x396>
    149c:	bf00      	nop
    149e:	e000      	b.n	14a2 <tcp_receive+0x396>
    14a0:	bf00      	nop
    14a2:	687b      	ldr	r3, [r7, #4]
    14a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14a6:	2b00      	cmp	r3, #0
    14a8:	d021      	beq.n	14ee <tcp_receive+0x3e2>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
    14aa:	687b      	ldr	r3, [r7, #4]
    14ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14ae:	68db      	ldr	r3, [r3, #12]
    14b0:	685b      	ldr	r3, [r3, #4]
    14b2:	4618      	mov	r0, r3
    14b4:	f7ff fffe 	bl	0 <lwip_ntohl>
			14b4: R_ARM_THM_CALL	lwip_ntohl
    14b8:	4604      	mov	r4, r0
    14ba:	687b      	ldr	r3, [r7, #4]
    14bc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14be:	891b      	ldrh	r3, [r3, #8]
    14c0:	461d      	mov	r5, r3
    14c2:	687b      	ldr	r3, [r7, #4]
    14c4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14c6:	68db      	ldr	r3, [r3, #12]
    14c8:	899b      	ldrh	r3, [r3, #12]
    14ca:	b29b      	uxth	r3, r3
    14cc:	4618      	mov	r0, r3
    14ce:	f7ff fffe 	bl	0 <lwip_ntohs>
			14ce: R_ARM_THM_CALL	lwip_ntohs
    14d2:	4603      	mov	r3, r0
    14d4:	f003 0303 	and.w	r3, r3, #3
    14d8:	2b00      	cmp	r3, #0
    14da:	bf0c      	ite	eq
    14dc:	2300      	moveq	r3, #0
    14de:	2301      	movne	r3, #1
    14e0:	18eb      	adds	r3, r5, r3
    14e2:	18e2      	adds	r2, r4, r3
    14e4:	4b0e      	ldr	r3, [pc, #56]	; (1520 <tcp_receive+0x414>)
    14e6:	681b      	ldr	r3, [r3, #0]
    14e8:	1ad3      	subs	r3, r2, r3
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
    14ea:	2b00      	cmp	r3, #0
    14ec:	dd92      	ble.n	1414 <tcp_receive+0x308>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
    14ee:	687b      	ldr	r3, [r7, #4]
    14f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    14f2:	2b00      	cmp	r3, #0
    14f4:	d104      	bne.n	1500 <tcp_receive+0x3f4>
        pcb->rtime = -1;
    14f6:	687b      	ldr	r3, [r7, #4]
    14f8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    14fc:	869a      	strh	r2, [r3, #52]	; 0x34
    14fe:	e003      	b.n	1508 <tcp_receive+0x3fc>
      else
        pcb->rtime = 0;
    1500:	687b      	ldr	r3, [r7, #4]
    1502:	f04f 0200 	mov.w	r2, #0
    1506:	869a      	strh	r2, [r3, #52]	; 0x34

      pcb->polltmr = 0;
    1508:	687b      	ldr	r3, [r7, #4]
    150a:	f04f 0200 	mov.w	r2, #0
    150e:	77da      	strb	r2, [r3, #31]
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    1510:	e054      	b.n	15bc <tcp_receive+0x4b0>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
    1512:	687b      	ldr	r3, [r7, #4]
    1514:	f04f 0200 	mov.w	r2, #0
    1518:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    151c:	e04e      	b.n	15bc <tcp_receive+0x4b0>
    151e:	bf00      	nop
    1520:	0000001c 	.word	0x0000001c
			1520: R_ARM_ABS32	.bss
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
    1524:	687b      	ldr	r3, [r7, #4]
    1526:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1528:	62fb      	str	r3, [r7, #44]	; 0x2c
      pcb->unsent = pcb->unsent->next;
    152a:	687b      	ldr	r3, [r7, #4]
    152c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    152e:	681a      	ldr	r2, [r3, #0]
    1530:	687b      	ldr	r3, [r7, #4]
    1532:	66da      	str	r2, [r3, #108]	; 0x6c
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
    1534:	687b      	ldr	r3, [r7, #4]
    1536:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    1538:	2b00      	cmp	r3, #0
    153a:	d104      	bne.n	1546 <tcp_receive+0x43a>
        pcb->unsent_oversize = 0;
    153c:	687b      	ldr	r3, [r7, #4]
    153e:	f04f 0200 	mov.w	r2, #0
    1542:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
    1546:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1548:	685b      	ldr	r3, [r3, #4]
    154a:	4618      	mov	r0, r3
    154c:	f7ff fffe 	bl	0 <pbuf_clen>
			154c: R_ARM_THM_CALL	pbuf_clen
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
    1550:	687b      	ldr	r3, [r7, #4]
    1552:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
    1556:	2b00      	cmp	r3, #0
    1558:	d015      	beq.n	1586 <tcp_receive+0x47a>
    155a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    155c:	68db      	ldr	r3, [r3, #12]
    155e:	899b      	ldrh	r3, [r3, #12]
    1560:	b29b      	uxth	r3, r3
    1562:	4618      	mov	r0, r3
    1564:	f7ff fffe 	bl	0 <lwip_ntohs>
			1564: R_ARM_THM_CALL	lwip_ntohs
    1568:	4603      	mov	r3, r0
    156a:	f003 0301 	and.w	r3, r3, #1
    156e:	b2db      	uxtb	r3, r3
    1570:	2b00      	cmp	r3, #0
    1572:	d008      	beq.n	1586 <tcp_receive+0x47a>
        pcb->acked--;
    1574:	687b      	ldr	r3, [r7, #4]
    1576:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
    157a:	f103 33ff 	add.w	r3, r3, #4294967295
    157e:	b29a      	uxth	r2, r3
    1580:	687b      	ldr	r3, [r7, #4]
    1582:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
    1586:	687b      	ldr	r3, [r7, #4]
    1588:	f8b3 4068 	ldrh.w	r4, [r3, #104]	; 0x68
    158c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    158e:	685b      	ldr	r3, [r3, #4]
    1590:	4618      	mov	r0, r3
    1592:	f7ff fffe 	bl	0 <pbuf_clen>
			1592: R_ARM_THM_CALL	pbuf_clen
    1596:	4603      	mov	r3, r0
    1598:	1ae3      	subs	r3, r4, r3
    159a:	b29a      	uxth	r2, r3
    159c:	687b      	ldr	r3, [r7, #4]
    159e:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
      tcp_seg_free(next);
    15a2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
    15a4:	f7ff fffe 	bl	0 <tcp_seg_free>
			15a4: R_ARM_THM_CALL	tcp_seg_free
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
    15a8:	687b      	ldr	r3, [r7, #4]
    15aa:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
    15ae:	2b00      	cmp	r3, #0
    15b0:	d004      	beq.n	15bc <tcp_receive+0x4b0>
        LWIP_ASSERT("tcp_receive: valid queue length",
    15b2:	687b      	ldr	r3, [r7, #4]
    15b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    15b6:	2b00      	cmp	r3, #0
    15b8:	e000      	b.n	15bc <tcp_receive+0x4b0>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    15ba:	bf00      	nop
    15bc:	687b      	ldr	r3, [r7, #4]
    15be:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    15c0:	2b00      	cmp	r3, #0
    15c2:	d028      	beq.n	1616 <tcp_receive+0x50a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    15c4:	4b83      	ldr	r3, [pc, #524]	; (17d4 <tcp_receive+0x6c8>)
    15c6:	681c      	ldr	r4, [r3, #0]
    15c8:	687b      	ldr	r3, [r7, #4]
    15ca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    15cc:	68db      	ldr	r3, [r3, #12]
    15ce:	685b      	ldr	r3, [r3, #4]
    15d0:	4618      	mov	r0, r3
    15d2:	f7ff fffe 	bl	0 <lwip_ntohl>
			15d2: R_ARM_THM_CALL	lwip_ntohl
    15d6:	4605      	mov	r5, r0
    15d8:	687b      	ldr	r3, [r7, #4]
    15da:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    15dc:	891b      	ldrh	r3, [r3, #8]
    15de:	461e      	mov	r6, r3
    15e0:	687b      	ldr	r3, [r7, #4]
    15e2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    15e4:	68db      	ldr	r3, [r3, #12]
    15e6:	899b      	ldrh	r3, [r3, #12]
    15e8:	b29b      	uxth	r3, r3
    15ea:	4618      	mov	r0, r3
    15ec:	f7ff fffe 	bl	0 <lwip_ntohs>
			15ec: R_ARM_THM_CALL	lwip_ntohs
    15f0:	4603      	mov	r3, r0
    15f2:	f003 0303 	and.w	r3, r3, #3
    15f6:	2b00      	cmp	r3, #0
    15f8:	bf0c      	ite	eq
    15fa:	2300      	moveq	r3, #0
    15fc:	2301      	movne	r3, #1
    15fe:	18f3      	adds	r3, r6, r3
    1600:	18eb      	adds	r3, r5, r3
    1602:	1ae3      	subs	r3, r4, r3
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
    1604:	2b00      	cmp	r3, #0
    1606:	db06      	blt.n	1616 <tcp_receive+0x50a>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
    1608:	4b72      	ldr	r3, [pc, #456]	; (17d4 <tcp_receive+0x6c8>)
    160a:	681a      	ldr	r2, [r3, #0]
    160c:	687b      	ldr	r3, [r7, #4]
    160e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1610:	1ad3      	subs	r3, r2, r3
    1612:	2b00      	cmp	r3, #0
    1614:	dd86      	ble.n	1524 <tcp_receive+0x418>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
    1616:	687b      	ldr	r3, [r7, #4]
    1618:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    161a:	2b00      	cmp	r3, #0
    161c:	d05c      	beq.n	16d8 <tcp_receive+0x5cc>
    161e:	687b      	ldr	r3, [r7, #4]
    1620:	6bda      	ldr	r2, [r3, #60]	; 0x3c
    1622:	4b6c      	ldr	r3, [pc, #432]	; (17d4 <tcp_receive+0x6c8>)
    1624:	681b      	ldr	r3, [r3, #0]
    1626:	1ad3      	subs	r3, r2, r3
    1628:	2b00      	cmp	r3, #0
    162a:	da55      	bge.n	16d8 <tcp_receive+0x5cc>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
    162c:	4b6a      	ldr	r3, [pc, #424]	; (17d8 <tcp_receive+0x6cc>)
    162e:	681b      	ldr	r3, [r3, #0]
    1630:	b29a      	uxth	r2, r3
    1632:	687b      	ldr	r3, [r7, #4]
    1634:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1636:	b29b      	uxth	r3, r3
    1638:	1ad3      	subs	r3, r2, r3
    163a:	b29b      	uxth	r3, r3
    163c:	83fb      	strh	r3, [r7, #30]

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
    163e:	8bfa      	ldrh	r2, [r7, #30]
    1640:	687b      	ldr	r3, [r7, #4]
    1642:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
    1646:	b21b      	sxth	r3, r3
    1648:	ea4f 03e3 	mov.w	r3, r3, asr #3
    164c:	b29b      	uxth	r3, r3
    164e:	b29b      	uxth	r3, r3
    1650:	1ad3      	subs	r3, r2, r3
    1652:	b29b      	uxth	r3, r3
    1654:	83fb      	strh	r3, [r7, #30]
      pcb->sa += m;
    1656:	687b      	ldr	r3, [r7, #4]
    1658:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
    165c:	b29a      	uxth	r2, r3
    165e:	8bfb      	ldrh	r3, [r7, #30]
    1660:	18d3      	adds	r3, r2, r3
    1662:	b29b      	uxth	r3, r3
    1664:	b29a      	uxth	r2, r3
    1666:	687b      	ldr	r3, [r7, #4]
    1668:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
      if (m < 0) {
    166c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
    1670:	2b00      	cmp	r3, #0
    1672:	da04      	bge.n	167e <tcp_receive+0x572>
        m = -m;
    1674:	8bfb      	ldrh	r3, [r7, #30]
    1676:	f1c3 0300 	rsb	r3, r3, #0
    167a:	b29b      	uxth	r3, r3
    167c:	83fb      	strh	r3, [r7, #30]
      }
      m = m - (pcb->sv >> 2);
    167e:	8bfa      	ldrh	r2, [r7, #30]
    1680:	687b      	ldr	r3, [r7, #4]
    1682:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
    1686:	b21b      	sxth	r3, r3
    1688:	ea4f 03a3 	mov.w	r3, r3, asr #2
    168c:	b29b      	uxth	r3, r3
    168e:	b29b      	uxth	r3, r3
    1690:	1ad3      	subs	r3, r2, r3
    1692:	b29b      	uxth	r3, r3
    1694:	83fb      	strh	r3, [r7, #30]
      pcb->sv += m;
    1696:	687b      	ldr	r3, [r7, #4]
    1698:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
    169c:	b29a      	uxth	r2, r3
    169e:	8bfb      	ldrh	r3, [r7, #30]
    16a0:	18d3      	adds	r3, r2, r3
    16a2:	b29b      	uxth	r3, r3
    16a4:	b29a      	uxth	r2, r3
    16a6:	687b      	ldr	r3, [r7, #4]
    16a8:	f8a3 2042 	strh.w	r2, [r3, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
    16ac:	687b      	ldr	r3, [r7, #4]
    16ae:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
    16b2:	b21b      	sxth	r3, r3
    16b4:	ea4f 03e3 	mov.w	r3, r3, asr #3
    16b8:	b29b      	uxth	r3, r3
    16ba:	b29a      	uxth	r2, r3
    16bc:	687b      	ldr	r3, [r7, #4]
    16be:	f8b3 3042 	ldrh.w	r3, [r3, #66]	; 0x42
    16c2:	b29b      	uxth	r3, r3
    16c4:	18d3      	adds	r3, r2, r3
    16c6:	b29b      	uxth	r3, r3
    16c8:	b29a      	uxth	r2, r3
    16ca:	687b      	ldr	r3, [r7, #4]
    16cc:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
    16d0:	687b      	ldr	r3, [r7, #4]
    16d2:	f04f 0200 	mov.w	r2, #0
    16d6:	639a      	str	r2, [r3, #56]	; 0x38

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
    16d8:	4b40      	ldr	r3, [pc, #256]	; (17dc <tcp_receive+0x6d0>)
    16da:	881b      	ldrh	r3, [r3, #0]
    16dc:	2b00      	cmp	r3, #0
    16de:	f000 8463 	beq.w	1fa8 <tcp_receive+0xe9c>
    16e2:	687b      	ldr	r3, [r7, #4]
    16e4:	7e1b      	ldrb	r3, [r3, #24]
    16e6:	2b06      	cmp	r3, #6
    16e8:	f200 845e 	bhi.w	1fa8 <tcp_receive+0xe9c>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
    16ec:	687b      	ldr	r3, [r7, #4]
    16ee:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    16f0:	4b3b      	ldr	r3, [pc, #236]	; (17e0 <tcp_receive+0x6d4>)
    16f2:	681b      	ldr	r3, [r3, #0]
    16f4:	ea6f 0303 	mvn.w	r3, r3
    16f8:	18d3      	adds	r3, r2, r3
    16fa:	2b00      	cmp	r3, #0
    16fc:	db74      	blt.n	17e8 <tcp_receive+0x6dc>
    16fe:	687b      	ldr	r3, [r7, #4]
    1700:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1702:	4b36      	ldr	r3, [pc, #216]	; (17dc <tcp_receive+0x6d0>)
    1704:	881b      	ldrh	r3, [r3, #0]
    1706:	4619      	mov	r1, r3
    1708:	4b35      	ldr	r3, [pc, #212]	; (17e0 <tcp_receive+0x6d4>)
    170a:	681b      	ldr	r3, [r3, #0]
    170c:	18cb      	adds	r3, r1, r3
    170e:	1ad3      	subs	r3, r2, r3
    1710:	f103 0301 	add.w	r3, r3, #1
    1714:	2b00      	cmp	r3, #0
    1716:	dc67      	bgt.n	17e8 <tcp_receive+0x6dc>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
    1718:	687b      	ldr	r3, [r7, #4]
    171a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    171c:	4b30      	ldr	r3, [pc, #192]	; (17e0 <tcp_receive+0x6d4>)
    171e:	681b      	ldr	r3, [r3, #0]
    1720:	1ad3      	subs	r3, r2, r3
    1722:	623b      	str	r3, [r7, #32]
      p = inseg.p;
    1724:	4b2f      	ldr	r3, [pc, #188]	; (17e4 <tcp_receive+0x6d8>)
    1726:	685b      	ldr	r3, [r3, #4]
    1728:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
    172a:	4b2e      	ldr	r3, [pc, #184]	; (17e4 <tcp_receive+0x6d8>)
    172c:	685b      	ldr	r3, [r3, #4]
    172e:	895b      	ldrh	r3, [r3, #10]
    1730:	461a      	mov	r2, r3
    1732:	6a3b      	ldr	r3, [r7, #32]
    1734:	429a      	cmp	r2, r3
    1736:	da28      	bge.n	178a <tcp_receive+0x67e>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
    1738:	4b2a      	ldr	r3, [pc, #168]	; (17e4 <tcp_receive+0x6d8>)
    173a:	685b      	ldr	r3, [r3, #4]
    173c:	891a      	ldrh	r2, [r3, #8]
    173e:	6a3b      	ldr	r3, [r7, #32]
    1740:	b29b      	uxth	r3, r3
    1742:	1ad3      	subs	r3, r2, r3
    1744:	823b      	strh	r3, [r7, #16]
        while (p->len < off) {
    1746:	e00e      	b.n	1766 <tcp_receive+0x65a>
          off -= p->len;
    1748:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    174a:	895b      	ldrh	r3, [r3, #10]
    174c:	6a3a      	ldr	r2, [r7, #32]
    174e:	1ad3      	subs	r3, r2, r3
    1750:	623b      	str	r3, [r7, #32]
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
    1752:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1754:	8a3a      	ldrh	r2, [r7, #16]
    1756:	811a      	strh	r2, [r3, #8]
          p->len = 0;
    1758:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    175a:	f04f 0200 	mov.w	r2, #0
    175e:	815a      	strh	r2, [r3, #10]
          p = p->next;
    1760:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1762:	681b      	ldr	r3, [r3, #0]
    1764:	627b      	str	r3, [r7, #36]	; 0x24
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
    1766:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1768:	895b      	ldrh	r3, [r3, #10]
    176a:	461a      	mov	r2, r3
    176c:	6a3b      	ldr	r3, [r7, #32]
    176e:	429a      	cmp	r2, r3
    1770:	dbea      	blt.n	1748 <tcp_receive+0x63c>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
    1772:	6a3b      	ldr	r3, [r7, #32]
    1774:	b29b      	uxth	r3, r3
    1776:	f1c3 0300 	rsb	r3, r3, #0
    177a:	b29b      	uxth	r3, r3
    177c:	b29b      	uxth	r3, r3
    177e:	b21b      	sxth	r3, r3
    1780:	6a78      	ldr	r0, [r7, #36]	; 0x24
    1782:	4619      	mov	r1, r3
    1784:	f7ff fffe 	bl	0 <pbuf_header>
			1784: R_ARM_THM_CALL	pbuf_header
    1788:	e00c      	b.n	17a4 <tcp_receive+0x698>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
    178a:	4b16      	ldr	r3, [pc, #88]	; (17e4 <tcp_receive+0x6d8>)
    178c:	685a      	ldr	r2, [r3, #4]
    178e:	6a3b      	ldr	r3, [r7, #32]
    1790:	b29b      	uxth	r3, r3
    1792:	f1c3 0300 	rsb	r3, r3, #0
    1796:	b29b      	uxth	r3, r3
    1798:	b29b      	uxth	r3, r3
    179a:	b21b      	sxth	r3, r3
    179c:	4610      	mov	r0, r2
    179e:	4619      	mov	r1, r3
    17a0:	f7ff fffe 	bl	0 <pbuf_header>
			17a0: R_ARM_THM_CALL	pbuf_header
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
    17a4:	4b0f      	ldr	r3, [pc, #60]	; (17e4 <tcp_receive+0x6d8>)
    17a6:	891a      	ldrh	r2, [r3, #8]
    17a8:	4b0d      	ldr	r3, [pc, #52]	; (17e0 <tcp_receive+0x6d4>)
    17aa:	681b      	ldr	r3, [r3, #0]
    17ac:	b299      	uxth	r1, r3
    17ae:	687b      	ldr	r3, [r7, #4]
    17b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    17b2:	b29b      	uxth	r3, r3
    17b4:	1acb      	subs	r3, r1, r3
    17b6:	b29b      	uxth	r3, r3
    17b8:	18d3      	adds	r3, r2, r3
    17ba:	b29a      	uxth	r2, r3
    17bc:	4b09      	ldr	r3, [pc, #36]	; (17e4 <tcp_receive+0x6d8>)
    17be:	811a      	strh	r2, [r3, #8]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    17c0:	4b08      	ldr	r3, [pc, #32]	; (17e4 <tcp_receive+0x6d8>)
    17c2:	68db      	ldr	r3, [r3, #12]
    17c4:	687a      	ldr	r2, [r7, #4]
    17c6:	6a91      	ldr	r1, [r2, #40]	; 0x28
    17c8:	4a05      	ldr	r2, [pc, #20]	; (17e0 <tcp_receive+0x6d4>)
    17ca:	6011      	str	r1, [r2, #0]
    17cc:	4a04      	ldr	r2, [pc, #16]	; (17e0 <tcp_receive+0x6d4>)
    17ce:	6812      	ldr	r2, [r2, #0]
    17d0:	605a      	str	r2, [r3, #4]
    17d2:	e017      	b.n	1804 <tcp_receive+0x6f8>
    17d4:	0000001c 	.word	0x0000001c
			17d4: R_ARM_ABS32	.bss
    17d8:	00000000 	.word	0x00000000
			17d8: R_ARM_ABS32	tcp_ticks
    17dc:	00000022 	.word	0x00000022
			17dc: R_ARM_ABS32	.bss
    17e0:	00000018 	.word	0x00000018
			17e0: R_ARM_ABS32	.bss
    17e4:	00000000 	.word	0x00000000
			17e4: R_ARM_ABS32	.bss
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
    17e8:	4b66      	ldr	r3, [pc, #408]	; (1984 <tcp_receive+0x878>)
    17ea:	681a      	ldr	r2, [r3, #0]
    17ec:	687b      	ldr	r3, [r7, #4]
    17ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    17f0:	1ad3      	subs	r3, r2, r3
    17f2:	2b00      	cmp	r3, #0
    17f4:	da06      	bge.n	1804 <tcp_receive+0x6f8>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
    17f6:	687b      	ldr	r3, [r7, #4]
    17f8:	7f9b      	ldrb	r3, [r3, #30]
    17fa:	f043 0302 	orr.w	r3, r3, #2
    17fe:	b2da      	uxtb	r2, r3
    1800:	687b      	ldr	r3, [r7, #4]
    1802:	779a      	strb	r2, [r3, #30]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    1804:	4b5f      	ldr	r3, [pc, #380]	; (1984 <tcp_receive+0x878>)
    1806:	681a      	ldr	r2, [r3, #0]
    1808:	687b      	ldr	r3, [r7, #4]
    180a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    180c:	1ad3      	subs	r3, r2, r3
    180e:	2b00      	cmp	r3, #0
    1810:	f2c0 83bf 	blt.w	1f92 <tcp_receive+0xe86>
    1814:	4b5b      	ldr	r3, [pc, #364]	; (1984 <tcp_receive+0x878>)
    1816:	681a      	ldr	r2, [r3, #0]
    1818:	687b      	ldr	r3, [r7, #4]
    181a:	6a99      	ldr	r1, [r3, #40]	; 0x28
    181c:	687b      	ldr	r3, [r7, #4]
    181e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    1820:	18cb      	adds	r3, r1, r3
    1822:	1ad3      	subs	r3, r2, r3
    1824:	f103 0301 	add.w	r3, r3, #1
    1828:	2b00      	cmp	r3, #0
    182a:	f300 83b2 	bgt.w	1f92 <tcp_receive+0xe86>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    182e:	687b      	ldr	r3, [r7, #4]
    1830:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1832:	4b54      	ldr	r3, [pc, #336]	; (1984 <tcp_receive+0x878>)
    1834:	681b      	ldr	r3, [r3, #0]
    1836:	429a      	cmp	r2, r3
    1838:	f040 823f 	bne.w	1cba <tcp_receive+0xbae>
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
    183c:	4b52      	ldr	r3, [pc, #328]	; (1988 <tcp_receive+0x87c>)
    183e:	891c      	ldrh	r4, [r3, #8]
    1840:	4b51      	ldr	r3, [pc, #324]	; (1988 <tcp_receive+0x87c>)
    1842:	68db      	ldr	r3, [r3, #12]
    1844:	899b      	ldrh	r3, [r3, #12]
    1846:	b29b      	uxth	r3, r3
    1848:	4618      	mov	r0, r3
    184a:	f7ff fffe 	bl	0 <lwip_ntohs>
			184a: R_ARM_THM_CALL	lwip_ntohs
    184e:	4603      	mov	r3, r0
    1850:	f003 0303 	and.w	r3, r3, #3
    1854:	2b00      	cmp	r3, #0
    1856:	bf0c      	ite	eq
    1858:	2300      	moveq	r3, #0
    185a:	2301      	movne	r3, #1
    185c:	b29b      	uxth	r3, r3
    185e:	18e3      	adds	r3, r4, r3
    1860:	b29a      	uxth	r2, r3
    1862:	4b4a      	ldr	r3, [pc, #296]	; (198c <tcp_receive+0x880>)
    1864:	801a      	strh	r2, [r3, #0]

        if (tcplen > pcb->rcv_wnd) {
    1866:	687b      	ldr	r3, [r7, #4]
    1868:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    186a:	4b48      	ldr	r3, [pc, #288]	; (198c <tcp_receive+0x880>)
    186c:	881b      	ldrh	r3, [r3, #0]
    186e:	429a      	cmp	r2, r3
    1870:	d260      	bcs.n	1934 <tcp_receive+0x828>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    1872:	4b45      	ldr	r3, [pc, #276]	; (1988 <tcp_receive+0x87c>)
    1874:	68db      	ldr	r3, [r3, #12]
    1876:	899b      	ldrh	r3, [r3, #12]
    1878:	b29b      	uxth	r3, r3
    187a:	4618      	mov	r0, r3
    187c:	f7ff fffe 	bl	0 <lwip_ntohs>
			187c: R_ARM_THM_CALL	lwip_ntohs
    1880:	4603      	mov	r3, r0
    1882:	f003 0301 	and.w	r3, r3, #1
    1886:	b2db      	uxtb	r3, r3
    1888:	2b00      	cmp	r3, #0
    188a:	d01f      	beq.n	18cc <tcp_receive+0x7c0>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
    188c:	4b3e      	ldr	r3, [pc, #248]	; (1988 <tcp_receive+0x87c>)
    188e:	68dc      	ldr	r4, [r3, #12]
    1890:	4b3d      	ldr	r3, [pc, #244]	; (1988 <tcp_receive+0x87c>)
    1892:	68db      	ldr	r3, [r3, #12]
    1894:	899b      	ldrh	r3, [r3, #12]
    1896:	b29b      	uxth	r3, r3
    1898:	b29b      	uxth	r3, r3
    189a:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    189e:	b29d      	uxth	r5, r3
    18a0:	4b39      	ldr	r3, [pc, #228]	; (1988 <tcp_receive+0x87c>)
    18a2:	68db      	ldr	r3, [r3, #12]
    18a4:	899b      	ldrh	r3, [r3, #12]
    18a6:	b29b      	uxth	r3, r3
    18a8:	4618      	mov	r0, r3
    18aa:	f7ff fffe 	bl	0 <lwip_ntohs>
			18aa: R_ARM_THM_CALL	lwip_ntohs
    18ae:	4603      	mov	r3, r0
    18b0:	f003 033e 	and.w	r3, r3, #62	; 0x3e
    18b4:	b29b      	uxth	r3, r3
    18b6:	4618      	mov	r0, r3
    18b8:	f7ff fffe 	bl	0 <lwip_htons>
			18b8: R_ARM_THM_CALL	lwip_htons
    18bc:	4603      	mov	r3, r0
    18be:	b29b      	uxth	r3, r3
    18c0:	462a      	mov	r2, r5
    18c2:	ea42 0303 	orr.w	r3, r2, r3
    18c6:	b29b      	uxth	r3, r3
    18c8:	b29b      	uxth	r3, r3
    18ca:	81a3      	strh	r3, [r4, #12]
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
    18cc:	687b      	ldr	r3, [r7, #4]
    18ce:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    18d0:	4b2d      	ldr	r3, [pc, #180]	; (1988 <tcp_receive+0x87c>)
    18d2:	811a      	strh	r2, [r3, #8]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    18d4:	4b2c      	ldr	r3, [pc, #176]	; (1988 <tcp_receive+0x87c>)
    18d6:	68db      	ldr	r3, [r3, #12]
    18d8:	899b      	ldrh	r3, [r3, #12]
    18da:	b29b      	uxth	r3, r3
    18dc:	4618      	mov	r0, r3
    18de:	f7ff fffe 	bl	0 <lwip_ntohs>
			18de: R_ARM_THM_CALL	lwip_ntohs
    18e2:	4603      	mov	r3, r0
    18e4:	f003 0302 	and.w	r3, r3, #2
    18e8:	2b00      	cmp	r3, #0
    18ea:	d006      	beq.n	18fa <tcp_receive+0x7ee>
            inseg.len -= 1;
    18ec:	4b26      	ldr	r3, [pc, #152]	; (1988 <tcp_receive+0x87c>)
    18ee:	891b      	ldrh	r3, [r3, #8]
    18f0:	f103 33ff 	add.w	r3, r3, #4294967295
    18f4:	b29a      	uxth	r2, r3
    18f6:	4b24      	ldr	r3, [pc, #144]	; (1988 <tcp_receive+0x87c>)
    18f8:	811a      	strh	r2, [r3, #8]
          }
          pbuf_realloc(inseg.p, inseg.len);
    18fa:	4b23      	ldr	r3, [pc, #140]	; (1988 <tcp_receive+0x87c>)
    18fc:	685a      	ldr	r2, [r3, #4]
    18fe:	4b22      	ldr	r3, [pc, #136]	; (1988 <tcp_receive+0x87c>)
    1900:	891b      	ldrh	r3, [r3, #8]
    1902:	4610      	mov	r0, r2
    1904:	4619      	mov	r1, r3
    1906:	f7ff fffe 	bl	0 <pbuf_realloc>
			1906: R_ARM_THM_CALL	pbuf_realloc
          tcplen = TCP_TCPLEN(&inseg);
    190a:	4b1f      	ldr	r3, [pc, #124]	; (1988 <tcp_receive+0x87c>)
    190c:	891c      	ldrh	r4, [r3, #8]
    190e:	4b1e      	ldr	r3, [pc, #120]	; (1988 <tcp_receive+0x87c>)
    1910:	68db      	ldr	r3, [r3, #12]
    1912:	899b      	ldrh	r3, [r3, #12]
    1914:	b29b      	uxth	r3, r3
    1916:	4618      	mov	r0, r3
    1918:	f7ff fffe 	bl	0 <lwip_ntohs>
			1918: R_ARM_THM_CALL	lwip_ntohs
    191c:	4603      	mov	r3, r0
    191e:	f003 0303 	and.w	r3, r3, #3
    1922:	2b00      	cmp	r3, #0
    1924:	bf0c      	ite	eq
    1926:	2300      	moveq	r3, #0
    1928:	2301      	movne	r3, #1
    192a:	b29b      	uxth	r3, r3
    192c:	18e3      	adds	r3, r4, r3
    192e:	b29a      	uxth	r2, r3
    1930:	4b16      	ldr	r3, [pc, #88]	; (198c <tcp_receive+0x880>)
    1932:	801a      	strh	r2, [r3, #0]
        }
#if TCP_QUEUE_OOSEQ
        /* Received in-sequence data, adjust ooseq data if:
           - FIN has been received or
           - inseq overlaps with ooseq */
        if (pcb->ooseq != NULL) {
    1934:	687b      	ldr	r3, [r7, #4]
    1936:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1938:	2b00      	cmp	r3, #0
    193a:	f000 80cd 	beq.w	1ad8 <tcp_receive+0x9cc>
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    193e:	4b12      	ldr	r3, [pc, #72]	; (1988 <tcp_receive+0x87c>)
    1940:	68db      	ldr	r3, [r3, #12]
    1942:	899b      	ldrh	r3, [r3, #12]
    1944:	b29b      	uxth	r3, r3
    1946:	4618      	mov	r0, r3
    1948:	f7ff fffe 	bl	0 <lwip_ntohs>
			1948: R_ARM_THM_CALL	lwip_ntohs
    194c:	4603      	mov	r3, r0
    194e:	f003 0301 	and.w	r3, r3, #1
    1952:	b2db      	uxtb	r3, r3
    1954:	2b00      	cmp	r3, #0
    1956:	d010      	beq.n	197a <tcp_receive+0x86e>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
    1958:	e00a      	b.n	1970 <tcp_receive+0x864>
              struct tcp_seg *old_ooseq = pcb->ooseq;
    195a:	687b      	ldr	r3, [r7, #4]
    195c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    195e:	60fb      	str	r3, [r7, #12]
              pcb->ooseq = pcb->ooseq->next;
    1960:	687b      	ldr	r3, [r7, #4]
    1962:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1964:	681a      	ldr	r2, [r3, #0]
    1966:	687b      	ldr	r3, [r7, #4]
    1968:	675a      	str	r2, [r3, #116]	; 0x74
              tcp_seg_free(old_ooseq);
    196a:	68f8      	ldr	r0, [r7, #12]
    196c:	f7ff fffe 	bl	0 <tcp_seg_free>
			196c: R_ARM_THM_CALL	tcp_seg_free
            LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                        ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
            /* Received in-order FIN means anything that was received
             * out of order must now have been received in-order, so
             * bin the ooseq queue */
            while (pcb->ooseq != NULL) {
    1970:	687b      	ldr	r3, [r7, #4]
    1972:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1974:	2b00      	cmp	r3, #0
    1976:	d1f0      	bne.n	195a <tcp_receive+0x84e>
    1978:	e0ae      	b.n	1ad8 <tcp_receive+0x9cc>
              struct tcp_seg *old_ooseq = pcb->ooseq;
              pcb->ooseq = pcb->ooseq->next;
              tcp_seg_free(old_ooseq);
            }
          } else {
            next = pcb->ooseq;
    197a:	687b      	ldr	r3, [r7, #4]
    197c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    197e:	62fb      	str	r3, [r7, #44]	; 0x2c
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    1980:	e04b      	b.n	1a1a <tcp_receive+0x90e>
    1982:	bf00      	nop
    1984:	00000018 	.word	0x00000018
			1984: R_ARM_ABS32	.bss
    1988:	00000000 	.word	0x00000000
			1988: R_ARM_ABS32	.bss
    198c:	00000022 	.word	0x00000022
			198c: R_ARM_ABS32	.bss
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
    1990:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1992:	68db      	ldr	r3, [r3, #12]
    1994:	899b      	ldrh	r3, [r3, #12]
    1996:	b29b      	uxth	r3, r3
    1998:	4618      	mov	r0, r3
    199a:	f7ff fffe 	bl	0 <lwip_ntohs>
			199a: R_ARM_THM_CALL	lwip_ntohs
    199e:	4603      	mov	r3, r0
    19a0:	f003 0301 	and.w	r3, r3, #1
    19a4:	b2db      	uxtb	r3, r3
    19a6:	2b00      	cmp	r3, #0
    19a8:	d02f      	beq.n	1a0a <tcp_receive+0x8fe>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
    19aa:	4b66      	ldr	r3, [pc, #408]	; (1b44 <tcp_receive+0xa38>)
    19ac:	68db      	ldr	r3, [r3, #12]
    19ae:	899b      	ldrh	r3, [r3, #12]
    19b0:	b29b      	uxth	r3, r3
    19b2:	4618      	mov	r0, r3
    19b4:	f7ff fffe 	bl	0 <lwip_ntohs>
			19b4: R_ARM_THM_CALL	lwip_ntohs
    19b8:	4603      	mov	r3, r0
    19ba:	f003 0302 	and.w	r3, r3, #2
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
                   TCP_SEQ_GEQ(seqno + tcplen,
                               next->tcphdr->seqno + next->len)) {
              /* inseg cannot have FIN here (already processed above) */
              if (TCPH_FLAGS(next->tcphdr) & TCP_FIN &&
    19be:	2b00      	cmp	r3, #0
    19c0:	d123      	bne.n	1a0a <tcp_receive+0x8fe>
                  (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
                TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
    19c2:	4b60      	ldr	r3, [pc, #384]	; (1b44 <tcp_receive+0xa38>)
    19c4:	68dc      	ldr	r4, [r3, #12]
    19c6:	4b5f      	ldr	r3, [pc, #380]	; (1b44 <tcp_receive+0xa38>)
    19c8:	68db      	ldr	r3, [r3, #12]
    19ca:	899b      	ldrh	r3, [r3, #12]
    19cc:	b29d      	uxth	r5, r3
    19ce:	f04f 0001 	mov.w	r0, #1
    19d2:	f7ff fffe 	bl	0 <lwip_htons>
			19d2: R_ARM_THM_CALL	lwip_htons
    19d6:	4603      	mov	r3, r0
    19d8:	ea45 0303 	orr.w	r3, r5, r3
    19dc:	b29b      	uxth	r3, r3
    19de:	81a3      	strh	r3, [r4, #12]
                tcplen = TCP_TCPLEN(&inseg);
    19e0:	4b58      	ldr	r3, [pc, #352]	; (1b44 <tcp_receive+0xa38>)
    19e2:	891c      	ldrh	r4, [r3, #8]
    19e4:	4b57      	ldr	r3, [pc, #348]	; (1b44 <tcp_receive+0xa38>)
    19e6:	68db      	ldr	r3, [r3, #12]
    19e8:	899b      	ldrh	r3, [r3, #12]
    19ea:	b29b      	uxth	r3, r3
    19ec:	4618      	mov	r0, r3
    19ee:	f7ff fffe 	bl	0 <lwip_ntohs>
			19ee: R_ARM_THM_CALL	lwip_ntohs
    19f2:	4603      	mov	r3, r0
    19f4:	f003 0303 	and.w	r3, r3, #3
    19f8:	2b00      	cmp	r3, #0
    19fa:	bf0c      	ite	eq
    19fc:	2300      	moveq	r3, #0
    19fe:	2301      	movne	r3, #1
    1a00:	b29b      	uxth	r3, r3
    1a02:	18e3      	adds	r3, r4, r3
    1a04:	b29a      	uxth	r2, r3
    1a06:	4b50      	ldr	r3, [pc, #320]	; (1b48 <tcp_receive+0xa3c>)
    1a08:	801a      	strh	r2, [r3, #0]
              }
              prev = next;
    1a0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a0c:	62bb      	str	r3, [r7, #40]	; 0x28
              next = next->next;
    1a0e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a10:	681b      	ldr	r3, [r3, #0]
    1a12:	62fb      	str	r3, [r7, #44]	; 0x2c
              tcp_seg_free(prev);
    1a14:	6ab8      	ldr	r0, [r7, #40]	; 0x28
    1a16:	f7ff fffe 	bl	0 <tcp_seg_free>
			1a16: R_ARM_THM_CALL	tcp_seg_free
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    1a1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a1c:	2b00      	cmp	r3, #0
    1a1e:	d00e      	beq.n	1a3e <tcp_receive+0x932>
                   TCP_SEQ_GEQ(seqno + tcplen,
    1a20:	4b49      	ldr	r3, [pc, #292]	; (1b48 <tcp_receive+0xa3c>)
    1a22:	881b      	ldrh	r3, [r3, #0]
    1a24:	461a      	mov	r2, r3
    1a26:	4b49      	ldr	r3, [pc, #292]	; (1b4c <tcp_receive+0xa40>)
    1a28:	681b      	ldr	r3, [r3, #0]
    1a2a:	18d2      	adds	r2, r2, r3
    1a2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a2e:	68db      	ldr	r3, [r3, #12]
    1a30:	6859      	ldr	r1, [r3, #4]
    1a32:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a34:	891b      	ldrh	r3, [r3, #8]
    1a36:	18cb      	adds	r3, r1, r3
    1a38:	1ad3      	subs	r3, r2, r3
            }
          } else {
            next = pcb->ooseq;
            /* Remove all segments on ooseq that are covered by inseg already.
             * FIN is copied from ooseq to inseg if present. */
            while (next &&
    1a3a:	2b00      	cmp	r3, #0
    1a3c:	daa8      	bge.n	1990 <tcp_receive+0x884>
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
    1a3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a40:	2b00      	cmp	r3, #0
    1a42:	d046      	beq.n	1ad2 <tcp_receive+0x9c6>
                TCP_SEQ_GT(seqno + tcplen,
    1a44:	4b40      	ldr	r3, [pc, #256]	; (1b48 <tcp_receive+0xa3c>)
    1a46:	881b      	ldrh	r3, [r3, #0]
    1a48:	461a      	mov	r2, r3
    1a4a:	4b40      	ldr	r3, [pc, #256]	; (1b4c <tcp_receive+0xa40>)
    1a4c:	681b      	ldr	r3, [r3, #0]
    1a4e:	18d2      	adds	r2, r2, r3
    1a50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a52:	68db      	ldr	r3, [r3, #12]
    1a54:	685b      	ldr	r3, [r3, #4]
    1a56:	1ad3      	subs	r3, r2, r3
              next = next->next;
              tcp_seg_free(prev);
            }
            /* Now trim right side of inseg if it overlaps with the first
             * segment on ooseq */
            if (next &&
    1a58:	2b00      	cmp	r3, #0
    1a5a:	dd3a      	ble.n	1ad2 <tcp_receive+0x9c6>
                TCP_SEQ_GT(seqno + tcplen,
                           next->tcphdr->seqno)) {
              /* inseg cannot have FIN here (already processed above) */
              inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
    1a5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1a5e:	68db      	ldr	r3, [r3, #12]
    1a60:	685b      	ldr	r3, [r3, #4]
    1a62:	b29a      	uxth	r2, r3
    1a64:	4b39      	ldr	r3, [pc, #228]	; (1b4c <tcp_receive+0xa40>)
    1a66:	681b      	ldr	r3, [r3, #0]
    1a68:	b29b      	uxth	r3, r3
    1a6a:	1ad3      	subs	r3, r2, r3
    1a6c:	b29a      	uxth	r2, r3
    1a6e:	4b35      	ldr	r3, [pc, #212]	; (1b44 <tcp_receive+0xa38>)
    1a70:	811a      	strh	r2, [r3, #8]
              if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
    1a72:	4b34      	ldr	r3, [pc, #208]	; (1b44 <tcp_receive+0xa38>)
    1a74:	68db      	ldr	r3, [r3, #12]
    1a76:	899b      	ldrh	r3, [r3, #12]
    1a78:	b29b      	uxth	r3, r3
    1a7a:	4618      	mov	r0, r3
    1a7c:	f7ff fffe 	bl	0 <lwip_ntohs>
			1a7c: R_ARM_THM_CALL	lwip_ntohs
    1a80:	4603      	mov	r3, r0
    1a82:	f003 0302 	and.w	r3, r3, #2
    1a86:	2b00      	cmp	r3, #0
    1a88:	d006      	beq.n	1a98 <tcp_receive+0x98c>
                inseg.len -= 1;
    1a8a:	4b2e      	ldr	r3, [pc, #184]	; (1b44 <tcp_receive+0xa38>)
    1a8c:	891b      	ldrh	r3, [r3, #8]
    1a8e:	f103 33ff 	add.w	r3, r3, #4294967295
    1a92:	b29a      	uxth	r2, r3
    1a94:	4b2b      	ldr	r3, [pc, #172]	; (1b44 <tcp_receive+0xa38>)
    1a96:	811a      	strh	r2, [r3, #8]
              }
              pbuf_realloc(inseg.p, inseg.len);
    1a98:	4b2a      	ldr	r3, [pc, #168]	; (1b44 <tcp_receive+0xa38>)
    1a9a:	685a      	ldr	r2, [r3, #4]
    1a9c:	4b29      	ldr	r3, [pc, #164]	; (1b44 <tcp_receive+0xa38>)
    1a9e:	891b      	ldrh	r3, [r3, #8]
    1aa0:	4610      	mov	r0, r2
    1aa2:	4619      	mov	r1, r3
    1aa4:	f7ff fffe 	bl	0 <pbuf_realloc>
			1aa4: R_ARM_THM_CALL	pbuf_realloc
              tcplen = TCP_TCPLEN(&inseg);
    1aa8:	4b26      	ldr	r3, [pc, #152]	; (1b44 <tcp_receive+0xa38>)
    1aaa:	891c      	ldrh	r4, [r3, #8]
    1aac:	4b25      	ldr	r3, [pc, #148]	; (1b44 <tcp_receive+0xa38>)
    1aae:	68db      	ldr	r3, [r3, #12]
    1ab0:	899b      	ldrh	r3, [r3, #12]
    1ab2:	b29b      	uxth	r3, r3
    1ab4:	4618      	mov	r0, r3
    1ab6:	f7ff fffe 	bl	0 <lwip_ntohs>
			1ab6: R_ARM_THM_CALL	lwip_ntohs
    1aba:	4603      	mov	r3, r0
    1abc:	f003 0303 	and.w	r3, r3, #3
    1ac0:	2b00      	cmp	r3, #0
    1ac2:	bf0c      	ite	eq
    1ac4:	2300      	moveq	r3, #0
    1ac6:	2301      	movne	r3, #1
    1ac8:	b29b      	uxth	r3, r3
    1aca:	18e3      	adds	r3, r4, r3
    1acc:	b29a      	uxth	r2, r3
    1ace:	4b1e      	ldr	r3, [pc, #120]	; (1b48 <tcp_receive+0xa3c>)
    1ad0:	801a      	strh	r2, [r3, #0]
              LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
                          (seqno + tcplen) == next->tcphdr->seqno);
            }
            pcb->ooseq = next;
    1ad2:	687b      	ldr	r3, [r7, #4]
    1ad4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
    1ad6:	675a      	str	r2, [r3, #116]	; 0x74
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
    1ad8:	4b1b      	ldr	r3, [pc, #108]	; (1b48 <tcp_receive+0xa3c>)
    1ada:	881b      	ldrh	r3, [r3, #0]
    1adc:	461a      	mov	r2, r3
    1ade:	4b1b      	ldr	r3, [pc, #108]	; (1b4c <tcp_receive+0xa40>)
    1ae0:	681b      	ldr	r3, [r3, #0]
    1ae2:	18d2      	adds	r2, r2, r3
    1ae4:	687b      	ldr	r3, [r7, #4]
    1ae6:	629a      	str	r2, [r3, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
    1ae8:	687b      	ldr	r3, [r7, #4]
    1aea:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
    1aec:	4b16      	ldr	r3, [pc, #88]	; (1b48 <tcp_receive+0xa3c>)
    1aee:	881b      	ldrh	r3, [r3, #0]
    1af0:	1ad3      	subs	r3, r2, r3
    1af2:	b29a      	uxth	r2, r3
    1af4:	687b      	ldr	r3, [r7, #4]
    1af6:	859a      	strh	r2, [r3, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
    1af8:	6878      	ldr	r0, [r7, #4]
    1afa:	f7ff fffe 	bl	0 <tcp_update_rcv_ann_wnd>
			1afa: R_ARM_THM_CALL	tcp_update_rcv_ann_wnd
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
    1afe:	4b11      	ldr	r3, [pc, #68]	; (1b44 <tcp_receive+0xa38>)
    1b00:	685b      	ldr	r3, [r3, #4]
    1b02:	891b      	ldrh	r3, [r3, #8]
    1b04:	2b00      	cmp	r3, #0
    1b06:	d007      	beq.n	1b18 <tcp_receive+0xa0c>
          recv_data = inseg.p;
    1b08:	4b0e      	ldr	r3, [pc, #56]	; (1b44 <tcp_receive+0xa38>)
    1b0a:	685a      	ldr	r2, [r3, #4]
    1b0c:	4b10      	ldr	r3, [pc, #64]	; (1b50 <tcp_receive+0xa44>)
    1b0e:	601a      	str	r2, [r3, #0]
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
    1b10:	4b0c      	ldr	r3, [pc, #48]	; (1b44 <tcp_receive+0xa38>)
    1b12:	f04f 0200 	mov.w	r2, #0
    1b16:	605a      	str	r2, [r3, #4]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
    1b18:	4b0a      	ldr	r3, [pc, #40]	; (1b44 <tcp_receive+0xa38>)
    1b1a:	68db      	ldr	r3, [r3, #12]
    1b1c:	899b      	ldrh	r3, [r3, #12]
    1b1e:	b29b      	uxth	r3, r3
    1b20:	4618      	mov	r0, r3
    1b22:	f7ff fffe 	bl	0 <lwip_ntohs>
			1b22: R_ARM_THM_CALL	lwip_ntohs
    1b26:	4603      	mov	r3, r0
    1b28:	f003 0301 	and.w	r3, r3, #1
    1b2c:	b2db      	uxtb	r3, r3
    1b2e:	2b00      	cmp	r3, #0
    1b30:	f000 8097 	beq.w	1c62 <tcp_receive+0xb56>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
    1b34:	4b07      	ldr	r3, [pc, #28]	; (1b54 <tcp_receive+0xa48>)
    1b36:	781b      	ldrb	r3, [r3, #0]
    1b38:	f043 0320 	orr.w	r3, r3, #32
    1b3c:	b2da      	uxtb	r2, r3
    1b3e:	4b05      	ldr	r3, [pc, #20]	; (1b54 <tcp_receive+0xa48>)
    1b40:	701a      	strb	r2, [r3, #0]
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    1b42:	e08f      	b.n	1c64 <tcp_receive+0xb58>
    1b44:	00000000 	.word	0x00000000
			1b44: R_ARM_ABS32	.bss
    1b48:	00000022 	.word	0x00000022
			1b48: R_ARM_ABS32	.bss
    1b4c:	00000018 	.word	0x00000018
			1b4c: R_ARM_ABS32	.bss
    1b50:	00000028 	.word	0x00000028
			1b50: R_ARM_ABS32	.bss
    1b54:	00000024 	.word	0x00000024
			1b54: R_ARM_ABS32	.bss
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
    1b58:	687b      	ldr	r3, [r7, #4]
    1b5a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1b5c:	60bb      	str	r3, [r7, #8]
          seqno = pcb->ooseq->tcphdr->seqno;
    1b5e:	687b      	ldr	r3, [r7, #4]
    1b60:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1b62:	68db      	ldr	r3, [r3, #12]
    1b64:	685a      	ldr	r2, [r3, #4]
    1b66:	4b7f      	ldr	r3, [pc, #508]	; (1d64 <tcp_receive+0xc58>)
    1b68:	601a      	str	r2, [r3, #0]

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
    1b6a:	687b      	ldr	r3, [r7, #4]
    1b6c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
    1b6e:	68bb      	ldr	r3, [r7, #8]
    1b70:	891b      	ldrh	r3, [r3, #8]
    1b72:	461d      	mov	r5, r3
    1b74:	68bb      	ldr	r3, [r7, #8]
    1b76:	68db      	ldr	r3, [r3, #12]
    1b78:	899b      	ldrh	r3, [r3, #12]
    1b7a:	b29b      	uxth	r3, r3
    1b7c:	4618      	mov	r0, r3
    1b7e:	f7ff fffe 	bl	0 <lwip_ntohs>
			1b7e: R_ARM_THM_CALL	lwip_ntohs
    1b82:	4603      	mov	r3, r0
    1b84:	f003 0303 	and.w	r3, r3, #3
    1b88:	2b00      	cmp	r3, #0
    1b8a:	bf0c      	ite	eq
    1b8c:	2300      	moveq	r3, #0
    1b8e:	2301      	movne	r3, #1
    1b90:	18eb      	adds	r3, r5, r3
    1b92:	18e2      	adds	r2, r4, r3
    1b94:	687b      	ldr	r3, [r7, #4]
    1b96:	629a      	str	r2, [r3, #40]	; 0x28
          LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
    1b98:	68bb      	ldr	r3, [r7, #8]
    1b9a:	68db      	ldr	r3, [r3, #12]
    1b9c:	899b      	ldrh	r3, [r3, #12]
    1b9e:	b29b      	uxth	r3, r3
    1ba0:	4618      	mov	r0, r3
    1ba2:	f7ff fffe 	bl	0 <lwip_ntohs>
			1ba2: R_ARM_THM_CALL	lwip_ntohs
    1ba6:	4603      	mov	r3, r0
    1ba8:	f003 0303 	and.w	r3, r3, #3
    1bac:	2b00      	cmp	r3, #0
                      pcb->rcv_wnd >= TCP_TCPLEN(cseg));
          pcb->rcv_wnd -= TCP_TCPLEN(cseg);
    1bae:	687b      	ldr	r3, [r7, #4]
    1bb0:	8d9c      	ldrh	r4, [r3, #44]	; 0x2c
    1bb2:	68bb      	ldr	r3, [r7, #8]
    1bb4:	891d      	ldrh	r5, [r3, #8]
    1bb6:	68bb      	ldr	r3, [r7, #8]
    1bb8:	68db      	ldr	r3, [r3, #12]
    1bba:	899b      	ldrh	r3, [r3, #12]
    1bbc:	b29b      	uxth	r3, r3
    1bbe:	4618      	mov	r0, r3
    1bc0:	f7ff fffe 	bl	0 <lwip_ntohs>
			1bc0: R_ARM_THM_CALL	lwip_ntohs
    1bc4:	4603      	mov	r3, r0
    1bc6:	f003 0303 	and.w	r3, r3, #3
    1bca:	2b00      	cmp	r3, #0
    1bcc:	bf0c      	ite	eq
    1bce:	2300      	moveq	r3, #0
    1bd0:	2301      	movne	r3, #1
    1bd2:	b29b      	uxth	r3, r3
    1bd4:	18eb      	adds	r3, r5, r3
    1bd6:	b29b      	uxth	r3, r3
    1bd8:	1ae3      	subs	r3, r4, r3
    1bda:	b29a      	uxth	r2, r3
    1bdc:	687b      	ldr	r3, [r7, #4]
    1bde:	859a      	strh	r2, [r3, #44]	; 0x2c

          tcp_update_rcv_ann_wnd(pcb);
    1be0:	6878      	ldr	r0, [r7, #4]
    1be2:	f7ff fffe 	bl	0 <tcp_update_rcv_ann_wnd>
			1be2: R_ARM_THM_CALL	tcp_update_rcv_ann_wnd

          if (cseg->p->tot_len > 0) {
    1be6:	68bb      	ldr	r3, [r7, #8]
    1be8:	685b      	ldr	r3, [r3, #4]
    1bea:	891b      	ldrh	r3, [r3, #8]
    1bec:	2b00      	cmp	r3, #0
    1bee:	d014      	beq.n	1c1a <tcp_receive+0xb0e>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
    1bf0:	4b5d      	ldr	r3, [pc, #372]	; (1d68 <tcp_receive+0xc5c>)
    1bf2:	681b      	ldr	r3, [r3, #0]
    1bf4:	2b00      	cmp	r3, #0
    1bf6:	d008      	beq.n	1c0a <tcp_receive+0xafe>
              pbuf_cat(recv_data, cseg->p);
    1bf8:	4b5b      	ldr	r3, [pc, #364]	; (1d68 <tcp_receive+0xc5c>)
    1bfa:	681a      	ldr	r2, [r3, #0]
    1bfc:	68bb      	ldr	r3, [r7, #8]
    1bfe:	685b      	ldr	r3, [r3, #4]
    1c00:	4610      	mov	r0, r2
    1c02:	4619      	mov	r1, r3
    1c04:	f7ff fffe 	bl	0 <pbuf_cat>
			1c04: R_ARM_THM_CALL	pbuf_cat
    1c08:	e003      	b.n	1c12 <tcp_receive+0xb06>
            } else {
              recv_data = cseg->p;
    1c0a:	68bb      	ldr	r3, [r7, #8]
    1c0c:	685a      	ldr	r2, [r3, #4]
    1c0e:	4b56      	ldr	r3, [pc, #344]	; (1d68 <tcp_receive+0xc5c>)
    1c10:	601a      	str	r2, [r3, #0]
            }
            cseg->p = NULL;
    1c12:	68bb      	ldr	r3, [r7, #8]
    1c14:	f04f 0200 	mov.w	r2, #0
    1c18:	605a      	str	r2, [r3, #4]
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
    1c1a:	68bb      	ldr	r3, [r7, #8]
    1c1c:	68db      	ldr	r3, [r3, #12]
    1c1e:	899b      	ldrh	r3, [r3, #12]
    1c20:	b29b      	uxth	r3, r3
    1c22:	4618      	mov	r0, r3
    1c24:	f7ff fffe 	bl	0 <lwip_ntohs>
			1c24: R_ARM_THM_CALL	lwip_ntohs
    1c28:	4603      	mov	r3, r0
    1c2a:	f003 0301 	and.w	r3, r3, #1
    1c2e:	b2db      	uxtb	r3, r3
    1c30:	2b00      	cmp	r3, #0
    1c32:	d00e      	beq.n	1c52 <tcp_receive+0xb46>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags |= TF_GOT_FIN;
    1c34:	4b4d      	ldr	r3, [pc, #308]	; (1d6c <tcp_receive+0xc60>)
    1c36:	781b      	ldrb	r3, [r3, #0]
    1c38:	f043 0320 	orr.w	r3, r3, #32
    1c3c:	b2da      	uxtb	r2, r3
    1c3e:	4b4b      	ldr	r3, [pc, #300]	; (1d6c <tcp_receive+0xc60>)
    1c40:	701a      	strb	r2, [r3, #0]
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
    1c42:	687b      	ldr	r3, [r7, #4]
    1c44:	7e1b      	ldrb	r3, [r3, #24]
    1c46:	2b04      	cmp	r3, #4
    1c48:	d103      	bne.n	1c52 <tcp_receive+0xb46>
              pcb->state = CLOSE_WAIT;
    1c4a:	687b      	ldr	r3, [r7, #4]
    1c4c:	f04f 0207 	mov.w	r2, #7
    1c50:	761a      	strb	r2, [r3, #24]
            } 
          }

          pcb->ooseq = cseg->next;
    1c52:	68bb      	ldr	r3, [r7, #8]
    1c54:	681a      	ldr	r2, [r3, #0]
    1c56:	687b      	ldr	r3, [r7, #4]
    1c58:	675a      	str	r2, [r3, #116]	; 0x74
          tcp_seg_free(cseg);
    1c5a:	68b8      	ldr	r0, [r7, #8]
    1c5c:	f7ff fffe 	bl	0 <tcp_seg_free>
			1c5c: R_ARM_THM_CALL	tcp_seg_free
    1c60:	e000      	b.n	1c64 <tcp_receive+0xb58>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    1c62:	bf00      	nop
    1c64:	687b      	ldr	r3, [r7, #4]
    1c66:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1c68:	2b00      	cmp	r3, #0
    1c6a:	d008      	beq.n	1c7e <tcp_receive+0xb72>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
    1c6c:	687b      	ldr	r3, [r7, #4]
    1c6e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1c70:	68db      	ldr	r3, [r3, #12]
    1c72:	685a      	ldr	r2, [r3, #4]
    1c74:	687b      	ldr	r3, [r7, #4]
    1c76:	6a9b      	ldr	r3, [r3, #40]	; 0x28
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           are now in sequence. */
        while (pcb->ooseq != NULL &&
    1c78:	429a      	cmp	r2, r3
    1c7a:	f43f af6d 	beq.w	1b58 <tcp_receive+0xa4c>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
    1c7e:	687b      	ldr	r3, [r7, #4]
    1c80:	7f9b      	ldrb	r3, [r3, #30]
    1c82:	f003 0301 	and.w	r3, r3, #1
    1c86:	b2db      	uxtb	r3, r3
    1c88:	2b00      	cmp	r3, #0
    1c8a:	d00e      	beq.n	1caa <tcp_receive+0xb9e>
    1c8c:	687b      	ldr	r3, [r7, #4]
    1c8e:	7f9b      	ldrb	r3, [r3, #30]
    1c90:	f023 0301 	bic.w	r3, r3, #1
    1c94:	b2da      	uxtb	r2, r3
    1c96:	687b      	ldr	r3, [r7, #4]
    1c98:	779a      	strb	r2, [r3, #30]
    1c9a:	687b      	ldr	r3, [r7, #4]
    1c9c:	7f9b      	ldrb	r3, [r3, #30]
    1c9e:	f043 0302 	orr.w	r3, r3, #2
    1ca2:	b2da      	uxtb	r2, r3
    1ca4:	687b      	ldr	r3, [r7, #4]
    1ca6:	779a      	strb	r2, [r3, #30]
    1ca8:	e171      	b.n	1f8e <tcp_receive+0xe82>
    1caa:	687b      	ldr	r3, [r7, #4]
    1cac:	7f9b      	ldrb	r3, [r3, #30]
    1cae:	f043 0301 	orr.w	r3, r3, #1
    1cb2:	b2da      	uxtb	r2, r3
    1cb4:	687b      	ldr	r3, [r7, #4]
    1cb6:	779a      	strb	r2, [r3, #30]
    1cb8:	e169      	b.n	1f8e <tcp_receive+0xe82>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
    1cba:	6878      	ldr	r0, [r7, #4]
    1cbc:	f7ff fffe 	bl	0 <tcp_send_empty_ack>
			1cbc: R_ARM_THM_CALL	tcp_send_empty_ack
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
    1cc0:	687b      	ldr	r3, [r7, #4]
    1cc2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1cc4:	2b00      	cmp	r3, #0
    1cc6:	d106      	bne.n	1cd6 <tcp_receive+0xbca>
          pcb->ooseq = tcp_seg_copy(&inseg);
    1cc8:	4829      	ldr	r0, [pc, #164]	; (1d70 <tcp_receive+0xc64>)
    1cca:	f7ff fffe 	bl	0 <tcp_seg_copy>
			1cca: R_ARM_THM_CALL	tcp_seg_copy
    1cce:	4602      	mov	r2, r0
    1cd0:	687b      	ldr	r3, [r7, #4]
    1cd2:	675a      	str	r2, [r3, #116]	; 0x74
    1cd4:	e15b      	b.n	1f8e <tcp_receive+0xe82>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
    1cd6:	f04f 0300 	mov.w	r3, #0
    1cda:	62bb      	str	r3, [r7, #40]	; 0x28
          for(next = pcb->ooseq; next != NULL; next = next->next) {
    1cdc:	687b      	ldr	r3, [r7, #4]
    1cde:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    1ce0:	62fb      	str	r3, [r7, #44]	; 0x2c
    1ce2:	e142      	b.n	1f6a <tcp_receive+0xe5e>
            if (seqno == next->tcphdr->seqno) {
    1ce4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ce6:	68db      	ldr	r3, [r3, #12]
    1ce8:	685a      	ldr	r2, [r3, #4]
    1cea:	4b1e      	ldr	r3, [pc, #120]	; (1d64 <tcp_receive+0xc58>)
    1cec:	681b      	ldr	r3, [r3, #0]
    1cee:	429a      	cmp	r2, r3
    1cf0:	d11d      	bne.n	1d2e <tcp_receive+0xc22>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
    1cf2:	4b1f      	ldr	r3, [pc, #124]	; (1d70 <tcp_receive+0xc64>)
    1cf4:	891a      	ldrh	r2, [r3, #8]
    1cf6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1cf8:	891b      	ldrh	r3, [r3, #8]
    1cfa:	429a      	cmp	r2, r3
    1cfc:	f240 813a 	bls.w	1f74 <tcp_receive+0xe68>
                /* The incoming segment is larger than the old
                   segment. We replace some segments with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
    1d00:	481b      	ldr	r0, [pc, #108]	; (70 <tcp_seg_copy+0x70>)
    1d02:	f7ff fffe 	bl	0 <tcp_seg_copy>
			1d02: R_ARM_THM_CALL	tcp_seg_copy
    1d06:	60b8      	str	r0, [r7, #8]
                if (cseg != NULL) {
    1d08:	68bb      	ldr	r3, [r7, #8]
    1d0a:	2b00      	cmp	r3, #0
    1d0c:	f000 8134 	beq.w	1f78 <tcp_receive+0xe6c>
                  if (prev != NULL) {
    1d10:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d12:	2b00      	cmp	r3, #0
    1d14:	d003      	beq.n	1d1e <tcp_receive+0xc12>
                    prev->next = cseg;
    1d16:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d18:	68ba      	ldr	r2, [r7, #8]
    1d1a:	601a      	str	r2, [r3, #0]
    1d1c:	e002      	b.n	1d24 <tcp_receive+0xc18>
                  } else {
                    pcb->ooseq = cseg;
    1d1e:	687b      	ldr	r3, [r7, #4]
    1d20:	68ba      	ldr	r2, [r7, #8]
    1d22:	675a      	str	r2, [r3, #116]	; 0x74
                  }
                  tcp_oos_insert_segment(cseg, next);
    1d24:	68b8      	ldr	r0, [r7, #8]
    1d26:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    1d28:	f7ff f976 	bl	1018 <tcp_oos_insert_segment>
                }
                break;
    1d2c:	e12f      	b.n	1f8e <tcp_receive+0xe82>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
    1d2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d30:	2b00      	cmp	r3, #0
    1d32:	d11f      	bne.n	1d74 <tcp_receive+0xc68>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
    1d34:	4b0b      	ldr	r3, [pc, #44]	; (1d64 <tcp_receive+0xc58>)
    1d36:	681a      	ldr	r2, [r3, #0]
    1d38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1d3a:	68db      	ldr	r3, [r3, #12]
    1d3c:	685b      	ldr	r3, [r3, #4]
    1d3e:	1ad3      	subs	r3, r2, r3
    1d40:	2b00      	cmp	r3, #0
    1d42:	da59      	bge.n	1df8 <tcp_receive+0xcec>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */
                  cseg = tcp_seg_copy(&inseg);
    1d44:	480a      	ldr	r0, [pc, #40]	; (1d70 <tcp_receive+0xc64>)
    1d46:	f7ff fffe 	bl	0 <tcp_seg_copy>
			1d46: R_ARM_THM_CALL	tcp_seg_copy
    1d4a:	60b8      	str	r0, [r7, #8]
                  if (cseg != NULL) {
    1d4c:	68bb      	ldr	r3, [r7, #8]
    1d4e:	2b00      	cmp	r3, #0
    1d50:	f000 8114 	beq.w	1f7c <tcp_receive+0xe70>
                    pcb->ooseq = cseg;
    1d54:	687b      	ldr	r3, [r7, #4]
    1d56:	68ba      	ldr	r2, [r7, #8]
    1d58:	675a      	str	r2, [r3, #116]	; 0x74
                    tcp_oos_insert_segment(cseg, next);
    1d5a:	68b8      	ldr	r0, [r7, #8]
    1d5c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    1d5e:	f7ff f95b 	bl	1018 <tcp_oos_insert_segment>
                  }
                  break;
    1d62:	e114      	b.n	22c <tcp_input+0x22c>
    1d64:	00000018 	.word	0x00000018
			1d64: R_ARM_ABS32	.bss
    1d68:	00000028 	.word	0x00000028
			1d68: R_ARM_ABS32	.bss
    1d6c:	00000024 	.word	0x00000024
			1d6c: R_ARM_ABS32	.bss
    1d70:	00000000 	.word	0x00000000
			1d70: R_ARM_ABS32	.bss
                }
              } else {
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
    1d74:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d76:	68db      	ldr	r3, [r3, #12]
    1d78:	685b      	ldr	r3, [r3, #4]
    1d7a:	ea6f 0203 	mvn.w	r2, r3
    1d7e:	4b87      	ldr	r3, [pc, #540]	; (1f9c <tcp_receive+0xe90>)
    1d80:	681b      	ldr	r3, [r3, #0]
    1d82:	18d3      	adds	r3, r2, r3
    1d84:	2b00      	cmp	r3, #0
    1d86:	db37      	blt.n	1df8 <tcp_receive+0xcec>
    1d88:	4b84      	ldr	r3, [pc, #528]	; (1f9c <tcp_receive+0xe90>)
    1d8a:	681a      	ldr	r2, [r3, #0]
    1d8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1d8e:	68db      	ldr	r3, [r3, #12]
    1d90:	685b      	ldr	r3, [r3, #4]
    1d92:	1ad3      	subs	r3, r2, r3
    1d94:	f103 0301 	add.w	r3, r3, #1
    1d98:	2b00      	cmp	r3, #0
    1d9a:	dc2d      	bgt.n	1df8 <tcp_receive+0xcec>
                  /* The sequence number of the incoming segment is in
                     between the sequence numbers of the previous and
                     the next segment on ->ooseq. We trim trim the previous
                     segment, delete next segments that included in received segment
                     and trim received, if needed. */
                  cseg = tcp_seg_copy(&inseg);
    1d9c:	4880      	ldr	r0, [pc, #512]	; (1fa0 <tcp_receive+0xe94>)
    1d9e:	f7ff fffe 	bl	0 <tcp_seg_copy>
			1d9e: R_ARM_THM_CALL	tcp_seg_copy
    1da2:	60b8      	str	r0, [r7, #8]
                  if (cseg != NULL) {
    1da4:	68bb      	ldr	r3, [r7, #8]
    1da6:	2b00      	cmp	r3, #0
    1da8:	f000 80ea 	beq.w	1f80 <tcp_receive+0xe74>
                    if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
    1dac:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dae:	68db      	ldr	r3, [r3, #12]
    1db0:	685a      	ldr	r2, [r3, #4]
    1db2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1db4:	891b      	ldrh	r3, [r3, #8]
    1db6:	18d2      	adds	r2, r2, r3
    1db8:	4b78      	ldr	r3, [pc, #480]	; (1f9c <tcp_receive+0xe90>)
    1dba:	681b      	ldr	r3, [r3, #0]
    1dbc:	1ad3      	subs	r3, r2, r3
    1dbe:	2b00      	cmp	r3, #0
    1dc0:	dd12      	ble.n	1de8 <tcp_receive+0xcdc>
                      /* We need to trim the prev segment. */
                      prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
    1dc2:	4b76      	ldr	r3, [pc, #472]	; (1f9c <tcp_receive+0xe90>)
    1dc4:	681b      	ldr	r3, [r3, #0]
    1dc6:	b29a      	uxth	r2, r3
    1dc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dca:	68db      	ldr	r3, [r3, #12]
    1dcc:	685b      	ldr	r3, [r3, #4]
    1dce:	b29b      	uxth	r3, r3
    1dd0:	1ad3      	subs	r3, r2, r3
    1dd2:	b29a      	uxth	r2, r3
    1dd4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dd6:	811a      	strh	r2, [r3, #8]
                      pbuf_realloc(prev->p, prev->len);
    1dd8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dda:	685a      	ldr	r2, [r3, #4]
    1ddc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dde:	891b      	ldrh	r3, [r3, #8]
    1de0:	4610      	mov	r0, r2
    1de2:	4619      	mov	r1, r3
    1de4:	f7ff fffe 	bl	0 <pbuf_realloc>
			1de4: R_ARM_THM_CALL	pbuf_realloc
                    }
                    prev->next = cseg;
    1de8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dea:	68ba      	ldr	r2, [r7, #8]
    1dec:	601a      	str	r2, [r3, #0]
                    tcp_oos_insert_segment(cseg, next);
    1dee:	68b8      	ldr	r0, [r7, #8]
    1df0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    1df2:	f7ff f911 	bl	1018 <tcp_oos_insert_segment>
                  }
                  break;
    1df6:	e0ca      	b.n	1f8e <tcp_receive+0xe82>
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    1df8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1dfa:	681b      	ldr	r3, [r3, #0]
    1dfc:	2b00      	cmp	r3, #0
    1dfe:	f040 80af 	bne.w	1f60 <tcp_receive+0xe54>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
    1e02:	4b66      	ldr	r3, [pc, #408]	; (1f9c <tcp_receive+0xe90>)
    1e04:	681a      	ldr	r2, [r3, #0]
    1e06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e08:	68db      	ldr	r3, [r3, #12]
    1e0a:	685b      	ldr	r3, [r3, #4]
    1e0c:	1ad3      	subs	r3, r2, r3
                }
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
    1e0e:	2b00      	cmp	r3, #0
    1e10:	f340 80a6 	ble.w	1f60 <tcp_receive+0xe54>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
    1e14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e16:	68db      	ldr	r3, [r3, #12]
    1e18:	899b      	ldrh	r3, [r3, #12]
    1e1a:	b29b      	uxth	r3, r3
    1e1c:	4618      	mov	r0, r3
    1e1e:	f7ff fffe 	bl	0 <lwip_ntohs>
			1e1e: R_ARM_THM_CALL	lwip_ntohs
    1e22:	4603      	mov	r3, r0
    1e24:	f003 0301 	and.w	r3, r3, #1
    1e28:	b2db      	uxtb	r3, r3
    1e2a:	2b00      	cmp	r3, #0
    1e2c:	f040 80aa 	bne.w	1f84 <tcp_receive+0xe78>
                  /* segment "next" already contains all data */
                  break;
                }
                next->next = tcp_seg_copy(&inseg);
    1e30:	485b      	ldr	r0, [pc, #364]	; (170 <tcp_seg_copy+0x170>)
    1e32:	f7ff fffe 	bl	0 <tcp_seg_copy>
			1e32: R_ARM_THM_CALL	tcp_seg_copy
    1e36:	4602      	mov	r2, r0
    1e38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e3a:	601a      	str	r2, [r3, #0]
                if (next->next != NULL) {
    1e3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e3e:	681b      	ldr	r3, [r3, #0]
    1e40:	2b00      	cmp	r3, #0
    1e42:	f000 80a1 	beq.w	1f88 <tcp_receive+0xe7c>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
    1e46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e48:	68db      	ldr	r3, [r3, #12]
    1e4a:	685a      	ldr	r2, [r3, #4]
    1e4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e4e:	891b      	ldrh	r3, [r3, #8]
    1e50:	18d2      	adds	r2, r2, r3
    1e52:	4b52      	ldr	r3, [pc, #328]	; (1f9c <tcp_receive+0xe90>)
    1e54:	681b      	ldr	r3, [r3, #0]
    1e56:	1ad3      	subs	r3, r2, r3
    1e58:	2b00      	cmp	r3, #0
    1e5a:	dd12      	ble.n	1e82 <tcp_receive+0xd76>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
    1e5c:	4b4f      	ldr	r3, [pc, #316]	; (1f9c <tcp_receive+0xe90>)
    1e5e:	681b      	ldr	r3, [r3, #0]
    1e60:	b29a      	uxth	r2, r3
    1e62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e64:	68db      	ldr	r3, [r3, #12]
    1e66:	685b      	ldr	r3, [r3, #4]
    1e68:	b29b      	uxth	r3, r3
    1e6a:	1ad3      	subs	r3, r2, r3
    1e6c:	b29a      	uxth	r2, r3
    1e6e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e70:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->p, next->len);
    1e72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e74:	685a      	ldr	r2, [r3, #4]
    1e76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e78:	891b      	ldrh	r3, [r3, #8]
    1e7a:	4610      	mov	r0, r2
    1e7c:	4619      	mov	r1, r3
    1e7e:	f7ff fffe 	bl	0 <pbuf_realloc>
			1e7e: R_ARM_THM_CALL	pbuf_realloc
                  }
                  /* check if the remote side overruns our receive window */
                  if ((u32_t)tcplen + seqno > pcb->rcv_nxt + (u32_t)pcb->rcv_wnd) {
    1e82:	4b48      	ldr	r3, [pc, #288]	; (1fa4 <tcp_receive+0xe98>)
    1e84:	881b      	ldrh	r3, [r3, #0]
    1e86:	461a      	mov	r2, r3
    1e88:	4b44      	ldr	r3, [pc, #272]	; (1f9c <tcp_receive+0xe90>)
    1e8a:	681b      	ldr	r3, [r3, #0]
    1e8c:	18d2      	adds	r2, r2, r3
    1e8e:	687b      	ldr	r3, [r7, #4]
    1e90:	6a99      	ldr	r1, [r3, #40]	; 0x28
    1e92:	687b      	ldr	r3, [r7, #4]
    1e94:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    1e96:	18cb      	adds	r3, r1, r3
    1e98:	429a      	cmp	r2, r3
    1e9a:	d977      	bls.n	1f8c <tcp_receive+0xe80>
                    LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                                ("tcp_receive: other end overran receive window"
                                 "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                                 seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
                    if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
    1e9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1e9e:	681b      	ldr	r3, [r3, #0]
    1ea0:	68db      	ldr	r3, [r3, #12]
    1ea2:	899b      	ldrh	r3, [r3, #12]
    1ea4:	b29b      	uxth	r3, r3
    1ea6:	4618      	mov	r0, r3
    1ea8:	f7ff fffe 	bl	0 <lwip_ntohs>
			1ea8: R_ARM_THM_CALL	lwip_ntohs
    1eac:	4603      	mov	r3, r0
    1eae:	f003 0301 	and.w	r3, r3, #1
    1eb2:	b2db      	uxtb	r3, r3
    1eb4:	2b00      	cmp	r3, #0
    1eb6:	d022      	beq.n	1efe <tcp_receive+0xdf2>
                      /* Must remove the FIN from the header as we're trimming 
                       * that byte of sequence-space from the packet */
                      TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) &~ TCP_FIN);
    1eb8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1eba:	681b      	ldr	r3, [r3, #0]
    1ebc:	68dc      	ldr	r4, [r3, #12]
    1ebe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ec0:	681b      	ldr	r3, [r3, #0]
    1ec2:	68db      	ldr	r3, [r3, #12]
    1ec4:	899b      	ldrh	r3, [r3, #12]
    1ec6:	b29b      	uxth	r3, r3
    1ec8:	b29b      	uxth	r3, r3
    1eca:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    1ece:	b29d      	uxth	r5, r3
    1ed0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1ed2:	681b      	ldr	r3, [r3, #0]
    1ed4:	68db      	ldr	r3, [r3, #12]
    1ed6:	899b      	ldrh	r3, [r3, #12]
    1ed8:	b29b      	uxth	r3, r3
    1eda:	4618      	mov	r0, r3
    1edc:	f7ff fffe 	bl	0 <lwip_ntohs>
			1edc: R_ARM_THM_CALL	lwip_ntohs
    1ee0:	4603      	mov	r3, r0
    1ee2:	f003 033e 	and.w	r3, r3, #62	; 0x3e
    1ee6:	b29b      	uxth	r3, r3
    1ee8:	4618      	mov	r0, r3
    1eea:	f7ff fffe 	bl	0 <lwip_htons>
			1eea: R_ARM_THM_CALL	lwip_htons
    1eee:	4603      	mov	r3, r0
    1ef0:	b29b      	uxth	r3, r3
    1ef2:	462a      	mov	r2, r5
    1ef4:	ea42 0303 	orr.w	r3, r2, r3
    1ef8:	b29b      	uxth	r3, r3
    1efa:	b29b      	uxth	r3, r3
    1efc:	81a3      	strh	r3, [r4, #12]
                    }
                    /* Adjust length of segment to fit in the window. */
                    next->next->len = pcb->rcv_nxt + pcb->rcv_wnd - seqno;
    1efe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f00:	681b      	ldr	r3, [r3, #0]
    1f02:	687a      	ldr	r2, [r7, #4]
    1f04:	6a92      	ldr	r2, [r2, #40]	; 0x28
    1f06:	b291      	uxth	r1, r2
    1f08:	687a      	ldr	r2, [r7, #4]
    1f0a:	8d92      	ldrh	r2, [r2, #44]	; 0x2c
    1f0c:	188a      	adds	r2, r1, r2
    1f0e:	b291      	uxth	r1, r2
    1f10:	4a22      	ldr	r2, [pc, #136]	; (1f9c <tcp_receive+0xe90>)
    1f12:	6812      	ldr	r2, [r2, #0]
    1f14:	b292      	uxth	r2, r2
    1f16:	1a8a      	subs	r2, r1, r2
    1f18:	b292      	uxth	r2, r2
    1f1a:	811a      	strh	r2, [r3, #8]
                    pbuf_realloc(next->next->p, next->next->len);
    1f1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f1e:	681b      	ldr	r3, [r3, #0]
    1f20:	685a      	ldr	r2, [r3, #4]
    1f22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f24:	681b      	ldr	r3, [r3, #0]
    1f26:	891b      	ldrh	r3, [r3, #8]
    1f28:	4610      	mov	r0, r2
    1f2a:	4619      	mov	r1, r3
    1f2c:	f7ff fffe 	bl	0 <pbuf_realloc>
			1f2c: R_ARM_THM_CALL	pbuf_realloc
                    tcplen = TCP_TCPLEN(next->next);
    1f30:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f32:	681b      	ldr	r3, [r3, #0]
    1f34:	891c      	ldrh	r4, [r3, #8]
    1f36:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f38:	681b      	ldr	r3, [r3, #0]
    1f3a:	68db      	ldr	r3, [r3, #12]
    1f3c:	899b      	ldrh	r3, [r3, #12]
    1f3e:	b29b      	uxth	r3, r3
    1f40:	4618      	mov	r0, r3
    1f42:	f7ff fffe 	bl	0 <lwip_ntohs>
			1f42: R_ARM_THM_CALL	lwip_ntohs
    1f46:	4603      	mov	r3, r0
    1f48:	f003 0303 	and.w	r3, r3, #3
    1f4c:	2b00      	cmp	r3, #0
    1f4e:	bf0c      	ite	eq
    1f50:	2300      	moveq	r3, #0
    1f52:	2301      	movne	r3, #1
    1f54:	b29b      	uxth	r3, r3
    1f56:	18e3      	adds	r3, r4, r3
    1f58:	b29a      	uxth	r2, r3
    1f5a:	4b12      	ldr	r3, [pc, #72]	; (1fa4 <tcp_receive+0xe98>)
    1f5c:	801a      	strh	r2, [r3, #0]
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
    1f5e:	e016      	b.n	1f8e <tcp_receive+0xe82>
              }
            }
            prev = next;
    1f60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f62:	62bb      	str	r3, [r7, #40]	; 0x28
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
    1f64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f66:	681b      	ldr	r3, [r3, #0]
    1f68:	62fb      	str	r3, [r7, #44]	; 0x2c
    1f6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f6c:	2b00      	cmp	r3, #0
    1f6e:	f47f aeb9 	bne.w	1ce4 <tcp_receive+0xbd8>
    1f72:	e00c      	b.n	1f8e <tcp_receive+0xe82>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
    1f74:	bf00      	nop
    1f76:	e00a      	b.n	1f8e <tcp_receive+0xe82>
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_oos_insert_segment(cseg, next);
                }
                break;
    1f78:	bf00      	nop
    1f7a:	e008      	b.n	1f8e <tcp_receive+0xe82>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    pcb->ooseq = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
    1f7c:	bf00      	nop
    1f7e:	e006      	b.n	1f8e <tcp_receive+0xe82>
                      pbuf_realloc(prev->p, prev->len);
                    }
                    prev->next = cseg;
                    tcp_oos_insert_segment(cseg, next);
                  }
                  break;
    1f80:	bf00      	nop
    1f82:	e004      	b.n	1f8e <tcp_receive+0xe82>
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
                  /* segment "next" already contains all data */
                  break;
    1f84:	bf00      	nop
    1f86:	e002      	b.n	1f8e <tcp_receive+0xe82>
                    tcplen = TCP_TCPLEN(next->next);
                    LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
                                (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
                  }
                }
                break;
    1f88:	bf00      	nop
    1f8a:	e000      	b.n	1f8e <tcp_receive+0xe82>
    1f8c:	bf00      	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
    1f8e:	bf00      	nop
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    1f90:	e024      	b.n	1fdc <tcp_receive+0xed0>
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
#endif /* TCP_QUEUE_OOSEQ */
      }
    } else {
      /* The incoming segment is not withing the window. */
      tcp_send_empty_ack(pcb);
    1f92:	6878      	ldr	r0, [r7, #4]
    1f94:	f7ff fffe 	bl	0 <tcp_send_empty_ack>
			1f94: R_ARM_THM_CALL	tcp_send_empty_ack
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
    1f98:	e020      	b.n	1fdc <tcp_receive+0xed0>
    1f9a:	bf00      	nop
    1f9c:	00000018 	.word	0x00000018
			1f9c: R_ARM_ABS32	.bss
    1fa0:	00000000 	.word	0x00000000
			1fa0: R_ARM_ABS32	.bss
    1fa4:	00000022 	.word	0x00000022
			1fa4: R_ARM_ABS32	.bss
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
    1fa8:	4b0e      	ldr	r3, [pc, #56]	; (1fe4 <tcp_receive+0xed8>)
    1faa:	681a      	ldr	r2, [r3, #0]
    1fac:	687b      	ldr	r3, [r7, #4]
    1fae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    1fb0:	1ad3      	subs	r3, r2, r3
    1fb2:	2b00      	cmp	r3, #0
    1fb4:	db0b      	blt.n	1fce <tcp_receive+0xec2>
    1fb6:	4b0b      	ldr	r3, [pc, #44]	; (1fe4 <tcp_receive+0xed8>)
    1fb8:	681a      	ldr	r2, [r3, #0]
    1fba:	687b      	ldr	r3, [r7, #4]
    1fbc:	6a99      	ldr	r1, [r3, #40]	; 0x28
    1fbe:	687b      	ldr	r3, [r7, #4]
    1fc0:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    1fc2:	18cb      	adds	r3, r1, r3
    1fc4:	1ad3      	subs	r3, r2, r3
    1fc6:	f103 0301 	add.w	r3, r3, #1
    1fca:	2b00      	cmp	r3, #0
    1fcc:	dd06      	ble.n	1fdc <tcp_receive+0xed0>
      tcp_ack_now(pcb);
    1fce:	687b      	ldr	r3, [r7, #4]
    1fd0:	7f9b      	ldrb	r3, [r3, #30]
    1fd2:	f043 0302 	orr.w	r3, r3, #2
    1fd6:	b2da      	uxtb	r2, r3
    1fd8:	687b      	ldr	r3, [r7, #4]
    1fda:	779a      	strb	r2, [r3, #30]
    }
  }
}
    1fdc:	f107 0734 	add.w	r7, r7, #52	; 0x34
    1fe0:	46bd      	mov	sp, r7
    1fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1fe4:	00000018 	.word	0x00000018
			1fe4: R_ARM_ABS32	.bss

00001fe8 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
    1fe8:	b580      	push	{r7, lr}
    1fea:	b086      	sub	sp, #24
    1fec:	af00      	add	r7, sp, #0
    1fee:	6078      	str	r0, [r7, #4]
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
    1ff0:	4b47      	ldr	r3, [pc, #284]	; (2110 <tcp_parseopt+0x128>)
    1ff2:	681b      	ldr	r3, [r3, #0]
    1ff4:	f103 0314 	add.w	r3, r3, #20
    1ff8:	613b      	str	r3, [r7, #16]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    1ffa:	4b45      	ldr	r3, [pc, #276]	; (2110 <tcp_parseopt+0x128>)
    1ffc:	681b      	ldr	r3, [r3, #0]
    1ffe:	899b      	ldrh	r3, [r3, #12]
    2000:	b29b      	uxth	r3, r3
    2002:	4618      	mov	r0, r3
    2004:	f7ff fffe 	bl	0 <lwip_ntohs>
			2004: R_ARM_THM_CALL	lwip_ntohs
    2008:	4603      	mov	r3, r0
    200a:	ea4f 3313 	mov.w	r3, r3, lsr #12
    200e:	b29b      	uxth	r3, r3
    2010:	2b05      	cmp	r3, #5
    2012:	d978      	bls.n	2106 <tcp_parseopt+0x11e>
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    2014:	4b3e      	ldr	r3, [pc, #248]	; (2110 <tcp_parseopt+0x128>)
    2016:	681b      	ldr	r3, [r3, #0]
    2018:	899b      	ldrh	r3, [r3, #12]
    201a:	b29b      	uxth	r3, r3
    201c:	4618      	mov	r0, r3
    201e:	f7ff fffe 	bl	0 <lwip_ntohs>
			201e: R_ARM_THM_CALL	lwip_ntohs
    2022:	4603      	mov	r3, r0
    2024:	ea4f 3313 	mov.w	r3, r3, lsr #12
    2028:	b29b      	uxth	r3, r3
    202a:	f1a3 0305 	sub.w	r3, r3, #5
    202e:	b29b      	uxth	r3, r3
    2030:	ea4f 0383 	mov.w	r3, r3, lsl #2
    2034:	81fb      	strh	r3, [r7, #14]
    for (c = 0; c < max_c; ) {
    2036:	f04f 0300 	mov.w	r3, #0
    203a:	82fb      	strh	r3, [r7, #22]
    203c:	e057      	b.n	20ee <tcp_parseopt+0x106>
      opt = opts[c];
    203e:	8afb      	ldrh	r3, [r7, #22]
    2040:	693a      	ldr	r2, [r7, #16]
    2042:	18d3      	adds	r3, r2, r3
    2044:	781b      	ldrb	r3, [r3, #0]
    2046:	737b      	strb	r3, [r7, #13]
      switch (opt) {
    2048:	7b7b      	ldrb	r3, [r7, #13]
    204a:	2b01      	cmp	r3, #1
    204c:	d004      	beq.n	2058 <tcp_parseopt+0x70>
    204e:	2b02      	cmp	r3, #2
    2050:	d007      	beq.n	2062 <tcp_parseopt+0x7a>
    2052:	2b00      	cmp	r3, #0
    2054:	d050      	beq.n	20f8 <tcp_parseopt+0x110>
    2056:	e038      	b.n	20ca <tcp_parseopt+0xe2>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
    2058:	8afb      	ldrh	r3, [r7, #22]
    205a:	f103 0301 	add.w	r3, r3, #1
    205e:	82fb      	strh	r3, [r7, #22]
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
    2060:	e045      	b.n	20ee <tcp_parseopt+0x106>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
    2062:	8afb      	ldrh	r3, [r7, #22]
    2064:	f103 0301 	add.w	r3, r3, #1
    2068:	693a      	ldr	r2, [r7, #16]
    206a:	18d3      	adds	r3, r2, r3
    206c:	781b      	ldrb	r3, [r3, #0]
    206e:	2b04      	cmp	r3, #4
    2070:	d144      	bne.n	20fc <tcp_parseopt+0x114>
    2072:	8afb      	ldrh	r3, [r7, #22]
    2074:	f103 0204 	add.w	r2, r3, #4
    2078:	89fb      	ldrh	r3, [r7, #14]
    207a:	429a      	cmp	r2, r3
    207c:	dc40      	bgt.n	2100 <tcp_parseopt+0x118>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
    207e:	8afb      	ldrh	r3, [r7, #22]
    2080:	f103 0302 	add.w	r3, r3, #2
    2084:	693a      	ldr	r2, [r7, #16]
    2086:	18d3      	adds	r3, r2, r3
    2088:	781b      	ldrb	r3, [r3, #0]
    208a:	ea4f 2303 	mov.w	r3, r3, lsl #8
    208e:	b29a      	uxth	r2, r3
    2090:	8afb      	ldrh	r3, [r7, #22]
    2092:	f103 0303 	add.w	r3, r3, #3
    2096:	6939      	ldr	r1, [r7, #16]
    2098:	18cb      	adds	r3, r1, r3
    209a:	781b      	ldrb	r3, [r3, #0]
    209c:	ea42 0303 	orr.w	r3, r2, r3
    20a0:	b29b      	uxth	r3, r3
    20a2:	817b      	strh	r3, [r7, #10]
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
    20a4:	897a      	ldrh	r2, [r7, #10]
    20a6:	f240 53dc 	movw	r3, #1500	; 0x5dc
    20aa:	429a      	cmp	r2, r3
    20ac:	d804      	bhi.n	20b8 <tcp_parseopt+0xd0>
    20ae:	897b      	ldrh	r3, [r7, #10]
    20b0:	2b00      	cmp	r3, #0
    20b2:	d001      	beq.n	20b8 <tcp_parseopt+0xd0>
    20b4:	897b      	ldrh	r3, [r7, #10]
    20b6:	e001      	b.n	20bc <tcp_parseopt+0xd4>
    20b8:	f240 53dc 	movw	r3, #1500	; 0x5dc
    20bc:	687a      	ldr	r2, [r7, #4]
    20be:	86d3      	strh	r3, [r2, #54]	; 0x36
        /* Advance to next option */
        c += 0x04;
    20c0:	8afb      	ldrh	r3, [r7, #22]
    20c2:	f103 0304 	add.w	r3, r3, #4
    20c6:	82fb      	strh	r3, [r7, #22]
        break;
    20c8:	e011      	b.n	20ee <tcp_parseopt+0x106>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
    20ca:	8afb      	ldrh	r3, [r7, #22]
    20cc:	f103 0301 	add.w	r3, r3, #1
    20d0:	693a      	ldr	r2, [r7, #16]
    20d2:	18d3      	adds	r3, r2, r3
    20d4:	781b      	ldrb	r3, [r3, #0]
    20d6:	2b00      	cmp	r3, #0
    20d8:	d014      	beq.n	2104 <tcp_parseopt+0x11c>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
    20da:	8afb      	ldrh	r3, [r7, #22]
    20dc:	f103 0301 	add.w	r3, r3, #1
    20e0:	693a      	ldr	r2, [r7, #16]
    20e2:	18d3      	adds	r3, r2, r3
    20e4:	781b      	ldrb	r3, [r3, #0]
    20e6:	461a      	mov	r2, r3
    20e8:	8afb      	ldrh	r3, [r7, #22]
    20ea:	18d3      	adds	r3, r2, r3
    20ec:	82fb      	strh	r3, [r7, #22]
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
    20ee:	8afa      	ldrh	r2, [r7, #22]
    20f0:	89fb      	ldrh	r3, [r7, #14]
    20f2:	429a      	cmp	r2, r3
    20f4:	d3a3      	bcc.n	203e <tcp_parseopt+0x56>
    20f6:	e006      	b.n	2106 <tcp_parseopt+0x11e>
      opt = opts[c];
      switch (opt) {
      case 0x00:
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
    20f8:	bf00      	nop
    20fa:	e004      	b.n	2106 <tcp_parseopt+0x11e>
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
    20fc:	bf00      	nop
    20fe:	e002      	b.n	2106 <tcp_parseopt+0x11e>
    2100:	bf00      	nop
    2102:	e000      	b.n	2106 <tcp_parseopt+0x11e>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          return;
    2104:	bf00      	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
    2106:	f107 0718 	add.w	r7, r7, #24
    210a:	46bd      	mov	sp, r7
    210c:	bd80      	pop	{r7, pc}
    210e:	bf00      	nop
    2110:	00000010 	.word	0x00000010
			2110: R_ARM_ABS32	.bss

tcp_out.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  66716 Jul 30 19:07 2021 tcp_out.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012e8  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000131c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000131c  2**0
                  ALLOC
  3 .debug_abbrev 0000023c  00000000  00000000  0000131c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000118b  00000000  00000000  00001558  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000086c  00000000  00000000  000026e3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000ac2f  00000000  00000000  00002f4f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000382  00000000  00000000  0000db7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000db  00000000  00000000  0000df00  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000001b1  00000000  00000000  0000dfdb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000e18c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_ranges 00000060  00000000  00000000  0000e1ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000838  00000000  00000000  0000e20c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0000ea44  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000ea6f  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00000218  00000000  00000000  0000eaa0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 tcp_out.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     F .text	000000e6 tcp_output_alloc_header
00000170 l     F .text	00000128 tcp_create_segment
00000298 l     F .text	000000ae tcp_pbuf_prealloc
00000348 l     F .text	000000b4 tcp_write_checks
00000d88 l     F .text	00000164 tcp_output_segment
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 lwip_htonl
000000e8 g     F .text	00000088 tcp_send_fin
00000000         *UND*	00000000 lwip_ntohs
0000089c g     F .text	000001ae tcp_enqueue_flags
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 tcp_seg_free
000003fc g     F .text	0000049e tcp_write
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 pbuf_clen
00000000         *UND*	00000000 pbuf_cat
00000000         *UND*	00000000 tcp_segs_free
00000a4c g     F .text	00000080 tcp_send_empty_ack
00000000         *UND*	00000000 ip_output
00000acc g     F .text	000002bc tcp_output
00000000         *UND*	00000000 lwip_ntohl
00000000         *UND*	00000000 tcp_input_pcb
00000000         *UND*	00000000 tcp_eff_send_mss
00000000         *UND*	00000000 ip_route
00000000         *UND*	00000000 tcp_ticks
00000eec g     F .text	000000d2 tcp_rst
00000fc0 g     F .text	0000006a tcp_rexmit_rto
0000102c g     F .text	000000a0 tcp_rexmit
000010cc g     F .text	000000b0 tcp_rexmit_fast
0000117c g     F .text	00000064 tcp_keepalive
000011e0 g     F .text	00000106 tcp_zero_window_probe
00000000         *UND*	00000000 pbuf_copy_partial



Disassembly of section .text:

00000000 <tcp_output_alloc_header>:
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
       0:	b580      	push	{r7, lr}
       2:	b086      	sub	sp, #24
       4:	af00      	add	r7, sp, #0
       6:	60f8      	str	r0, [r7, #12]
       8:	607b      	str	r3, [r7, #4]
       a:	460b      	mov	r3, r1
       c:	817b      	strh	r3, [r7, #10]
       e:	4613      	mov	r3, r2
      10:	813b      	strh	r3, [r7, #8]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
      12:	897a      	ldrh	r2, [r7, #10]
      14:	893b      	ldrh	r3, [r7, #8]
      16:	18d3      	adds	r3, r2, r3
      18:	b29b      	uxth	r3, r3
      1a:	f103 0314 	add.w	r3, r3, #20
      1e:	b29b      	uxth	r3, r3
      20:	f04f 0001 	mov.w	r0, #1
      24:	4619      	mov	r1, r3
      26:	f04f 0200 	mov.w	r2, #0
      2a:	f7ff fffe 	bl	0 <pbuf_alloc>
			2a: R_ARM_THM_CALL	pbuf_alloc
      2e:	6178      	str	r0, [r7, #20]
  if (p != NULL) {
      30:	697b      	ldr	r3, [r7, #20]
      32:	2b00      	cmp	r3, #0
      34:	d051      	beq.n	da <tcp_output_alloc_header+0xda>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
      36:	697b      	ldr	r3, [r7, #20]
      38:	685b      	ldr	r3, [r3, #4]
      3a:	613b      	str	r3, [r7, #16]
    tcphdr->src = htons(pcb->local_port);
      3c:	68fb      	ldr	r3, [r7, #12]
      3e:	8b5b      	ldrh	r3, [r3, #26]
      40:	4618      	mov	r0, r3
      42:	f7ff fffe 	bl	0 <lwip_htons>
			42: R_ARM_THM_CALL	lwip_htons
      46:	4603      	mov	r3, r0
      48:	461a      	mov	r2, r3
      4a:	693b      	ldr	r3, [r7, #16]
      4c:	801a      	strh	r2, [r3, #0]
    tcphdr->dest = htons(pcb->remote_port);
      4e:	68fb      	ldr	r3, [r7, #12]
      50:	8b9b      	ldrh	r3, [r3, #28]
      52:	4618      	mov	r0, r3
      54:	f7ff fffe 	bl	0 <lwip_htons>
			54: R_ARM_THM_CALL	lwip_htons
      58:	4603      	mov	r3, r0
      5a:	461a      	mov	r2, r3
      5c:	693b      	ldr	r3, [r7, #16]
      5e:	805a      	strh	r2, [r3, #2]
    tcphdr->seqno = seqno_be;
      60:	693b      	ldr	r3, [r7, #16]
      62:	687a      	ldr	r2, [r7, #4]
      64:	605a      	str	r2, [r3, #4]
    tcphdr->ackno = htonl(pcb->rcv_nxt);
      66:	68fb      	ldr	r3, [r7, #12]
      68:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      6a:	4618      	mov	r0, r3
      6c:	f7ff fffe 	bl	0 <lwip_htonl>
			6c: R_ARM_THM_CALL	lwip_htonl
      70:	4602      	mov	r2, r0
      72:	693b      	ldr	r3, [r7, #16]
      74:	609a      	str	r2, [r3, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
      76:	897b      	ldrh	r3, [r7, #10]
      78:	ea4f 0393 	mov.w	r3, r3, lsr #2
      7c:	b29b      	uxth	r3, r3
      7e:	f103 0305 	add.w	r3, r3, #5
      82:	b29b      	uxth	r3, r3
      84:	ea4f 3303 	mov.w	r3, r3, lsl #12
      88:	b29b      	uxth	r3, r3
      8a:	f043 0310 	orr.w	r3, r3, #16
      8e:	b29b      	uxth	r3, r3
      90:	4618      	mov	r0, r3
      92:	f7ff fffe 	bl	0 <lwip_htons>
			92: R_ARM_THM_CALL	lwip_htons
      96:	4603      	mov	r3, r0
      98:	461a      	mov	r2, r3
      9a:	693b      	ldr	r3, [r7, #16]
      9c:	819a      	strh	r2, [r3, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
      9e:	68fb      	ldr	r3, [r7, #12]
      a0:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
      a2:	4618      	mov	r0, r3
      a4:	f7ff fffe 	bl	0 <lwip_htons>
			a4: R_ARM_THM_CALL	lwip_htons
      a8:	4603      	mov	r3, r0
      aa:	461a      	mov	r2, r3
      ac:	693b      	ldr	r3, [r7, #16]
      ae:	81da      	strh	r2, [r3, #14]
    tcphdr->chksum = 0;
      b0:	693b      	ldr	r3, [r7, #16]
      b2:	f04f 0200 	mov.w	r2, #0
      b6:	741a      	strb	r2, [r3, #16]
      b8:	f04f 0200 	mov.w	r2, #0
      bc:	745a      	strb	r2, [r3, #17]
    tcphdr->urgp = 0;
      be:	693b      	ldr	r3, [r7, #16]
      c0:	f04f 0200 	mov.w	r2, #0
      c4:	749a      	strb	r2, [r3, #18]
      c6:	f04f 0200 	mov.w	r2, #0
      ca:	74da      	strb	r2, [r3, #19]

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
      cc:	68fb      	ldr	r3, [r7, #12]
      ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
      d0:	68fb      	ldr	r3, [r7, #12]
      d2:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
      d4:	18d2      	adds	r2, r2, r3
      d6:	68fb      	ldr	r3, [r7, #12]
      d8:	631a      	str	r2, [r3, #48]	; 0x30
  }
  return p;
      da:	697b      	ldr	r3, [r7, #20]
}
      dc:	4618      	mov	r0, r3
      de:	f107 0718 	add.w	r7, r7, #24
      e2:	46bd      	mov	sp, r7
      e4:	bd80      	pop	{r7, pc}
      e6:	bf00      	nop

000000e8 <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
      e8:	b5b0      	push	{r4, r5, r7, lr}
      ea:	b084      	sub	sp, #16
      ec:	af00      	add	r7, sp, #0
      ee:	6078      	str	r0, [r7, #4]
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
      f0:	687b      	ldr	r3, [r7, #4]
      f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
      f4:	2b00      	cmp	r3, #0
      f6:	d02f      	beq.n	158 <tcp_send_fin+0x70>
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
      f8:	687b      	ldr	r3, [r7, #4]
      fa:	6edb      	ldr	r3, [r3, #108]	; 0x6c
      fc:	60fb      	str	r3, [r7, #12]
      fe:	e002      	b.n	106 <tcp_send_fin+0x1e>
         last_unsent = last_unsent->next);
     100:	68fb      	ldr	r3, [r7, #12]
     102:	681b      	ldr	r3, [r3, #0]
     104:	60fb      	str	r3, [r7, #12]
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
     106:	68fb      	ldr	r3, [r7, #12]
     108:	681b      	ldr	r3, [r3, #0]
     10a:	2b00      	cmp	r3, #0
     10c:	d1f8      	bne.n	100 <tcp_send_fin+0x18>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
     10e:	68fb      	ldr	r3, [r7, #12]
     110:	68db      	ldr	r3, [r3, #12]
     112:	899b      	ldrh	r3, [r3, #12]
     114:	b29b      	uxth	r3, r3
     116:	4618      	mov	r0, r3
     118:	f7ff fffe 	bl	0 <lwip_ntohs>
			118: R_ARM_THM_CALL	lwip_ntohs
     11c:	4603      	mov	r3, r0
     11e:	f003 0307 	and.w	r3, r3, #7
     122:	2b00      	cmp	r3, #0
     124:	d118      	bne.n	158 <tcp_send_fin+0x70>
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
     126:	68fb      	ldr	r3, [r7, #12]
     128:	68dc      	ldr	r4, [r3, #12]
     12a:	68fb      	ldr	r3, [r7, #12]
     12c:	68db      	ldr	r3, [r3, #12]
     12e:	899b      	ldrh	r3, [r3, #12]
     130:	b29d      	uxth	r5, r3
     132:	f04f 0001 	mov.w	r0, #1
     136:	f7ff fffe 	bl	0 <lwip_htons>
			136: R_ARM_THM_CALL	lwip_htons
     13a:	4603      	mov	r3, r0
     13c:	ea45 0303 	orr.w	r3, r5, r3
     140:	b29b      	uxth	r3, r3
     142:	81a3      	strh	r3, [r4, #12]
      pcb->flags |= TF_FIN;
     144:	687b      	ldr	r3, [r7, #4]
     146:	7f9b      	ldrb	r3, [r3, #30]
     148:	f043 0320 	orr.w	r3, r3, #32
     14c:	b2da      	uxtb	r2, r3
     14e:	687b      	ldr	r3, [r7, #4]
     150:	779a      	strb	r2, [r3, #30]
      return ERR_OK;
     152:	f04f 0300 	mov.w	r3, #0
     156:	e005      	b.n	164 <tcp_send_fin+0x7c>
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
     158:	6878      	ldr	r0, [r7, #4]
     15a:	f04f 0101 	mov.w	r1, #1
     15e:	f7ff fffe 	bl	89c <tcp_enqueue_flags>
			15e: R_ARM_THM_CALL	tcp_enqueue_flags
     162:	4603      	mov	r3, r0
     164:	b25b      	sxtb	r3, r3
}
     166:	4618      	mov	r0, r3
     168:	f107 0710 	add.w	r7, r7, #16
     16c:	46bd      	mov	sp, r7
     16e:	bdb0      	pop	{r4, r5, r7, pc}

00000170 <tcp_create_segment>:
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
     170:	b590      	push	{r4, r7, lr}
     172:	b087      	sub	sp, #28
     174:	af00      	add	r7, sp, #0
     176:	60f8      	str	r0, [r7, #12]
     178:	60b9      	str	r1, [r7, #8]
     17a:	603b      	str	r3, [r7, #0]
     17c:	4613      	mov	r3, r2
     17e:	71fb      	strb	r3, [r7, #7]
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
     180:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
     184:	f003 0301 	and.w	r3, r3, #1
     188:	b2db      	uxtb	r3, r3
     18a:	2b00      	cmp	r3, #0
     18c:	d002      	beq.n	194 <tcp_create_segment+0x24>
     18e:	f04f 0204 	mov.w	r2, #4
     192:	e001      	b.n	198 <tcp_create_segment+0x28>
     194:	f04f 0200 	mov.w	r2, #0
     198:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
     19c:	f003 0302 	and.w	r3, r3, #2
     1a0:	2b00      	cmp	r3, #0
     1a2:	d002      	beq.n	1aa <tcp_create_segment+0x3a>
     1a4:	f04f 030c 	mov.w	r3, #12
     1a8:	e001      	b.n	1ae <tcp_create_segment+0x3e>
     1aa:	f04f 0300 	mov.w	r3, #0
     1ae:	18d3      	adds	r3, r2, r3
     1b0:	75fb      	strb	r3, [r7, #23]

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
     1b2:	f04f 0004 	mov.w	r0, #4
     1b6:	f7ff fffe 	bl	0 <memp_malloc>
			1b6: R_ARM_THM_CALL	memp_malloc
     1ba:	4603      	mov	r3, r0
     1bc:	613b      	str	r3, [r7, #16]
     1be:	693b      	ldr	r3, [r7, #16]
     1c0:	2b00      	cmp	r3, #0
     1c2:	d105      	bne.n	1d0 <tcp_create_segment+0x60>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
     1c4:	68b8      	ldr	r0, [r7, #8]
     1c6:	f7ff fffe 	bl	0 <pbuf_free>
			1c6: R_ARM_THM_CALL	pbuf_free
    return NULL;
     1ca:	f04f 0300 	mov.w	r3, #0
     1ce:	e05e      	b.n	28e <tcp_create_segment+0x11e>
  }
  seg->flags = optflags;
     1d0:	693b      	ldr	r3, [r7, #16]
     1d2:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
     1d6:	729a      	strb	r2, [r3, #10]
  seg->next = NULL;
     1d8:	693b      	ldr	r3, [r7, #16]
     1da:	f04f 0200 	mov.w	r2, #0
     1de:	601a      	str	r2, [r3, #0]
  seg->p = p;
     1e0:	693b      	ldr	r3, [r7, #16]
     1e2:	68ba      	ldr	r2, [r7, #8]
     1e4:	605a      	str	r2, [r3, #4]
  seg->len = p->tot_len - optlen;
     1e6:	68bb      	ldr	r3, [r7, #8]
     1e8:	891a      	ldrh	r2, [r3, #8]
     1ea:	7dfb      	ldrb	r3, [r7, #23]
     1ec:	b29b      	uxth	r3, r3
     1ee:	1ad3      	subs	r3, r2, r3
     1f0:	b29a      	uxth	r2, r3
     1f2:	693b      	ldr	r3, [r7, #16]
     1f4:	811a      	strh	r2, [r3, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
     1f6:	68b8      	ldr	r0, [r7, #8]
     1f8:	f04f 0114 	mov.w	r1, #20
     1fc:	f7ff fffe 	bl	0 <pbuf_header>
			1fc: R_ARM_THM_CALL	pbuf_header
     200:	4603      	mov	r3, r0
     202:	2b00      	cmp	r3, #0
     204:	d005      	beq.n	212 <tcp_create_segment+0xa2>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
     206:	6938      	ldr	r0, [r7, #16]
     208:	f7ff fffe 	bl	0 <tcp_seg_free>
			208: R_ARM_THM_CALL	tcp_seg_free
    return NULL;
     20c:	f04f 0300 	mov.w	r3, #0
     210:	e03d      	b.n	28e <tcp_create_segment+0x11e>
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
     212:	693b      	ldr	r3, [r7, #16]
     214:	685b      	ldr	r3, [r3, #4]
     216:	685b      	ldr	r3, [r3, #4]
     218:	461a      	mov	r2, r3
     21a:	693b      	ldr	r3, [r7, #16]
     21c:	60da      	str	r2, [r3, #12]
  seg->tcphdr->src = htons(pcb->local_port);
     21e:	693b      	ldr	r3, [r7, #16]
     220:	68dc      	ldr	r4, [r3, #12]
     222:	68fb      	ldr	r3, [r7, #12]
     224:	8b5b      	ldrh	r3, [r3, #26]
     226:	4618      	mov	r0, r3
     228:	f7ff fffe 	bl	0 <lwip_htons>
			228: R_ARM_THM_CALL	lwip_htons
     22c:	4603      	mov	r3, r0
     22e:	8023      	strh	r3, [r4, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
     230:	693b      	ldr	r3, [r7, #16]
     232:	68dc      	ldr	r4, [r3, #12]
     234:	68fb      	ldr	r3, [r7, #12]
     236:	8b9b      	ldrh	r3, [r3, #28]
     238:	4618      	mov	r0, r3
     23a:	f7ff fffe 	bl	0 <lwip_htons>
			23a: R_ARM_THM_CALL	lwip_htons
     23e:	4603      	mov	r3, r0
     240:	8063      	strh	r3, [r4, #2]
  seg->tcphdr->seqno = htonl(seqno);
     242:	693b      	ldr	r3, [r7, #16]
     244:	68dc      	ldr	r4, [r3, #12]
     246:	6838      	ldr	r0, [r7, #0]
     248:	f7ff fffe 	bl	0 <lwip_htonl>
			248: R_ARM_THM_CALL	lwip_htonl
     24c:	4603      	mov	r3, r0
     24e:	6063      	str	r3, [r4, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
     250:	693b      	ldr	r3, [r7, #16]
     252:	68dc      	ldr	r4, [r3, #12]
     254:	7dfb      	ldrb	r3, [r7, #23]
     256:	ea4f 0393 	mov.w	r3, r3, lsr #2
     25a:	b2db      	uxtb	r3, r3
     25c:	f103 0305 	add.w	r3, r3, #5
     260:	ea4f 3303 	mov.w	r3, r3, lsl #12
     264:	b29a      	uxth	r2, r3
     266:	79fb      	ldrb	r3, [r7, #7]
     268:	b29b      	uxth	r3, r3
     26a:	ea42 0303 	orr.w	r3, r2, r3
     26e:	b29b      	uxth	r3, r3
     270:	b29b      	uxth	r3, r3
     272:	4618      	mov	r0, r3
     274:	f7ff fffe 	bl	0 <lwip_htons>
			274: R_ARM_THM_CALL	lwip_htons
     278:	4603      	mov	r3, r0
     27a:	81a3      	strh	r3, [r4, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
     27c:	693b      	ldr	r3, [r7, #16]
     27e:	68db      	ldr	r3, [r3, #12]
     280:	f04f 0200 	mov.w	r2, #0
     284:	749a      	strb	r2, [r3, #18]
     286:	f04f 0200 	mov.w	r2, #0
     28a:	74da      	strb	r2, [r3, #19]
  return seg;
     28c:	693b      	ldr	r3, [r7, #16]
} 
     28e:	4618      	mov	r0, r3
     290:	f107 071c 	add.w	r7, r7, #28
     294:	46bd      	mov	sp, r7
     296:	bd90      	pop	{r4, r7, pc}

00000298 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
     298:	b580      	push	{r7, lr}
     29a:	b086      	sub	sp, #24
     29c:	af00      	add	r7, sp, #0
     29e:	607b      	str	r3, [r7, #4]
     2a0:	4603      	mov	r3, r0
     2a2:	73fb      	strb	r3, [r7, #15]
     2a4:	460b      	mov	r3, r1
     2a6:	81bb      	strh	r3, [r7, #12]
     2a8:	4613      	mov	r3, r2
     2aa:	817b      	strh	r3, [r7, #10]
  struct pbuf *p;
  u16_t alloc = length;
     2ac:	89bb      	ldrh	r3, [r7, #12]
     2ae:	82fb      	strh	r3, [r7, #22]
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
     2b0:	89ba      	ldrh	r2, [r7, #12]
     2b2:	897b      	ldrh	r3, [r7, #10]
     2b4:	429a      	cmp	r2, r3
     2b6:	d223      	bcs.n	300 <tcp_pbuf_prealloc+0x68>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
     2b8:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
     2bc:	f003 0302 	and.w	r3, r3, #2
     2c0:	2b00      	cmp	r3, #0
     2c2:	d111      	bne.n	2e8 <tcp_pbuf_prealloc+0x50>
        (!(pcb->flags & TF_NODELAY) &&
     2c4:	6a3b      	ldr	r3, [r7, #32]
     2c6:	7f9b      	ldrb	r3, [r3, #30]
     2c8:	f003 0340 	and.w	r3, r3, #64	; 0x40
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
     2cc:	2b00      	cmp	r3, #0
     2ce:	d117      	bne.n	300 <tcp_pbuf_prealloc+0x68>
        (!(pcb->flags & TF_NODELAY) &&
     2d0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
     2d4:	2b00      	cmp	r3, #0
     2d6:	d007      	beq.n	2e8 <tcp_pbuf_prealloc+0x50>
         (!first_seg ||
          pcb->unsent != NULL ||
     2d8:	6a3b      	ldr	r3, [r7, #32]
     2da:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
     2dc:	2b00      	cmp	r3, #0
     2de:	d103      	bne.n	2e8 <tcp_pbuf_prealloc+0x50>
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
     2e0:	6a3b      	ldr	r3, [r7, #32]
     2e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
     2e4:	2b00      	cmp	r3, #0
     2e6:	d00b      	beq.n	300 <tcp_pbuf_prealloc+0x68>
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
     2e8:	89bb      	ldrh	r3, [r7, #12]
     2ea:	f503 63ba 	add.w	r3, r3, #1488	; 0x5d0
     2ee:	f103 030f 	add.w	r3, r3, #15
     2f2:	f023 0203 	bic.w	r2, r3, #3
     2f6:	897b      	ldrh	r3, [r7, #10]
     2f8:	429a      	cmp	r2, r3
     2fa:	bfb8      	it	lt
     2fc:	4613      	movlt	r3, r2
     2fe:	82fb      	strh	r3, [r7, #22]
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
     300:	7bfa      	ldrb	r2, [r7, #15]
     302:	8afb      	ldrh	r3, [r7, #22]
     304:	4610      	mov	r0, r2
     306:	4619      	mov	r1, r3
     308:	f04f 0200 	mov.w	r2, #0
     30c:	f7ff fffe 	bl	0 <pbuf_alloc>
			30c: R_ARM_THM_CALL	pbuf_alloc
     310:	6138      	str	r0, [r7, #16]
  if (p == NULL) {
     312:	693b      	ldr	r3, [r7, #16]
     314:	2b00      	cmp	r3, #0
     316:	d102      	bne.n	31e <tcp_pbuf_prealloc+0x86>
    return NULL;
     318:	f04f 0300 	mov.w	r3, #0
     31c:	e00e      	b.n	33c <tcp_pbuf_prealloc+0xa4>
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
  *oversize = p->len - length;
     31e:	693b      	ldr	r3, [r7, #16]
     320:	895a      	ldrh	r2, [r3, #10]
     322:	89bb      	ldrh	r3, [r7, #12]
     324:	1ad3      	subs	r3, r2, r3
     326:	b29a      	uxth	r2, r3
     328:	687b      	ldr	r3, [r7, #4]
     32a:	801a      	strh	r2, [r3, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
     32c:	693b      	ldr	r3, [r7, #16]
     32e:	89ba      	ldrh	r2, [r7, #12]
     330:	811a      	strh	r2, [r3, #8]
     332:	693b      	ldr	r3, [r7, #16]
     334:	891a      	ldrh	r2, [r3, #8]
     336:	693b      	ldr	r3, [r7, #16]
     338:	815a      	strh	r2, [r3, #10]
  return p;
     33a:	693b      	ldr	r3, [r7, #16]
}
     33c:	4618      	mov	r0, r3
     33e:	f107 0718 	add.w	r7, r7, #24
     342:	46bd      	mov	sp, r7
     344:	bd80      	pop	{r7, pc}
     346:	bf00      	nop

00000348 <tcp_write_checks>:
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
     348:	b480      	push	{r7}
     34a:	b083      	sub	sp, #12
     34c:	af00      	add	r7, sp, #0
     34e:	6078      	str	r0, [r7, #4]
     350:	460b      	mov	r3, r1
     352:	807b      	strh	r3, [r7, #2]
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
     354:	687b      	ldr	r3, [r7, #4]
     356:	7e1b      	ldrb	r3, [r3, #24]
     358:	2b04      	cmp	r3, #4
     35a:	d00e      	beq.n	37a <tcp_write_checks+0x32>
      (pcb->state != CLOSE_WAIT) &&
     35c:	687b      	ldr	r3, [r7, #4]
     35e:	7e1b      	ldrb	r3, [r3, #24]
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
     360:	2b07      	cmp	r3, #7
     362:	d00a      	beq.n	37a <tcp_write_checks+0x32>
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
     364:	687b      	ldr	r3, [r7, #4]
     366:	7e1b      	ldrb	r3, [r3, #24]
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
     368:	2b02      	cmp	r3, #2
     36a:	d006      	beq.n	37a <tcp_write_checks+0x32>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
     36c:	687b      	ldr	r3, [r7, #4]
     36e:	7e1b      	ldrb	r3, [r3, #24]
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
     370:	2b03      	cmp	r3, #3
     372:	d002      	beq.n	37a <tcp_write_checks+0x32>
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
     374:	f04f 03f3 	mov.w	r3, #243	; 0xf3
     378:	e039      	b.n	3ee <tcp_write_checks+0xa6>
  } else if (len == 0) {
     37a:	887b      	ldrh	r3, [r7, #2]
     37c:	2b00      	cmp	r3, #0
     37e:	d102      	bne.n	386 <tcp_write_checks+0x3e>
    return ERR_OK;
     380:	f04f 0300 	mov.w	r3, #0
     384:	e033      	b.n	3ee <tcp_write_checks+0xa6>
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
     386:	687b      	ldr	r3, [r7, #4]
     388:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
     38c:	887a      	ldrh	r2, [r7, #2]
     38e:	429a      	cmp	r2, r3
     390:	d909      	bls.n	3a6 <tcp_write_checks+0x5e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
     392:	687b      	ldr	r3, [r7, #4]
     394:	7f9b      	ldrb	r3, [r3, #30]
     396:	f063 037f 	orn	r3, r3, #127	; 0x7f
     39a:	b2da      	uxtb	r2, r3
     39c:	687b      	ldr	r3, [r7, #4]
     39e:	779a      	strb	r2, [r3, #30]
    return ERR_MEM;
     3a0:	f04f 03ff 	mov.w	r3, #255	; 0xff
     3a4:	e023      	b.n	3ee <tcp_write_checks+0xa6>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
     3a6:	687b      	ldr	r3, [r7, #4]
     3a8:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     3ac:	2b07      	cmp	r3, #7
     3ae:	d806      	bhi.n	3be <tcp_write_checks+0x76>
     3b0:	687b      	ldr	r3, [r7, #4]
     3b2:	f8b3 2068 	ldrh.w	r2, [r3, #104]	; 0x68
     3b6:	f64f 73fc 	movw	r3, #65532	; 0xfffc
     3ba:	429a      	cmp	r2, r3
     3bc:	d909      	bls.n	3d2 <tcp_write_checks+0x8a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
     3be:	687b      	ldr	r3, [r7, #4]
     3c0:	7f9b      	ldrb	r3, [r3, #30]
     3c2:	f063 037f 	orn	r3, r3, #127	; 0x7f
     3c6:	b2da      	uxtb	r2, r3
     3c8:	687b      	ldr	r3, [r7, #4]
     3ca:	779a      	strb	r2, [r3, #30]
    return ERR_MEM;
     3cc:	f04f 03ff 	mov.w	r3, #255	; 0xff
     3d0:	e00d      	b.n	3ee <tcp_write_checks+0xa6>
  }
  if (pcb->snd_queuelen != 0) {
     3d2:	687b      	ldr	r3, [r7, #4]
     3d4:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     3d8:	2b00      	cmp	r3, #0
     3da:	d003      	beq.n	3e4 <tcp_write_checks+0x9c>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
     3dc:	687b      	ldr	r3, [r7, #4]
     3de:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     3e0:	2b00      	cmp	r3, #0
     3e2:	e002      	b.n	3ea <tcp_write_checks+0xa2>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
     3e4:	687b      	ldr	r3, [r7, #4]
     3e6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     3e8:	2b00      	cmp	r3, #0
      pcb->unacked == NULL && pcb->unsent == NULL);
  }
  return ERR_OK;
     3ea:	f04f 0300 	mov.w	r3, #0
     3ee:	b25b      	sxtb	r3, r3
}
     3f0:	4618      	mov	r0, r3
     3f2:	f107 070c 	add.w	r7, r7, #12
     3f6:	46bd      	mov	sp, r7
     3f8:	bc80      	pop	{r7}
     3fa:	4770      	bx	lr

000003fc <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
     3fc:	b5b0      	push	{r4, r5, r7, lr}
     3fe:	b098      	sub	sp, #96	; 0x60
     400:	af04      	add	r7, sp, #16
     402:	60f8      	str	r0, [r7, #12]
     404:	60b9      	str	r1, [r7, #8]
     406:	80fa      	strh	r2, [r7, #6]
     408:	717b      	strb	r3, [r7, #5]
  struct pbuf *concat_p = NULL;
     40a:	f04f 0300 	mov.w	r3, #0
     40e:	64fb      	str	r3, [r7, #76]	; 0x4c
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
     410:	f04f 0300 	mov.w	r3, #0
     414:	64bb      	str	r3, [r7, #72]	; 0x48
     416:	f04f 0300 	mov.w	r3, #0
     41a:	647b      	str	r3, [r7, #68]	; 0x44
     41c:	f04f 0300 	mov.w	r3, #0
     420:	643b      	str	r3, [r7, #64]	; 0x40
     422:	f04f 0300 	mov.w	r3, #0
     426:	63fb      	str	r3, [r7, #60]	; 0x3c
  u16_t pos = 0; /* position in 'arg' data */
     428:	f04f 0300 	mov.w	r3, #0
     42c:	877b      	strh	r3, [r7, #58]	; 0x3a
  u16_t queuelen;
  u8_t optlen = 0;
     42e:	f04f 0300 	mov.w	r3, #0
     432:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  u8_t optflags = 0;
     436:	f04f 0300 	mov.w	r3, #0
     43a:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a
#if TCP_OVERSIZE
  u16_t oversize = 0;
     43e:	f04f 0300 	mov.w	r3, #0
     442:	82fb      	strh	r3, [r7, #22]
  u16_t oversize_used = 0;
     444:	f04f 0300 	mov.w	r3, #0
     448:	86fb      	strh	r3, [r7, #54]	; 0x36
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
     44a:	68fb      	ldr	r3, [r7, #12]
     44c:	f8b3 3062 	ldrh.w	r3, [r3, #98]	; 0x62
     450:	ea4f 0353 	mov.w	r3, r3, lsr #1
     454:	b29a      	uxth	r2, r3
     456:	68fb      	ldr	r3, [r7, #12]
     458:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     45a:	429a      	cmp	r2, r3
     45c:	bf38      	it	cc
     45e:	4613      	movcc	r3, r2
     460:	853b      	strh	r3, [r7, #40]	; 0x28
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
     462:	68bb      	ldr	r3, [r7, #8]
     464:	2b00      	cmp	r3, #0
     466:	d102      	bne.n	46e <tcp_write+0x72>
     468:	f04f 03f2 	mov.w	r3, #242	; 0xf2
     46c:	e20f      	b.n	88e <tcp_write+0x492>
             arg != NULL, return ERR_ARG;);

  err = tcp_write_checks(pcb, len);
     46e:	88fb      	ldrh	r3, [r7, #6]
     470:	68f8      	ldr	r0, [r7, #12]
     472:	4619      	mov	r1, r3
     474:	f7ff ff68 	bl	348 <tcp_write_checks>
     478:	4603      	mov	r3, r0
     47a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  if (err != ERR_OK) {
     47e:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
     482:	2b00      	cmp	r3, #0
     484:	d002      	beq.n	48c <tcp_write+0x90>
    return err;
     486:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
     48a:	e200      	b.n	88e <tcp_write+0x492>
  }
  queuelen = pcb->snd_queuelen;
     48c:	68fb      	ldr	r3, [r7, #12]
     48e:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     492:	873b      	strh	r3, [r7, #56]	; 0x38
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
     494:	68fb      	ldr	r3, [r7, #12]
     496:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     498:	2b00      	cmp	r3, #0
     49a:	f000 8144 	beq.w	726 <tcp_write+0x32a>
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
     49e:	68fb      	ldr	r3, [r7, #12]
     4a0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     4a2:	64bb      	str	r3, [r7, #72]	; 0x48
     4a4:	e002      	b.n	4ac <tcp_write+0xb0>
         last_unsent = last_unsent->next);
     4a6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     4a8:	681b      	ldr	r3, [r3, #0]
     4aa:	64bb      	str	r3, [r7, #72]	; 0x48
  if (pcb->unsent != NULL) {
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
     4ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     4ae:	681b      	ldr	r3, [r3, #0]
     4b0:	2b00      	cmp	r3, #0
     4b2:	d1f8      	bne.n	4a6 <tcp_write+0xaa>
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
     4b4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     4b6:	7a9b      	ldrb	r3, [r3, #10]
     4b8:	f003 0301 	and.w	r3, r3, #1
     4bc:	b2db      	uxtb	r3, r3
     4be:	2b00      	cmp	r3, #0
     4c0:	d002      	beq.n	4c8 <tcp_write+0xcc>
     4c2:	f04f 0204 	mov.w	r2, #4
     4c6:	e001      	b.n	4cc <tcp_write+0xd0>
     4c8:	f04f 0200 	mov.w	r2, #0
     4cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     4ce:	7a9b      	ldrb	r3, [r3, #10]
     4d0:	f003 0302 	and.w	r3, r3, #2
     4d4:	2b00      	cmp	r3, #0
     4d6:	d002      	beq.n	4de <tcp_write+0xe2>
     4d8:	f04f 030c 	mov.w	r3, #12
     4dc:	e001      	b.n	4e2 <tcp_write+0xe6>
     4de:	f04f 0300 	mov.w	r3, #0
     4e2:	18d3      	adds	r3, r2, r3
     4e4:	84bb      	strh	r3, [r7, #36]	; 0x24
    space = mss_local - (last_unsent->len + unsent_optlen);
     4e6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     4e8:	891a      	ldrh	r2, [r3, #8]
     4ea:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
     4ec:	18d3      	adds	r3, r2, r3
     4ee:	b29b      	uxth	r3, r3
     4f0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
     4f2:	1ad3      	subs	r3, r2, r3
     4f4:	86bb      	strh	r3, [r7, #52]	; 0x34
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
     4f6:	68fb      	ldr	r3, [r7, #12]
     4f8:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
     4fc:	82fb      	strh	r3, [r7, #22]
    if (oversize > 0) {
     4fe:	8afb      	ldrh	r3, [r7, #22]
     500:	2b00      	cmp	r3, #0
     502:	d014      	beq.n	52e <tcp_write+0x132>
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
     504:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     506:	647b      	str	r3, [r7, #68]	; 0x44
      oversize_used = oversize < len ? oversize : len;
     508:	8afb      	ldrh	r3, [r7, #22]
     50a:	88fa      	ldrh	r2, [r7, #6]
     50c:	429a      	cmp	r2, r3
     50e:	bf38      	it	cc
     510:	4613      	movcc	r3, r2
     512:	86fb      	strh	r3, [r7, #54]	; 0x36
      pos += oversize_used;
     514:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
     516:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     518:	18d3      	adds	r3, r2, r3
     51a:	877b      	strh	r3, [r7, #58]	; 0x3a
      oversize -= oversize_used;
     51c:	8afa      	ldrh	r2, [r7, #22]
     51e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     520:	1ad3      	subs	r3, r2, r3
     522:	b29b      	uxth	r3, r3
     524:	82fb      	strh	r3, [r7, #22]
      space -= oversize_used;
     526:	8eba      	ldrh	r2, [r7, #52]	; 0x34
     528:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     52a:	1ad3      	subs	r3, r2, r3
     52c:	86bb      	strh	r3, [r7, #52]	; 0x34
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
     52e:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
     530:	88fb      	ldrh	r3, [r7, #6]
     532:	429a      	cmp	r2, r3
     534:	f080 80f7 	bcs.w	726 <tcp_write+0x32a>
     538:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
     53a:	2b00      	cmp	r3, #0
     53c:	f000 80f3 	beq.w	726 <tcp_write+0x32a>
     540:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     542:	891b      	ldrh	r3, [r3, #8]
     544:	2b00      	cmp	r3, #0
     546:	f000 80ee 	beq.w	726 <tcp_write+0x32a>
      u16_t seglen = space < len - pos ? space : len - pos;
     54a:	88fa      	ldrh	r2, [r7, #6]
     54c:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     54e:	1ad2      	subs	r2, r2, r3
     550:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
     552:	429a      	cmp	r2, r3
     554:	bfb8      	it	lt
     556:	4613      	movlt	r3, r2
     558:	847b      	strh	r3, [r7, #34]	; 0x22
      seg = last_unsent;
     55a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     55c:	647b      	str	r3, [r7, #68]	; 0x44

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
     55e:	797b      	ldrb	r3, [r7, #5]
     560:	f003 0301 	and.w	r3, r3, #1
     564:	b2db      	uxtb	r3, r3
     566:	2b00      	cmp	r3, #0
     568:	d01f      	beq.n	5aa <tcp_write+0x1ae>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
     56a:	8c79      	ldrh	r1, [r7, #34]	; 0x22
     56c:	8eba      	ldrh	r2, [r7, #52]	; 0x34
     56e:	f107 0316 	add.w	r3, r7, #22
     572:	68f8      	ldr	r0, [r7, #12]
     574:	9000      	str	r0, [sp, #0]
     576:	7978      	ldrb	r0, [r7, #5]
     578:	9001      	str	r0, [sp, #4]
     57a:	f04f 0001 	mov.w	r0, #1
     57e:	9002      	str	r0, [sp, #8]
     580:	f04f 0003 	mov.w	r0, #3
     584:	f7ff fe88 	bl	298 <tcp_pbuf_prealloc>
     588:	64f8      	str	r0, [r7, #76]	; 0x4c
     58a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     58c:	2b00      	cmp	r3, #0
     58e:	f000 8158 	beq.w	842 <tcp_write+0x446>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
     592:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     594:	6859      	ldr	r1, [r3, #4]
     596:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     598:	68ba      	ldr	r2, [r7, #8]
     59a:	18d2      	adds	r2, r2, r3
     59c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
     59e:	4608      	mov	r0, r1
     5a0:	4611      	mov	r1, r2
     5a2:	461a      	mov	r2, r3
     5a4:	f7ff fffe 	bl	0 <memcpy>
			5a4: R_ARM_THM_CALL	memcpy
     5a8:	e011      	b.n	5ce <tcp_write+0x1d2>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
     5aa:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
     5ac:	f04f 0003 	mov.w	r0, #3
     5b0:	4619      	mov	r1, r3
     5b2:	f04f 0201 	mov.w	r2, #1
     5b6:	f7ff fffe 	bl	0 <pbuf_alloc>
			5b6: R_ARM_THM_CALL	pbuf_alloc
     5ba:	64f8      	str	r0, [r7, #76]	; 0x4c
     5bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     5be:	2b00      	cmp	r3, #0
     5c0:	f000 8141 	beq.w	846 <tcp_write+0x44a>
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
     5c4:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     5c6:	68ba      	ldr	r2, [r7, #8]
     5c8:	18d2      	adds	r2, r2, r3
     5ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     5cc:	605a      	str	r2, [r3, #4]
      }

      pos += seglen;
     5ce:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
     5d0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
     5d2:	18d3      	adds	r3, r2, r3
     5d4:	877b      	strh	r3, [r7, #58]	; 0x3a
      queuelen += pbuf_clen(concat_p);
     5d6:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
     5d8:	f7ff fffe 	bl	0 <pbuf_clen>
			5d8: R_ARM_THM_CALL	pbuf_clen
     5dc:	4603      	mov	r3, r0
     5de:	461a      	mov	r2, r3
     5e0:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
     5e2:	18d3      	adds	r3, r2, r3
     5e4:	873b      	strh	r3, [r7, #56]	; 0x38
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
     5e6:	e09e      	b.n	726 <tcp_write+0x32a>
    struct pbuf *p;
    u16_t left = len - pos;
     5e8:	88fa      	ldrh	r2, [r7, #6]
     5ea:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     5ec:	1ad3      	subs	r3, r2, r3
     5ee:	843b      	strh	r3, [r7, #32]
    u16_t max_len = mss_local - optlen;
     5f0:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
     5f4:	b29b      	uxth	r3, r3
     5f6:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
     5f8:	1ad3      	subs	r3, r2, r3
     5fa:	83fb      	strh	r3, [r7, #30]
    u16_t seglen = left > max_len ? max_len : left;
     5fc:	8c3a      	ldrh	r2, [r7, #32]
     5fe:	8bfb      	ldrh	r3, [r7, #30]
     600:	429a      	cmp	r2, r3
     602:	bf38      	it	cc
     604:	4613      	movcc	r3, r2
     606:	83bb      	strh	r3, [r7, #28]
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
     608:	797b      	ldrb	r3, [r7, #5]
     60a:	f003 0301 	and.w	r3, r3, #1
     60e:	b2db      	uxtb	r3, r3
     610:	2b00      	cmp	r3, #0
     612:	d02b      	beq.n	66c <tcp_write+0x270>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
     614:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
     618:	b29a      	uxth	r2, r3
     61a:	8bbb      	ldrh	r3, [r7, #28]
     61c:	18d3      	adds	r3, r2, r3
     61e:	b299      	uxth	r1, r3
     620:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     622:	2b00      	cmp	r3, #0
     624:	bf14      	ite	ne
     626:	2300      	movne	r3, #0
     628:	2301      	moveq	r3, #1
     62a:	b2d8      	uxtb	r0, r3
     62c:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
     62e:	f107 0316 	add.w	r3, r7, #22
     632:	68fc      	ldr	r4, [r7, #12]
     634:	9400      	str	r4, [sp, #0]
     636:	797c      	ldrb	r4, [r7, #5]
     638:	9401      	str	r4, [sp, #4]
     63a:	9002      	str	r0, [sp, #8]
     63c:	f04f 0000 	mov.w	r0, #0
     640:	f7ff fe2a 	bl	298 <tcp_pbuf_prealloc>
     644:	6338      	str	r0, [r7, #48]	; 0x30
     646:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     648:	2b00      	cmp	r3, #0
     64a:	f000 80fe 	beq.w	84a <tcp_write+0x44e>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
     64e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     650:	685a      	ldr	r2, [r3, #4]
     652:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
     656:	18d1      	adds	r1, r2, r3
     658:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     65a:	68ba      	ldr	r2, [r7, #8]
     65c:	18d2      	adds	r2, r2, r3
     65e:	8bbb      	ldrh	r3, [r7, #28]
     660:	4608      	mov	r0, r1
     662:	4611      	mov	r1, r2
     664:	461a      	mov	r2, r3
     666:	f7ff fffe 	bl	0 <memcpy>
			666: R_ARM_THM_CALL	memcpy
     66a:	e027      	b.n	6bc <tcp_write+0x2c0>
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
     66c:	8bbb      	ldrh	r3, [r7, #28]
     66e:	f04f 0000 	mov.w	r0, #0
     672:	4619      	mov	r1, r3
     674:	f04f 0201 	mov.w	r2, #1
     678:	f7ff fffe 	bl	0 <pbuf_alloc>
			678: R_ARM_THM_CALL	pbuf_alloc
     67c:	61b8      	str	r0, [r7, #24]
     67e:	69bb      	ldr	r3, [r7, #24]
     680:	2b00      	cmp	r3, #0
     682:	f000 80e4 	beq.w	84e <tcp_write+0x452>
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
     686:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     688:	68ba      	ldr	r2, [r7, #8]
     68a:	18d2      	adds	r2, r2, r3
     68c:	69bb      	ldr	r3, [r7, #24]
     68e:	605a      	str	r2, [r3, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
     690:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
     694:	b29b      	uxth	r3, r3
     696:	f04f 0000 	mov.w	r0, #0
     69a:	4619      	mov	r1, r3
     69c:	f04f 0200 	mov.w	r2, #0
     6a0:	f7ff fffe 	bl	0 <pbuf_alloc>
			6a0: R_ARM_THM_CALL	pbuf_alloc
     6a4:	6338      	str	r0, [r7, #48]	; 0x30
     6a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     6a8:	2b00      	cmp	r3, #0
     6aa:	d103      	bne.n	6b4 <tcp_write+0x2b8>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
     6ac:	69b8      	ldr	r0, [r7, #24]
     6ae:	f7ff fffe 	bl	0 <pbuf_free>
			6ae: R_ARM_THM_CALL	pbuf_free
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
     6b2:	e0cf      	b.n	854 <tcp_write+0x458>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
     6b4:	6b38      	ldr	r0, [r7, #48]	; 0x30
     6b6:	69b9      	ldr	r1, [r7, #24]
     6b8:	f7ff fffe 	bl	0 <pbuf_cat>
			6b8: R_ARM_THM_CALL	pbuf_cat
    }

    queuelen += pbuf_clen(p);
     6bc:	6b38      	ldr	r0, [r7, #48]	; 0x30
     6be:	f7ff fffe 	bl	0 <pbuf_clen>
			6be: R_ARM_THM_CALL	pbuf_clen
     6c2:	4603      	mov	r3, r0
     6c4:	461a      	mov	r2, r3
     6c6:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
     6c8:	18d3      	adds	r3, r2, r3
     6ca:	873b      	strh	r3, [r7, #56]	; 0x38

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
     6cc:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
     6ce:	2b08      	cmp	r3, #8
     6d0:	d804      	bhi.n	6dc <tcp_write+0x2e0>
     6d2:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
     6d4:	f64f 73fc 	movw	r3, #65532	; 0xfffc
     6d8:	429a      	cmp	r2, r3
     6da:	d903      	bls.n	6e4 <tcp_write+0x2e8>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
     6dc:	6b38      	ldr	r0, [r7, #48]	; 0x30
     6de:	f7ff fffe 	bl	0 <pbuf_free>
			6de: R_ARM_THM_CALL	pbuf_free
      goto memerr;
     6e2:	e0b7      	b.n	854 <tcp_write+0x458>
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
     6e4:	68fb      	ldr	r3, [r7, #12]
     6e6:	6dda      	ldr	r2, [r3, #92]	; 0x5c
     6e8:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
     6ea:	18d3      	adds	r3, r2, r3
     6ec:	f897 202a 	ldrb.w	r2, [r7, #42]	; 0x2a
     6f0:	9200      	str	r2, [sp, #0]
     6f2:	68f8      	ldr	r0, [r7, #12]
     6f4:	6b39      	ldr	r1, [r7, #48]	; 0x30
     6f6:	f04f 0200 	mov.w	r2, #0
     6fa:	f7ff fd39 	bl	170 <tcp_create_segment>
     6fe:	6478      	str	r0, [r7, #68]	; 0x44
     700:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     702:	2b00      	cmp	r3, #0
     704:	f000 80a5 	beq.w	852 <tcp_write+0x456>
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
     708:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     70a:	2b00      	cmp	r3, #0
     70c:	d102      	bne.n	714 <tcp_write+0x318>
      queue = seg;
     70e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     710:	63fb      	str	r3, [r7, #60]	; 0x3c
     712:	e002      	b.n	71a <tcp_write+0x31e>
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
      prev_seg->next = seg;
     714:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     716:	6c7a      	ldr	r2, [r7, #68]	; 0x44
     718:	601a      	str	r2, [r3, #0]
    }
    /* remember last segment of to-be-queued data for next iteration */
    prev_seg = seg;
     71a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     71c:	643b      	str	r3, [r7, #64]	; 0x40

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
     71e:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
     720:	8bbb      	ldrh	r3, [r7, #28]
     722:	18d3      	adds	r3, r2, r3
     724:	877b      	strh	r3, [r7, #58]	; 0x3a
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
     726:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
     728:	88fb      	ldrh	r3, [r7, #6]
     72a:	429a      	cmp	r2, r3
     72c:	f4ff af5c 	bcc.w	5e8 <tcp_write+0x1ec>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
     730:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     732:	2b00      	cmp	r3, #0
     734:	d02d      	beq.n	792 <tcp_write+0x396>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
     736:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     738:	685b      	ldr	r3, [r3, #4]
     73a:	62fb      	str	r3, [r7, #44]	; 0x2c
     73c:	e01f      	b.n	77e <tcp_write+0x382>
      p->tot_len += oversize_used;
     73e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     740:	891a      	ldrh	r2, [r3, #8]
     742:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     744:	18d3      	adds	r3, r2, r3
     746:	b29a      	uxth	r2, r3
     748:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     74a:	811a      	strh	r2, [r3, #8]
      if (p->next == NULL) {
     74c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     74e:	681b      	ldr	r3, [r3, #0]
     750:	2b00      	cmp	r3, #0
     752:	d111      	bne.n	778 <tcp_write+0x37c>
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
     754:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     756:	685a      	ldr	r2, [r3, #4]
     758:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     75a:	895b      	ldrh	r3, [r3, #10]
     75c:	18d2      	adds	r2, r2, r3
     75e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     760:	4610      	mov	r0, r2
     762:	68b9      	ldr	r1, [r7, #8]
     764:	461a      	mov	r2, r3
     766:	f7ff fffe 	bl	0 <memcpy>
			766: R_ARM_THM_CALL	memcpy
        p->len += oversize_used;
     76a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     76c:	895a      	ldrh	r2, [r3, #10]
     76e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     770:	18d3      	adds	r3, r2, r3
     772:	b29a      	uxth	r2, r3
     774:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     776:	815a      	strh	r2, [r3, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
     778:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     77a:	681b      	ldr	r3, [r3, #0]
     77c:	62fb      	str	r3, [r7, #44]	; 0x2c
     77e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     780:	2b00      	cmp	r3, #0
     782:	d1dc      	bne.n	73e <tcp_write+0x342>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
     784:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     786:	891a      	ldrh	r2, [r3, #8]
     788:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     78a:	18d3      	adds	r3, r2, r3
     78c:	b29a      	uxth	r2, r3
     78e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     790:	811a      	strh	r2, [r3, #8]
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
     792:	8afa      	ldrh	r2, [r7, #22]
     794:	68fb      	ldr	r3, [r7, #12]
     796:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
     79a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     79c:	2b00      	cmp	r3, #0
     79e:	d00d      	beq.n	7bc <tcp_write+0x3c0>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
     7a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     7a2:	685b      	ldr	r3, [r3, #4]
     7a4:	4618      	mov	r0, r3
     7a6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
     7a8:	f7ff fffe 	bl	0 <pbuf_cat>
			7a8: R_ARM_THM_CALL	pbuf_cat
    last_unsent->len += concat_p->tot_len;
     7ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     7ae:	891a      	ldrh	r2, [r3, #8]
     7b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     7b2:	891b      	ldrh	r3, [r3, #8]
     7b4:	18d3      	adds	r3, r2, r3
     7b6:	b29a      	uxth	r2, r3
     7b8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     7ba:	811a      	strh	r2, [r3, #8]

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
     7bc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     7be:	2b00      	cmp	r3, #0
     7c0:	d103      	bne.n	7ca <tcp_write+0x3ce>
    pcb->unsent = queue;
     7c2:	68fb      	ldr	r3, [r7, #12]
     7c4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     7c6:	66da      	str	r2, [r3, #108]	; 0x6c
     7c8:	e002      	b.n	7d0 <tcp_write+0x3d4>
  } else {
    last_unsent->next = queue;
     7ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     7cc:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     7ce:	601a      	str	r2, [r3, #0]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
     7d0:	68fb      	ldr	r3, [r7, #12]
     7d2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
     7d4:	88fb      	ldrh	r3, [r7, #6]
     7d6:	18d2      	adds	r2, r2, r3
     7d8:	68fb      	ldr	r3, [r7, #12]
     7da:	65da      	str	r2, [r3, #92]	; 0x5c
  pcb->snd_buf -= len;
     7dc:	68fb      	ldr	r3, [r7, #12]
     7de:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
     7e2:	88fb      	ldrh	r3, [r7, #6]
     7e4:	1ad3      	subs	r3, r2, r3
     7e6:	b29a      	uxth	r2, r3
     7e8:	68fb      	ldr	r3, [r7, #12]
     7ea:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  pcb->snd_queuelen = queuelen;
     7ee:	68fb      	ldr	r3, [r7, #12]
     7f0:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
     7f2:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
     7f6:	68fb      	ldr	r3, [r7, #12]
     7f8:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     7fc:	2b00      	cmp	r3, #0
     7fe:	d002      	beq.n	806 <tcp_write+0x40a>
    LWIP_ASSERT("tcp_write: valid queue length",
     800:	68fb      	ldr	r3, [r7, #12]
     802:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     804:	2b00      	cmp	r3, #0
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
     806:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     808:	2b00      	cmp	r3, #0
     80a:	d017      	beq.n	83c <tcp_write+0x440>
     80c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     80e:	68db      	ldr	r3, [r3, #12]
     810:	2b00      	cmp	r3, #0
     812:	d013      	beq.n	83c <tcp_write+0x440>
     814:	797b      	ldrb	r3, [r7, #5]
     816:	f003 0302 	and.w	r3, r3, #2
     81a:	2b00      	cmp	r3, #0
     81c:	d10e      	bne.n	83c <tcp_write+0x440>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
     81e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     820:	68dc      	ldr	r4, [r3, #12]
     822:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     824:	68db      	ldr	r3, [r3, #12]
     826:	899b      	ldrh	r3, [r3, #12]
     828:	b29d      	uxth	r5, r3
     82a:	f04f 0008 	mov.w	r0, #8
     82e:	f7ff fffe 	bl	0 <lwip_htons>
			82e: R_ARM_THM_CALL	lwip_htons
     832:	4603      	mov	r3, r0
     834:	ea45 0303 	orr.w	r3, r5, r3
     838:	b29b      	uxth	r3, r3
     83a:	81a3      	strh	r3, [r4, #12]
  }

  return ERR_OK;
     83c:	f04f 0300 	mov.w	r3, #0
     840:	e025      	b.n	88e <tcp_write+0x492>
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
                       seglen));
          goto memerr;
     842:	bf00      	nop
     844:	e006      	b.n	854 <tcp_write+0x458>
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2,
                      ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
          goto memerr;
     846:	bf00      	nop
     848:	e004      	b.n	854 <tcp_write+0x458>
    if (apiflags & TCP_WRITE_FLAG_COPY) {
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
     84a:	bf00      	nop
     84c:	e002      	b.n	854 <tcp_write+0x458>
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
     84e:	bf00      	nop
     850:	e000      	b.n	854 <tcp_write+0x458>
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
      goto memerr;
     852:	bf00      	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
     854:	68fb      	ldr	r3, [r7, #12]
     856:	7f9b      	ldrb	r3, [r3, #30]
     858:	f063 037f 	orn	r3, r3, #127	; 0x7f
     85c:	b2da      	uxtb	r2, r3
     85e:	68fb      	ldr	r3, [r7, #12]
     860:	779a      	strb	r2, [r3, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
     862:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     864:	2b00      	cmp	r3, #0
     866:	d002      	beq.n	86e <tcp_write+0x472>
    pbuf_free(concat_p);
     868:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
     86a:	f7ff fffe 	bl	0 <pbuf_free>
			86a: R_ARM_THM_CALL	pbuf_free
  }
  if (queue != NULL) {
     86e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     870:	2b00      	cmp	r3, #0
     872:	d002      	beq.n	87a <tcp_write+0x47e>
    tcp_segs_free(queue);
     874:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
     876:	f7ff fffe 	bl	0 <tcp_segs_free>
			876: R_ARM_THM_CALL	tcp_segs_free
  }
  if (pcb->snd_queuelen != 0) {
     87a:	68fb      	ldr	r3, [r7, #12]
     87c:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     880:	2b00      	cmp	r3, #0
     882:	d002      	beq.n	88a <tcp_write+0x48e>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
     884:	68fb      	ldr	r3, [r7, #12]
     886:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     888:	2b00      	cmp	r3, #0
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
     88a:	f04f 03ff 	mov.w	r3, #255	; 0xff
     88e:	b25b      	sxtb	r3, r3
}
     890:	4618      	mov	r0, r3
     892:	f107 0750 	add.w	r7, r7, #80	; 0x50
     896:	46bd      	mov	sp, r7
     898:	bdb0      	pop	{r4, r5, r7, pc}
     89a:	bf00      	nop

0000089c <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
     89c:	b590      	push	{r4, r7, lr}
     89e:	b08b      	sub	sp, #44	; 0x2c
     8a0:	af02      	add	r7, sp, #8
     8a2:	6078      	str	r0, [r7, #4]
     8a4:	460b      	mov	r3, r1
     8a6:	70fb      	strb	r3, [r7, #3]
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
     8a8:	f04f 0300 	mov.w	r3, #0
     8ac:	77fb      	strb	r3, [r7, #31]
  u8_t optlen = 0;
     8ae:	f04f 0300 	mov.w	r3, #0
     8b2:	75fb      	strb	r3, [r7, #23]

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
     8b4:	687b      	ldr	r3, [r7, #4]
     8b6:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     8ba:	2b07      	cmp	r3, #7
     8bc:	d806      	bhi.n	8cc <tcp_enqueue_flags+0x30>
     8be:	687b      	ldr	r3, [r7, #4]
     8c0:	f8b3 2068 	ldrh.w	r2, [r3, #104]	; 0x68
     8c4:	f64f 73fc 	movw	r3, #65532	; 0xfffc
     8c8:	429a      	cmp	r2, r3
     8ca:	d909      	bls.n	8e0 <tcp_enqueue_flags+0x44>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
                                       pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
     8cc:	687b      	ldr	r3, [r7, #4]
     8ce:	7f9b      	ldrb	r3, [r3, #30]
     8d0:	f063 037f 	orn	r3, r3, #127	; 0x7f
     8d4:	b2da      	uxtb	r2, r3
     8d6:	687b      	ldr	r3, [r7, #4]
     8d8:	779a      	strb	r2, [r3, #30]
    return ERR_MEM;
     8da:	f04f 03ff 	mov.w	r3, #255	; 0xff
     8de:	e0ae      	b.n	a3e <tcp_enqueue_flags+0x1a2>
  }

  if (flags & TCP_SYN) {
     8e0:	78fb      	ldrb	r3, [r7, #3]
     8e2:	f003 0302 	and.w	r3, r3, #2
     8e6:	2b00      	cmp	r3, #0
     8e8:	d002      	beq.n	8f0 <tcp_enqueue_flags+0x54>
    optflags = TF_SEG_OPTS_MSS;
     8ea:	f04f 0301 	mov.w	r3, #1
     8ee:	77fb      	strb	r3, [r7, #31]
#if LWIP_TCP_TIMESTAMPS
  if ((pcb->flags & TF_TIMESTAMP)) {
    optflags |= TF_SEG_OPTS_TS;
  }
#endif /* LWIP_TCP_TIMESTAMPS */
  optlen = LWIP_TCP_OPT_LENGTH(optflags);
     8f0:	7ffb      	ldrb	r3, [r7, #31]
     8f2:	f003 0301 	and.w	r3, r3, #1
     8f6:	b2db      	uxtb	r3, r3
     8f8:	2b00      	cmp	r3, #0
     8fa:	d002      	beq.n	902 <tcp_enqueue_flags+0x66>
     8fc:	f04f 0204 	mov.w	r2, #4
     900:	e001      	b.n	906 <tcp_enqueue_flags+0x6a>
     902:	f04f 0200 	mov.w	r2, #0
     906:	7ffb      	ldrb	r3, [r7, #31]
     908:	f003 0302 	and.w	r3, r3, #2
     90c:	2b00      	cmp	r3, #0
     90e:	d002      	beq.n	916 <tcp_enqueue_flags+0x7a>
     910:	f04f 030c 	mov.w	r3, #12
     914:	e001      	b.n	91a <tcp_enqueue_flags+0x7e>
     916:	f04f 0300 	mov.w	r3, #0
     91a:	18d3      	adds	r3, r2, r3
     91c:	75fb      	strb	r3, [r7, #23]

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
     91e:	687b      	ldr	r3, [r7, #4]
     920:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
     924:	2b00      	cmp	r3, #0
     926:	d102      	bne.n	92e <tcp_enqueue_flags+0x92>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
     928:	f04f 03ff 	mov.w	r3, #255	; 0xff
     92c:	e087      	b.n	a3e <tcp_enqueue_flags+0x1a2>
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
     92e:	7dfb      	ldrb	r3, [r7, #23]
     930:	b29b      	uxth	r3, r3
     932:	f04f 0000 	mov.w	r0, #0
     936:	4619      	mov	r1, r3
     938:	f04f 0200 	mov.w	r2, #0
     93c:	f7ff fffe 	bl	0 <pbuf_alloc>
			93c: R_ARM_THM_CALL	pbuf_alloc
     940:	6138      	str	r0, [r7, #16]
     942:	693b      	ldr	r3, [r7, #16]
     944:	2b00      	cmp	r3, #0
     946:	d109      	bne.n	95c <tcp_enqueue_flags+0xc0>
    pcb->flags |= TF_NAGLEMEMERR;
     948:	687b      	ldr	r3, [r7, #4]
     94a:	7f9b      	ldrb	r3, [r3, #30]
     94c:	f063 037f 	orn	r3, r3, #127	; 0x7f
     950:	b2da      	uxtb	r2, r3
     952:	687b      	ldr	r3, [r7, #4]
     954:	779a      	strb	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
     956:	f04f 03ff 	mov.w	r3, #255	; 0xff
     95a:	e070      	b.n	a3e <tcp_enqueue_flags+0x1a2>
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
     95c:	687b      	ldr	r3, [r7, #4]
     95e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
     960:	78fa      	ldrb	r2, [r7, #3]
     962:	7ff9      	ldrb	r1, [r7, #31]
     964:	9100      	str	r1, [sp, #0]
     966:	6878      	ldr	r0, [r7, #4]
     968:	6939      	ldr	r1, [r7, #16]
     96a:	f7ff fc01 	bl	170 <tcp_create_segment>
     96e:	60f8      	str	r0, [r7, #12]
     970:	68fb      	ldr	r3, [r7, #12]
     972:	2b00      	cmp	r3, #0
     974:	d109      	bne.n	98a <tcp_enqueue_flags+0xee>
    pcb->flags |= TF_NAGLEMEMERR;
     976:	687b      	ldr	r3, [r7, #4]
     978:	7f9b      	ldrb	r3, [r3, #30]
     97a:	f063 037f 	orn	r3, r3, #127	; 0x7f
     97e:	b2da      	uxtb	r2, r3
     980:	687b      	ldr	r3, [r7, #4]
     982:	779a      	strb	r2, [r3, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
     984:	f04f 03ff 	mov.w	r3, #255	; 0xff
     988:	e059      	b.n	a3e <tcp_enqueue_flags+0x1a2>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
     98a:	687b      	ldr	r3, [r7, #4]
     98c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     98e:	2b00      	cmp	r3, #0
     990:	d103      	bne.n	99a <tcp_enqueue_flags+0xfe>
    pcb->unsent = seg;
     992:	687b      	ldr	r3, [r7, #4]
     994:	68fa      	ldr	r2, [r7, #12]
     996:	66da      	str	r2, [r3, #108]	; 0x6c
     998:	e00d      	b.n	9b6 <tcp_enqueue_flags+0x11a>
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
     99a:	687b      	ldr	r3, [r7, #4]
     99c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     99e:	61bb      	str	r3, [r7, #24]
     9a0:	e002      	b.n	9a8 <tcp_enqueue_flags+0x10c>
     9a2:	69bb      	ldr	r3, [r7, #24]
     9a4:	681b      	ldr	r3, [r3, #0]
     9a6:	61bb      	str	r3, [r7, #24]
     9a8:	69bb      	ldr	r3, [r7, #24]
     9aa:	681b      	ldr	r3, [r3, #0]
     9ac:	2b00      	cmp	r3, #0
     9ae:	d1f8      	bne.n	9a2 <tcp_enqueue_flags+0x106>
    useg->next = seg;
     9b0:	69bb      	ldr	r3, [r7, #24]
     9b2:	68fa      	ldr	r2, [r7, #12]
     9b4:	601a      	str	r2, [r3, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
     9b6:	687b      	ldr	r3, [r7, #4]
     9b8:	f04f 0200 	mov.w	r2, #0
     9bc:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
     9c0:	78fb      	ldrb	r3, [r7, #3]
     9c2:	f003 0302 	and.w	r3, r3, #2
     9c6:	2b00      	cmp	r3, #0
     9c8:	d105      	bne.n	9d6 <tcp_enqueue_flags+0x13a>
     9ca:	78fb      	ldrb	r3, [r7, #3]
     9cc:	f003 0301 	and.w	r3, r3, #1
     9d0:	b2db      	uxtb	r3, r3
     9d2:	2b00      	cmp	r3, #0
     9d4:	d00e      	beq.n	9f4 <tcp_enqueue_flags+0x158>
    pcb->snd_lbb++;
     9d6:	687b      	ldr	r3, [r7, #4]
     9d8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
     9da:	f103 0201 	add.w	r2, r3, #1
     9de:	687b      	ldr	r3, [r7, #4]
     9e0:	65da      	str	r2, [r3, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
     9e2:	687b      	ldr	r3, [r7, #4]
     9e4:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
     9e8:	f103 33ff 	add.w	r3, r3, #4294967295
     9ec:	b29a      	uxth	r2, r3
     9ee:	687b      	ldr	r3, [r7, #4]
     9f0:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
     9f4:	78fb      	ldrb	r3, [r7, #3]
     9f6:	f003 0301 	and.w	r3, r3, #1
     9fa:	b2db      	uxtb	r3, r3
     9fc:	2b00      	cmp	r3, #0
     9fe:	d006      	beq.n	a0e <tcp_enqueue_flags+0x172>
    pcb->flags |= TF_FIN;
     a00:	687b      	ldr	r3, [r7, #4]
     a02:	7f9b      	ldrb	r3, [r3, #30]
     a04:	f043 0320 	orr.w	r3, r3, #32
     a08:	b2da      	uxtb	r2, r3
     a0a:	687b      	ldr	r3, [r7, #4]
     a0c:	779a      	strb	r2, [r3, #30]
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
     a0e:	687b      	ldr	r3, [r7, #4]
     a10:	f8b3 4068 	ldrh.w	r4, [r3, #104]	; 0x68
     a14:	68fb      	ldr	r3, [r7, #12]
     a16:	685b      	ldr	r3, [r3, #4]
     a18:	4618      	mov	r0, r3
     a1a:	f7ff fffe 	bl	0 <pbuf_clen>
			a1a: R_ARM_THM_CALL	pbuf_clen
     a1e:	4603      	mov	r3, r0
     a20:	18e3      	adds	r3, r4, r3
     a22:	b29a      	uxth	r2, r3
     a24:	687b      	ldr	r3, [r7, #4]
     a26:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
     a2a:	687b      	ldr	r3, [r7, #4]
     a2c:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     a30:	2b00      	cmp	r3, #0
     a32:	d002      	beq.n	a3a <tcp_enqueue_flags+0x19e>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
     a34:	687b      	ldr	r3, [r7, #4]
     a36:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     a38:	2b00      	cmp	r3, #0
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
     a3a:	f04f 0300 	mov.w	r3, #0
     a3e:	b25b      	sxtb	r3, r3
}
     a40:	4618      	mov	r0, r3
     a42:	f107 0724 	add.w	r7, r7, #36	; 0x24
     a46:	46bd      	mov	sp, r7
     a48:	bd90      	pop	{r4, r7, pc}
     a4a:	bf00      	nop

00000a4c <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
     a4c:	b590      	push	{r4, r7, lr}
     a4e:	b089      	sub	sp, #36	; 0x24
     a50:	af02      	add	r7, sp, #8
     a52:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;
     a54:	f04f 0300 	mov.w	r3, #0
     a58:	75fb      	strb	r3, [r7, #23]
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
     a5a:	7dfb      	ldrb	r3, [r7, #23]
     a5c:	b29c      	uxth	r4, r3
     a5e:	687b      	ldr	r3, [r7, #4]
     a60:	6d1b      	ldr	r3, [r3, #80]	; 0x50
     a62:	4618      	mov	r0, r3
     a64:	f7ff fffe 	bl	0 <lwip_htonl>
			a64: R_ARM_THM_CALL	lwip_htonl
     a68:	4603      	mov	r3, r0
     a6a:	6878      	ldr	r0, [r7, #4]
     a6c:	4621      	mov	r1, r4
     a6e:	f04f 0200 	mov.w	r2, #0
     a72:	f7ff fac5 	bl	0 <tcp_output_alloc_header>
     a76:	6138      	str	r0, [r7, #16]
  if (p == NULL) {
     a78:	693b      	ldr	r3, [r7, #16]
     a7a:	2b00      	cmp	r3, #0
     a7c:	d102      	bne.n	a84 <tcp_send_empty_ack+0x38>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
     a7e:	f04f 03fe 	mov.w	r3, #254	; 0xfe
     a82:	e01d      	b.n	ac0 <tcp_send_empty_ack+0x74>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
     a84:	693b      	ldr	r3, [r7, #16]
     a86:	685b      	ldr	r3, [r3, #4]
     a88:	60fb      	str	r3, [r7, #12]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
     a8a:	687b      	ldr	r3, [r7, #4]
     a8c:	7f9b      	ldrb	r3, [r3, #30]
     a8e:	f023 0303 	bic.w	r3, r3, #3
     a92:	b2da      	uxtb	r2, r3
     a94:	687b      	ldr	r3, [r7, #4]
     a96:	779a      	strb	r2, [r3, #30]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
     a98:	6879      	ldr	r1, [r7, #4]
     a9a:	687b      	ldr	r3, [r7, #4]
     a9c:	f103 0204 	add.w	r2, r3, #4
     aa0:	687b      	ldr	r3, [r7, #4]
     aa2:	7a9b      	ldrb	r3, [r3, #10]
     aa4:	6878      	ldr	r0, [r7, #4]
     aa6:	7a40      	ldrb	r0, [r0, #9]
     aa8:	9000      	str	r0, [sp, #0]
     aaa:	f04f 0006 	mov.w	r0, #6
     aae:	9001      	str	r0, [sp, #4]
     ab0:	6938      	ldr	r0, [r7, #16]
     ab2:	f7ff fffe 	bl	0 <ip_output>
			ab2: R_ARM_THM_CALL	ip_output
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
     ab6:	6938      	ldr	r0, [r7, #16]
     ab8:	f7ff fffe 	bl	0 <pbuf_free>
			ab8: R_ARM_THM_CALL	pbuf_free

  return ERR_OK;
     abc:	f04f 0300 	mov.w	r3, #0
     ac0:	b25b      	sxtb	r3, r3
}
     ac2:	4618      	mov	r0, r3
     ac4:	f107 071c 	add.w	r7, r7, #28
     ac8:	46bd      	mov	sp, r7
     aca:	bd90      	pop	{r4, r7, pc}

00000acc <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
     acc:	b5b0      	push	{r4, r5, r7, lr}
     ace:	b088      	sub	sp, #32
     ad0:	af00      	add	r7, sp, #0
     ad2:	6078      	str	r0, [r7, #4]

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
     ad4:	4b7d      	ldr	r3, [pc, #500]	; (ccc <tcp_output+0x200>)
     ad6:	681a      	ldr	r2, [r3, #0]
     ad8:	687b      	ldr	r3, [r7, #4]
     ada:	429a      	cmp	r2, r3
     adc:	d102      	bne.n	ae4 <tcp_output+0x18>
    return ERR_OK;
     ade:	f04f 0300 	mov.w	r3, #0
     ae2:	e14b      	b.n	d7c <tcp_output+0x2b0>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
     ae4:	687b      	ldr	r3, [r7, #4]
     ae6:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
     aea:	687b      	ldr	r3, [r7, #4]
     aec:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
     af0:	429a      	cmp	r2, r3
     af2:	bf38      	it	cc
     af4:	4613      	movcc	r3, r2
     af6:	b29b      	uxth	r3, r3
     af8:	613b      	str	r3, [r7, #16]

  seg = pcb->unsent;
     afa:	687b      	ldr	r3, [r7, #4]
     afc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     afe:	61fb      	str	r3, [r7, #28]
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     b00:	687b      	ldr	r3, [r7, #4]
     b02:	7f9b      	ldrb	r3, [r3, #30]
     b04:	f003 0302 	and.w	r3, r3, #2
     b08:	2b00      	cmp	r3, #0
     b0a:	d017      	beq.n	b3c <tcp_output+0x70>
     b0c:	69fb      	ldr	r3, [r7, #28]
     b0e:	2b00      	cmp	r3, #0
     b10:	d00f      	beq.n	b32 <tcp_output+0x66>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     b12:	69fb      	ldr	r3, [r7, #28]
     b14:	68db      	ldr	r3, [r3, #12]
     b16:	685b      	ldr	r3, [r3, #4]
     b18:	4618      	mov	r0, r3
     b1a:	f7ff fffe 	bl	0 <lwip_ntohl>
			b1a: R_ARM_THM_CALL	lwip_ntohl
     b1e:	4602      	mov	r2, r0
     b20:	687b      	ldr	r3, [r7, #4]
     b22:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     b24:	1ad2      	subs	r2, r2, r3
     b26:	69fb      	ldr	r3, [r7, #28]
     b28:	891b      	ldrh	r3, [r3, #8]
     b2a:	18d2      	adds	r2, r2, r3
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
     b2c:	693b      	ldr	r3, [r7, #16]
     b2e:	429a      	cmp	r2, r3
     b30:	d904      	bls.n	b3c <tcp_output+0x70>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
     b32:	6878      	ldr	r0, [r7, #4]
     b34:	f7ff fffe 	bl	a4c <tcp_send_empty_ack>
			b34: R_ARM_THM_CALL	tcp_send_empty_ack
     b38:	4603      	mov	r3, r0
     b3a:	e11f      	b.n	d7c <tcp_output+0x2b0>
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
     b3c:	687b      	ldr	r3, [r7, #4]
     b3e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     b40:	61bb      	str	r3, [r7, #24]
  if (useg != NULL) {
     b42:	69bb      	ldr	r3, [r7, #24]
     b44:	2b00      	cmp	r3, #0
     b46:	f000 80f1 	beq.w	d2c <tcp_output+0x260>
    for (; useg->next != NULL; useg = useg->next);
     b4a:	e002      	b.n	b52 <tcp_output+0x86>
     b4c:	69bb      	ldr	r3, [r7, #24]
     b4e:	681b      	ldr	r3, [r3, #0]
     b50:	61bb      	str	r3, [r7, #24]
     b52:	69bb      	ldr	r3, [r7, #24]
     b54:	681b      	ldr	r3, [r3, #0]
     b56:	2b00      	cmp	r3, #0
     b58:	d1f8      	bne.n	b4c <tcp_output+0x80>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
     b5a:	e0e7      	b.n	d2c <tcp_output+0x260>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
     b5c:	69fb      	ldr	r3, [r7, #28]
     b5e:	68db      	ldr	r3, [r3, #12]
     b60:	899b      	ldrh	r3, [r3, #12]
     b62:	b29b      	uxth	r3, r3
     b64:	4618      	mov	r0, r3
     b66:	f7ff fffe 	bl	0 <lwip_ntohs>
			b66: R_ARM_THM_CALL	lwip_ntohs
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
     b6a:	687b      	ldr	r3, [r7, #4]
     b6c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     b6e:	2b00      	cmp	r3, #0
     b70:	d01f      	beq.n	bb2 <tcp_output+0xe6>
     b72:	687b      	ldr	r3, [r7, #4]
     b74:	7f9b      	ldrb	r3, [r3, #30]
     b76:	f003 0344 	and.w	r3, r3, #68	; 0x44
     b7a:	2b00      	cmp	r3, #0
     b7c:	d119      	bne.n	bb2 <tcp_output+0xe6>
     b7e:	687b      	ldr	r3, [r7, #4]
     b80:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     b82:	2b00      	cmp	r3, #0
     b84:	d00b      	beq.n	b9e <tcp_output+0xd2>
     b86:	687b      	ldr	r3, [r7, #4]
     b88:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     b8a:	681b      	ldr	r3, [r3, #0]
     b8c:	2b00      	cmp	r3, #0
     b8e:	d110      	bne.n	bb2 <tcp_output+0xe6>
     b90:	687b      	ldr	r3, [r7, #4]
     b92:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     b94:	891a      	ldrh	r2, [r3, #8]
     b96:	687b      	ldr	r3, [r7, #4]
     b98:	8edb      	ldrh	r3, [r3, #54]	; 0x36
     b9a:	429a      	cmp	r2, r3
     b9c:	d209      	bcs.n	bb2 <tcp_output+0xe6>
     b9e:	687b      	ldr	r3, [r7, #4]
     ba0:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
     ba4:	2b00      	cmp	r3, #0
     ba6:	d004      	beq.n	bb2 <tcp_output+0xe6>
     ba8:	687b      	ldr	r3, [r7, #4]
     baa:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
     bae:	2b07      	cmp	r3, #7
     bb0:	d902      	bls.n	bb8 <tcp_output+0xec>
     bb2:	f04f 0301 	mov.w	r3, #1
     bb6:	e001      	b.n	bbc <tcp_output+0xf0>
     bb8:	f04f 0300 	mov.w	r3, #0
     bbc:	2b00      	cmp	r3, #0
     bbe:	d106      	bne.n	bce <tcp_output+0x102>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
     bc0:	687b      	ldr	r3, [r7, #4]
     bc2:	7f9b      	ldrb	r3, [r3, #30]
     bc4:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
     bc8:	2b00      	cmp	r3, #0
     bca:	f000 80c4 	beq.w	d56 <tcp_output+0x28a>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
     bce:	69fb      	ldr	r3, [r7, #28]
     bd0:	681a      	ldr	r2, [r3, #0]
     bd2:	687b      	ldr	r3, [r7, #4]
     bd4:	66da      	str	r2, [r3, #108]	; 0x6c

    if (pcb->state != SYN_SENT) {
     bd6:	687b      	ldr	r3, [r7, #4]
     bd8:	7e1b      	ldrb	r3, [r3, #24]
     bda:	2b02      	cmp	r3, #2
     bdc:	d015      	beq.n	c0a <tcp_output+0x13e>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
     bde:	69fb      	ldr	r3, [r7, #28]
     be0:	68dc      	ldr	r4, [r3, #12]
     be2:	69fb      	ldr	r3, [r7, #28]
     be4:	68db      	ldr	r3, [r3, #12]
     be6:	899b      	ldrh	r3, [r3, #12]
     be8:	b29d      	uxth	r5, r3
     bea:	f04f 0010 	mov.w	r0, #16
     bee:	f7ff fffe 	bl	0 <lwip_htons>
			bee: R_ARM_THM_CALL	lwip_htons
     bf2:	4603      	mov	r3, r0
     bf4:	ea45 0303 	orr.w	r3, r5, r3
     bf8:	b29b      	uxth	r3, r3
     bfa:	81a3      	strh	r3, [r4, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
     bfc:	687b      	ldr	r3, [r7, #4]
     bfe:	7f9b      	ldrb	r3, [r3, #30]
     c00:	f023 0303 	bic.w	r3, r3, #3
     c04:	b2da      	uxtb	r2, r3
     c06:	687b      	ldr	r3, [r7, #4]
     c08:	779a      	strb	r2, [r3, #30]
    }

    tcp_output_segment(seg, pcb);
     c0a:	69f8      	ldr	r0, [r7, #28]
     c0c:	6879      	ldr	r1, [r7, #4]
     c0e:	f000 f8bb 	bl	d88 <tcp_output_segment>
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
     c12:	69fb      	ldr	r3, [r7, #28]
     c14:	68db      	ldr	r3, [r3, #12]
     c16:	685b      	ldr	r3, [r3, #4]
     c18:	4618      	mov	r0, r3
     c1a:	f7ff fffe 	bl	0 <lwip_ntohl>
			c1a: R_ARM_THM_CALL	lwip_ntohl
     c1e:	4604      	mov	r4, r0
     c20:	69fb      	ldr	r3, [r7, #28]
     c22:	891b      	ldrh	r3, [r3, #8]
     c24:	461d      	mov	r5, r3
     c26:	69fb      	ldr	r3, [r7, #28]
     c28:	68db      	ldr	r3, [r3, #12]
     c2a:	899b      	ldrh	r3, [r3, #12]
     c2c:	b29b      	uxth	r3, r3
     c2e:	4618      	mov	r0, r3
     c30:	f7ff fffe 	bl	0 <lwip_ntohs>
			c30: R_ARM_THM_CALL	lwip_ntohs
     c34:	4603      	mov	r3, r0
     c36:	f003 0303 	and.w	r3, r3, #3
     c3a:	2b00      	cmp	r3, #0
     c3c:	bf0c      	ite	eq
     c3e:	2300      	moveq	r3, #0
     c40:	2301      	movne	r3, #1
     c42:	18eb      	adds	r3, r5, r3
     c44:	18e3      	adds	r3, r4, r3
     c46:	60fb      	str	r3, [r7, #12]
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
     c48:	687b      	ldr	r3, [r7, #4]
     c4a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
     c4c:	68fb      	ldr	r3, [r7, #12]
     c4e:	1ad3      	subs	r3, r2, r3
     c50:	2b00      	cmp	r3, #0
     c52:	da02      	bge.n	c5a <tcp_output+0x18e>
      pcb->snd_nxt = snd_nxt;
     c54:	687b      	ldr	r3, [r7, #4]
     c56:	68fa      	ldr	r2, [r7, #12]
     c58:	651a      	str	r2, [r3, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
     c5a:	69fb      	ldr	r3, [r7, #28]
     c5c:	891b      	ldrh	r3, [r3, #8]
     c5e:	461c      	mov	r4, r3
     c60:	69fb      	ldr	r3, [r7, #28]
     c62:	68db      	ldr	r3, [r3, #12]
     c64:	899b      	ldrh	r3, [r3, #12]
     c66:	b29b      	uxth	r3, r3
     c68:	4618      	mov	r0, r3
     c6a:	f7ff fffe 	bl	0 <lwip_ntohs>
			c6a: R_ARM_THM_CALL	lwip_ntohs
     c6e:	4603      	mov	r3, r0
     c70:	f003 0303 	and.w	r3, r3, #3
     c74:	2b00      	cmp	r3, #0
     c76:	bf0c      	ite	eq
     c78:	2300      	moveq	r3, #0
     c7a:	2301      	movne	r3, #1
     c7c:	18e3      	adds	r3, r4, r3
     c7e:	2b00      	cmp	r3, #0
     c80:	dd4e      	ble.n	d20 <tcp_output+0x254>
      seg->next = NULL;
     c82:	69fb      	ldr	r3, [r7, #28]
     c84:	f04f 0200 	mov.w	r2, #0
     c88:	601a      	str	r2, [r3, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
     c8a:	687b      	ldr	r3, [r7, #4]
     c8c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     c8e:	2b00      	cmp	r3, #0
     c90:	d105      	bne.n	c9e <tcp_output+0x1d2>
        pcb->unacked = seg;
     c92:	687b      	ldr	r3, [r7, #4]
     c94:	69fa      	ldr	r2, [r7, #28]
     c96:	671a      	str	r2, [r3, #112]	; 0x70
        useg = seg;
     c98:	69fb      	ldr	r3, [r7, #28]
     c9a:	61bb      	str	r3, [r7, #24]
     c9c:	e043      	b.n	d26 <tcp_output+0x25a>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
     c9e:	69fb      	ldr	r3, [r7, #28]
     ca0:	68db      	ldr	r3, [r3, #12]
     ca2:	685b      	ldr	r3, [r3, #4]
     ca4:	4618      	mov	r0, r3
     ca6:	f7ff fffe 	bl	0 <lwip_ntohl>
			ca6: R_ARM_THM_CALL	lwip_ntohl
     caa:	4604      	mov	r4, r0
     cac:	69bb      	ldr	r3, [r7, #24]
     cae:	68db      	ldr	r3, [r3, #12]
     cb0:	685b      	ldr	r3, [r3, #4]
     cb2:	4618      	mov	r0, r3
     cb4:	f7ff fffe 	bl	0 <lwip_ntohl>
			cb4: R_ARM_THM_CALL	lwip_ntohl
     cb8:	4603      	mov	r3, r0
     cba:	1ae3      	subs	r3, r4, r3
     cbc:	2b00      	cmp	r3, #0
     cbe:	da28      	bge.n	d12 <tcp_output+0x246>
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
     cc0:	687b      	ldr	r3, [r7, #4]
     cc2:	f103 0370 	add.w	r3, r3, #112	; 0x70
     cc6:	617b      	str	r3, [r7, #20]
          while (*cur_seg &&
     cc8:	e005      	b.n	cd6 <tcp_output+0x20a>
     cca:	bf00      	nop
     ccc:	00000000 	.word	0x00000000
			ccc: R_ARM_ABS32	tcp_input_pcb
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
     cd0:	697b      	ldr	r3, [r7, #20]
     cd2:	681b      	ldr	r3, [r3, #0]
     cd4:	617b      	str	r3, [r7, #20]
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
     cd6:	697b      	ldr	r3, [r7, #20]
     cd8:	681b      	ldr	r3, [r3, #0]
     cda:	2b00      	cmp	r3, #0
     cdc:	d011      	beq.n	d02 <tcp_output+0x236>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
     cde:	697b      	ldr	r3, [r7, #20]
     ce0:	681b      	ldr	r3, [r3, #0]
     ce2:	68db      	ldr	r3, [r3, #12]
     ce4:	685b      	ldr	r3, [r3, #4]
     ce6:	4618      	mov	r0, r3
     ce8:	f7ff fffe 	bl	0 <lwip_ntohl>
			ce8: R_ARM_THM_CALL	lwip_ntohl
     cec:	4604      	mov	r4, r0
     cee:	69fb      	ldr	r3, [r7, #28]
     cf0:	68db      	ldr	r3, [r3, #12]
     cf2:	685b      	ldr	r3, [r3, #4]
     cf4:	4618      	mov	r0, r3
     cf6:	f7ff fffe 	bl	0 <lwip_ntohl>
			cf6: R_ARM_THM_CALL	lwip_ntohl
     cfa:	4603      	mov	r3, r0
     cfc:	1ae3      	subs	r3, r4, r3
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
     cfe:	2b00      	cmp	r3, #0
     d00:	dbe6      	blt.n	cd0 <tcp_output+0x204>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
     d02:	697b      	ldr	r3, [r7, #20]
     d04:	681a      	ldr	r2, [r3, #0]
     d06:	69fb      	ldr	r3, [r7, #28]
     d08:	601a      	str	r2, [r3, #0]
          (*cur_seg) = seg;
     d0a:	697b      	ldr	r3, [r7, #20]
     d0c:	69fa      	ldr	r2, [r7, #28]
     d0e:	601a      	str	r2, [r3, #0]
     d10:	e009      	b.n	d26 <tcp_output+0x25a>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
     d12:	69bb      	ldr	r3, [r7, #24]
     d14:	69fa      	ldr	r2, [r7, #28]
     d16:	601a      	str	r2, [r3, #0]
          useg = useg->next;
     d18:	69bb      	ldr	r3, [r7, #24]
     d1a:	681b      	ldr	r3, [r3, #0]
     d1c:	61bb      	str	r3, [r7, #24]
     d1e:	e002      	b.n	d26 <tcp_output+0x25a>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
     d20:	69f8      	ldr	r0, [r7, #28]
     d22:	f7ff fffe 	bl	0 <tcp_seg_free>
			d22: R_ARM_THM_CALL	tcp_seg_free
    }
    seg = pcb->unsent;
     d26:	687b      	ldr	r3, [r7, #4]
     d28:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     d2a:	61fb      	str	r3, [r7, #28]
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
     d2c:	69fb      	ldr	r3, [r7, #28]
     d2e:	2b00      	cmp	r3, #0
     d30:	d012      	beq.n	d58 <tcp_output+0x28c>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
     d32:	69fb      	ldr	r3, [r7, #28]
     d34:	68db      	ldr	r3, [r3, #12]
     d36:	685b      	ldr	r3, [r3, #4]
     d38:	4618      	mov	r0, r3
     d3a:	f7ff fffe 	bl	0 <lwip_ntohl>
			d3a: R_ARM_THM_CALL	lwip_ntohl
     d3e:	4602      	mov	r2, r0
     d40:	687b      	ldr	r3, [r7, #4]
     d42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
     d44:	1ad2      	subs	r2, r2, r3
     d46:	69fb      	ldr	r3, [r7, #28]
     d48:	891b      	ldrh	r3, [r3, #8]
     d4a:	18d2      	adds	r2, r2, r3
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
     d4c:	693b      	ldr	r3, [r7, #16]
     d4e:	429a      	cmp	r2, r3
     d50:	f67f af04 	bls.w	b5c <tcp_output+0x90>
     d54:	e000      	b.n	d58 <tcp_output+0x28c>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
     d56:	bf00      	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
     d58:	687b      	ldr	r3, [r7, #4]
     d5a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
     d5c:	2b00      	cmp	r3, #0
     d5e:	d104      	bne.n	d6a <tcp_output+0x29e>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
     d60:	687b      	ldr	r3, [r7, #4]
     d62:	f04f 0200 	mov.w	r2, #0
     d66:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
     d6a:	687b      	ldr	r3, [r7, #4]
     d6c:	7f9b      	ldrb	r3, [r3, #30]
     d6e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     d72:	b2da      	uxtb	r2, r3
     d74:	687b      	ldr	r3, [r7, #4]
     d76:	779a      	strb	r2, [r3, #30]
  return ERR_OK;
     d78:	f04f 0300 	mov.w	r3, #0
     d7c:	b25b      	sxtb	r3, r3
}
     d7e:	4618      	mov	r0, r3
     d80:	f107 0720 	add.w	r7, r7, #32
     d84:	46bd      	mov	sp, r7
     d86:	bdb0      	pop	{r4, r5, r7, pc}

00000d88 <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
     d88:	b590      	push	{r4, r7, lr}
     d8a:	b089      	sub	sp, #36	; 0x24
     d8c:	af02      	add	r7, sp, #8
     d8e:	6078      	str	r0, [r7, #4]
     d90:	6039      	str	r1, [r7, #0]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
     d92:	687b      	ldr	r3, [r7, #4]
     d94:	68dc      	ldr	r4, [r3, #12]
     d96:	683b      	ldr	r3, [r7, #0]
     d98:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     d9a:	4618      	mov	r0, r3
     d9c:	f7ff fffe 	bl	0 <lwip_htonl>
			d9c: R_ARM_THM_CALL	lwip_htonl
     da0:	4603      	mov	r3, r0
     da2:	60a3      	str	r3, [r4, #8]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
     da4:	687b      	ldr	r3, [r7, #4]
     da6:	68dc      	ldr	r4, [r3, #12]
     da8:	683b      	ldr	r3, [r7, #0]
     daa:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
     dac:	4618      	mov	r0, r3
     dae:	f7ff fffe 	bl	0 <lwip_htons>
			dae: R_ARM_THM_CALL	lwip_htons
     db2:	4603      	mov	r3, r0
     db4:	81e3      	strh	r3, [r4, #14]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
     db6:	683b      	ldr	r3, [r7, #0]
     db8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     dba:	683b      	ldr	r3, [r7, #0]
     dbc:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
     dbe:	18d2      	adds	r2, r2, r3
     dc0:	683b      	ldr	r3, [r7, #0]
     dc2:	631a      	str	r2, [r3, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
     dc4:	687b      	ldr	r3, [r7, #4]
     dc6:	68db      	ldr	r3, [r3, #12]
     dc8:	f103 0314 	add.w	r3, r3, #20
     dcc:	617b      	str	r3, [r7, #20]
  if (seg->flags & TF_SEG_OPTS_MSS) {
     dce:	687b      	ldr	r3, [r7, #4]
     dd0:	7a9b      	ldrb	r3, [r3, #10]
     dd2:	f003 0301 	and.w	r3, r3, #1
     dd6:	b2db      	uxtb	r3, r3
     dd8:	2b00      	cmp	r3, #0
     dda:	d016      	beq.n	e0a <tcp_output_segment+0x82>
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
     ddc:	683b      	ldr	r3, [r7, #0]
     dde:	f103 0304 	add.w	r3, r3, #4
     de2:	f240 50dc 	movw	r0, #1500	; 0x5dc
     de6:	4619      	mov	r1, r3
     de8:	f7ff fffe 	bl	0 <tcp_eff_send_mss>
			de8: R_ARM_THM_CALL	tcp_eff_send_mss
     dec:	4603      	mov	r3, r0
     dee:	827b      	strh	r3, [r7, #18]
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
     df0:	8a7b      	ldrh	r3, [r7, #18]
     df2:	f043 7301 	orr.w	r3, r3, #33816576	; 0x2040000
     df6:	4618      	mov	r0, r3
     df8:	f7ff fffe 	bl	0 <lwip_htonl>
			df8: R_ARM_THM_CALL	lwip_htonl
     dfc:	4602      	mov	r2, r0
     dfe:	697b      	ldr	r3, [r7, #20]
     e00:	601a      	str	r2, [r3, #0]
    opts += 1;
     e02:	697b      	ldr	r3, [r7, #20]
     e04:	f103 0304 	add.w	r3, r3, #4
     e08:	617b      	str	r3, [r7, #20]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
     e0a:	683b      	ldr	r3, [r7, #0]
     e0c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
     e0e:	b21b      	sxth	r3, r3
     e10:	f1b3 3fff 	cmp.w	r3, #4294967295
     e14:	d103      	bne.n	e1e <tcp_output_segment+0x96>
    pcb->rtime = 0;
     e16:	683b      	ldr	r3, [r7, #0]
     e18:	f04f 0200 	mov.w	r2, #0
     e1c:	869a      	strh	r2, [r3, #52]	; 0x34
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
     e1e:	683b      	ldr	r3, [r7, #0]
     e20:	2b00      	cmp	r3, #0
     e22:	d003      	beq.n	e2c <tcp_output_segment+0xa4>
     e24:	683b      	ldr	r3, [r7, #0]
     e26:	681b      	ldr	r3, [r3, #0]
     e28:	2b00      	cmp	r3, #0
     e2a:	d10d      	bne.n	e48 <tcp_output_segment+0xc0>
    netif = ip_route(&(pcb->remote_ip));
     e2c:	683b      	ldr	r3, [r7, #0]
     e2e:	f103 0304 	add.w	r3, r3, #4
     e32:	4618      	mov	r0, r3
     e34:	f7ff fffe 	bl	0 <ip_route>
			e34: R_ARM_THM_CALL	ip_route
     e38:	60f8      	str	r0, [r7, #12]
    if (netif == NULL) {
     e3a:	68fb      	ldr	r3, [r7, #12]
     e3c:	2b00      	cmp	r3, #0
     e3e:	d04d      	beq.n	edc <tcp_output_segment+0x154>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
     e40:	68fb      	ldr	r3, [r7, #12]
     e42:	685a      	ldr	r2, [r3, #4]
     e44:	683b      	ldr	r3, [r7, #0]
     e46:	601a      	str	r2, [r3, #0]
  }

  if (pcb->rttest == 0) {
     e48:	683b      	ldr	r3, [r7, #0]
     e4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     e4c:	2b00      	cmp	r3, #0
     e4e:	d10c      	bne.n	e6a <tcp_output_segment+0xe2>
    pcb->rttest = tcp_ticks;
     e50:	4b25      	ldr	r3, [pc, #148]	; (ee8 <tcp_output_segment+0x160>)
     e52:	681a      	ldr	r2, [r3, #0]
     e54:	683b      	ldr	r3, [r7, #0]
     e56:	639a      	str	r2, [r3, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
     e58:	687b      	ldr	r3, [r7, #4]
     e5a:	68db      	ldr	r3, [r3, #12]
     e5c:	685b      	ldr	r3, [r3, #4]
     e5e:	4618      	mov	r0, r3
     e60:	f7ff fffe 	bl	0 <lwip_ntohl>
			e60: R_ARM_THM_CALL	lwip_ntohl
     e64:	4602      	mov	r2, r0
     e66:	683b      	ldr	r3, [r7, #0]
     e68:	63da      	str	r2, [r3, #60]	; 0x3c
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
     e6a:	687b      	ldr	r3, [r7, #4]
     e6c:	68db      	ldr	r3, [r3, #12]
     e6e:	b29a      	uxth	r2, r3
     e70:	687b      	ldr	r3, [r7, #4]
     e72:	685b      	ldr	r3, [r3, #4]
     e74:	685b      	ldr	r3, [r3, #4]
     e76:	b29b      	uxth	r3, r3
     e78:	1ad3      	subs	r3, r2, r3
     e7a:	817b      	strh	r3, [r7, #10]

  seg->p->len -= len;
     e7c:	687b      	ldr	r3, [r7, #4]
     e7e:	685b      	ldr	r3, [r3, #4]
     e80:	687a      	ldr	r2, [r7, #4]
     e82:	6852      	ldr	r2, [r2, #4]
     e84:	8951      	ldrh	r1, [r2, #10]
     e86:	897a      	ldrh	r2, [r7, #10]
     e88:	1a8a      	subs	r2, r1, r2
     e8a:	b292      	uxth	r2, r2
     e8c:	815a      	strh	r2, [r3, #10]
  seg->p->tot_len -= len;
     e8e:	687b      	ldr	r3, [r7, #4]
     e90:	685b      	ldr	r3, [r3, #4]
     e92:	687a      	ldr	r2, [r7, #4]
     e94:	6852      	ldr	r2, [r2, #4]
     e96:	8911      	ldrh	r1, [r2, #8]
     e98:	897a      	ldrh	r2, [r7, #10]
     e9a:	1a8a      	subs	r2, r1, r2
     e9c:	b292      	uxth	r2, r2
     e9e:	811a      	strh	r2, [r3, #8]

  seg->p->payload = seg->tcphdr;
     ea0:	687b      	ldr	r3, [r7, #4]
     ea2:	685b      	ldr	r3, [r3, #4]
     ea4:	687a      	ldr	r2, [r7, #4]
     ea6:	68d2      	ldr	r2, [r2, #12]
     ea8:	605a      	str	r2, [r3, #4]

  seg->tcphdr->chksum = 0;
     eaa:	687b      	ldr	r3, [r7, #4]
     eac:	68db      	ldr	r3, [r3, #12]
     eae:	f04f 0200 	mov.w	r2, #0
     eb2:	741a      	strb	r2, [r3, #16]
     eb4:	f04f 0200 	mov.w	r2, #0
     eb8:	745a      	strb	r2, [r3, #17]

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
     eba:	687b      	ldr	r3, [r7, #4]
     ebc:	6858      	ldr	r0, [r3, #4]
     ebe:	6839      	ldr	r1, [r7, #0]
     ec0:	683b      	ldr	r3, [r7, #0]
     ec2:	f103 0204 	add.w	r2, r3, #4
     ec6:	683b      	ldr	r3, [r7, #0]
     ec8:	7a9b      	ldrb	r3, [r3, #10]
     eca:	683c      	ldr	r4, [r7, #0]
     ecc:	7a64      	ldrb	r4, [r4, #9]
     ece:	9400      	str	r4, [sp, #0]
     ed0:	f04f 0406 	mov.w	r4, #6
     ed4:	9401      	str	r4, [sp, #4]
     ed6:	f7ff fffe 	bl	0 <ip_output>
			ed6: R_ARM_THM_CALL	ip_output
     eda:	e000      	b.n	ede <tcp_output_segment+0x156>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
     edc:	bf00      	nop
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
     ede:	f107 071c 	add.w	r7, r7, #28
     ee2:	46bd      	mov	sp, r7
     ee4:	bd90      	pop	{r4, r7, pc}
     ee6:	bf00      	nop
     ee8:	00000000 	.word	0x00000000
			ee8: R_ARM_ABS32	tcp_ticks

00000eec <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
     eec:	b580      	push	{r7, lr}
     eee:	b088      	sub	sp, #32
     ef0:	af02      	add	r7, sp, #8
     ef2:	60f8      	str	r0, [r7, #12]
     ef4:	60b9      	str	r1, [r7, #8]
     ef6:	607a      	str	r2, [r7, #4]
     ef8:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
     efa:	f04f 0001 	mov.w	r0, #1
     efe:	f04f 0114 	mov.w	r1, #20
     f02:	f04f 0200 	mov.w	r2, #0
     f06:	f7ff fffe 	bl	0 <pbuf_alloc>
			f06: R_ARM_THM_CALL	pbuf_alloc
     f0a:	6178      	str	r0, [r7, #20]
  if (p == NULL) {
     f0c:	697b      	ldr	r3, [r7, #20]
     f0e:	2b00      	cmp	r3, #0
     f10:	d050      	beq.n	fb4 <tcp_rst+0xc8>
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
     f12:	697b      	ldr	r3, [r7, #20]
     f14:	685b      	ldr	r3, [r3, #4]
     f16:	613b      	str	r3, [r7, #16]
  tcphdr->src = htons(local_port);
     f18:	8c3b      	ldrh	r3, [r7, #32]
     f1a:	4618      	mov	r0, r3
     f1c:	f7ff fffe 	bl	0 <lwip_htons>
			f1c: R_ARM_THM_CALL	lwip_htons
     f20:	4603      	mov	r3, r0
     f22:	461a      	mov	r2, r3
     f24:	693b      	ldr	r3, [r7, #16]
     f26:	801a      	strh	r2, [r3, #0]
  tcphdr->dest = htons(remote_port);
     f28:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
     f2a:	4618      	mov	r0, r3
     f2c:	f7ff fffe 	bl	0 <lwip_htons>
			f2c: R_ARM_THM_CALL	lwip_htons
     f30:	4603      	mov	r3, r0
     f32:	461a      	mov	r2, r3
     f34:	693b      	ldr	r3, [r7, #16]
     f36:	805a      	strh	r2, [r3, #2]
  tcphdr->seqno = htonl(seqno);
     f38:	68f8      	ldr	r0, [r7, #12]
     f3a:	f7ff fffe 	bl	0 <lwip_htonl>
			f3a: R_ARM_THM_CALL	lwip_htonl
     f3e:	4602      	mov	r2, r0
     f40:	693b      	ldr	r3, [r7, #16]
     f42:	605a      	str	r2, [r3, #4]
  tcphdr->ackno = htonl(ackno);
     f44:	68b8      	ldr	r0, [r7, #8]
     f46:	f7ff fffe 	bl	0 <lwip_htonl>
			f46: R_ARM_THM_CALL	lwip_htonl
     f4a:	4602      	mov	r2, r0
     f4c:	693b      	ldr	r3, [r7, #16]
     f4e:	609a      	str	r2, [r3, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
     f50:	f245 0014 	movw	r0, #20500	; 0x5014
     f54:	f7ff fffe 	bl	0 <lwip_htons>
			f54: R_ARM_THM_CALL	lwip_htons
     f58:	4603      	mov	r3, r0
     f5a:	461a      	mov	r2, r3
     f5c:	693b      	ldr	r3, [r7, #16]
     f5e:	819a      	strh	r2, [r3, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
     f60:	693b      	ldr	r3, [r7, #16]
     f62:	f04f 0200 	mov.w	r2, #0
     f66:	f042 0217 	orr.w	r2, r2, #23
     f6a:	739a      	strb	r2, [r3, #14]
     f6c:	f04f 0200 	mov.w	r2, #0
     f70:	f042 0270 	orr.w	r2, r2, #112	; 0x70
     f74:	73da      	strb	r2, [r3, #15]
  tcphdr->chksum = 0;
     f76:	693b      	ldr	r3, [r7, #16]
     f78:	f04f 0200 	mov.w	r2, #0
     f7c:	741a      	strb	r2, [r3, #16]
     f7e:	f04f 0200 	mov.w	r2, #0
     f82:	745a      	strb	r2, [r3, #17]
  tcphdr->urgp = 0;
     f84:	693b      	ldr	r3, [r7, #16]
     f86:	f04f 0200 	mov.w	r2, #0
     f8a:	749a      	strb	r2, [r3, #18]
     f8c:	f04f 0200 	mov.w	r2, #0
     f90:	74da      	strb	r2, [r3, #19]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
     f92:	f04f 0300 	mov.w	r3, #0
     f96:	9300      	str	r3, [sp, #0]
     f98:	f04f 0306 	mov.w	r3, #6
     f9c:	9301      	str	r3, [sp, #4]
     f9e:	6978      	ldr	r0, [r7, #20]
     fa0:	6879      	ldr	r1, [r7, #4]
     fa2:	683a      	ldr	r2, [r7, #0]
     fa4:	f04f 03ff 	mov.w	r3, #255	; 0xff
     fa8:	f7ff fffe 	bl	0 <ip_output>
			fa8: R_ARM_THM_CALL	ip_output
  pbuf_free(p);
     fac:	6978      	ldr	r0, [r7, #20]
     fae:	f7ff fffe 	bl	0 <pbuf_free>
			fae: R_ARM_THM_CALL	pbuf_free
     fb2:	e000      	b.n	fb6 <tcp_rst+0xca>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
     fb4:	bf00      	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
     fb6:	f107 0718 	add.w	r7, r7, #24
     fba:	46bd      	mov	sp, r7
     fbc:	bd80      	pop	{r7, pc}
     fbe:	bf00      	nop

00000fc0 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
     fc0:	b580      	push	{r7, lr}
     fc2:	b084      	sub	sp, #16
     fc4:	af00      	add	r7, sp, #0
     fc6:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
     fc8:	687b      	ldr	r3, [r7, #4]
     fca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     fcc:	2b00      	cmp	r3, #0
     fce:	d027      	beq.n	1020 <tcp_rexmit_rto+0x60>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
     fd0:	687b      	ldr	r3, [r7, #4]
     fd2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
     fd4:	60fb      	str	r3, [r7, #12]
     fd6:	e002      	b.n	fde <tcp_rexmit_rto+0x1e>
     fd8:	68fb      	ldr	r3, [r7, #12]
     fda:	681b      	ldr	r3, [r3, #0]
     fdc:	60fb      	str	r3, [r7, #12]
     fde:	68fb      	ldr	r3, [r7, #12]
     fe0:	681b      	ldr	r3, [r3, #0]
     fe2:	2b00      	cmp	r3, #0
     fe4:	d1f8      	bne.n	fd8 <tcp_rexmit_rto+0x18>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
     fe6:	687b      	ldr	r3, [r7, #4]
     fe8:	6eda      	ldr	r2, [r3, #108]	; 0x6c
     fea:	68fb      	ldr	r3, [r7, #12]
     fec:	601a      	str	r2, [r3, #0]
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
     fee:	687b      	ldr	r3, [r7, #4]
     ff0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
     ff2:	687b      	ldr	r3, [r7, #4]
     ff4:	66da      	str	r2, [r3, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
     ff6:	687b      	ldr	r3, [r7, #4]
     ff8:	f04f 0200 	mov.w	r2, #0
     ffc:	671a      	str	r2, [r3, #112]	; 0x70
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
     ffe:	687b      	ldr	r3, [r7, #4]
    1000:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
    1004:	f103 0301 	add.w	r3, r3, #1
    1008:	b2da      	uxtb	r2, r3
    100a:	687b      	ldr	r3, [r7, #4]
    100c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
    1010:	687b      	ldr	r3, [r7, #4]
    1012:	f04f 0200 	mov.w	r2, #0
    1016:	639a      	str	r2, [r3, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
    1018:	6878      	ldr	r0, [r7, #4]
    101a:	f7ff fffe 	bl	acc <tcp_output>
			101a: R_ARM_THM_CALL	tcp_output
    101e:	e000      	b.n	1022 <tcp_rexmit_rto+0x62>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
    1020:	bf00      	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
    1022:	f107 0710 	add.w	r7, r7, #16
    1026:	46bd      	mov	sp, r7
    1028:	bd80      	pop	{r7, pc}
    102a:	bf00      	nop

0000102c <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
    102c:	b590      	push	{r4, r7, lr}
    102e:	b085      	sub	sp, #20
    1030:	af00      	add	r7, sp, #0
    1032:	6078      	str	r0, [r7, #4]
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    1034:	687b      	ldr	r3, [r7, #4]
    1036:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1038:	2b00      	cmp	r3, #0
    103a:	d042      	beq.n	10c2 <tcp_rexmit+0x96>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
    103c:	687b      	ldr	r3, [r7, #4]
    103e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    1040:	60bb      	str	r3, [r7, #8]
  pcb->unacked = seg->next;
    1042:	68bb      	ldr	r3, [r7, #8]
    1044:	681a      	ldr	r2, [r3, #0]
    1046:	687b      	ldr	r3, [r7, #4]
    1048:	671a      	str	r2, [r3, #112]	; 0x70

  cur_seg = &(pcb->unsent);
    104a:	687b      	ldr	r3, [r7, #4]
    104c:	f103 036c 	add.w	r3, r3, #108	; 0x6c
    1050:	60fb      	str	r3, [r7, #12]
  while (*cur_seg &&
    1052:	e002      	b.n	105a <tcp_rexmit+0x2e>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
    1054:	68fb      	ldr	r3, [r7, #12]
    1056:	681b      	ldr	r3, [r3, #0]
    1058:	60fb      	str	r3, [r7, #12]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    105a:	68fb      	ldr	r3, [r7, #12]
    105c:	681b      	ldr	r3, [r3, #0]
    105e:	2b00      	cmp	r3, #0
    1060:	d011      	beq.n	1086 <tcp_rexmit+0x5a>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
    1062:	68fb      	ldr	r3, [r7, #12]
    1064:	681b      	ldr	r3, [r3, #0]
    1066:	68db      	ldr	r3, [r3, #12]
    1068:	685b      	ldr	r3, [r3, #4]
    106a:	4618      	mov	r0, r3
    106c:	f7ff fffe 	bl	0 <lwip_ntohl>
			106c: R_ARM_THM_CALL	lwip_ntohl
    1070:	4604      	mov	r4, r0
    1072:	68bb      	ldr	r3, [r7, #8]
    1074:	68db      	ldr	r3, [r3, #12]
    1076:	685b      	ldr	r3, [r3, #4]
    1078:	4618      	mov	r0, r3
    107a:	f7ff fffe 	bl	0 <lwip_ntohl>
			107a: R_ARM_THM_CALL	lwip_ntohl
    107e:	4603      	mov	r3, r0
    1080:	1ae3      	subs	r3, r4, r3
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
    1082:	2b00      	cmp	r3, #0
    1084:	dbe6      	blt.n	1054 <tcp_rexmit+0x28>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
    1086:	68fb      	ldr	r3, [r7, #12]
    1088:	681a      	ldr	r2, [r3, #0]
    108a:	68bb      	ldr	r3, [r7, #8]
    108c:	601a      	str	r2, [r3, #0]
  *cur_seg = seg;
    108e:	68fb      	ldr	r3, [r7, #12]
    1090:	68ba      	ldr	r2, [r7, #8]
    1092:	601a      	str	r2, [r3, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    1094:	68bb      	ldr	r3, [r7, #8]
    1096:	681b      	ldr	r3, [r3, #0]
    1098:	2b00      	cmp	r3, #0
    109a:	d104      	bne.n	10a6 <tcp_rexmit+0x7a>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
    109c:	687b      	ldr	r3, [r7, #4]
    109e:	f04f 0200 	mov.w	r2, #0
    10a2:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
    10a6:	687b      	ldr	r3, [r7, #4]
    10a8:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
    10ac:	f103 0301 	add.w	r3, r3, #1
    10b0:	b2da      	uxtb	r2, r3
    10b2:	687b      	ldr	r3, [r7, #4]
    10b4:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
    10b8:	687b      	ldr	r3, [r7, #4]
    10ba:	f04f 0200 	mov.w	r2, #0
    10be:	639a      	str	r2, [r3, #56]	; 0x38
    10c0:	e000      	b.n	10c4 <tcp_rexmit+0x98>
{
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
    return;
    10c2:	bf00      	nop

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  /* No need to call tcp_output: we are always called from tcp_input()
     and thus tcp_output directly returns. */
}
    10c4:	f107 0714 	add.w	r7, r7, #20
    10c8:	46bd      	mov	sp, r7
    10ca:	bd90      	pop	{r4, r7, pc}

000010cc <tcp_rexmit_fast>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
    10cc:	b580      	push	{r7, lr}
    10ce:	b082      	sub	sp, #8
    10d0:	af00      	add	r7, sp, #0
    10d2:	6078      	str	r0, [r7, #4]
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
    10d4:	687b      	ldr	r3, [r7, #4]
    10d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    10d8:	2b00      	cmp	r3, #0
    10da:	d04b      	beq.n	1174 <tcp_rexmit_fast+0xa8>
    10dc:	687b      	ldr	r3, [r7, #4]
    10de:	7f9b      	ldrb	r3, [r3, #30]
    10e0:	f003 0304 	and.w	r3, r3, #4
    10e4:	2b00      	cmp	r3, #0
    10e6:	d145      	bne.n	1174 <tcp_rexmit_fast+0xa8>
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
    10e8:	6878      	ldr	r0, [r7, #4]
    10ea:	f7ff fffe 	bl	102c <tcp_rexmit>
			10ea: R_ARM_THM_CALL	tcp_rexmit

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
    10ee:	687b      	ldr	r3, [r7, #4]
    10f0:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
    10f4:	687b      	ldr	r3, [r7, #4]
    10f6:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    10fa:	429a      	cmp	r2, r3
    10fc:	d909      	bls.n	1112 <tcp_rexmit_fast+0x46>
      pcb->ssthresh = pcb->snd_wnd / 2;
    10fe:	687b      	ldr	r3, [r7, #4]
    1100:	f8b3 3060 	ldrh.w	r3, [r3, #96]	; 0x60
    1104:	ea4f 0353 	mov.w	r3, r3, lsr #1
    1108:	b29a      	uxth	r2, r3
    110a:	687b      	ldr	r3, [r7, #4]
    110c:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    1110:	e008      	b.n	1124 <tcp_rexmit_fast+0x58>
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    1112:	687b      	ldr	r3, [r7, #4]
    1114:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
    1118:	ea4f 0353 	mov.w	r3, r3, lsr #1
    111c:	b29a      	uxth	r2, r3
    111e:	687b      	ldr	r3, [r7, #4]
    1120:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
    1124:	687b      	ldr	r3, [r7, #4]
    1126:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
    112a:	461a      	mov	r2, r3
    112c:	687b      	ldr	r3, [r7, #4]
    112e:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    1130:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1134:	429a      	cmp	r2, r3
    1136:	da07      	bge.n	1148 <tcp_rexmit_fast+0x7c>
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    1138:	687b      	ldr	r3, [r7, #4]
    113a:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    113c:	ea4f 0343 	mov.w	r3, r3, lsl #1
    1140:	b29a      	uxth	r2, r3
    1142:	687b      	ldr	r3, [r7, #4]
    1144:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    1148:	687b      	ldr	r3, [r7, #4]
    114a:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
    114e:	687b      	ldr	r3, [r7, #4]
    1150:	8edb      	ldrh	r3, [r3, #54]	; 0x36
    1152:	4619      	mov	r1, r3
    1154:	ea4f 0141 	mov.w	r1, r1, lsl #1
    1158:	18cb      	adds	r3, r1, r3
    115a:	b29b      	uxth	r3, r3
    115c:	18d3      	adds	r3, r2, r3
    115e:	b29a      	uxth	r2, r3
    1160:	687b      	ldr	r3, [r7, #4]
    1162:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
    pcb->flags |= TF_INFR;
    1166:	687b      	ldr	r3, [r7, #4]
    1168:	7f9b      	ldrb	r3, [r3, #30]
    116a:	f043 0304 	orr.w	r3, r3, #4
    116e:	b2da      	uxtb	r2, r3
    1170:	687b      	ldr	r3, [r7, #4]
    1172:	779a      	strb	r2, [r3, #30]
  } 
}
    1174:	f107 0708 	add.w	r7, r7, #8
    1178:	46bd      	mov	sp, r7
    117a:	bd80      	pop	{r7, pc}

0000117c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
    117c:	b580      	push	{r7, lr}
    117e:	b086      	sub	sp, #24
    1180:	af02      	add	r7, sp, #8
    1182:	6078      	str	r0, [r7, #4]
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
    1184:	687b      	ldr	r3, [r7, #4]
    1186:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    1188:	f103 33ff 	add.w	r3, r3, #4294967295
    118c:	4618      	mov	r0, r3
    118e:	f7ff fffe 	bl	0 <lwip_htonl>
			118e: R_ARM_THM_CALL	lwip_htonl
    1192:	4603      	mov	r3, r0
    1194:	6878      	ldr	r0, [r7, #4]
    1196:	f04f 0100 	mov.w	r1, #0
    119a:	f04f 0200 	mov.w	r2, #0
    119e:	f7fe ff2f 	bl	0 <tcp_output_alloc_header>
    11a2:	60f8      	str	r0, [r7, #12]
  if(p == NULL) {
    11a4:	68fb      	ldr	r3, [r7, #12]
    11a6:	2b00      	cmp	r3, #0
    11a8:	d015      	beq.n	11d6 <tcp_keepalive+0x5a>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    11aa:	68fb      	ldr	r3, [r7, #12]
    11ac:	685b      	ldr	r3, [r3, #4]
    11ae:	60bb      	str	r3, [r7, #8]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    11b0:	6879      	ldr	r1, [r7, #4]
    11b2:	687b      	ldr	r3, [r7, #4]
    11b4:	f103 0204 	add.w	r2, r3, #4
    11b8:	687b      	ldr	r3, [r7, #4]
    11ba:	7a9b      	ldrb	r3, [r3, #10]
    11bc:	f04f 0000 	mov.w	r0, #0
    11c0:	9000      	str	r0, [sp, #0]
    11c2:	f04f 0006 	mov.w	r0, #6
    11c6:	9001      	str	r0, [sp, #4]
    11c8:	68f8      	ldr	r0, [r7, #12]
    11ca:	f7ff fffe 	bl	0 <ip_output>
			11ca: R_ARM_THM_CALL	ip_output
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    11ce:	68f8      	ldr	r0, [r7, #12]
    11d0:	f7ff fffe 	bl	0 <pbuf_free>
			11d0: R_ARM_THM_CALL	pbuf_free
    11d4:	e000      	b.n	11d8 <tcp_keepalive+0x5c>
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
    11d6:	bf00      	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    11d8:	f107 0710 	add.w	r7, r7, #16
    11dc:	46bd      	mov	sp, r7
    11de:	bd80      	pop	{r7, pc}

000011e0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
    11e0:	b590      	push	{r4, r7, lr}
    11e2:	b08b      	sub	sp, #44	; 0x2c
    11e4:	af02      	add	r7, sp, #8
    11e6:	6078      	str	r0, [r7, #4]
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
    11e8:	687b      	ldr	r3, [r7, #4]
    11ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
    11ec:	61fb      	str	r3, [r7, #28]

  if(seg == NULL) {
    11ee:	69fb      	ldr	r3, [r7, #28]
    11f0:	2b00      	cmp	r3, #0
    11f2:	d102      	bne.n	11fa <tcp_zero_window_probe+0x1a>
    seg = pcb->unsent;
    11f4:	687b      	ldr	r3, [r7, #4]
    11f6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
    11f8:	61fb      	str	r3, [r7, #28]
  }
  if(seg == NULL) {
    11fa:	69fb      	ldr	r3, [r7, #28]
    11fc:	2b00      	cmp	r3, #0
    11fe:	d06b      	beq.n	12d8 <tcp_zero_window_probe+0xf8>
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
    1200:	69fb      	ldr	r3, [r7, #28]
    1202:	68db      	ldr	r3, [r3, #12]
    1204:	899b      	ldrh	r3, [r3, #12]
    1206:	b29b      	uxth	r3, r3
    1208:	4618      	mov	r0, r3
    120a:	f7ff fffe 	bl	0 <lwip_ntohs>
			120a: R_ARM_THM_CALL	lwip_ntohs
    120e:	4603      	mov	r3, r0
    1210:	f003 0301 	and.w	r3, r3, #1
    1214:	b2db      	uxtb	r3, r3
    1216:	2b00      	cmp	r3, #0
    1218:	d006      	beq.n	1228 <tcp_zero_window_probe+0x48>
    121a:	69fb      	ldr	r3, [r7, #28]
    121c:	891b      	ldrh	r3, [r3, #8]
    121e:	2b00      	cmp	r3, #0
    1220:	d102      	bne.n	1228 <tcp_zero_window_probe+0x48>
    1222:	f04f 0301 	mov.w	r3, #1
    1226:	e001      	b.n	122c <tcp_zero_window_probe+0x4c>
    1228:	f04f 0300 	mov.w	r3, #0
    122c:	76fb      	strb	r3, [r7, #27]
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;
    122e:	7efb      	ldrb	r3, [r7, #27]
    1230:	2b00      	cmp	r3, #0
    1232:	bf14      	ite	ne
    1234:	2300      	movne	r3, #0
    1236:	2301      	moveq	r3, #1
    1238:	833b      	strh	r3, [r7, #24]

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
    123a:	69fb      	ldr	r3, [r7, #28]
    123c:	68db      	ldr	r3, [r3, #12]
    123e:	685b      	ldr	r3, [r3, #4]
    1240:	8b3a      	ldrh	r2, [r7, #24]
    1242:	6878      	ldr	r0, [r7, #4]
    1244:	f04f 0100 	mov.w	r1, #0
    1248:	f7fe feda 	bl	0 <tcp_output_alloc_header>
    124c:	6178      	str	r0, [r7, #20]
  if(p == NULL) {
    124e:	697b      	ldr	r3, [r7, #20]
    1250:	2b00      	cmp	r3, #0
    1252:	d043      	beq.n	12dc <tcp_zero_window_probe+0xfc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
    1254:	697b      	ldr	r3, [r7, #20]
    1256:	685b      	ldr	r3, [r3, #4]
    1258:	613b      	str	r3, [r7, #16]

  if (is_fin) {
    125a:	7efb      	ldrb	r3, [r7, #27]
    125c:	2b00      	cmp	r3, #0
    125e:	d014      	beq.n	128a <tcp_zero_window_probe+0xaa>
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
    1260:	693b      	ldr	r3, [r7, #16]
    1262:	899b      	ldrh	r3, [r3, #12]
    1264:	b29b      	uxth	r3, r3
    1266:	b29b      	uxth	r3, r3
    1268:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
    126c:	b29c      	uxth	r4, r3
    126e:	f04f 0011 	mov.w	r0, #17
    1272:	f7ff fffe 	bl	0 <lwip_htons>
			1272: R_ARM_THM_CALL	lwip_htons
    1276:	4603      	mov	r3, r0
    1278:	b29b      	uxth	r3, r3
    127a:	4622      	mov	r2, r4
    127c:	ea42 0303 	orr.w	r3, r2, r3
    1280:	b29b      	uxth	r3, r3
    1282:	b29a      	uxth	r2, r3
    1284:	693b      	ldr	r3, [r7, #16]
    1286:	819a      	strh	r2, [r3, #12]
    1288:	e013      	b.n	12b2 <tcp_zero_window_probe+0xd2>
  } else {
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    128a:	697b      	ldr	r3, [r7, #20]
    128c:	685b      	ldr	r3, [r3, #4]
    128e:	f103 0314 	add.w	r3, r3, #20
    1292:	60fb      	str	r3, [r7, #12]
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
    1294:	69fb      	ldr	r3, [r7, #28]
    1296:	685a      	ldr	r2, [r3, #4]
    1298:	69fb      	ldr	r3, [r7, #28]
    129a:	685b      	ldr	r3, [r3, #4]
    129c:	8919      	ldrh	r1, [r3, #8]
    129e:	69fb      	ldr	r3, [r7, #28]
    12a0:	891b      	ldrh	r3, [r3, #8]
    12a2:	1acb      	subs	r3, r1, r3
    12a4:	b29b      	uxth	r3, r3
    12a6:	4610      	mov	r0, r2
    12a8:	68f9      	ldr	r1, [r7, #12]
    12aa:	f04f 0201 	mov.w	r2, #1
    12ae:	f7ff fffe 	bl	0 <pbuf_copy_partial>
			12ae: R_ARM_THM_CALL	pbuf_copy_partial
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
    12b2:	6879      	ldr	r1, [r7, #4]
    12b4:	687b      	ldr	r3, [r7, #4]
    12b6:	f103 0204 	add.w	r2, r3, #4
    12ba:	687b      	ldr	r3, [r7, #4]
    12bc:	7a9b      	ldrb	r3, [r3, #10]
    12be:	f04f 0000 	mov.w	r0, #0
    12c2:	9000      	str	r0, [sp, #0]
    12c4:	f04f 0006 	mov.w	r0, #6
    12c8:	9001      	str	r0, [sp, #4]
    12ca:	6978      	ldr	r0, [r7, #20]
    12cc:	f7ff fffe 	bl	0 <ip_output>
			12cc: R_ARM_THM_CALL	ip_output
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
    12d0:	6978      	ldr	r0, [r7, #20]
    12d2:	f7ff fffe 	bl	0 <pbuf_free>
			12d2: R_ARM_THM_CALL	pbuf_free
    12d6:	e002      	b.n	12de <tcp_zero_window_probe+0xfe>

  if(seg == NULL) {
    seg = pcb->unsent;
  }
  if(seg == NULL) {
    return;
    12d8:	bf00      	nop
    12da:	e000      	b.n	12de <tcp_zero_window_probe+0xfe>
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
    12dc:	bf00      	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
    12de:	f107 0724 	add.w	r7, r7, #36	; 0x24
    12e2:	46bd      	mov	sp, r7
    12e4:	bd90      	pop	{r4, r7, pc}
    12e6:	bf00      	nop

timers.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  65968 Jul 30 19:07 2021 timers.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000428  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000045c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00000000  00000000  0000045c  2**2
                  ALLOC
  3 .debug_abbrev 000001a7  00000000  00000000  0000045c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000a67  00000000  00000000  00000603  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000615  00000000  00000000  0000106a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000cb0a  00000000  00000000  0000167f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000288  00000000  00000000  0000e189  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000007b  00000000  00000000  0000e411  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000014d  00000000  00000000  0000e48c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000e5d9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000651  00000000  00000000  0000e5f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000ec4a  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000ec75  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000188  00000000  00000000  0000eca8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 timers.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 next_timeout
00000004 l       .bss	00000000 tcpip_tcp_timer_active
00000000 l     F .text	0000004c tcpip_tcp_timer
00000090 l     F .text	00000028 ip_reass_timer
000000b8 l     F .text	00000028 arp_timer
000000e0 l     F .text	00000028 dhcp_timer_coarse
00000108 l     F .text	00000028 dhcp_timer_fine
00000130 l     F .text	00000028 igmp_timer
00000158 l     F .text	00000028 dns_timer
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000         *UND*	00000000 tcp_tmr
000001f4 g     F .text	000000e8 sys_timeout
00000000         *UND*	00000000 tcp_active_pcbs
00000000         *UND*	00000000 tcp_tw_pcbs
0000004c g     F .text	00000044 tcp_timer_needed
00000000         *UND*	00000000 ip_reass_tmr
00000000         *UND*	00000000 etharp_tmr
00000000         *UND*	00000000 dhcp_coarse_tmr
00000000         *UND*	00000000 dhcp_fine_tmr
00000000         *UND*	00000000 igmp_tmr
00000000         *UND*	00000000 dns_tmr
00000180 g     F .text	00000074 sys_timeouts_init
00000000         *UND*	00000000 memp_malloc
000002dc g     F .text	00000094 sys_untimeout
00000000         *UND*	00000000 memp_free
00000370 g     F .text	000000b8 sys_timeouts_mbox_fetch
00000000         *UND*	00000000 sys_arch_mbox_fetch



Disassembly of section .text:

00000000 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
   8:	f7ff fffe 	bl	0 <tcp_tmr>
			8: R_ARM_THM_CALL	tcp_tmr
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
   c:	4b0b      	ldr	r3, [pc, #44]	; (3c <tcpip_tcp_timer+0x3c>)
   e:	681b      	ldr	r3, [r3, #0]
  10:	2b00      	cmp	r3, #0
  12:	d103      	bne.n	1c <tcpip_tcp_timer+0x1c>
  14:	4b0a      	ldr	r3, [pc, #40]	; (40 <tcpip_tcp_timer+0x40>)
  16:	681b      	ldr	r3, [r3, #0]
  18:	2b00      	cmp	r3, #0
  1a:	d007      	beq.n	2c <tcpip_tcp_timer+0x2c>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  1c:	f04f 00fa 	mov.w	r0, #250	; 0xfa
  20:	4908      	ldr	r1, [pc, #32]	; (44 <tcpip_tcp_timer+0x44>)
  22:	f04f 0200 	mov.w	r2, #0
  26:	f7ff fffe 	bl	1f4 <sys_timeout>
			26: R_ARM_THM_CALL	sys_timeout
  2a:	e003      	b.n	34 <tcpip_tcp_timer+0x34>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  2c:	4b06      	ldr	r3, [pc, #24]	; (48 <tcpip_tcp_timer+0x48>)
  2e:	f04f 0200 	mov.w	r2, #0
  32:	601a      	str	r2, [r3, #0]
  }
}
  34:	f107 0708 	add.w	r7, r7, #8
  38:	46bd      	mov	sp, r7
  3a:	bd80      	pop	{r7, pc}
	...
			3c: R_ARM_ABS32	tcp_active_pcbs
			40: R_ARM_ABS32	tcp_tw_pcbs
			44: R_ARM_ABS32	tcpip_tcp_timer
  48:	00000004 	.word	0x00000004
			48: R_ARM_ABS32	.bss

0000004c <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  4c:	b580      	push	{r7, lr}
  4e:	af00      	add	r7, sp, #0
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  50:	4b0b      	ldr	r3, [pc, #44]	; (80 <tcp_timer_needed+0x34>)
  52:	681b      	ldr	r3, [r3, #0]
  54:	2b00      	cmp	r3, #0
  56:	d112      	bne.n	7e <tcp_timer_needed+0x32>
  58:	4b0a      	ldr	r3, [pc, #40]	; (84 <tcp_timer_needed+0x38>)
  5a:	681b      	ldr	r3, [r3, #0]
  5c:	2b00      	cmp	r3, #0
  5e:	d103      	bne.n	68 <tcp_timer_needed+0x1c>
  60:	4b09      	ldr	r3, [pc, #36]	; (88 <tcp_timer_needed+0x3c>)
  62:	681b      	ldr	r3, [r3, #0]
  64:	2b00      	cmp	r3, #0
  66:	d00a      	beq.n	7e <tcp_timer_needed+0x32>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  68:	4b05      	ldr	r3, [pc, #20]	; (80 <tcp_timer_needed+0x34>)
  6a:	f04f 0201 	mov.w	r2, #1
  6e:	601a      	str	r2, [r3, #0]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  70:	f04f 00fa 	mov.w	r0, #250	; 0xfa
  74:	4905      	ldr	r1, [pc, #20]	; (8c <tcp_timer_needed+0x40>)
  76:	f04f 0200 	mov.w	r2, #0
  7a:	f7ff fffe 	bl	1f4 <sys_timeout>
			7a: R_ARM_THM_CALL	sys_timeout
  }
}
  7e:	bd80      	pop	{r7, pc}
  80:	00000004 	.word	0x00000004
			80: R_ARM_ABS32	.bss
	...
			84: R_ARM_ABS32	tcp_active_pcbs
			88: R_ARM_ABS32	tcp_tw_pcbs
			8c: R_ARM_ABS32	tcpip_tcp_timer

00000090 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  90:	b580      	push	{r7, lr}
  92:	b082      	sub	sp, #8
  94:	af00      	add	r7, sp, #0
  96:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  98:	f7ff fffe 	bl	0 <ip_reass_tmr>
			98: R_ARM_THM_CALL	ip_reass_tmr
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  9c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  a0:	4904      	ldr	r1, [pc, #16]	; (b4 <ip_reass_timer+0x24>)
  a2:	f04f 0200 	mov.w	r2, #0
  a6:	f7ff fffe 	bl	1f4 <sys_timeout>
			a6: R_ARM_THM_CALL	sys_timeout
}
  aa:	f107 0708 	add.w	r7, r7, #8
  ae:	46bd      	mov	sp, r7
  b0:	bd80      	pop	{r7, pc}
  b2:	bf00      	nop
  b4:	00000000 	.word	0x00000000
			b4: R_ARM_ABS32	ip_reass_timer

000000b8 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  b8:	b580      	push	{r7, lr}
  ba:	b082      	sub	sp, #8
  bc:	af00      	add	r7, sp, #0
  be:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  c0:	f7ff fffe 	bl	0 <etharp_tmr>
			c0: R_ARM_THM_CALL	etharp_tmr
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  c4:	f241 3088 	movw	r0, #5000	; 0x1388
  c8:	4904      	ldr	r1, [pc, #16]	; (dc <arp_timer+0x24>)
  ca:	f04f 0200 	mov.w	r2, #0
  ce:	f7ff fffe 	bl	1f4 <sys_timeout>
			ce: R_ARM_THM_CALL	sys_timeout
}
  d2:	f107 0708 	add.w	r7, r7, #8
  d6:	46bd      	mov	sp, r7
  d8:	bd80      	pop	{r7, pc}
  da:	bf00      	nop
  dc:	00000000 	.word	0x00000000
			dc: R_ARM_ABS32	arp_timer

000000e0 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  e0:	b580      	push	{r7, lr}
  e2:	b082      	sub	sp, #8
  e4:	af00      	add	r7, sp, #0
  e6:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  e8:	f7ff fffe 	bl	0 <dhcp_coarse_tmr>
			e8: R_ARM_THM_CALL	dhcp_coarse_tmr
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  ec:	f64e 2060 	movw	r0, #60000	; 0xea60
  f0:	4904      	ldr	r1, [pc, #16]	; (104 <dhcp_timer_coarse+0x24>)
  f2:	f04f 0200 	mov.w	r2, #0
  f6:	f7ff fffe 	bl	1f4 <sys_timeout>
			f6: R_ARM_THM_CALL	sys_timeout
}
  fa:	f107 0708 	add.w	r7, r7, #8
  fe:	46bd      	mov	sp, r7
 100:	bd80      	pop	{r7, pc}
 102:	bf00      	nop
 104:	00000000 	.word	0x00000000
			104: R_ARM_ABS32	dhcp_timer_coarse

00000108 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
 108:	b580      	push	{r7, lr}
 10a:	b082      	sub	sp, #8
 10c:	af00      	add	r7, sp, #0
 10e:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
 110:	f7ff fffe 	bl	0 <dhcp_fine_tmr>
			110: R_ARM_THM_CALL	dhcp_fine_tmr
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
 114:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 118:	4904      	ldr	r1, [pc, #16]	; (12c <dhcp_timer_fine+0x24>)
 11a:	f04f 0200 	mov.w	r2, #0
 11e:	f7ff fffe 	bl	1f4 <sys_timeout>
			11e: R_ARM_THM_CALL	sys_timeout
}
 122:	f107 0708 	add.w	r7, r7, #8
 126:	46bd      	mov	sp, r7
 128:	bd80      	pop	{r7, pc}
 12a:	bf00      	nop
 12c:	00000000 	.word	0x00000000
			12c: R_ARM_ABS32	dhcp_timer_fine

00000130 <igmp_timer>:
 *
 * @param arg unused argument
 */
static void
igmp_timer(void *arg)
{
 130:	b580      	push	{r7, lr}
 132:	b082      	sub	sp, #8
 134:	af00      	add	r7, sp, #0
 136:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: igmp_tmr()\n"));
  igmp_tmr();
 138:	f7ff fffe 	bl	0 <igmp_tmr>
			138: R_ARM_THM_CALL	igmp_tmr
  sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
 13c:	f04f 0064 	mov.w	r0, #100	; 0x64
 140:	4904      	ldr	r1, [pc, #16]	; (154 <igmp_timer+0x24>)
 142:	f04f 0200 	mov.w	r2, #0
 146:	f7ff fffe 	bl	1f4 <sys_timeout>
			146: R_ARM_THM_CALL	sys_timeout
}
 14a:	f107 0708 	add.w	r7, r7, #8
 14e:	46bd      	mov	sp, r7
 150:	bd80      	pop	{r7, pc}
 152:	bf00      	nop
 154:	00000000 	.word	0x00000000
			154: R_ARM_ABS32	igmp_timer

00000158 <dns_timer>:
 *
 * @param arg unused argument
 */
static void
dns_timer(void *arg)
{
 158:	b580      	push	{r7, lr}
 15a:	b082      	sub	sp, #8
 15c:	af00      	add	r7, sp, #0
 15e:	6078      	str	r0, [r7, #4]
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: dns_tmr()\n"));
  dns_tmr();
 160:	f7ff fffe 	bl	0 <dns_tmr>
			160: R_ARM_THM_CALL	dns_tmr
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
 164:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 168:	4904      	ldr	r1, [pc, #16]	; (17c <dns_timer+0x24>)
 16a:	f04f 0200 	mov.w	r2, #0
 16e:	f7ff fffe 	bl	1f4 <sys_timeout>
			16e: R_ARM_THM_CALL	sys_timeout
}
 172:	f107 0708 	add.w	r7, r7, #8
 176:	46bd      	mov	sp, r7
 178:	bd80      	pop	{r7, pc}
 17a:	bf00      	nop
 17c:	00000000 	.word	0x00000000
			17c: R_ARM_ABS32	dns_timer

00000180 <sys_timeouts_init>:
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
 180:	b580      	push	{r7, lr}
 182:	af00      	add	r7, sp, #0
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 184:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 188:	4914      	ldr	r1, [pc, #80]	; (1dc <sys_timeouts_init+0x5c>)
 18a:	f04f 0200 	mov.w	r2, #0
 18e:	f7ff fffe 	bl	1f4 <sys_timeout>
			18e: R_ARM_THM_CALL	sys_timeout
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 192:	f241 3088 	movw	r0, #5000	; 0x1388
 196:	4912      	ldr	r1, [pc, #72]	; (1e0 <sys_timeouts_init+0x60>)
 198:	f04f 0200 	mov.w	r2, #0
 19c:	f7ff fffe 	bl	1f4 <sys_timeout>
			19c: R_ARM_THM_CALL	sys_timeout
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
 1a0:	f64e 2060 	movw	r0, #60000	; 0xea60
 1a4:	490f      	ldr	r1, [pc, #60]	; (1e4 <sys_timeouts_init+0x64>)
 1a6:	f04f 0200 	mov.w	r2, #0
 1aa:	f7ff fffe 	bl	1f4 <sys_timeout>
			1aa: R_ARM_THM_CALL	sys_timeout
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
 1ae:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 1b2:	490d      	ldr	r1, [pc, #52]	; (1e8 <sys_timeouts_init+0x68>)
 1b4:	f04f 0200 	mov.w	r2, #0
 1b8:	f7ff fffe 	bl	1f4 <sys_timeout>
			1b8: R_ARM_THM_CALL	sys_timeout
#endif /* LWIP_DHCP */
#if LWIP_AUTOIP
  sys_timeout(AUTOIP_TMR_INTERVAL, autoip_timer, NULL);
#endif /* LWIP_AUTOIP */
#if LWIP_IGMP
  sys_timeout(IGMP_TMR_INTERVAL, igmp_timer, NULL);
 1bc:	f04f 0064 	mov.w	r0, #100	; 0x64
 1c0:	490a      	ldr	r1, [pc, #40]	; (1ec <sys_timeouts_init+0x6c>)
 1c2:	f04f 0200 	mov.w	r2, #0
 1c6:	f7ff fffe 	bl	1f4 <sys_timeout>
			1c6: R_ARM_THM_CALL	sys_timeout
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
 1ca:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 1ce:	4908      	ldr	r1, [pc, #32]	; (1f0 <sys_timeouts_init+0x70>)
 1d0:	f04f 0200 	mov.w	r2, #0
 1d4:	f7ff fffe 	bl	1f4 <sys_timeout>
			1d4: R_ARM_THM_CALL	sys_timeout

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
#endif
}
 1d8:	bd80      	pop	{r7, pc}
 1da:	bf00      	nop
	...
			1dc: R_ARM_ABS32	ip_reass_timer
			1e0: R_ARM_ABS32	arp_timer
			1e4: R_ARM_ABS32	dhcp_timer_coarse
			1e8: R_ARM_ABS32	dhcp_timer_fine
			1ec: R_ARM_ABS32	igmp_timer
			1f0: R_ARM_ABS32	dns_timer

000001f4 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 1f4:	b580      	push	{r7, lr}
 1f6:	b086      	sub	sp, #24
 1f8:	af00      	add	r7, sp, #0
 1fa:	60f8      	str	r0, [r7, #12]
 1fc:	60b9      	str	r1, [r7, #8]
 1fe:	607a      	str	r2, [r7, #4]
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 200:	f04f 000c 	mov.w	r0, #12
 204:	f7ff fffe 	bl	0 <memp_malloc>
			204: R_ARM_THM_CALL	memp_malloc
 208:	4603      	mov	r3, r0
 20a:	613b      	str	r3, [r7, #16]
  if (timeout == NULL) {
 20c:	693b      	ldr	r3, [r7, #16]
 20e:	2b00      	cmp	r3, #0
 210:	d05c      	beq.n	2cc <sys_timeout+0xd8>
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 212:	693b      	ldr	r3, [r7, #16]
 214:	f04f 0200 	mov.w	r2, #0
 218:	601a      	str	r2, [r3, #0]
  timeout->h = handler;
 21a:	693b      	ldr	r3, [r7, #16]
 21c:	68ba      	ldr	r2, [r7, #8]
 21e:	609a      	str	r2, [r3, #8]
  timeout->arg = arg;
 220:	693b      	ldr	r3, [r7, #16]
 222:	687a      	ldr	r2, [r7, #4]
 224:	60da      	str	r2, [r3, #12]
  timeout->time = msecs;
 226:	693b      	ldr	r3, [r7, #16]
 228:	68fa      	ldr	r2, [r7, #12]
 22a:	605a      	str	r2, [r3, #4]
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 22c:	4b2a      	ldr	r3, [pc, #168]	; (2d8 <sys_timeout+0xe4>)
 22e:	681b      	ldr	r3, [r3, #0]
 230:	2b00      	cmp	r3, #0
 232:	d103      	bne.n	23c <sys_timeout+0x48>
    next_timeout = timeout;
 234:	4b28      	ldr	r3, [pc, #160]	; (2d8 <sys_timeout+0xe4>)
 236:	693a      	ldr	r2, [r7, #16]
 238:	601a      	str	r2, [r3, #0]
    return;
 23a:	e048      	b.n	2ce <sys_timeout+0xda>
  }

  if (next_timeout->time > msecs) {
 23c:	4b26      	ldr	r3, [pc, #152]	; (2d8 <sys_timeout+0xe4>)
 23e:	681b      	ldr	r3, [r3, #0]
 240:	685a      	ldr	r2, [r3, #4]
 242:	68fb      	ldr	r3, [r7, #12]
 244:	429a      	cmp	r2, r3
 246:	d90f      	bls.n	268 <sys_timeout+0x74>
    next_timeout->time -= msecs;
 248:	4b23      	ldr	r3, [pc, #140]	; (2d8 <sys_timeout+0xe4>)
 24a:	681b      	ldr	r3, [r3, #0]
 24c:	4a22      	ldr	r2, [pc, #136]	; (2d8 <sys_timeout+0xe4>)
 24e:	6812      	ldr	r2, [r2, #0]
 250:	6851      	ldr	r1, [r2, #4]
 252:	68fa      	ldr	r2, [r7, #12]
 254:	1a8a      	subs	r2, r1, r2
 256:	605a      	str	r2, [r3, #4]
    timeout->next = next_timeout;
 258:	4b1f      	ldr	r3, [pc, #124]	; (2d8 <sys_timeout+0xe4>)
 25a:	681a      	ldr	r2, [r3, #0]
 25c:	693b      	ldr	r3, [r7, #16]
 25e:	601a      	str	r2, [r3, #0]
    next_timeout = timeout;
 260:	4b1d      	ldr	r3, [pc, #116]	; (2d8 <sys_timeout+0xe4>)
 262:	693a      	ldr	r2, [r7, #16]
 264:	601a      	str	r2, [r3, #0]
 266:	e032      	b.n	2ce <sys_timeout+0xda>
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
 268:	4b1b      	ldr	r3, [pc, #108]	; (2d8 <sys_timeout+0xe4>)
 26a:	681b      	ldr	r3, [r3, #0]
 26c:	617b      	str	r3, [r7, #20]
 26e:	e029      	b.n	2c4 <sys_timeout+0xd0>
      timeout->time -= t->time;
 270:	693b      	ldr	r3, [r7, #16]
 272:	685a      	ldr	r2, [r3, #4]
 274:	697b      	ldr	r3, [r7, #20]
 276:	685b      	ldr	r3, [r3, #4]
 278:	1ad2      	subs	r2, r2, r3
 27a:	693b      	ldr	r3, [r7, #16]
 27c:	605a      	str	r2, [r3, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 27e:	697b      	ldr	r3, [r7, #20]
 280:	681b      	ldr	r3, [r3, #0]
 282:	2b00      	cmp	r3, #0
 284:	d006      	beq.n	294 <sys_timeout+0xa0>
 286:	697b      	ldr	r3, [r7, #20]
 288:	681b      	ldr	r3, [r3, #0]
 28a:	685a      	ldr	r2, [r3, #4]
 28c:	693b      	ldr	r3, [r7, #16]
 28e:	685b      	ldr	r3, [r3, #4]
 290:	429a      	cmp	r2, r3
 292:	d914      	bls.n	2be <sys_timeout+0xca>
        if (t->next != NULL) {
 294:	697b      	ldr	r3, [r7, #20]
 296:	681b      	ldr	r3, [r3, #0]
 298:	2b00      	cmp	r3, #0
 29a:	d008      	beq.n	2ae <sys_timeout+0xba>
          t->next->time -= timeout->time;
 29c:	697b      	ldr	r3, [r7, #20]
 29e:	681b      	ldr	r3, [r3, #0]
 2a0:	697a      	ldr	r2, [r7, #20]
 2a2:	6812      	ldr	r2, [r2, #0]
 2a4:	6851      	ldr	r1, [r2, #4]
 2a6:	693a      	ldr	r2, [r7, #16]
 2a8:	6852      	ldr	r2, [r2, #4]
 2aa:	1a8a      	subs	r2, r1, r2
 2ac:	605a      	str	r2, [r3, #4]
        }
        timeout->next = t->next;
 2ae:	697b      	ldr	r3, [r7, #20]
 2b0:	681a      	ldr	r2, [r3, #0]
 2b2:	693b      	ldr	r3, [r7, #16]
 2b4:	601a      	str	r2, [r3, #0]
        t->next = timeout;
 2b6:	697b      	ldr	r3, [r7, #20]
 2b8:	693a      	ldr	r2, [r7, #16]
 2ba:	601a      	str	r2, [r3, #0]
        break;
 2bc:	e007      	b.n	2ce <sys_timeout+0xda>
  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
 2be:	697b      	ldr	r3, [r7, #20]
 2c0:	681b      	ldr	r3, [r3, #0]
 2c2:	617b      	str	r3, [r7, #20]
 2c4:	697b      	ldr	r3, [r7, #20]
 2c6:	2b00      	cmp	r3, #0
 2c8:	d1d2      	bne.n	270 <sys_timeout+0x7c>
 2ca:	e000      	b.n	2ce <sys_timeout+0xda>
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
 2cc:	bf00      	nop
        t->next = timeout;
        break;
      }
    }
  }
}
 2ce:	f107 0718 	add.w	r7, r7, #24
 2d2:	46bd      	mov	sp, r7
 2d4:	bd80      	pop	{r7, pc}
 2d6:	bf00      	nop
 2d8:	00000000 	.word	0x00000000
			2d8: R_ARM_ABS32	.bss

000002dc <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 2dc:	b580      	push	{r7, lr}
 2de:	b084      	sub	sp, #16
 2e0:	af00      	add	r7, sp, #0
 2e2:	6078      	str	r0, [r7, #4]
 2e4:	6039      	str	r1, [r7, #0]
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
 2e6:	4b21      	ldr	r3, [pc, #132]	; (36c <sys_untimeout+0x90>)
 2e8:	681b      	ldr	r3, [r3, #0]
 2ea:	2b00      	cmp	r3, #0
 2ec:	d038      	beq.n	360 <sys_untimeout+0x84>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 2ee:	4b1f      	ldr	r3, [pc, #124]	; (36c <sys_untimeout+0x90>)
 2f0:	681b      	ldr	r3, [r3, #0]
 2f2:	60bb      	str	r3, [r7, #8]
 2f4:	f04f 0300 	mov.w	r3, #0
 2f8:	60fb      	str	r3, [r7, #12]
 2fa:	e02d      	b.n	358 <sys_untimeout+0x7c>
    if ((t->h == handler) && (t->arg == arg)) {
 2fc:	68bb      	ldr	r3, [r7, #8]
 2fe:	689a      	ldr	r2, [r3, #8]
 300:	687b      	ldr	r3, [r7, #4]
 302:	429a      	cmp	r2, r3
 304:	d123      	bne.n	34e <sys_untimeout+0x72>
 306:	68bb      	ldr	r3, [r7, #8]
 308:	68da      	ldr	r2, [r3, #12]
 30a:	683b      	ldr	r3, [r7, #0]
 30c:	429a      	cmp	r2, r3
 30e:	d11e      	bne.n	34e <sys_untimeout+0x72>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 310:	68fb      	ldr	r3, [r7, #12]
 312:	2b00      	cmp	r3, #0
 314:	d104      	bne.n	320 <sys_untimeout+0x44>
        next_timeout = t->next;
 316:	68bb      	ldr	r3, [r7, #8]
 318:	681a      	ldr	r2, [r3, #0]
 31a:	4b14      	ldr	r3, [pc, #80]	; (36c <sys_untimeout+0x90>)
 31c:	601a      	str	r2, [r3, #0]
 31e:	e003      	b.n	328 <sys_untimeout+0x4c>
      } else {
        prev_t->next = t->next;
 320:	68bb      	ldr	r3, [r7, #8]
 322:	681a      	ldr	r2, [r3, #0]
 324:	68fb      	ldr	r3, [r7, #12]
 326:	601a      	str	r2, [r3, #0]
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
 328:	68bb      	ldr	r3, [r7, #8]
 32a:	681b      	ldr	r3, [r3, #0]
 32c:	2b00      	cmp	r3, #0
 32e:	d008      	beq.n	342 <sys_untimeout+0x66>
        t->next->time += t->time;
 330:	68bb      	ldr	r3, [r7, #8]
 332:	681b      	ldr	r3, [r3, #0]
 334:	68ba      	ldr	r2, [r7, #8]
 336:	6812      	ldr	r2, [r2, #0]
 338:	6851      	ldr	r1, [r2, #4]
 33a:	68ba      	ldr	r2, [r7, #8]
 33c:	6852      	ldr	r2, [r2, #4]
 33e:	188a      	adds	r2, r1, r2
 340:	605a      	str	r2, [r3, #4]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 342:	f04f 000c 	mov.w	r0, #12
 346:	68b9      	ldr	r1, [r7, #8]
 348:	f7ff fffe 	bl	0 <memp_free>
			348: R_ARM_THM_CALL	memp_free
      return;
 34c:	e009      	b.n	362 <sys_untimeout+0x86>

  if (next_timeout == NULL) {
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 34e:	68bb      	ldr	r3, [r7, #8]
 350:	60fb      	str	r3, [r7, #12]
 352:	68bb      	ldr	r3, [r7, #8]
 354:	681b      	ldr	r3, [r3, #0]
 356:	60bb      	str	r3, [r7, #8]
 358:	68bb      	ldr	r3, [r7, #8]
 35a:	2b00      	cmp	r3, #0
 35c:	d1ce      	bne.n	2fc <sys_untimeout+0x20>
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
 35e:	e000      	b.n	362 <sys_untimeout+0x86>
sys_untimeout(sys_timeout_handler handler, void *arg)
{
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
    return;
 360:	bf00      	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
 362:	f107 0710 	add.w	r7, r7, #16
 366:	46bd      	mov	sp, r7
 368:	bd80      	pop	{r7, pc}
 36a:	bf00      	nop
 36c:	00000000 	.word	0x00000000
			36c: R_ARM_ABS32	.bss

00000370 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 370:	b580      	push	{r7, lr}
 372:	b086      	sub	sp, #24
 374:	af00      	add	r7, sp, #0
 376:	6078      	str	r0, [r7, #4]
 378:	6039      	str	r1, [r7, #0]
 37a:	e000      	b.n	37e <sys_timeouts_mbox_fetch+0xe>
        UNLOCK_TCPIP_CORE();
      }
      LWIP_TCPIP_THREAD_ALIVE();

      /* We try again to fetch a message from the mbox. */
      goto again;
 37c:	bf00      	nop
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 37e:	4b29      	ldr	r3, [pc, #164]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 380:	681b      	ldr	r3, [r3, #0]
 382:	2b00      	cmp	r3, #0
 384:	d107      	bne.n	396 <sys_timeouts_mbox_fetch+0x26>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 386:	6878      	ldr	r0, [r7, #4]
 388:	6839      	ldr	r1, [r7, #0]
 38a:	f04f 0200 	mov.w	r2, #0
 38e:	f7ff fffe 	bl	0 <sys_arch_mbox_fetch>
			38e: R_ARM_THM_CALL	sys_arch_mbox_fetch
 392:	6178      	str	r0, [r7, #20]
 394:	e042      	b.n	41c <sys_timeouts_mbox_fetch+0xac>
  } else {
    if (next_timeout->time > 0) {
 396:	4b23      	ldr	r3, [pc, #140]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 398:	681b      	ldr	r3, [r3, #0]
 39a:	685b      	ldr	r3, [r3, #4]
 39c:	2b00      	cmp	r3, #0
 39e:	d009      	beq.n	3b4 <sys_timeouts_mbox_fetch+0x44>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
 3a0:	4b20      	ldr	r3, [pc, #128]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 3a2:	681b      	ldr	r3, [r3, #0]
 3a4:	685b      	ldr	r3, [r3, #4]
 3a6:	6878      	ldr	r0, [r7, #4]
 3a8:	6839      	ldr	r1, [r7, #0]
 3aa:	461a      	mov	r2, r3
 3ac:	f7ff fffe 	bl	0 <sys_arch_mbox_fetch>
			3ac: R_ARM_THM_CALL	sys_arch_mbox_fetch
 3b0:	6178      	str	r0, [r7, #20]
 3b2:	e002      	b.n	3ba <sys_timeouts_mbox_fetch+0x4a>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
 3b4:	f04f 33ff 	mov.w	r3, #4294967295
 3b8:	617b      	str	r3, [r7, #20]
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
 3ba:	697b      	ldr	r3, [r7, #20]
 3bc:	f1b3 3fff 	cmp.w	r3, #4294967295
 3c0:	d118      	bne.n	3f4 <sys_timeouts_mbox_fetch+0x84>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
 3c2:	4b18      	ldr	r3, [pc, #96]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 3c4:	681b      	ldr	r3, [r3, #0]
 3c6:	613b      	str	r3, [r7, #16]
      next_timeout = tmptimeout->next;
 3c8:	693b      	ldr	r3, [r7, #16]
 3ca:	681a      	ldr	r2, [r3, #0]
 3cc:	4b15      	ldr	r3, [pc, #84]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 3ce:	601a      	str	r2, [r3, #0]
      handler = tmptimeout->h;
 3d0:	693b      	ldr	r3, [r7, #16]
 3d2:	689b      	ldr	r3, [r3, #8]
 3d4:	60fb      	str	r3, [r7, #12]
      arg = tmptimeout->arg;
 3d6:	693b      	ldr	r3, [r7, #16]
 3d8:	68db      	ldr	r3, [r3, #12]
 3da:	60bb      	str	r3, [r7, #8]
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 3dc:	f04f 000c 	mov.w	r0, #12
 3e0:	6939      	ldr	r1, [r7, #16]
 3e2:	f7ff fffe 	bl	0 <memp_free>
			3e2: R_ARM_THM_CALL	memp_free
      if (handler != NULL) {
 3e6:	68fb      	ldr	r3, [r7, #12]
 3e8:	2b00      	cmp	r3, #0
 3ea:	d0c7      	beq.n	37c <sys_timeouts_mbox_fetch+0xc>
        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
           timeout handler function. */
        LOCK_TCPIP_CORE();
        handler(arg);
 3ec:	68fb      	ldr	r3, [r7, #12]
 3ee:	68b8      	ldr	r0, [r7, #8]
 3f0:	4798      	blx	r3
        UNLOCK_TCPIP_CORE();
      }
      LWIP_TCPIP_THREAD_ALIVE();

      /* We try again to fetch a message from the mbox. */
      goto again;
 3f2:	e7c4      	b.n	37e <sys_timeouts_mbox_fetch+0xe>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
 3f4:	4b0b      	ldr	r3, [pc, #44]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 3f6:	681b      	ldr	r3, [r3, #0]
 3f8:	685a      	ldr	r2, [r3, #4]
 3fa:	697b      	ldr	r3, [r7, #20]
 3fc:	429a      	cmp	r2, r3
 3fe:	d908      	bls.n	412 <sys_timeouts_mbox_fetch+0xa2>
        next_timeout->time -= time_needed;
 400:	4b08      	ldr	r3, [pc, #32]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 402:	681b      	ldr	r3, [r3, #0]
 404:	4a07      	ldr	r2, [pc, #28]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 406:	6812      	ldr	r2, [r2, #0]
 408:	6851      	ldr	r1, [r2, #4]
 40a:	697a      	ldr	r2, [r7, #20]
 40c:	1a8a      	subs	r2, r1, r2
 40e:	605a      	str	r2, [r3, #4]
 410:	e004      	b.n	41c <sys_timeouts_mbox_fetch+0xac>
      } else {
        next_timeout->time = 0;
 412:	4b04      	ldr	r3, [pc, #16]	; (424 <sys_timeouts_mbox_fetch+0xb4>)
 414:	681b      	ldr	r3, [r3, #0]
 416:	f04f 0200 	mov.w	r2, #0
 41a:	605a      	str	r2, [r3, #4]
      }
    }
  }
}
 41c:	f107 0718 	add.w	r7, r7, #24
 420:	46bd      	mov	sp, r7
 422:	bd80      	pop	{r7, pc}
 424:	00000000 	.word	0x00000000
			424: R_ARM_ABS32	.bss

udp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  56820 Jul 30 19:07 2021 udp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000079c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000002  00000000  00000000  000007d0  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000007d2  2**0
                  ALLOC
  3 .debug_abbrev 000001f6  00000000  00000000  000007d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000cea  00000000  00000000  000009c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000006d5  00000000  00000000  000016b2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00009f4a  00000000  00000000  00001d87  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000295  00000000  00000000  0000bcd1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000c0  00000000  00000000  0000bf66  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000170  00000000  00000000  0000c026  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000c196  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000006e2  00000000  00000000  0000c1b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000c898  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000c8c3  2**0
                  CONTENTS, READONLY
 14 .debug_frame  0000017c  00000000  00000000  0000c8f4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 udp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     O .data	00000002 udp_port
0000000c l     F .text	00000088 udp_new_port
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 udp_pcbs
00000000 g     F .text	0000000a udp_init
00000094 g     F .text	000002b4 udp_input
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 ip4_addr_isbroadcast
00000000         *UND*	00000000 lwip_ntohs
00000000         *UND*	00000000 current_iphdr_dest
00000000         *UND*	00000000 current_iphdr_src
00000000         *UND*	00000000 icmp_dest_unreach
00000348 g     F .text	00000028 udp_send
00000370 g     F .text	00000056 udp_sendto
00000000         *UND*	00000000 ip_route
000003c8 g     F .text	0000016e udp_sendto_if
00000538 g     F .text	000000cc udp_bind
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 pbuf_chain
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 ip_output_if
00000604 g     F .text	000000a4 udp_connect
000006a8 g     F .text	00000030 udp_disconnect
000006d8 g     F .text	00000022 udp_recv
000006fc g     F .text	00000064 udp_remove
00000000         *UND*	00000000 memp_free
00000760 g     F .text	0000003a udp_new
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 memset



Disassembly of section .text:

00000000 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
#if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
  udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
#endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
}
   4:	46bd      	mov	sp, r7
   6:	bc80      	pop	{r7}
   8:	4770      	bx	lr
   a:	bf00      	nop

0000000c <udp_new_port>:
 *
 * @return a new (free) local UDP port number
 */
static u16_t
udp_new_port(void)
{
   c:	b480      	push	{r7}
   e:	b083      	sub	sp, #12
  10:	af00      	add	r7, sp, #0
  u16_t n = 0;
  12:	f04f 0300 	mov.w	r3, #0
  16:	80fb      	strh	r3, [r7, #6]
  18:	e000      	b.n	1c <udp_new_port+0x10>
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
        return 0;
      }
      goto again;
  1a:	bf00      	nop
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
  1c:	4b1b      	ldr	r3, [pc, #108]	; (8c <udp_new_port+0x80>)
  1e:	881b      	ldrh	r3, [r3, #0]
  20:	f64f 72ff 	movw	r2, #65535	; 0xffff
  24:	4293      	cmp	r3, r2
  26:	bf14      	ite	ne
  28:	2200      	movne	r2, #0
  2a:	2201      	moveq	r2, #1
  2c:	b2d2      	uxtb	r2, r2
  2e:	f103 0301 	add.w	r3, r3, #1
  32:	b299      	uxth	r1, r3
  34:	4b15      	ldr	r3, [pc, #84]	; (8c <udp_new_port+0x80>)
  36:	8019      	strh	r1, [r3, #0]
  38:	2a00      	cmp	r2, #0
  3a:	d003      	beq.n	44 <udp_new_port+0x38>
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  3c:	4b13      	ldr	r3, [pc, #76]	; (8c <udp_new_port+0x80>)
  3e:	f44f 4240 	mov.w	r2, #49152	; 0xc000
  42:	801a      	strh	r2, [r3, #0]
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  44:	4b12      	ldr	r3, [pc, #72]	; (90 <udp_new_port+0x84>)
  46:	681b      	ldr	r3, [r3, #0]
  48:	603b      	str	r3, [r7, #0]
  4a:	e014      	b.n	76 <udp_new_port+0x6a>
    if (pcb->local_port == udp_port) {
  4c:	683b      	ldr	r3, [r7, #0]
  4e:	8a5a      	ldrh	r2, [r3, #18]
  50:	4b0e      	ldr	r3, [pc, #56]	; (8c <udp_new_port+0x80>)
  52:	881b      	ldrh	r3, [r3, #0]
  54:	429a      	cmp	r2, r3
  56:	d10b      	bne.n	70 <udp_new_port+0x64>
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
  58:	88fb      	ldrh	r3, [r7, #6]
  5a:	f103 0301 	add.w	r3, r3, #1
  5e:	80fb      	strh	r3, [r7, #6]
  60:	88fa      	ldrh	r2, [r7, #6]
  62:	f643 73ff 	movw	r3, #16383	; 0x3fff
  66:	429a      	cmp	r2, r3
  68:	d9d7      	bls.n	1a <udp_new_port+0xe>
        return 0;
  6a:	f04f 0300 	mov.w	r3, #0
  6e:	e007      	b.n	80 <udp_new_port+0x74>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  70:	683b      	ldr	r3, [r7, #0]
  72:	68db      	ldr	r3, [r3, #12]
  74:	603b      	str	r3, [r7, #0]
  76:	683b      	ldr	r3, [r7, #0]
  78:	2b00      	cmp	r3, #0
  7a:	d1e7      	bne.n	4c <udp_new_port+0x40>
        return 0;
      }
      goto again;
    }
  }
  return udp_port;
  7c:	4b03      	ldr	r3, [pc, #12]	; (8c <udp_new_port+0x80>)
  7e:	881b      	ldrh	r3, [r3, #0]
  if (ipcb != NULL) {
    return 0;
  }
  return udp_port;
#endif
}
  80:	4618      	mov	r0, r3
  82:	f107 070c 	add.w	r7, r7, #12
  86:	46bd      	mov	sp, r7
  88:	bc80      	pop	{r7}
  8a:	4770      	bx	lr
	...
			8c: R_ARM_ABS32	.data
			90: R_ARM_ABS32	udp_pcbs

00000094 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  94:	b590      	push	{r4, r7, lr}
  96:	b08d      	sub	sp, #52	; 0x34
  98:	af02      	add	r7, sp, #8
  9a:	6078      	str	r0, [r7, #4]
  9c:	6039      	str	r1, [r7, #0]

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = (struct ip_hdr *)p->payload;
  9e:	687b      	ldr	r3, [r7, #4]
  a0:	685b      	ldr	r3, [r3, #4]
  a2:	617b      	str	r3, [r7, #20]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  a4:	687b      	ldr	r3, [r7, #4]
  a6:	891b      	ldrh	r3, [r3, #8]
  a8:	461a      	mov	r2, r3
  aa:	697b      	ldr	r3, [r7, #20]
  ac:	781b      	ldrb	r3, [r3, #0]
  ae:	f003 030f 	and.w	r3, r3, #15
  b2:	f103 0302 	add.w	r3, r3, #2
  b6:	ea4f 0383 	mov.w	r3, r3, lsl #2
  ba:	429a      	cmp	r2, r3
  bc:	db13      	blt.n	e6 <udp_input+0x52>
  be:	697b      	ldr	r3, [r7, #20]
  c0:	781b      	ldrb	r3, [r3, #0]
  c2:	f003 030f 	and.w	r3, r3, #15
  c6:	b29b      	uxth	r3, r3
  c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
  cc:	b29b      	uxth	r3, r3
  ce:	f1c3 0300 	rsb	r3, r3, #0
  d2:	b29b      	uxth	r3, r3
  d4:	b29b      	uxth	r3, r3
  d6:	b21b      	sxth	r3, r3
  d8:	6878      	ldr	r0, [r7, #4]
  da:	4619      	mov	r1, r3
  dc:	f7ff fffe 	bl	0 <pbuf_header>
			dc: R_ARM_THM_CALL	pbuf_header
  e0:	4603      	mov	r3, r0
  e2:	2b00      	cmp	r3, #0
  e4:	d003      	beq.n	ee <udp_input+0x5a>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  e6:	6878      	ldr	r0, [r7, #4]
  e8:	f7ff fffe 	bl	0 <pbuf_free>
			e8: R_ARM_THM_CALL	pbuf_free
    goto end;
  ec:	e125      	b.n	33a <udp_input+0x2a6>
  }

  udphdr = (struct udp_hdr *)p->payload;
  ee:	687b      	ldr	r3, [r7, #4]
  f0:	685b      	ldr	r3, [r3, #4]
  f2:	613b      	str	r3, [r7, #16]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
  f4:	4b7b      	ldr	r3, [pc, #492]	; (2e4 <udp_input+0x250>)
  f6:	681b      	ldr	r3, [r3, #0]
  f8:	4618      	mov	r0, r3
  fa:	6839      	ldr	r1, [r7, #0]
  fc:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			fc: R_ARM_THM_CALL	ip4_addr_isbroadcast
 100:	4603      	mov	r3, r0
 102:	73fb      	strb	r3, [r7, #15]

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 104:	693b      	ldr	r3, [r7, #16]
 106:	881b      	ldrh	r3, [r3, #0]
 108:	b29b      	uxth	r3, r3
 10a:	4618      	mov	r0, r3
 10c:	f7ff fffe 	bl	0 <lwip_ntohs>
			10c: R_ARM_THM_CALL	lwip_ntohs
 110:	4603      	mov	r3, r0
 112:	81bb      	strh	r3, [r7, #12]
  dest = ntohs(udphdr->dest);
 114:	693b      	ldr	r3, [r7, #16]
 116:	885b      	ldrh	r3, [r3, #2]
 118:	b29b      	uxth	r3, r3
 11a:	4618      	mov	r0, r3
 11c:	f7ff fffe 	bl	0 <lwip_ntohs>
			11c: R_ARM_THM_CALL	lwip_ntohs
 120:	4603      	mov	r3, r0
 122:	817b      	strh	r3, [r7, #10]
               ip4_addr3_16(&iphdr->dest), ip4_addr4_16(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1_16(&iphdr->src), ip4_addr2_16(&iphdr->src),
               ip4_addr3_16(&iphdr->src), ip4_addr4_16(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
 124:	f04f 0300 	mov.w	r3, #0
 128:	627b      	str	r3, [r7, #36]	; 0x24
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
 12a:	897b      	ldrh	r3, [r7, #10]
 12c:	2b44      	cmp	r3, #68	; 0x44
 12e:	d129      	bne.n	184 <udp_input+0xf0>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
 130:	89bb      	ldrh	r3, [r7, #12]
 132:	2b43      	cmp	r3, #67	; 0x43
 134:	f040 80a9 	bne.w	28a <udp_input+0x1f6>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
 138:	683b      	ldr	r3, [r7, #0]
 13a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 13c:	2b00      	cmp	r3, #0
 13e:	f000 80a4 	beq.w	28a <udp_input+0x1f6>
 142:	683b      	ldr	r3, [r7, #0]
 144:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 146:	685b      	ldr	r3, [r3, #4]
 148:	2b00      	cmp	r3, #0
 14a:	f000 809e 	beq.w	28a <udp_input+0x1f6>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 14e:	683b      	ldr	r3, [r7, #0]
 150:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 152:	685b      	ldr	r3, [r3, #4]
 154:	f103 0304 	add.w	r3, r3, #4
 158:	2b00      	cmp	r3, #0
 15a:	d00e      	beq.n	17a <udp_input+0xe6>
 15c:	683b      	ldr	r3, [r7, #0]
 15e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 160:	685b      	ldr	r3, [r3, #4]
 162:	685b      	ldr	r3, [r3, #4]
 164:	2b00      	cmp	r3, #0
 166:	d008      	beq.n	17a <udp_input+0xe6>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
 168:	683b      	ldr	r3, [r7, #0]
 16a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 16c:	685b      	ldr	r3, [r3, #4]
 16e:	685a      	ldr	r2, [r3, #4]
 170:	4b5d      	ldr	r3, [pc, #372]	; (2e8 <udp_input+0x254>)
 172:	681b      	ldr	r3, [r3, #0]
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
 174:	429a      	cmp	r2, r3
 176:	f040 8088 	bne.w	28a <udp_input+0x1f6>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &current_iphdr_src))) {
          pcb = inp->dhcp->pcb;
 17a:	683b      	ldr	r3, [r7, #0]
 17c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 17e:	685b      	ldr	r3, [r3, #4]
 180:	627b      	str	r3, [r7, #36]	; 0x24
 182:	e082      	b.n	28a <udp_input+0x1f6>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
 184:	f04f 0300 	mov.w	r3, #0
 188:	623b      	str	r3, [r7, #32]
    local_match = 0;
 18a:	f04f 0300 	mov.w	r3, #0
 18e:	76fb      	strb	r3, [r7, #27]
    uncon_pcb = NULL;
 190:	f04f 0300 	mov.w	r3, #0
 194:	61fb      	str	r3, [r7, #28]
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 196:	4b55      	ldr	r3, [pc, #340]	; (2ec <udp_input+0x258>)
 198:	681b      	ldr	r3, [r3, #0]
 19a:	627b      	str	r3, [r7, #36]	; 0x24
 19c:	e06b      	b.n	276 <udp_input+0x1e2>
      local_match = 0;
 19e:	f04f 0300 	mov.w	r3, #0
 1a2:	76fb      	strb	r3, [r7, #27]
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
 1a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1a6:	8a5b      	ldrh	r3, [r3, #18]
 1a8:	897a      	ldrh	r2, [r7, #10]
 1aa:	429a      	cmp	r2, r3
 1ac:	d138      	bne.n	220 <udp_input+0x18c>
        if (
 1ae:	7bfb      	ldrb	r3, [r7, #15]
 1b0:	2b00      	cmp	r3, #0
 1b2:	d106      	bne.n	1c2 <udp_input+0x12e>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 1b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1b6:	2b00      	cmp	r3, #0
 1b8:	d024      	beq.n	204 <udp_input+0x170>
 1ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1bc:	681b      	ldr	r3, [r3, #0]
 1be:	2b00      	cmp	r3, #0
 1c0:	d020      	beq.n	204 <udp_input+0x170>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 1c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1c4:	681a      	ldr	r2, [r3, #0]
 1c6:	4b47      	ldr	r3, [pc, #284]	; (2e4 <udp_input+0x250>)
 1c8:	681b      	ldr	r3, [r3, #0]
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 1ca:	429a      	cmp	r2, r3
 1cc:	d01a      	beq.n	204 <udp_input+0x170>
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
#if LWIP_IGMP
           ip_addr_ismulticast(&current_iphdr_dest) ||
 1ce:	4b45      	ldr	r3, [pc, #276]	; (2e4 <udp_input+0x250>)
 1d0:	681b      	ldr	r3, [r3, #0]
 1d2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 1d6:	2be0      	cmp	r3, #224	; 0xe0
 1d8:	d014      	beq.n	204 <udp_input+0x170>
#if LWIP_IGMP
           ip_addr_ismulticast(&current_iphdr_dest) ||
 1da:	7bfb      	ldrb	r3, [r7, #15]
 1dc:	2b00      	cmp	r3, #0
 1de:	d01f      	beq.n	220 <udp_input+0x18c>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
 1e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
#if IP_SOF_BROADCAST_RECV
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
 1e2:	2b00      	cmp	r3, #0
 1e4:	d00e      	beq.n	204 <udp_input+0x170>
             (ip_addr_isany(&pcb->local_ip) ||
 1e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1e8:	681b      	ldr	r3, [r3, #0]
 1ea:	2b00      	cmp	r3, #0
 1ec:	d00a      	beq.n	204 <udp_input+0x170>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
 1ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 1f0:	681a      	ldr	r2, [r3, #0]
 1f2:	4b3c      	ldr	r3, [pc, #240]	; (2e4 <udp_input+0x250>)
 1f4:	681b      	ldr	r3, [r3, #0]
 1f6:	405a      	eors	r2, r3
 1f8:	683b      	ldr	r3, [r7, #0]
 1fa:	689b      	ldr	r3, [r3, #8]
 1fc:	ea02 0303 	and.w	r3, r2, r3
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
 200:	2b00      	cmp	r3, #0
 202:	d10d      	bne.n	220 <udp_input+0x18c>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
 204:	f04f 0301 	mov.w	r3, #1
 208:	76fb      	strb	r3, [r7, #27]
          if ((uncon_pcb == NULL) && 
 20a:	69fb      	ldr	r3, [r7, #28]
 20c:	2b00      	cmp	r3, #0
 20e:	d107      	bne.n	220 <udp_input+0x18c>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
 210:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 212:	7c1b      	ldrb	r3, [r3, #16]
 214:	f003 0304 	and.w	r3, r3, #4
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 218:	2b00      	cmp	r3, #0
 21a:	d101      	bne.n	220 <udp_input+0x18c>
              ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
            /* the first unconnected matching PCB */
            uncon_pcb = pcb;
 21c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 21e:	61fb      	str	r3, [r7, #28]
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 220:	7efb      	ldrb	r3, [r7, #27]
 222:	2b00      	cmp	r3, #0
 224:	d022      	beq.n	26c <udp_input+0x1d8>
          (pcb->remote_port == src) &&
 226:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 228:	8a9b      	ldrh	r3, [r3, #20]
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 22a:	89ba      	ldrh	r2, [r7, #12]
 22c:	429a      	cmp	r2, r3
 22e:	d11d      	bne.n	26c <udp_input+0x1d8>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 230:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 232:	f103 0304 	add.w	r3, r3, #4
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
 236:	2b00      	cmp	r3, #0
 238:	d009      	beq.n	24e <udp_input+0x1ba>
          (ip_addr_isany(&pcb->remote_ip) ||
 23a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 23c:	685b      	ldr	r3, [r3, #4]
 23e:	2b00      	cmp	r3, #0
 240:	d005      	beq.n	24e <udp_input+0x1ba>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 242:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 244:	685a      	ldr	r2, [r3, #4]
 246:	4b28      	ldr	r3, [pc, #160]	; (2e8 <udp_input+0x254>)
 248:	681b      	ldr	r3, [r3, #0]
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 24a:	429a      	cmp	r2, r3
 24c:	d10e      	bne.n	26c <udp_input+0x1d8>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 24e:	6a3b      	ldr	r3, [r7, #32]
 250:	2b00      	cmp	r3, #0
 252:	d014      	beq.n	27e <udp_input+0x1ea>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 254:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 256:	68da      	ldr	r2, [r3, #12]
 258:	6a3b      	ldr	r3, [r7, #32]
 25a:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
 25c:	4b23      	ldr	r3, [pc, #140]	; (2ec <udp_input+0x258>)
 25e:	681a      	ldr	r2, [r3, #0]
 260:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 262:	60da      	str	r2, [r3, #12]
          udp_pcbs = pcb;
 264:	4b21      	ldr	r3, [pc, #132]	; (2ec <udp_input+0x258>)
 266:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 268:	601a      	str	r2, [r3, #0]
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 26a:	e009      	b.n	280 <udp_input+0x1ec>
      }
      prev = pcb;
 26c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 26e:	623b      	str	r3, [r7, #32]
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 270:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 272:	68db      	ldr	r3, [r3, #12]
 274:	627b      	str	r3, [r7, #36]	; 0x24
 276:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 278:	2b00      	cmp	r3, #0
 27a:	d190      	bne.n	19e <udp_input+0x10a>
 27c:	e000      	b.n	280 <udp_input+0x1ec>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
 27e:	bf00      	nop
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
 280:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 282:	2b00      	cmp	r3, #0
 284:	d101      	bne.n	28a <udp_input+0x1f6>
      pcb = uncon_pcb;
 286:	69fb      	ldr	r3, [r7, #28]
 288:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 28a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 28c:	2b00      	cmp	r3, #0
 28e:	d105      	bne.n	29c <udp_input+0x208>
 290:	683b      	ldr	r3, [r7, #0]
 292:	685a      	ldr	r2, [r3, #4]
 294:	4b13      	ldr	r3, [pc, #76]	; (2e4 <udp_input+0x250>)
 296:	681b      	ldr	r3, [r3, #0]
 298:	429a      	cmp	r2, r3
 29a:	d14b      	bne.n	334 <udp_input+0x2a0>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 29c:	6878      	ldr	r0, [r7, #4]
 29e:	f06f 0107 	mvn.w	r1, #7
 2a2:	f7ff fffe 	bl	0 <pbuf_header>
			2a2: R_ARM_THM_CALL	pbuf_header
 2a6:	4603      	mov	r3, r0
 2a8:	2b00      	cmp	r3, #0
 2aa:	d003      	beq.n	2b4 <udp_input+0x220>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
 2ac:	6878      	ldr	r0, [r7, #4]
 2ae:	f7ff fffe 	bl	0 <pbuf_free>
			2ae: R_ARM_THM_CALL	pbuf_free
      goto end;
 2b2:	e042      	b.n	33a <udp_input+0x2a6>
    }
    if (pcb != NULL) {
 2b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 2b6:	2b00      	cmp	r3, #0
 2b8:	d01a      	beq.n	2f0 <udp_input+0x25c>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 2ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 2bc:	69db      	ldr	r3, [r3, #28]
 2be:	2b00      	cmp	r3, #0
 2c0:	d00b      	beq.n	2da <udp_input+0x246>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 2c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 2c4:	69dc      	ldr	r4, [r3, #28]
 2c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 2c8:	6a1b      	ldr	r3, [r3, #32]
 2ca:	89ba      	ldrh	r2, [r7, #12]
 2cc:	9200      	str	r2, [sp, #0]
 2ce:	4618      	mov	r0, r3
 2d0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 2d2:	687a      	ldr	r2, [r7, #4]
 2d4:	4b04      	ldr	r3, [pc, #16]	; (2e8 <udp_input+0x254>)
 2d6:	47a0      	blx	r4
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 2d8:	e02f      	b.n	33a <udp_input+0x2a6>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
 2da:	6878      	ldr	r0, [r7, #4]
 2dc:	f7ff fffe 	bl	0 <pbuf_free>
			2dc: R_ARM_THM_CALL	pbuf_free
        goto end;
 2e0:	e02b      	b.n	33a <udp_input+0x2a6>
 2e2:	bf00      	nop
	...
			2e4: R_ARM_ABS32	current_iphdr_dest
			2e8: R_ARM_ABS32	current_iphdr_src
			2ec: R_ARM_ABS32	udp_pcbs
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 2f0:	7bfb      	ldrb	r3, [r7, #15]
 2f2:	2b00      	cmp	r3, #0
 2f4:	d11a      	bne.n	32c <udp_input+0x298>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 2f6:	4b13      	ldr	r3, [pc, #76]	; (344 <udp_input+0x2b0>)
 2f8:	681b      	ldr	r3, [r3, #0]
 2fa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 2fe:	2be0      	cmp	r3, #224	; 0xe0
 300:	d014      	beq.n	32c <udp_input+0x298>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 302:	697b      	ldr	r3, [r7, #20]
 304:	781b      	ldrb	r3, [r3, #0]
 306:	f003 030f 	and.w	r3, r3, #15
 30a:	f103 0302 	add.w	r3, r3, #2
 30e:	b29b      	uxth	r3, r3
 310:	ea4f 0383 	mov.w	r3, r3, lsl #2
 314:	b29b      	uxth	r3, r3
 316:	b29b      	uxth	r3, r3
 318:	b21b      	sxth	r3, r3
 31a:	6878      	ldr	r0, [r7, #4]
 31c:	4619      	mov	r1, r3
 31e:	f7ff fffe 	bl	0 <pbuf_header>
			31e: R_ARM_THM_CALL	pbuf_header
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 322:	6878      	ldr	r0, [r7, #4]
 324:	f04f 0103 	mov.w	r1, #3
 328:	f7ff fffe 	bl	0 <icmp_dest_unreach>
			328: R_ARM_THM_CALL	icmp_dest_unreach
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
 32c:	6878      	ldr	r0, [r7, #4]
 32e:	f7ff fffe 	bl	0 <pbuf_free>
			32e: R_ARM_THM_CALL	pbuf_free
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
 332:	e002      	b.n	33a <udp_input+0x2a6>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
 334:	6878      	ldr	r0, [r7, #4]
 336:	f7ff fffe 	bl	0 <pbuf_free>
			336: R_ARM_THM_CALL	pbuf_free
  }
end:
  PERF_STOP("udp_input");
}
 33a:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 33e:	46bd      	mov	sp, r7
 340:	bd90      	pop	{r4, r7, pc}
 342:	bf00      	nop
 344:	00000000 	.word	0x00000000
			344: R_ARM_ABS32	current_iphdr_dest

00000348 <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 348:	b580      	push	{r7, lr}
 34a:	b082      	sub	sp, #8
 34c:	af00      	add	r7, sp, #0
 34e:	6078      	str	r0, [r7, #4]
 350:	6039      	str	r1, [r7, #0]
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 352:	687b      	ldr	r3, [r7, #4]
 354:	f103 0204 	add.w	r2, r3, #4
 358:	687b      	ldr	r3, [r7, #4]
 35a:	8a9b      	ldrh	r3, [r3, #20]
 35c:	6878      	ldr	r0, [r7, #4]
 35e:	6839      	ldr	r1, [r7, #0]
 360:	f7ff fffe 	bl	370 <udp_sendto>
			360: R_ARM_THM_CALL	udp_sendto
 364:	4603      	mov	r3, r0
}
 366:	4618      	mov	r0, r3
 368:	f107 0708 	add.w	r7, r7, #8
 36c:	46bd      	mov	sp, r7
 36e:	bd80      	pop	{r7, pc}

00000370 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
 370:	b580      	push	{r7, lr}
 372:	b088      	sub	sp, #32
 374:	af02      	add	r7, sp, #8
 376:	60f8      	str	r0, [r7, #12]
 378:	60b9      	str	r1, [r7, #8]
 37a:	607a      	str	r2, [r7, #4]
 37c:	807b      	strh	r3, [r7, #2]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
 37e:	687b      	ldr	r3, [r7, #4]
 380:	681b      	ldr	r3, [r3, #0]
 382:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 386:	2be0      	cmp	r3, #224	; 0xe0
 388:	d103      	bne.n	392 <udp_sendto+0x22>
 38a:	68fb      	ldr	r3, [r7, #12]
 38c:	f103 0318 	add.w	r3, r3, #24
 390:	e000      	b.n	394 <udp_sendto+0x24>
 392:	687b      	ldr	r3, [r7, #4]
 394:	4618      	mov	r0, r3
 396:	f7ff fffe 	bl	0 <ip_route>
			396: R_ARM_THM_CALL	ip_route
 39a:	6178      	str	r0, [r7, #20]
#else
  netif = ip_route(dst_ip);
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 39c:	697b      	ldr	r3, [r7, #20]
 39e:	2b00      	cmp	r3, #0
 3a0:	d102      	bne.n	3a8 <udp_sendto+0x38>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 3a2:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 3a6:	e008      	b.n	3ba <udp_sendto+0x4a>
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 3a8:	887b      	ldrh	r3, [r7, #2]
 3aa:	697a      	ldr	r2, [r7, #20]
 3ac:	9200      	str	r2, [sp, #0]
 3ae:	68f8      	ldr	r0, [r7, #12]
 3b0:	68b9      	ldr	r1, [r7, #8]
 3b2:	687a      	ldr	r2, [r7, #4]
 3b4:	f7ff fffe 	bl	3c8 <udp_sendto_if>
			3b4: R_ARM_THM_CALL	udp_sendto_if
 3b8:	4603      	mov	r3, r0
 3ba:	b25b      	sxtb	r3, r3
#endif /* LWIP_CHECKSUM_ON_COPY */
}
 3bc:	4618      	mov	r0, r3
 3be:	f107 0718 	add.w	r7, r7, #24
 3c2:	46bd      	mov	sp, r7
 3c4:	bd80      	pop	{r7, pc}
 3c6:	bf00      	nop

000003c8 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 3c8:	b580      	push	{r7, lr}
 3ca:	b08c      	sub	sp, #48	; 0x30
 3cc:	af04      	add	r7, sp, #16
 3ce:	60f8      	str	r0, [r7, #12]
 3d0:	60b9      	str	r1, [r7, #8]
 3d2:	607a      	str	r2, [r7, #4]
 3d4:	807b      	strh	r3, [r7, #2]
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 3d6:	68fb      	ldr	r3, [r7, #12]
 3d8:	8a5b      	ldrh	r3, [r3, #18]
 3da:	2b00      	cmp	r3, #0
 3dc:	d10f      	bne.n	3fe <udp_sendto_if+0x36>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 3de:	68fa      	ldr	r2, [r7, #12]
 3e0:	68fb      	ldr	r3, [r7, #12]
 3e2:	8a5b      	ldrh	r3, [r3, #18]
 3e4:	68f8      	ldr	r0, [r7, #12]
 3e6:	4611      	mov	r1, r2
 3e8:	461a      	mov	r2, r3
 3ea:	f7ff fffe 	bl	538 <udp_bind>
			3ea: R_ARM_THM_CALL	udp_bind
 3ee:	4603      	mov	r3, r0
 3f0:	75fb      	strb	r3, [r7, #23]
    if (err != ERR_OK) {
 3f2:	f997 3017 	ldrsb.w	r3, [r7, #23]
 3f6:	2b00      	cmp	r3, #0
 3f8:	d001      	beq.n	3fe <udp_sendto_if+0x36>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
      return err;
 3fa:	7dfb      	ldrb	r3, [r7, #23]
 3fc:	e095      	b.n	52a <udp_sendto_if+0x162>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 3fe:	68b8      	ldr	r0, [r7, #8]
 400:	f04f 0108 	mov.w	r1, #8
 404:	f7ff fffe 	bl	0 <pbuf_header>
			404: R_ARM_THM_CALL	pbuf_header
 408:	4603      	mov	r3, r0
 40a:	2b00      	cmp	r3, #0
 40c:	d017      	beq.n	43e <udp_sendto_if+0x76>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 40e:	f04f 0001 	mov.w	r0, #1
 412:	f04f 0108 	mov.w	r1, #8
 416:	f04f 0200 	mov.w	r2, #0
 41a:	f7ff fffe 	bl	0 <pbuf_alloc>
			41a: R_ARM_THM_CALL	pbuf_alloc
 41e:	61b8      	str	r0, [r7, #24]
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 420:	69bb      	ldr	r3, [r7, #24]
 422:	2b00      	cmp	r3, #0
 424:	d102      	bne.n	42c <udp_sendto_if+0x64>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 426:	f04f 03ff 	mov.w	r3, #255	; 0xff
 42a:	e07e      	b.n	52a <udp_sendto_if+0x162>
    }
    if (p->tot_len != 0) {
 42c:	68bb      	ldr	r3, [r7, #8]
 42e:	891b      	ldrh	r3, [r3, #8]
 430:	2b00      	cmp	r3, #0
 432:	d006      	beq.n	442 <udp_sendto_if+0x7a>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 434:	69b8      	ldr	r0, [r7, #24]
 436:	68b9      	ldr	r1, [r7, #8]
 438:	f7ff fffe 	bl	0 <pbuf_chain>
			438: R_ARM_THM_CALL	pbuf_chain
 43c:	e001      	b.n	442 <udp_sendto_if+0x7a>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
 43e:	68bb      	ldr	r3, [r7, #8]
 440:	61bb      	str	r3, [r7, #24]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 442:	69bb      	ldr	r3, [r7, #24]
 444:	685b      	ldr	r3, [r3, #4]
 446:	613b      	str	r3, [r7, #16]
  udphdr->src = htons(pcb->local_port);
 448:	68fb      	ldr	r3, [r7, #12]
 44a:	8a5b      	ldrh	r3, [r3, #18]
 44c:	4618      	mov	r0, r3
 44e:	f7ff fffe 	bl	0 <lwip_htons>
			44e: R_ARM_THM_CALL	lwip_htons
 452:	4603      	mov	r3, r0
 454:	461a      	mov	r2, r3
 456:	693b      	ldr	r3, [r7, #16]
 458:	801a      	strh	r2, [r3, #0]
  udphdr->dest = htons(dst_port);
 45a:	887b      	ldrh	r3, [r7, #2]
 45c:	4618      	mov	r0, r3
 45e:	f7ff fffe 	bl	0 <lwip_htons>
			45e: R_ARM_THM_CALL	lwip_htons
 462:	4603      	mov	r3, r0
 464:	461a      	mov	r2, r3
 466:	693b      	ldr	r3, [r7, #16]
 468:	805a      	strh	r2, [r3, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 46a:	693b      	ldr	r3, [r7, #16]
 46c:	f04f 0200 	mov.w	r2, #0
 470:	719a      	strb	r2, [r3, #6]
 472:	f04f 0200 	mov.w	r2, #0
 476:	71da      	strb	r2, [r3, #7]

  /* Multicast Loop? */
#if LWIP_IGMP
  if (ip_addr_ismulticast(dst_ip) && ((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0)) {
 478:	687b      	ldr	r3, [r7, #4]
 47a:	681b      	ldr	r3, [r3, #0]
 47c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 480:	2be0      	cmp	r3, #224	; 0xe0
 482:	d10c      	bne.n	49e <udp_sendto_if+0xd6>
 484:	68fb      	ldr	r3, [r7, #12]
 486:	7c1b      	ldrb	r3, [r3, #16]
 488:	f003 0308 	and.w	r3, r3, #8
 48c:	2b00      	cmp	r3, #0
 48e:	d006      	beq.n	49e <udp_sendto_if+0xd6>
    q->flags |= PBUF_FLAG_MCASTLOOP;
 490:	69bb      	ldr	r3, [r7, #24]
 492:	7b5b      	ldrb	r3, [r3, #13]
 494:	f043 0304 	orr.w	r3, r3, #4
 498:	b2da      	uxtb	r2, r3
 49a:	69bb      	ldr	r3, [r7, #24]
 49c:	735a      	strb	r2, [r3, #13]
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 49e:	68fb      	ldr	r3, [r7, #12]
 4a0:	2b00      	cmp	r3, #0
 4a2:	d003      	beq.n	4ac <udp_sendto_if+0xe4>
 4a4:	68fb      	ldr	r3, [r7, #12]
 4a6:	681b      	ldr	r3, [r3, #0]
 4a8:	2b00      	cmp	r3, #0
 4aa:	d104      	bne.n	4b6 <udp_sendto_if+0xee>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 4ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 4ae:	f103 0304 	add.w	r3, r3, #4
 4b2:	61fb      	str	r3, [r7, #28]
 4b4:	e014      	b.n	4e0 <udp_sendto_if+0x118>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 4b6:	68fb      	ldr	r3, [r7, #12]
 4b8:	681a      	ldr	r2, [r3, #0]
 4ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
 4bc:	685b      	ldr	r3, [r3, #4]
 4be:	429a      	cmp	r2, r3
 4c0:	d00c      	beq.n	4dc <udp_sendto_if+0x114>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 4c2:	69ba      	ldr	r2, [r7, #24]
 4c4:	68bb      	ldr	r3, [r7, #8]
 4c6:	429a      	cmp	r2, r3
 4c8:	d005      	beq.n	4d6 <udp_sendto_if+0x10e>
        /* free the header pbuf */
        pbuf_free(q);
 4ca:	69b8      	ldr	r0, [r7, #24]
 4cc:	f7ff fffe 	bl	0 <pbuf_free>
			4cc: R_ARM_THM_CALL	pbuf_free
        q = NULL;
 4d0:	f04f 0300 	mov.w	r3, #0
 4d4:	61bb      	str	r3, [r7, #24]
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 4d6:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 4da:	e026      	b.n	52a <udp_sendto_if+0x162>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
 4dc:	68fb      	ldr	r3, [r7, #12]
 4de:	61fb      	str	r3, [r7, #28]
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 4e0:	69bb      	ldr	r3, [r7, #24]
 4e2:	891b      	ldrh	r3, [r3, #8]
 4e4:	4618      	mov	r0, r3
 4e6:	f7ff fffe 	bl	0 <lwip_htons>
			4e6: R_ARM_THM_CALL	lwip_htons
 4ea:	4603      	mov	r3, r0
 4ec:	461a      	mov	r2, r3
 4ee:	693b      	ldr	r3, [r7, #16]
 4f0:	809a      	strh	r2, [r3, #4]
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 4f2:	68fb      	ldr	r3, [r7, #12]
 4f4:	7a9b      	ldrb	r3, [r3, #10]
 4f6:	68fa      	ldr	r2, [r7, #12]
 4f8:	7a52      	ldrb	r2, [r2, #9]
 4fa:	9200      	str	r2, [sp, #0]
 4fc:	f04f 0211 	mov.w	r2, #17
 500:	9201      	str	r2, [sp, #4]
 502:	6aba      	ldr	r2, [r7, #40]	; 0x28
 504:	9202      	str	r2, [sp, #8]
 506:	69b8      	ldr	r0, [r7, #24]
 508:	69f9      	ldr	r1, [r7, #28]
 50a:	687a      	ldr	r2, [r7, #4]
 50c:	f7ff fffe 	bl	0 <ip_output_if>
			50c: R_ARM_THM_CALL	ip_output_if
 510:	4603      	mov	r3, r0
 512:	75fb      	strb	r3, [r7, #23]
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 514:	69ba      	ldr	r2, [r7, #24]
 516:	68bb      	ldr	r3, [r7, #8]
 518:	429a      	cmp	r2, r3
 51a:	d005      	beq.n	528 <udp_sendto_if+0x160>
    /* free the header pbuf */
    pbuf_free(q);
 51c:	69b8      	ldr	r0, [r7, #24]
 51e:	f7ff fffe 	bl	0 <pbuf_free>
			51e: R_ARM_THM_CALL	pbuf_free
    q = NULL;
 522:	f04f 0300 	mov.w	r3, #0
 526:	61bb      	str	r3, [r7, #24]
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 528:	7dfb      	ldrb	r3, [r7, #23]
 52a:	b25b      	sxtb	r3, r3
}
 52c:	4618      	mov	r0, r3
 52e:	f107 0720 	add.w	r7, r7, #32
 532:	46bd      	mov	sp, r7
 534:	bd80      	pop	{r7, pc}
 536:	bf00      	nop

00000538 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 538:	b580      	push	{r7, lr}
 53a:	b086      	sub	sp, #24
 53c:	af00      	add	r7, sp, #0
 53e:	60f8      	str	r0, [r7, #12]
 540:	60b9      	str	r1, [r7, #8]
 542:	4613      	mov	r3, r2
 544:	80fb      	strh	r3, [r7, #6]

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 546:	f04f 0300 	mov.w	r3, #0
 54a:	74fb      	strb	r3, [r7, #19]
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 54c:	4b2c      	ldr	r3, [pc, #176]	; (600 <udp_bind+0xc8>)
 54e:	681b      	ldr	r3, [r3, #0]
 550:	617b      	str	r3, [r7, #20]
 552:	e026      	b.n	5a2 <udp_bind+0x6a>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 554:	68fa      	ldr	r2, [r7, #12]
 556:	697b      	ldr	r3, [r7, #20]
 558:	429a      	cmp	r2, r3
 55a:	d103      	bne.n	564 <udp_bind+0x2c>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 55c:	f04f 0301 	mov.w	r3, #1
 560:	74fb      	strb	r3, [r7, #19]
 562:	e01b      	b.n	59c <udp_bind+0x64>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 564:	697b      	ldr	r3, [r7, #20]
 566:	8a5b      	ldrh	r3, [r3, #18]
 568:	88fa      	ldrh	r2, [r7, #6]
 56a:	429a      	cmp	r2, r3
 56c:	d116      	bne.n	59c <udp_bind+0x64>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 56e:	697b      	ldr	r3, [r7, #20]
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 570:	2b00      	cmp	r3, #0
 572:	d010      	beq.n	596 <udp_bind+0x5e>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 574:	697b      	ldr	r3, [r7, #20]
 576:	681b      	ldr	r3, [r3, #0]
 578:	2b00      	cmp	r3, #0
 57a:	d00c      	beq.n	596 <udp_bind+0x5e>
 57c:	68bb      	ldr	r3, [r7, #8]
 57e:	2b00      	cmp	r3, #0
 580:	d009      	beq.n	596 <udp_bind+0x5e>
           ip_addr_isany(ipaddr) ||
 582:	68bb      	ldr	r3, [r7, #8]
 584:	681b      	ldr	r3, [r3, #0]
 586:	2b00      	cmp	r3, #0
 588:	d005      	beq.n	596 <udp_bind+0x5e>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
 58a:	697b      	ldr	r3, [r7, #20]
 58c:	681a      	ldr	r2, [r3, #0]
 58e:	68bb      	ldr	r3, [r7, #8]
 590:	681b      	ldr	r3, [r3, #0]
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
           ip_addr_isany(ipaddr) ||
 592:	429a      	cmp	r2, r3
 594:	d102      	bne.n	59c <udp_bind+0x64>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 596:	f04f 03f8 	mov.w	r3, #248	; 0xf8
 59a:	e02b      	b.n	5f4 <udp_bind+0xbc>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 59c:	697b      	ldr	r3, [r7, #20]
 59e:	68db      	ldr	r3, [r3, #12]
 5a0:	617b      	str	r3, [r7, #20]
 5a2:	697b      	ldr	r3, [r7, #20]
 5a4:	2b00      	cmp	r3, #0
 5a6:	d1d5      	bne.n	554 <udp_bind+0x1c>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 5a8:	68bb      	ldr	r3, [r7, #8]
 5aa:	2b00      	cmp	r3, #0
 5ac:	d002      	beq.n	5b4 <udp_bind+0x7c>
 5ae:	68bb      	ldr	r3, [r7, #8]
 5b0:	681b      	ldr	r3, [r3, #0]
 5b2:	e001      	b.n	5b8 <udp_bind+0x80>
 5b4:	f04f 0300 	mov.w	r3, #0
 5b8:	68fa      	ldr	r2, [r7, #12]
 5ba:	6013      	str	r3, [r2, #0]

  /* no port specified? */
  if (port == 0) {
 5bc:	88fb      	ldrh	r3, [r7, #6]
 5be:	2b00      	cmp	r3, #0
 5c0:	d109      	bne.n	5d6 <udp_bind+0x9e>
    port = udp_new_port();
 5c2:	f7ff fd23 	bl	c <udp_new_port>
 5c6:	4603      	mov	r3, r0
 5c8:	80fb      	strh	r3, [r7, #6]
    if (port == 0) {
 5ca:	88fb      	ldrh	r3, [r7, #6]
 5cc:	2b00      	cmp	r3, #0
 5ce:	d102      	bne.n	5d6 <udp_bind+0x9e>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
 5d0:	f04f 03f8 	mov.w	r3, #248	; 0xf8
 5d4:	e00e      	b.n	5f4 <udp_bind+0xbc>
    }
  }
  pcb->local_port = port;
 5d6:	68fb      	ldr	r3, [r7, #12]
 5d8:	88fa      	ldrh	r2, [r7, #6]
 5da:	825a      	strh	r2, [r3, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 5dc:	7cfb      	ldrb	r3, [r7, #19]
 5de:	2b00      	cmp	r3, #0
 5e0:	d106      	bne.n	5f0 <udp_bind+0xb8>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 5e2:	4b07      	ldr	r3, [pc, #28]	; (600 <udp_bind+0xc8>)
 5e4:	681a      	ldr	r2, [r3, #0]
 5e6:	68fb      	ldr	r3, [r7, #12]
 5e8:	60da      	str	r2, [r3, #12]
    udp_pcbs = pcb;
 5ea:	4b05      	ldr	r3, [pc, #20]	; (600 <udp_bind+0xc8>)
 5ec:	68fa      	ldr	r2, [r7, #12]
 5ee:	601a      	str	r2, [r3, #0]
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 5f0:	f04f 0300 	mov.w	r3, #0
 5f4:	b25b      	sxtb	r3, r3
}
 5f6:	4618      	mov	r0, r3
 5f8:	f107 0718 	add.w	r7, r7, #24
 5fc:	46bd      	mov	sp, r7
 5fe:	bd80      	pop	{r7, pc}
 600:	00000000 	.word	0x00000000
			600: R_ARM_ABS32	udp_pcbs

00000604 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 604:	b580      	push	{r7, lr}
 606:	b086      	sub	sp, #24
 608:	af00      	add	r7, sp, #0
 60a:	60f8      	str	r0, [r7, #12]
 60c:	60b9      	str	r1, [r7, #8]
 60e:	4613      	mov	r3, r2
 610:	80fb      	strh	r3, [r7, #6]
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 612:	68fb      	ldr	r3, [r7, #12]
 614:	8a5b      	ldrh	r3, [r3, #18]
 616:	2b00      	cmp	r3, #0
 618:	d10f      	bne.n	63a <udp_connect+0x36>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 61a:	68fa      	ldr	r2, [r7, #12]
 61c:	68fb      	ldr	r3, [r7, #12]
 61e:	8a5b      	ldrh	r3, [r3, #18]
 620:	68f8      	ldr	r0, [r7, #12]
 622:	4611      	mov	r1, r2
 624:	461a      	mov	r2, r3
 626:	f7ff fffe 	bl	538 <udp_bind>
			626: R_ARM_THM_CALL	udp_bind
 62a:	4603      	mov	r3, r0
 62c:	74fb      	strb	r3, [r7, #19]
    if (err != ERR_OK) {
 62e:	f997 3013 	ldrsb.w	r3, [r7, #19]
 632:	2b00      	cmp	r3, #0
 634:	d001      	beq.n	63a <udp_connect+0x36>
      return err;
 636:	7cfb      	ldrb	r3, [r7, #19]
 638:	e02d      	b.n	696 <udp_connect+0x92>
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 63a:	68bb      	ldr	r3, [r7, #8]
 63c:	2b00      	cmp	r3, #0
 63e:	d002      	beq.n	646 <udp_connect+0x42>
 640:	68bb      	ldr	r3, [r7, #8]
 642:	681b      	ldr	r3, [r3, #0]
 644:	e001      	b.n	64a <udp_connect+0x46>
 646:	f04f 0300 	mov.w	r3, #0
 64a:	68fa      	ldr	r2, [r7, #12]
 64c:	6053      	str	r3, [r2, #4]
  pcb->remote_port = port;
 64e:	68fb      	ldr	r3, [r7, #12]
 650:	88fa      	ldrh	r2, [r7, #6]
 652:	829a      	strh	r2, [r3, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 654:	68fb      	ldr	r3, [r7, #12]
 656:	7c1b      	ldrb	r3, [r3, #16]
 658:	f043 0304 	orr.w	r3, r3, #4
 65c:	b2da      	uxtb	r2, r3
 65e:	68fb      	ldr	r3, [r7, #12]
 660:	741a      	strb	r2, [r3, #16]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 662:	4b10      	ldr	r3, [pc, #64]	; (6a4 <udp_connect+0xa0>)
 664:	681b      	ldr	r3, [r3, #0]
 666:	617b      	str	r3, [r7, #20]
 668:	e009      	b.n	67e <udp_connect+0x7a>
    if (pcb == ipcb) {
 66a:	68fa      	ldr	r2, [r7, #12]
 66c:	697b      	ldr	r3, [r7, #20]
 66e:	429a      	cmp	r2, r3
 670:	d102      	bne.n	678 <udp_connect+0x74>
      /* already on the list, just return */
      return ERR_OK;
 672:	f04f 0300 	mov.w	r3, #0
 676:	e00e      	b.n	696 <udp_connect+0x92>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 678:	697b      	ldr	r3, [r7, #20]
 67a:	68db      	ldr	r3, [r3, #12]
 67c:	617b      	str	r3, [r7, #20]
 67e:	697b      	ldr	r3, [r7, #20]
 680:	2b00      	cmp	r3, #0
 682:	d1f2      	bne.n	66a <udp_connect+0x66>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 684:	4b07      	ldr	r3, [pc, #28]	; (6a4 <udp_connect+0xa0>)
 686:	681a      	ldr	r2, [r3, #0]
 688:	68fb      	ldr	r3, [r7, #12]
 68a:	60da      	str	r2, [r3, #12]
  udp_pcbs = pcb;
 68c:	4b05      	ldr	r3, [pc, #20]	; (6a4 <udp_connect+0xa0>)
 68e:	68fa      	ldr	r2, [r7, #12]
 690:	601a      	str	r2, [r3, #0]
  return ERR_OK;
 692:	f04f 0300 	mov.w	r3, #0
 696:	b25b      	sxtb	r3, r3
}
 698:	4618      	mov	r0, r3
 69a:	f107 0718 	add.w	r7, r7, #24
 69e:	46bd      	mov	sp, r7
 6a0:	bd80      	pop	{r7, pc}
 6a2:	bf00      	nop
 6a4:	00000000 	.word	0x00000000
			6a4: R_ARM_ABS32	udp_pcbs

000006a8 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
 6a8:	b480      	push	{r7}
 6aa:	b083      	sub	sp, #12
 6ac:	af00      	add	r7, sp, #0
 6ae:	6078      	str	r0, [r7, #4]
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
 6b0:	687b      	ldr	r3, [r7, #4]
 6b2:	f04f 0200 	mov.w	r2, #0
 6b6:	605a      	str	r2, [r3, #4]
  pcb->remote_port = 0;
 6b8:	687b      	ldr	r3, [r7, #4]
 6ba:	f04f 0200 	mov.w	r2, #0
 6be:	829a      	strh	r2, [r3, #20]
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 6c0:	687b      	ldr	r3, [r7, #4]
 6c2:	7c1b      	ldrb	r3, [r3, #16]
 6c4:	f023 0304 	bic.w	r3, r3, #4
 6c8:	b2da      	uxtb	r2, r3
 6ca:	687b      	ldr	r3, [r7, #4]
 6cc:	741a      	strb	r2, [r3, #16]
}
 6ce:	f107 070c 	add.w	r7, r7, #12
 6d2:	46bd      	mov	sp, r7
 6d4:	bc80      	pop	{r7}
 6d6:	4770      	bx	lr

000006d8 <udp_recv>:
 * @param recv function pointer of the callback function
 * @param recv_arg additional argument to pass to the callback function
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
 6d8:	b480      	push	{r7}
 6da:	b085      	sub	sp, #20
 6dc:	af00      	add	r7, sp, #0
 6de:	60f8      	str	r0, [r7, #12]
 6e0:	60b9      	str	r1, [r7, #8]
 6e2:	607a      	str	r2, [r7, #4]
  /* remember recv() callback and user data */
  pcb->recv = recv;
 6e4:	68fb      	ldr	r3, [r7, #12]
 6e6:	68ba      	ldr	r2, [r7, #8]
 6e8:	61da      	str	r2, [r3, #28]
  pcb->recv_arg = recv_arg;
 6ea:	68fb      	ldr	r3, [r7, #12]
 6ec:	687a      	ldr	r2, [r7, #4]
 6ee:	621a      	str	r2, [r3, #32]
}
 6f0:	f107 0714 	add.w	r7, r7, #20
 6f4:	46bd      	mov	sp, r7
 6f6:	bc80      	pop	{r7}
 6f8:	4770      	bx	lr
 6fa:	bf00      	nop

000006fc <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 6fc:	b580      	push	{r7, lr}
 6fe:	b084      	sub	sp, #16
 700:	af00      	add	r7, sp, #0
 702:	6078      	str	r0, [r7, #4]
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 704:	4b15      	ldr	r3, [pc, #84]	; (75c <udp_remove+0x60>)
 706:	681a      	ldr	r2, [r3, #0]
 708:	687b      	ldr	r3, [r7, #4]
 70a:	429a      	cmp	r2, r3
 70c:	d105      	bne.n	71a <udp_remove+0x1e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 70e:	4b13      	ldr	r3, [pc, #76]	; (75c <udp_remove+0x60>)
 710:	681b      	ldr	r3, [r3, #0]
 712:	68da      	ldr	r2, [r3, #12]
 714:	4b11      	ldr	r3, [pc, #68]	; (75c <udp_remove+0x60>)
 716:	601a      	str	r2, [r3, #0]
 718:	e016      	b.n	748 <udp_remove+0x4c>
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 71a:	4b10      	ldr	r3, [pc, #64]	; (75c <udp_remove+0x60>)
 71c:	681b      	ldr	r3, [r3, #0]
 71e:	60fb      	str	r3, [r7, #12]
 720:	e00f      	b.n	742 <udp_remove+0x46>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 722:	68fb      	ldr	r3, [r7, #12]
 724:	68db      	ldr	r3, [r3, #12]
 726:	2b00      	cmp	r3, #0
 728:	d008      	beq.n	73c <udp_remove+0x40>
 72a:	68fb      	ldr	r3, [r7, #12]
 72c:	68da      	ldr	r2, [r3, #12]
 72e:	687b      	ldr	r3, [r7, #4]
 730:	429a      	cmp	r2, r3
 732:	d103      	bne.n	73c <udp_remove+0x40>
        /* remove pcb from list */
        pcb2->next = pcb->next;
 734:	687b      	ldr	r3, [r7, #4]
 736:	68da      	ldr	r2, [r3, #12]
 738:	68fb      	ldr	r3, [r7, #12]
 73a:	60da      	str	r2, [r3, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 73c:	68fb      	ldr	r3, [r7, #12]
 73e:	68db      	ldr	r3, [r3, #12]
 740:	60fb      	str	r3, [r7, #12]
 742:	68fb      	ldr	r3, [r7, #12]
 744:	2b00      	cmp	r3, #0
 746:	d1ec      	bne.n	722 <udp_remove+0x26>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 748:	f04f 0001 	mov.w	r0, #1
 74c:	6879      	ldr	r1, [r7, #4]
 74e:	f7ff fffe 	bl	0 <memp_free>
			74e: R_ARM_THM_CALL	memp_free
}
 752:	f107 0710 	add.w	r7, r7, #16
 756:	46bd      	mov	sp, r7
 758:	bd80      	pop	{r7, pc}
 75a:	bf00      	nop
 75c:	00000000 	.word	0x00000000
			75c: R_ARM_ABS32	udp_pcbs

00000760 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 760:	b580      	push	{r7, lr}
 762:	b082      	sub	sp, #8
 764:	af00      	add	r7, sp, #0
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 766:	f04f 0001 	mov.w	r0, #1
 76a:	f7ff fffe 	bl	0 <memp_malloc>
			76a: R_ARM_THM_CALL	memp_malloc
 76e:	4603      	mov	r3, r0
 770:	607b      	str	r3, [r7, #4]
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 772:	687b      	ldr	r3, [r7, #4]
 774:	2b00      	cmp	r3, #0
 776:	d00a      	beq.n	78e <udp_new+0x2e>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 778:	6878      	ldr	r0, [r7, #4]
 77a:	f04f 0100 	mov.w	r1, #0
 77e:	f04f 0224 	mov.w	r2, #36	; 0x24
 782:	f7ff fffe 	bl	0 <memset>
			782: R_ARM_THM_CALL	memset
    pcb->ttl = UDP_TTL;
 786:	687b      	ldr	r3, [r7, #4]
 788:	f04f 02ff 	mov.w	r2, #255	; 0xff
 78c:	729a      	strb	r2, [r3, #10]
  }
  return pcb;
 78e:	687b      	ldr	r3, [r7, #4]
}
 790:	4618      	mov	r0, r3
 792:	f107 0708 	add.w	r7, r7, #8
 796:	46bd      	mov	sp, r7
 798:	bd80      	pop	{r7, pc}
 79a:	bf00      	nop

api_lib.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  75764 Jul 30 19:07 2021 api_lib.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a14  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000a48  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000a48  2**0
                  ALLOC
  3 .debug_abbrev 00000202  00000000  00000000  00000a48  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000015d9  00000000  00000000  00000c4a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000009c4  00000000  00000000  00002223  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000c9e5  00000000  00000000  00002be7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000460  00000000  00000000  0000f5cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000001a9  00000000  00000000  0000fa2c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000022b  00000000  00000000  0000fbd5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000fe00  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000009ab  00000000  00000000  0000fe20  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  000107cb  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  000107f6  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000290  00000000  00000000  00010828  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 api_lib.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
000003d4 l     F .text	0000015c netconn_recv_data
00000844 l     F .text	00000068 netconn_close_shutdown
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	0000009c netconn_new_with_proto_and_callback
00000000         *UND*	00000000 netconn_alloc
00000000         *UND*	00000000 tcpip_apimsg
00000000         *UND*	00000000 sys_sem_valid
00000000         *UND*	00000000 sys_mbox_valid
00000000         *UND*	00000000 sys_sem_free
00000000         *UND*	00000000 sys_mbox_free
00000000         *UND*	00000000 memp_free
00000000         *UND*	00000000 do_newconn
0000009c g     F .text	00000040 netconn_delete
00000000         *UND*	00000000 netconn_free
00000000         *UND*	00000000 do_delconn
000000dc g     F .text	0000008c netconn_getaddr
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
00000000         *UND*	00000000 do_getaddr
00000168 g     F .text	00000070 netconn_bind
00000000         *UND*	00000000 do_bind
000001d8 g     F .text	00000070 netconn_connect
00000000         *UND*	00000000 do_connect
00000248 g     F .text	00000060 netconn_disconnect
00000000         *UND*	00000000 do_disconnect
000002a8 g     F .text	00000064 netconn_listen_with_backlog
00000000         *UND*	00000000 do_listen
0000030c g     F .text	000000c6 netconn_accept
00000000         *UND*	00000000 sys_arch_mbox_fetch
00000000         *UND*	00000000 do_recv
00000530 g     F .text	00000036 netconn_recv_tcp_pbuf
00000568 g     F .text	000000f4 netconn_recv
00000000         *UND*	00000000 memp_malloc
0000065c g     F .text	00000048 netconn_recved
000006a4 g     F .text	0000004a netconn_sendto
000006f0 g     F .text	00000068 netconn_send
00000000         *UND*	00000000 do_send
00000758 g     F .text	000000ec netconn_write_partly
00000000         *UND*	00000000 do_write
00000000         *UND*	00000000 do_close
000008ac g     F .text	0000001e netconn_close
000008cc g     F .text	00000048 netconn_shutdown
00000914 g     F .text	00000074 netconn_join_leave_group
00000000         *UND*	00000000 do_join_leave_group
00000988 g     F .text	0000008c netconn_gethostbyname
00000000         *UND*	00000000 sys_sem_new
00000000         *UND*	00000000 tcpip_callback_with_block
00000000         *UND*	00000000 sys_arch_sem_wait
00000000         *UND*	00000000 do_gethostbyname



Disassembly of section .text:

00000000 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
   0:	b580      	push	{r7, lr}
   2:	b08a      	sub	sp, #40	; 0x28
   4:	af00      	add	r7, sp, #0
   6:	460b      	mov	r3, r1
   8:	603a      	str	r2, [r7, #0]
   a:	4602      	mov	r2, r0
   c:	71fa      	strb	r2, [r7, #7]
   e:	71bb      	strb	r3, [r7, #6]
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  10:	79fb      	ldrb	r3, [r7, #7]
  12:	4618      	mov	r0, r3
  14:	6839      	ldr	r1, [r7, #0]
  16:	f7ff fffe 	bl	0 <netconn_alloc>
			16: R_ARM_THM_CALL	netconn_alloc
  1a:	6278      	str	r0, [r7, #36]	; 0x24
  if (conn != NULL) {
  1c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  1e:	2b00      	cmp	r3, #0
  20:	d033      	beq.n	8a <netconn_new_with_proto_and_callback+0x8a>
    msg.function = do_newconn;
  22:	4b1d      	ldr	r3, [pc, #116]	; (98 <netconn_new_with_proto_and_callback+0x98>)
  24:	60fb      	str	r3, [r7, #12]
    msg.msg.msg.n.proto = proto;
  26:	79bb      	ldrb	r3, [r7, #6]
  28:	763b      	strb	r3, [r7, #24]
    msg.msg.conn = conn;
  2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2c:	613b      	str	r3, [r7, #16]
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
  2e:	f107 030c 	add.w	r3, r7, #12
  32:	4618      	mov	r0, r3
  34:	f7ff fffe 	bl	0 <tcpip_apimsg>
			34: R_ARM_THM_CALL	tcpip_apimsg
  38:	4603      	mov	r3, r0
  3a:	2b00      	cmp	r3, #0
  3c:	d025      	beq.n	8a <netconn_new_with_proto_and_callback+0x8a>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
  3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40:	f103 030c 	add.w	r3, r3, #12
  44:	4618      	mov	r0, r3
  46:	f7ff fffe 	bl	0 <sys_sem_valid>
			46: R_ARM_THM_CALL	sys_sem_valid
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
  4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4c:	f103 0314 	add.w	r3, r3, #20
  50:	4618      	mov	r0, r3
  52:	f7ff fffe 	bl	0 <sys_mbox_valid>
			52: R_ARM_THM_CALL	sys_mbox_valid
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
  56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  58:	f103 031c 	add.w	r3, r3, #28
  5c:	4618      	mov	r0, r3
  5e:	f7ff fffe 	bl	0 <sys_mbox_valid>
			5e: R_ARM_THM_CALL	sys_mbox_valid
#endif /* LWIP_TCP */
      sys_sem_free(&conn->op_completed);
  62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  64:	f103 030c 	add.w	r3, r3, #12
  68:	4618      	mov	r0, r3
  6a:	f7ff fffe 	bl	0 <sys_sem_free>
			6a: R_ARM_THM_CALL	sys_sem_free
      sys_mbox_free(&conn->recvmbox);
  6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  70:	f103 0314 	add.w	r3, r3, #20
  74:	4618      	mov	r0, r3
  76:	f7ff fffe 	bl	0 <sys_mbox_free>
			76: R_ARM_THM_CALL	sys_mbox_free
      memp_free(MEMP_NETCONN, conn);
  7a:	f04f 0007 	mov.w	r0, #7
  7e:	6a79      	ldr	r1, [r7, #36]	; 0x24
  80:	f7ff fffe 	bl	0 <memp_free>
			80: R_ARM_THM_CALL	memp_free
      return NULL;
  84:	f04f 0300 	mov.w	r3, #0
  88:	e000      	b.n	8c <netconn_new_with_proto_and_callback+0x8c>
    }
  }
  return conn;
  8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  8c:	4618      	mov	r0, r3
  8e:	f107 0728 	add.w	r7, r7, #40	; 0x28
  92:	46bd      	mov	sp, r7
  94:	bd80      	pop	{r7, pc}
  96:	bf00      	nop
  98:	00000000 	.word	0x00000000
			98: R_ARM_ABS32	do_newconn

0000009c <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  9c:	b580      	push	{r7, lr}
  9e:	b088      	sub	sp, #32
  a0:	af00      	add	r7, sp, #0
  a2:	6078      	str	r0, [r7, #4]
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  a4:	687b      	ldr	r3, [r7, #4]
  a6:	2b00      	cmp	r3, #0
  a8:	d102      	bne.n	b0 <netconn_delete+0x14>
    return ERR_OK;
  aa:	f04f 0300 	mov.w	r3, #0
  ae:	e00d      	b.n	cc <netconn_delete+0x30>
  }

  msg.function = do_delconn;
  b0:	4b09      	ldr	r3, [pc, #36]	; (d8 <netconn_delete+0x3c>)
  b2:	60bb      	str	r3, [r7, #8]
  msg.msg.conn = conn;
  b4:	687b      	ldr	r3, [r7, #4]
  b6:	60fb      	str	r3, [r7, #12]
  tcpip_apimsg(&msg);
  b8:	f107 0308 	add.w	r3, r7, #8
  bc:	4618      	mov	r0, r3
  be:	f7ff fffe 	bl	0 <tcpip_apimsg>
			be: R_ARM_THM_CALL	tcpip_apimsg

  netconn_free(conn);
  c2:	6878      	ldr	r0, [r7, #4]
  c4:	f7ff fffe 	bl	0 <netconn_free>
			c4: R_ARM_THM_CALL	netconn_free

  /* don't care for return value of do_delconn since it only calls void functions */

  return ERR_OK;
  c8:	f04f 0300 	mov.w	r3, #0
  cc:	b25b      	sxtb	r3, r3
}
  ce:	4618      	mov	r0, r3
  d0:	f107 0720 	add.w	r7, r7, #32
  d4:	46bd      	mov	sp, r7
  d6:	bd80      	pop	{r7, pc}
  d8:	00000000 	.word	0x00000000
			d8: R_ARM_ABS32	do_delconn

000000dc <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
  dc:	b580      	push	{r7, lr}
  de:	b08c      	sub	sp, #48	; 0x30
  e0:	af00      	add	r7, sp, #0
  e2:	60f8      	str	r0, [r7, #12]
  e4:	60b9      	str	r1, [r7, #8]
  e6:	607a      	str	r2, [r7, #4]
  e8:	70fb      	strb	r3, [r7, #3]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  ea:	68fb      	ldr	r3, [r7, #12]
  ec:	2b00      	cmp	r3, #0
  ee:	d102      	bne.n	f6 <netconn_getaddr+0x1a>
  f0:	f04f 03f2 	mov.w	r3, #242	; 0xf2
  f4:	e030      	b.n	158 <netconn_getaddr+0x7c>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  f6:	68bb      	ldr	r3, [r7, #8]
  f8:	2b00      	cmp	r3, #0
  fa:	d102      	bne.n	102 <netconn_getaddr+0x26>
  fc:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 100:	e02a      	b.n	158 <netconn_getaddr+0x7c>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 102:	687b      	ldr	r3, [r7, #4]
 104:	2b00      	cmp	r3, #0
 106:	d102      	bne.n	10e <netconn_getaddr+0x32>
 108:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 10c:	e024      	b.n	158 <netconn_getaddr+0x7c>

  msg.function = do_getaddr;
 10e:	4b15      	ldr	r3, [pc, #84]	; (164 <netconn_getaddr+0x88>)
 110:	613b      	str	r3, [r7, #16]
  msg.msg.conn = conn;
 112:	68fb      	ldr	r3, [r7, #12]
 114:	617b      	str	r3, [r7, #20]
  msg.msg.msg.ad.ipaddr = addr;
 116:	68bb      	ldr	r3, [r7, #8]
 118:	61fb      	str	r3, [r7, #28]
  msg.msg.msg.ad.port = port;
 11a:	687b      	ldr	r3, [r7, #4]
 11c:	623b      	str	r3, [r7, #32]
  msg.msg.msg.ad.local = local;
 11e:	78fb      	ldrb	r3, [r7, #3]
 120:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  err = TCPIP_APIMSG(&msg);
 124:	f107 0310 	add.w	r3, r7, #16
 128:	4618      	mov	r0, r3
 12a:	f7ff fffe 	bl	0 <tcpip_apimsg>
			12a: R_ARM_THM_CALL	tcpip_apimsg
 12e:	4603      	mov	r3, r0
 130:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  NETCONN_SET_SAFE_ERR(conn, err);
 134:	f7ff fffe 	bl	0 <sys_arch_protect>
			134: R_ARM_THM_CALL	sys_arch_protect
 138:	62b8      	str	r0, [r7, #40]	; 0x28
 13a:	68fb      	ldr	r3, [r7, #12]
 13c:	7a1b      	ldrb	r3, [r3, #8]
 13e:	b25b      	sxtb	r3, r3
 140:	f113 0f09 	cmn.w	r3, #9
 144:	db03      	blt.n	14e <netconn_getaddr+0x72>
 146:	68fb      	ldr	r3, [r7, #12]
 148:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 14c:	721a      	strb	r2, [r3, #8]
 14e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 150:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			150: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 154:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 158:	b25b      	sxtb	r3, r3
}
 15a:	4618      	mov	r0, r3
 15c:	f107 0730 	add.w	r7, r7, #48	; 0x30
 160:	46bd      	mov	sp, r7
 162:	bd80      	pop	{r7, pc}
 164:	00000000 	.word	0x00000000
			164: R_ARM_ABS32	do_getaddr

00000168 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 168:	b580      	push	{r7, lr}
 16a:	b08c      	sub	sp, #48	; 0x30
 16c:	af00      	add	r7, sp, #0
 16e:	60f8      	str	r0, [r7, #12]
 170:	60b9      	str	r1, [r7, #8]
 172:	4613      	mov	r3, r2
 174:	80fb      	strh	r3, [r7, #6]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 176:	68fb      	ldr	r3, [r7, #12]
 178:	2b00      	cmp	r3, #0
 17a:	d102      	bne.n	182 <netconn_bind+0x1a>
 17c:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 180:	e021      	b.n	1c6 <netconn_bind+0x5e>

  msg.function = do_bind;
 182:	4b14      	ldr	r3, [pc, #80]	; (1d4 <netconn_bind+0x6c>)
 184:	613b      	str	r3, [r7, #16]
  msg.msg.conn = conn;
 186:	68fb      	ldr	r3, [r7, #12]
 188:	617b      	str	r3, [r7, #20]
  msg.msg.msg.bc.ipaddr = addr;
 18a:	68bb      	ldr	r3, [r7, #8]
 18c:	61fb      	str	r3, [r7, #28]
  msg.msg.msg.bc.port = port;
 18e:	88fb      	ldrh	r3, [r7, #6]
 190:	843b      	strh	r3, [r7, #32]
  err = TCPIP_APIMSG(&msg);
 192:	f107 0310 	add.w	r3, r7, #16
 196:	4618      	mov	r0, r3
 198:	f7ff fffe 	bl	0 <tcpip_apimsg>
			198: R_ARM_THM_CALL	tcpip_apimsg
 19c:	4603      	mov	r3, r0
 19e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  NETCONN_SET_SAFE_ERR(conn, err);
 1a2:	f7ff fffe 	bl	0 <sys_arch_protect>
			1a2: R_ARM_THM_CALL	sys_arch_protect
 1a6:	62b8      	str	r0, [r7, #40]	; 0x28
 1a8:	68fb      	ldr	r3, [r7, #12]
 1aa:	7a1b      	ldrb	r3, [r3, #8]
 1ac:	b25b      	sxtb	r3, r3
 1ae:	f113 0f09 	cmn.w	r3, #9
 1b2:	db03      	blt.n	1bc <netconn_bind+0x54>
 1b4:	68fb      	ldr	r3, [r7, #12]
 1b6:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 1ba:	721a      	strb	r2, [r3, #8]
 1bc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 1be:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			1be: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 1c2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 1c6:	b25b      	sxtb	r3, r3
}
 1c8:	4618      	mov	r0, r3
 1ca:	f107 0730 	add.w	r7, r7, #48	; 0x30
 1ce:	46bd      	mov	sp, r7
 1d0:	bd80      	pop	{r7, pc}
 1d2:	bf00      	nop
 1d4:	00000000 	.word	0x00000000
			1d4: R_ARM_ABS32	do_bind

000001d8 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 1d8:	b580      	push	{r7, lr}
 1da:	b08c      	sub	sp, #48	; 0x30
 1dc:	af00      	add	r7, sp, #0
 1de:	60f8      	str	r0, [r7, #12]
 1e0:	60b9      	str	r1, [r7, #8]
 1e2:	4613      	mov	r3, r2
 1e4:	80fb      	strh	r3, [r7, #6]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 1e6:	68fb      	ldr	r3, [r7, #12]
 1e8:	2b00      	cmp	r3, #0
 1ea:	d102      	bne.n	1f2 <netconn_connect+0x1a>
 1ec:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 1f0:	e021      	b.n	236 <netconn_connect+0x5e>

  msg.function = do_connect;
 1f2:	4b14      	ldr	r3, [pc, #80]	; (244 <netconn_connect+0x6c>)
 1f4:	613b      	str	r3, [r7, #16]
  msg.msg.conn = conn;
 1f6:	68fb      	ldr	r3, [r7, #12]
 1f8:	617b      	str	r3, [r7, #20]
  msg.msg.msg.bc.ipaddr = addr;
 1fa:	68bb      	ldr	r3, [r7, #8]
 1fc:	61fb      	str	r3, [r7, #28]
  msg.msg.msg.bc.port = port;
 1fe:	88fb      	ldrh	r3, [r7, #6]
 200:	843b      	strh	r3, [r7, #32]
  /* This is the only function which need to not block tcpip_thread */
  err = tcpip_apimsg(&msg);
 202:	f107 0310 	add.w	r3, r7, #16
 206:	4618      	mov	r0, r3
 208:	f7ff fffe 	bl	0 <tcpip_apimsg>
			208: R_ARM_THM_CALL	tcpip_apimsg
 20c:	4603      	mov	r3, r0
 20e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  NETCONN_SET_SAFE_ERR(conn, err);
 212:	f7ff fffe 	bl	0 <sys_arch_protect>
			212: R_ARM_THM_CALL	sys_arch_protect
 216:	62b8      	str	r0, [r7, #40]	; 0x28
 218:	68fb      	ldr	r3, [r7, #12]
 21a:	7a1b      	ldrb	r3, [r3, #8]
 21c:	b25b      	sxtb	r3, r3
 21e:	f113 0f09 	cmn.w	r3, #9
 222:	db03      	blt.n	22c <netconn_connect+0x54>
 224:	68fb      	ldr	r3, [r7, #12]
 226:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 22a:	721a      	strb	r2, [r3, #8]
 22c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 22e:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			22e: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 232:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 236:	b25b      	sxtb	r3, r3
}
 238:	4618      	mov	r0, r3
 23a:	f107 0730 	add.w	r7, r7, #48	; 0x30
 23e:	46bd      	mov	sp, r7
 240:	bd80      	pop	{r7, pc}
 242:	bf00      	nop
 244:	00000000 	.word	0x00000000
			244: R_ARM_ABS32	do_connect

00000248 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
 248:	b580      	push	{r7, lr}
 24a:	b08a      	sub	sp, #40	; 0x28
 24c:	af00      	add	r7, sp, #0
 24e:	6078      	str	r0, [r7, #4]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 250:	687b      	ldr	r3, [r7, #4]
 252:	2b00      	cmp	r3, #0
 254:	d102      	bne.n	25c <netconn_disconnect+0x14>
 256:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 25a:	e01d      	b.n	298 <netconn_disconnect+0x50>

  msg.function = do_disconnect;
 25c:	4b11      	ldr	r3, [pc, #68]	; (2a4 <netconn_disconnect+0x5c>)
 25e:	60bb      	str	r3, [r7, #8]
  msg.msg.conn = conn;
 260:	687b      	ldr	r3, [r7, #4]
 262:	60fb      	str	r3, [r7, #12]
  err = TCPIP_APIMSG(&msg);
 264:	f107 0308 	add.w	r3, r7, #8
 268:	4618      	mov	r0, r3
 26a:	f7ff fffe 	bl	0 <tcpip_apimsg>
			26a: R_ARM_THM_CALL	tcpip_apimsg
 26e:	4603      	mov	r3, r0
 270:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  NETCONN_SET_SAFE_ERR(conn, err);
 274:	f7ff fffe 	bl	0 <sys_arch_protect>
			274: R_ARM_THM_CALL	sys_arch_protect
 278:	6238      	str	r0, [r7, #32]
 27a:	687b      	ldr	r3, [r7, #4]
 27c:	7a1b      	ldrb	r3, [r3, #8]
 27e:	b25b      	sxtb	r3, r3
 280:	f113 0f09 	cmn.w	r3, #9
 284:	db03      	blt.n	28e <netconn_disconnect+0x46>
 286:	687b      	ldr	r3, [r7, #4]
 288:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 28c:	721a      	strb	r2, [r3, #8]
 28e:	6a38      	ldr	r0, [r7, #32]
 290:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			290: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 294:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 298:	b25b      	sxtb	r3, r3
}
 29a:	4618      	mov	r0, r3
 29c:	f107 0728 	add.w	r7, r7, #40	; 0x28
 2a0:	46bd      	mov	sp, r7
 2a2:	bd80      	pop	{r7, pc}
 2a4:	00000000 	.word	0x00000000
			2a4: R_ARM_ABS32	do_disconnect

000002a8 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 2a8:	b580      	push	{r7, lr}
 2aa:	b08a      	sub	sp, #40	; 0x28
 2ac:	af00      	add	r7, sp, #0
 2ae:	6078      	str	r0, [r7, #4]
 2b0:	460b      	mov	r3, r1
 2b2:	70fb      	strb	r3, [r7, #3]
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 2b4:	687b      	ldr	r3, [r7, #4]
 2b6:	2b00      	cmp	r3, #0
 2b8:	d102      	bne.n	2c0 <netconn_listen_with_backlog+0x18>
 2ba:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 2be:	e01d      	b.n	2fc <netconn_listen_with_backlog+0x54>

  msg.function = do_listen;
 2c0:	4b11      	ldr	r3, [pc, #68]	; (308 <netconn_listen_with_backlog+0x60>)
 2c2:	60bb      	str	r3, [r7, #8]
  msg.msg.conn = conn;
 2c4:	687b      	ldr	r3, [r7, #4]
 2c6:	60fb      	str	r3, [r7, #12]
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 2c8:	f107 0308 	add.w	r3, r7, #8
 2cc:	4618      	mov	r0, r3
 2ce:	f7ff fffe 	bl	0 <tcpip_apimsg>
			2ce: R_ARM_THM_CALL	tcpip_apimsg
 2d2:	4603      	mov	r3, r0
 2d4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  NETCONN_SET_SAFE_ERR(conn, err);
 2d8:	f7ff fffe 	bl	0 <sys_arch_protect>
			2d8: R_ARM_THM_CALL	sys_arch_protect
 2dc:	6238      	str	r0, [r7, #32]
 2de:	687b      	ldr	r3, [r7, #4]
 2e0:	7a1b      	ldrb	r3, [r3, #8]
 2e2:	b25b      	sxtb	r3, r3
 2e4:	f113 0f09 	cmn.w	r3, #9
 2e8:	db03      	blt.n	2f2 <netconn_listen_with_backlog+0x4a>
 2ea:	687b      	ldr	r3, [r7, #4]
 2ec:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 2f0:	721a      	strb	r2, [r3, #8]
 2f2:	6a38      	ldr	r0, [r7, #32]
 2f4:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			2f4: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 2f8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 2fc:	b25b      	sxtb	r3, r3
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 2fe:	4618      	mov	r0, r3
 300:	f107 0728 	add.w	r7, r7, #40	; 0x28
 304:	46bd      	mov	sp, r7
 306:	bd80      	pop	{r7, pc}
 308:	00000000 	.word	0x00000000
			308: R_ARM_ABS32	do_listen

0000030c <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 30c:	b580      	push	{r7, lr}
 30e:	b086      	sub	sp, #24
 310:	af00      	add	r7, sp, #0
 312:	6078      	str	r0, [r7, #4]
 314:	6039      	str	r1, [r7, #0]
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 316:	683b      	ldr	r3, [r7, #0]
 318:	2b00      	cmp	r3, #0
 31a:	d102      	bne.n	322 <netconn_accept+0x16>
 31c:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 320:	e051      	b.n	3c6 <netconn_accept+0xba>
  *new_conn = NULL;
 322:	683b      	ldr	r3, [r7, #0]
 324:	f04f 0200 	mov.w	r2, #0
 328:	601a      	str	r2, [r3, #0]
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 32a:	687b      	ldr	r3, [r7, #4]
 32c:	2b00      	cmp	r3, #0
 32e:	d102      	bne.n	336 <netconn_accept+0x2a>
 330:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 334:	e047      	b.n	3c6 <netconn_accept+0xba>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 336:	687b      	ldr	r3, [r7, #4]
 338:	f103 031c 	add.w	r3, r3, #28
 33c:	4618      	mov	r0, r3
 33e:	f7ff fffe 	bl	0 <sys_mbox_valid>
			33e: R_ARM_THM_CALL	sys_mbox_valid
 342:	4603      	mov	r3, r0
 344:	2b00      	cmp	r3, #0
 346:	d102      	bne.n	34e <netconn_accept+0x42>
 348:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 34c:	e03b      	b.n	3c6 <netconn_accept+0xba>

  err = conn->last_err;
 34e:	687b      	ldr	r3, [r7, #4]
 350:	7a1b      	ldrb	r3, [r3, #8]
 352:	75fb      	strb	r3, [r7, #23]
  if (ERR_IS_FATAL(err)) {
 354:	f997 3017 	ldrsb.w	r3, [r7, #23]
 358:	f113 0f09 	cmn.w	r3, #9
 35c:	da01      	bge.n	362 <netconn_accept+0x56>
    /* don't recv on fatal errors: this might block the application task
       waiting on acceptmbox forever! */
    return err;
 35e:	7dfb      	ldrb	r3, [r7, #23]
 360:	e031      	b.n	3c6 <netconn_accept+0xba>
  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
    return ERR_TIMEOUT;
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
 362:	687b      	ldr	r3, [r7, #4]
 364:	f103 021c 	add.w	r2, r3, #28
 368:	f107 030c 	add.w	r3, r7, #12
 36c:	4610      	mov	r0, r2
 36e:	4619      	mov	r1, r3
 370:	f04f 0200 	mov.w	r2, #0
 374:	f7ff fffe 	bl	0 <sys_arch_mbox_fetch>
			374: R_ARM_THM_CALL	sys_arch_mbox_fetch
#endif /* LWIP_SO_RCVTIMEO*/
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 378:	687b      	ldr	r3, [r7, #4]
 37a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 37c:	2b00      	cmp	r3, #0
 37e:	d007      	beq.n	390 <netconn_accept+0x84>
 380:	687b      	ldr	r3, [r7, #4]
 382:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 384:	6878      	ldr	r0, [r7, #4]
 386:	f04f 0101 	mov.w	r1, #1
 38a:	f04f 0200 	mov.w	r2, #0
 38e:	4798      	blx	r3

  if (newconn == NULL) {
 390:	68fb      	ldr	r3, [r7, #12]
 392:	2b00      	cmp	r3, #0
 394:	d112      	bne.n	3bc <netconn_accept+0xb0>
    /* connection has been aborted */
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
 396:	f7ff fffe 	bl	0 <sys_arch_protect>
			396: R_ARM_THM_CALL	sys_arch_protect
 39a:	6138      	str	r0, [r7, #16]
 39c:	687b      	ldr	r3, [r7, #4]
 39e:	7a1b      	ldrb	r3, [r3, #8]
 3a0:	b25b      	sxtb	r3, r3
 3a2:	f113 0f09 	cmn.w	r3, #9
 3a6:	db03      	blt.n	3b0 <netconn_accept+0xa4>
 3a8:	687b      	ldr	r3, [r7, #4]
 3aa:	f04f 02f6 	mov.w	r2, #246	; 0xf6
 3ae:	721a      	strb	r2, [r3, #8]
 3b0:	6938      	ldr	r0, [r7, #16]
 3b2:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			3b2: R_ARM_THM_CALL	sys_arch_unprotect
    return ERR_ABRT;
 3b6:	f04f 03f6 	mov.w	r3, #246	; 0xf6
 3ba:	e004      	b.n	3c6 <netconn_accept+0xba>
  msg.msg.conn = conn;
  /* don't care for the return value of do_recv */
  TCPIP_APIMSG(&msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
 3bc:	68fa      	ldr	r2, [r7, #12]
 3be:	683b      	ldr	r3, [r7, #0]
 3c0:	601a      	str	r2, [r3, #0]
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 3c2:	f04f 0300 	mov.w	r3, #0
 3c6:	b25b      	sxtb	r3, r3
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 3c8:	4618      	mov	r0, r3
 3ca:	f107 0718 	add.w	r7, r7, #24
 3ce:	46bd      	mov	sp, r7
 3d0:	bd80      	pop	{r7, pc}
 3d2:	bf00      	nop

000003d4 <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
 3d4:	b580      	push	{r7, lr}
 3d6:	b08c      	sub	sp, #48	; 0x30
 3d8:	af00      	add	r7, sp, #0
 3da:	6078      	str	r0, [r7, #4]
 3dc:	6039      	str	r1, [r7, #0]
  void *buf = NULL;
 3de:	f04f 0300 	mov.w	r3, #0
 3e2:	623b      	str	r3, [r7, #32]
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 3e4:	683b      	ldr	r3, [r7, #0]
 3e6:	2b00      	cmp	r3, #0
 3e8:	d102      	bne.n	3f0 <netconn_recv_data+0x1c>
 3ea:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 3ee:	e096      	b.n	51e <netconn_recv_data+0x14a>
  *new_buf = NULL;
 3f0:	683b      	ldr	r3, [r7, #0]
 3f2:	f04f 0200 	mov.w	r2, #0
 3f6:	601a      	str	r2, [r3, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 3f8:	687b      	ldr	r3, [r7, #4]
 3fa:	2b00      	cmp	r3, #0
 3fc:	d102      	bne.n	404 <netconn_recv_data+0x30>
 3fe:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 402:	e08c      	b.n	51e <netconn_recv_data+0x14a>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 404:	687b      	ldr	r3, [r7, #4]
 406:	f103 0314 	add.w	r3, r3, #20
 40a:	4618      	mov	r0, r3
 40c:	f7ff fffe 	bl	0 <sys_mbox_valid>
			40c: R_ARM_THM_CALL	sys_mbox_valid
 410:	4603      	mov	r3, r0
 412:	2b00      	cmp	r3, #0
 414:	d102      	bne.n	41c <netconn_recv_data+0x48>
 416:	f04f 03f3 	mov.w	r3, #243	; 0xf3
 41a:	e080      	b.n	51e <netconn_recv_data+0x14a>

  err = conn->last_err;
 41c:	687b      	ldr	r3, [r7, #4]
 41e:	7a1b      	ldrb	r3, [r3, #8]
 420:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
  if (ERR_IS_FATAL(err)) {
 424:	f997 302d 	ldrsb.w	r3, [r7, #45]	; 0x2d
 428:	f113 0f09 	cmn.w	r3, #9
 42c:	da02      	bge.n	434 <netconn_recv_data+0x60>
    /* don't recv on fatal errors: this might block the application task
       waiting on recvmbox forever! */
    /* @todo: this does not allow us to fetch data that has been put into recvmbox
       before the fatal error occurred - is that a problem? */
    return err;
 42e:	f897 302d 	ldrb.w	r3, [r7, #45]	; 0x2d
 432:	e074      	b.n	51e <netconn_recv_data+0x14a>
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
    return ERR_TIMEOUT;
  }
#else
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
 434:	687b      	ldr	r3, [r7, #4]
 436:	f103 0214 	add.w	r2, r3, #20
 43a:	f107 0320 	add.w	r3, r7, #32
 43e:	4610      	mov	r0, r2
 440:	4619      	mov	r1, r3
 442:	f04f 0200 	mov.w	r2, #0
 446:	f7ff fffe 	bl	0 <sys_arch_mbox_fetch>
			446: R_ARM_THM_CALL	sys_arch_mbox_fetch
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 44a:	687b      	ldr	r3, [r7, #4]
 44c:	781b      	ldrb	r3, [r3, #0]
 44e:	2b10      	cmp	r3, #16
 450:	d142      	bne.n	4d8 <netconn_recv_data+0x104>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 452:	687b      	ldr	r3, [r7, #4]
 454:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 458:	f003 0308 	and.w	r3, r3, #8
 45c:	2b00      	cmp	r3, #0
 45e:	d002      	beq.n	466 <netconn_recv_data+0x92>
 460:	6a3b      	ldr	r3, [r7, #32]
 462:	2b00      	cmp	r3, #0
 464:	d112      	bne.n	48c <netconn_recv_data+0xb8>
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 466:	4b31      	ldr	r3, [pc, #196]	; (52c <netconn_recv_data+0x158>)
 468:	60bb      	str	r3, [r7, #8]
      msg.msg.conn = conn;
 46a:	687b      	ldr	r3, [r7, #4]
 46c:	60fb      	str	r3, [r7, #12]
      if (buf != NULL) {
 46e:	6a3b      	ldr	r3, [r7, #32]
 470:	2b00      	cmp	r3, #0
 472:	d003      	beq.n	47c <netconn_recv_data+0xa8>
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
 474:	6a3b      	ldr	r3, [r7, #32]
 476:	891b      	ldrh	r3, [r3, #8]
 478:	617b      	str	r3, [r7, #20]
 47a:	e002      	b.n	482 <netconn_recv_data+0xae>
      } else {
        msg.msg.msg.r.len = 1;
 47c:	f04f 0301 	mov.w	r3, #1
 480:	617b      	str	r3, [r7, #20]
      }
      /* don't care for the return value of do_recv */
      TCPIP_APIMSG(&msg);
 482:	f107 0308 	add.w	r3, r7, #8
 486:	4618      	mov	r0, r3
 488:	f7ff fffe 	bl	0 <tcpip_apimsg>
			488: R_ARM_THM_CALL	tcpip_apimsg
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
 48c:	6a3b      	ldr	r3, [r7, #32]
 48e:	2b00      	cmp	r3, #0
 490:	d11e      	bne.n	4d0 <netconn_recv_data+0xfc>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 492:	687b      	ldr	r3, [r7, #4]
 494:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 496:	2b00      	cmp	r3, #0
 498:	d007      	beq.n	4aa <netconn_recv_data+0xd6>
 49a:	687b      	ldr	r3, [r7, #4]
 49c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 49e:	6878      	ldr	r0, [r7, #4]
 4a0:	f04f 0101 	mov.w	r1, #1
 4a4:	f04f 0200 	mov.w	r2, #0
 4a8:	4798      	blx	r3
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
 4aa:	f7ff fffe 	bl	0 <sys_arch_protect>
			4aa: R_ARM_THM_CALL	sys_arch_protect
 4ae:	62b8      	str	r0, [r7, #40]	; 0x28
 4b0:	687b      	ldr	r3, [r7, #4]
 4b2:	7a1b      	ldrb	r3, [r3, #8]
 4b4:	b25b      	sxtb	r3, r3
 4b6:	f113 0f09 	cmn.w	r3, #9
 4ba:	db03      	blt.n	4c4 <netconn_recv_data+0xf0>
 4bc:	687b      	ldr	r3, [r7, #4]
 4be:	f04f 02f4 	mov.w	r2, #244	; 0xf4
 4c2:	721a      	strb	r2, [r3, #8]
 4c4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 4c6:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			4c6: R_ARM_THM_CALL	sys_arch_unprotect
      return ERR_CLSD;
 4ca:	f04f 03f4 	mov.w	r3, #244	; 0xf4
 4ce:	e026      	b.n	51e <netconn_recv_data+0x14a>
    }
    len = ((struct pbuf *)buf)->tot_len;
 4d0:	6a3b      	ldr	r3, [r7, #32]
 4d2:	891b      	ldrh	r3, [r3, #8]
 4d4:	85fb      	strh	r3, [r7, #46]	; 0x2e
 4d6:	e003      	b.n	4e0 <netconn_recv_data+0x10c>
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
    len = netbuf_len((struct netbuf *)buf);
 4d8:	6a3b      	ldr	r3, [r7, #32]
 4da:	681b      	ldr	r3, [r3, #0]
 4dc:	891b      	ldrh	r3, [r3, #8]
 4de:	85fb      	strh	r3, [r7, #46]	; 0x2e
  }
#endif /* (LWIP_UDP || LWIP_RAW) */

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
 4e0:	f7ff fffe 	bl	0 <sys_arch_protect>
			4e0: R_ARM_THM_CALL	sys_arch_protect
 4e4:	6278      	str	r0, [r7, #36]	; 0x24
 4e6:	687b      	ldr	r3, [r7, #4]
 4e8:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 4ea:	b29a      	uxth	r2, r3
 4ec:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 4ee:	1ad3      	subs	r3, r2, r3
 4f0:	b29b      	uxth	r3, r3
 4f2:	b29a      	uxth	r2, r3
 4f4:	687b      	ldr	r3, [r7, #4]
 4f6:	859a      	strh	r2, [r3, #44]	; 0x2c
 4f8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 4fa:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			4fa: R_ARM_THM_CALL	sys_arch_unprotect
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 4fe:	687b      	ldr	r3, [r7, #4]
 500:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 502:	2b00      	cmp	r3, #0
 504:	d006      	beq.n	514 <netconn_recv_data+0x140>
 506:	687b      	ldr	r3, [r7, #4]
 508:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 50a:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 50c:	6878      	ldr	r0, [r7, #4]
 50e:	f04f 0101 	mov.w	r1, #1
 512:	4798      	blx	r3

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
 514:	6a3a      	ldr	r2, [r7, #32]
 516:	683b      	ldr	r3, [r7, #0]
 518:	601a      	str	r2, [r3, #0]
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 51a:	f04f 0300 	mov.w	r3, #0
 51e:	b25b      	sxtb	r3, r3
}
 520:	4618      	mov	r0, r3
 522:	f107 0730 	add.w	r7, r7, #48	; 0x30
 526:	46bd      	mov	sp, r7
 528:	bd80      	pop	{r7, pc}
 52a:	bf00      	nop
 52c:	00000000 	.word	0x00000000
			52c: R_ARM_ABS32	do_recv

00000530 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
 530:	b580      	push	{r7, lr}
 532:	b082      	sub	sp, #8
 534:	af00      	add	r7, sp, #0
 536:	6078      	str	r0, [r7, #4]
 538:	6039      	str	r1, [r7, #0]
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 53a:	687b      	ldr	r3, [r7, #4]
 53c:	2b00      	cmp	r3, #0
 53e:	d003      	beq.n	548 <netconn_recv_tcp_pbuf+0x18>
 540:	687b      	ldr	r3, [r7, #4]
 542:	781b      	ldrb	r3, [r3, #0]
 544:	2b10      	cmp	r3, #16
 546:	d002      	beq.n	54e <netconn_recv_tcp_pbuf+0x1e>
 548:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 54c:	e005      	b.n	55a <netconn_recv_tcp_pbuf+0x2a>
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
 54e:	683b      	ldr	r3, [r7, #0]
 550:	6878      	ldr	r0, [r7, #4]
 552:	4619      	mov	r1, r3
 554:	f7ff ff3e 	bl	3d4 <netconn_recv_data>
 558:	4603      	mov	r3, r0
 55a:	b25b      	sxtb	r3, r3
}
 55c:	4618      	mov	r0, r3
 55e:	f107 0708 	add.w	r7, r7, #8
 562:	46bd      	mov	sp, r7
 564:	bd80      	pop	{r7, pc}
 566:	bf00      	nop

00000568 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 568:	b580      	push	{r7, lr}
 56a:	b086      	sub	sp, #24
 56c:	af00      	add	r7, sp, #0
 56e:	6078      	str	r0, [r7, #4]
 570:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  struct netbuf *buf = NULL;
 572:	f04f 0300 	mov.w	r3, #0
 576:	617b      	str	r3, [r7, #20]
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 578:	683b      	ldr	r3, [r7, #0]
 57a:	2b00      	cmp	r3, #0
 57c:	d102      	bne.n	584 <netconn_recv+0x1c>
 57e:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 582:	e065      	b.n	650 <netconn_recv+0xe8>
  *new_buf = NULL;
 584:	683b      	ldr	r3, [r7, #0]
 586:	f04f 0200 	mov.w	r2, #0
 58a:	601a      	str	r2, [r3, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 58c:	687b      	ldr	r3, [r7, #4]
 58e:	2b00      	cmp	r3, #0
 590:	d102      	bne.n	598 <netconn_recv+0x30>
 592:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 596:	e05b      	b.n	650 <netconn_recv+0xe8>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 598:	687b      	ldr	r3, [r7, #4]
 59a:	f103 0314 	add.w	r3, r3, #20
 59e:	4618      	mov	r0, r3
 5a0:	f7ff fffe 	bl	0 <sys_mbox_valid>
			5a0: R_ARM_THM_CALL	sys_mbox_valid
 5a4:	4603      	mov	r3, r0
 5a6:	2b00      	cmp	r3, #0
 5a8:	d102      	bne.n	5b0 <netconn_recv+0x48>
 5aa:	f04f 03f3 	mov.w	r3, #243	; 0xf3
 5ae:	e04f      	b.n	650 <netconn_recv+0xe8>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 5b0:	687b      	ldr	r3, [r7, #4]
 5b2:	781b      	ldrb	r3, [r3, #0]
 5b4:	2b10      	cmp	r3, #16
 5b6:	d145      	bne.n	644 <netconn_recv+0xdc>
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
 5b8:	f04f 0300 	mov.w	r3, #0
 5bc:	60bb      	str	r3, [r7, #8]
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 5be:	f04f 0006 	mov.w	r0, #6
 5c2:	f7ff fffe 	bl	0 <memp_malloc>
			5c2: R_ARM_THM_CALL	memp_malloc
 5c6:	4603      	mov	r3, r0
 5c8:	617b      	str	r3, [r7, #20]
    if (buf == NULL) {
 5ca:	697b      	ldr	r3, [r7, #20]
 5cc:	2b00      	cmp	r3, #0
 5ce:	d112      	bne.n	5f6 <netconn_recv+0x8e>
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
 5d0:	f7ff fffe 	bl	0 <sys_arch_protect>
			5d0: R_ARM_THM_CALL	sys_arch_protect
 5d4:	6138      	str	r0, [r7, #16]
 5d6:	687b      	ldr	r3, [r7, #4]
 5d8:	7a1b      	ldrb	r3, [r3, #8]
 5da:	b25b      	sxtb	r3, r3
 5dc:	f113 0f09 	cmn.w	r3, #9
 5e0:	db03      	blt.n	5ea <netconn_recv+0x82>
 5e2:	687b      	ldr	r3, [r7, #4]
 5e4:	f04f 02ff 	mov.w	r2, #255	; 0xff
 5e8:	721a      	strb	r2, [r3, #8]
 5ea:	6938      	ldr	r0, [r7, #16]
 5ec:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			5ec: R_ARM_THM_CALL	sys_arch_unprotect
      return ERR_MEM;
 5f0:	f04f 03ff 	mov.w	r3, #255	; 0xff
 5f4:	e02c      	b.n	650 <netconn_recv+0xe8>
    }

    err = netconn_recv_data(conn, (void **)&p);
 5f6:	f107 0308 	add.w	r3, r7, #8
 5fa:	6878      	ldr	r0, [r7, #4]
 5fc:	4619      	mov	r1, r3
 5fe:	f7ff fee9 	bl	3d4 <netconn_recv_data>
 602:	4603      	mov	r3, r0
 604:	73fb      	strb	r3, [r7, #15]
    if (err != ERR_OK) {
 606:	f997 300f 	ldrsb.w	r3, [r7, #15]
 60a:	2b00      	cmp	r3, #0
 60c:	d006      	beq.n	61c <netconn_recv+0xb4>
      memp_free(MEMP_NETBUF, buf);
 60e:	f04f 0006 	mov.w	r0, #6
 612:	6979      	ldr	r1, [r7, #20]
 614:	f7ff fffe 	bl	0 <memp_free>
			614: R_ARM_THM_CALL	memp_free
      return err;
 618:	7bfb      	ldrb	r3, [r7, #15]
 61a:	e019      	b.n	650 <netconn_recv+0xe8>
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
 61c:	68ba      	ldr	r2, [r7, #8]
 61e:	697b      	ldr	r3, [r7, #20]
 620:	601a      	str	r2, [r3, #0]
    buf->ptr = p;
 622:	68ba      	ldr	r2, [r7, #8]
 624:	697b      	ldr	r3, [r7, #20]
 626:	605a      	str	r2, [r3, #4]
    buf->port = 0;
 628:	697b      	ldr	r3, [r7, #20]
 62a:	f04f 0200 	mov.w	r2, #0
 62e:	819a      	strh	r2, [r3, #12]
    ip_addr_set_any(&buf->addr);
 630:	697b      	ldr	r3, [r7, #20]
 632:	f04f 0200 	mov.w	r2, #0
 636:	609a      	str	r2, [r3, #8]
    *new_buf = buf;
 638:	683b      	ldr	r3, [r7, #0]
 63a:	697a      	ldr	r2, [r7, #20]
 63c:	601a      	str	r2, [r3, #0]
    /* don't set conn->last_err: it's only ERR_OK, anyway */
    return ERR_OK;
 63e:	f04f 0300 	mov.w	r3, #0
 642:	e005      	b.n	650 <netconn_recv+0xe8>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
 644:	683b      	ldr	r3, [r7, #0]
 646:	6878      	ldr	r0, [r7, #4]
 648:	4619      	mov	r1, r3
 64a:	f7ff fec3 	bl	3d4 <netconn_recv_data>
 64e:	4603      	mov	r3, r0
 650:	b25b      	sxtb	r3, r3
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 652:	4618      	mov	r0, r3
 654:	f107 0718 	add.w	r7, r7, #24
 658:	46bd      	mov	sp, r7
 65a:	bd80      	pop	{r7, pc}

0000065c <netconn_recved>:
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
 65c:	b580      	push	{r7, lr}
 65e:	b088      	sub	sp, #32
 660:	af00      	add	r7, sp, #0
 662:	6078      	str	r0, [r7, #4]
 664:	6039      	str	r1, [r7, #0]
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 666:	687b      	ldr	r3, [r7, #4]
 668:	2b00      	cmp	r3, #0
 66a:	d015      	beq.n	698 <netconn_recved+0x3c>
 66c:	687b      	ldr	r3, [r7, #4]
 66e:	781b      	ldrb	r3, [r3, #0]
 670:	2b10      	cmp	r3, #16
 672:	d111      	bne.n	698 <netconn_recved+0x3c>
      (netconn_get_noautorecved(conn))) {
 674:	687b      	ldr	r3, [r7, #4]
 676:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 67a:	f003 0308 	and.w	r3, r3, #8
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 67e:	2b00      	cmp	r3, #0
 680:	d00a      	beq.n	698 <netconn_recved+0x3c>
      (netconn_get_noautorecved(conn))) {
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
 682:	4b07      	ldr	r3, [pc, #28]	; (6a0 <netconn_recved+0x44>)
 684:	60bb      	str	r3, [r7, #8]
    msg.msg.conn = conn;
 686:	687b      	ldr	r3, [r7, #4]
 688:	60fb      	str	r3, [r7, #12]
    msg.msg.msg.r.len = length;
 68a:	683b      	ldr	r3, [r7, #0]
 68c:	617b      	str	r3, [r7, #20]
    /* don't care for the return value of do_recv */
    TCPIP_APIMSG(&msg);
 68e:	f107 0308 	add.w	r3, r7, #8
 692:	4618      	mov	r0, r3
 694:	f7ff fffe 	bl	0 <tcpip_apimsg>
			694: R_ARM_THM_CALL	tcpip_apimsg
  }
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
 698:	f107 0720 	add.w	r7, r7, #32
 69c:	46bd      	mov	sp, r7
 69e:	bd80      	pop	{r7, pc}
 6a0:	00000000 	.word	0x00000000
			6a0: R_ARM_ABS32	do_recv

000006a4 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
{
 6a4:	b580      	push	{r7, lr}
 6a6:	b084      	sub	sp, #16
 6a8:	af00      	add	r7, sp, #0
 6aa:	60f8      	str	r0, [r7, #12]
 6ac:	60b9      	str	r1, [r7, #8]
 6ae:	607a      	str	r2, [r7, #4]
 6b0:	807b      	strh	r3, [r7, #2]
  if (buf != NULL) {
 6b2:	68bb      	ldr	r3, [r7, #8]
 6b4:	2b00      	cmp	r3, #0
 6b6:	d012      	beq.n	6de <netconn_sendto+0x3a>
    ip_addr_set(&buf->addr, addr);
 6b8:	687b      	ldr	r3, [r7, #4]
 6ba:	2b00      	cmp	r3, #0
 6bc:	d002      	beq.n	6c4 <netconn_sendto+0x20>
 6be:	687b      	ldr	r3, [r7, #4]
 6c0:	681b      	ldr	r3, [r3, #0]
 6c2:	e001      	b.n	6c8 <netconn_sendto+0x24>
 6c4:	f04f 0300 	mov.w	r3, #0
 6c8:	68ba      	ldr	r2, [r7, #8]
 6ca:	6093      	str	r3, [r2, #8]
    buf->port = port;
 6cc:	68bb      	ldr	r3, [r7, #8]
 6ce:	887a      	ldrh	r2, [r7, #2]
 6d0:	819a      	strh	r2, [r3, #12]
    return netconn_send(conn, buf);
 6d2:	68f8      	ldr	r0, [r7, #12]
 6d4:	68b9      	ldr	r1, [r7, #8]
 6d6:	f7ff fffe 	bl	6f0 <netconn_send>
			6d6: R_ARM_THM_CALL	netconn_send
 6da:	4603      	mov	r3, r0
 6dc:	e001      	b.n	6e2 <netconn_sendto+0x3e>
  }
  return ERR_VAL;
 6de:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 6e2:	b25b      	sxtb	r3, r3
}
 6e4:	4618      	mov	r0, r3
 6e6:	f107 0710 	add.w	r7, r7, #16
 6ea:	46bd      	mov	sp, r7
 6ec:	bd80      	pop	{r7, pc}
 6ee:	bf00      	nop

000006f0 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
 6f0:	b580      	push	{r7, lr}
 6f2:	b08a      	sub	sp, #40	; 0x28
 6f4:	af00      	add	r7, sp, #0
 6f6:	6078      	str	r0, [r7, #4]
 6f8:	6039      	str	r1, [r7, #0]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 6fa:	687b      	ldr	r3, [r7, #4]
 6fc:	2b00      	cmp	r3, #0
 6fe:	d102      	bne.n	706 <netconn_send+0x16>
 700:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 704:	e01f      	b.n	746 <netconn_send+0x56>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
 706:	4b13      	ldr	r3, [pc, #76]	; (754 <netconn_send+0x64>)
 708:	60bb      	str	r3, [r7, #8]
  msg.msg.conn = conn;
 70a:	687b      	ldr	r3, [r7, #4]
 70c:	60fb      	str	r3, [r7, #12]
  msg.msg.msg.b = buf;
 70e:	683b      	ldr	r3, [r7, #0]
 710:	617b      	str	r3, [r7, #20]
  err = TCPIP_APIMSG(&msg);
 712:	f107 0308 	add.w	r3, r7, #8
 716:	4618      	mov	r0, r3
 718:	f7ff fffe 	bl	0 <tcpip_apimsg>
			718: R_ARM_THM_CALL	tcpip_apimsg
 71c:	4603      	mov	r3, r0
 71e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  NETCONN_SET_SAFE_ERR(conn, err);
 722:	f7ff fffe 	bl	0 <sys_arch_protect>
			722: R_ARM_THM_CALL	sys_arch_protect
 726:	6238      	str	r0, [r7, #32]
 728:	687b      	ldr	r3, [r7, #4]
 72a:	7a1b      	ldrb	r3, [r3, #8]
 72c:	b25b      	sxtb	r3, r3
 72e:	f113 0f09 	cmn.w	r3, #9
 732:	db03      	blt.n	73c <netconn_send+0x4c>
 734:	687b      	ldr	r3, [r7, #4]
 736:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 73a:	721a      	strb	r2, [r3, #8]
 73c:	6a38      	ldr	r0, [r7, #32]
 73e:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			73e: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 742:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 746:	b25b      	sxtb	r3, r3
}
 748:	4618      	mov	r0, r3
 74a:	f107 0728 	add.w	r7, r7, #40	; 0x28
 74e:	46bd      	mov	sp, r7
 750:	bd80      	pop	{r7, pc}
 752:	bf00      	nop
 754:	00000000 	.word	0x00000000
			754: R_ARM_ABS32	do_send

00000758 <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 758:	b580      	push	{r7, lr}
 75a:	b08c      	sub	sp, #48	; 0x30
 75c:	af00      	add	r7, sp, #0
 75e:	60f8      	str	r0, [r7, #12]
 760:	60b9      	str	r1, [r7, #8]
 762:	607a      	str	r2, [r7, #4]
 764:	70fb      	strb	r3, [r7, #3]
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 766:	68fb      	ldr	r3, [r7, #12]
 768:	2b00      	cmp	r3, #0
 76a:	d102      	bne.n	772 <netconn_write_partly+0x1a>
 76c:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 770:	e060      	b.n	834 <netconn_write_partly+0xdc>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 772:	68fb      	ldr	r3, [r7, #12]
 774:	781b      	ldrb	r3, [r3, #0]
 776:	2b10      	cmp	r3, #16
 778:	d002      	beq.n	780 <netconn_write_partly+0x28>
 77a:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 77e:	e059      	b.n	834 <netconn_write_partly+0xdc>
  if (size == 0) {
 780:	687b      	ldr	r3, [r7, #4]
 782:	2b00      	cmp	r3, #0
 784:	d102      	bne.n	78c <netconn_write_partly+0x34>
    return ERR_OK;
 786:	f04f 0300 	mov.w	r3, #0
 78a:	e053      	b.n	834 <netconn_write_partly+0xdc>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 78c:	68fb      	ldr	r3, [r7, #12]
 78e:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 792:	f003 0302 	and.w	r3, r3, #2
 796:	2b00      	cmp	r3, #0
 798:	d104      	bne.n	7a4 <netconn_write_partly+0x4c>
 79a:	78fb      	ldrb	r3, [r7, #3]
 79c:	f003 0304 	and.w	r3, r3, #4
 7a0:	2b00      	cmp	r3, #0
 7a2:	d002      	beq.n	7aa <netconn_write_partly+0x52>
 7a4:	f04f 0301 	mov.w	r3, #1
 7a8:	e001      	b.n	7ae <netconn_write_partly+0x56>
 7aa:	f04f 0300 	mov.w	r3, #0
 7ae:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  if (dontblock && !bytes_written) {
 7b2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 7b6:	2b00      	cmp	r3, #0
 7b8:	d005      	beq.n	7c6 <netconn_write_partly+0x6e>
 7ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 7bc:	2b00      	cmp	r3, #0
 7be:	d102      	bne.n	7c6 <netconn_write_partly+0x6e>
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
 7c0:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 7c4:	e036      	b.n	834 <netconn_write_partly+0xdc>
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 7c6:	4b1e      	ldr	r3, [pc, #120]	; (840 <netconn_write_partly+0xe8>)
 7c8:	613b      	str	r3, [r7, #16]
  msg.msg.conn = conn;
 7ca:	68fb      	ldr	r3, [r7, #12]
 7cc:	617b      	str	r3, [r7, #20]
  msg.msg.msg.w.dataptr = dataptr;
 7ce:	68bb      	ldr	r3, [r7, #8]
 7d0:	61fb      	str	r3, [r7, #28]
  msg.msg.msg.w.apiflags = apiflags;
 7d2:	78fb      	ldrb	r3, [r7, #3]
 7d4:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  msg.msg.msg.w.len = size;
 7d8:	687b      	ldr	r3, [r7, #4]
 7da:	623b      	str	r3, [r7, #32]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 7dc:	f107 0310 	add.w	r3, r7, #16
 7e0:	4618      	mov	r0, r3
 7e2:	f7ff fffe 	bl	0 <tcpip_apimsg>
			7e2: R_ARM_THM_CALL	tcpip_apimsg
 7e6:	4603      	mov	r3, r0
 7e8:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 7ec:	f997 302e 	ldrsb.w	r3, [r7, #46]	; 0x2e
 7f0:	2b00      	cmp	r3, #0
 7f2:	d10d      	bne.n	810 <netconn_write_partly+0xb8>
 7f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 7f6:	2b00      	cmp	r3, #0
 7f8:	d00a      	beq.n	810 <netconn_write_partly+0xb8>
    if (dontblock
 7fa:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 7fe:	2b00      	cmp	r3, #0
 800:	d003      	beq.n	80a <netconn_write_partly+0xb2>
#if LWIP_SO_SNDTIMEO
        || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
 802:	6a3a      	ldr	r2, [r7, #32]
 804:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 806:	601a      	str	r2, [r3, #0]
 808:	e002      	b.n	810 <netconn_write_partly+0xb8>
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
 80a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80c:	687a      	ldr	r2, [r7, #4]
 80e:	601a      	str	r2, [r3, #0]
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
 810:	f7ff fffe 	bl	0 <sys_arch_protect>
			810: R_ARM_THM_CALL	sys_arch_protect
 814:	62b8      	str	r0, [r7, #40]	; 0x28
 816:	68fb      	ldr	r3, [r7, #12]
 818:	7a1b      	ldrb	r3, [r3, #8]
 81a:	b25b      	sxtb	r3, r3
 81c:	f113 0f09 	cmn.w	r3, #9
 820:	db03      	blt.n	82a <netconn_write_partly+0xd2>
 822:	68fb      	ldr	r3, [r7, #12]
 824:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 828:	721a      	strb	r2, [r3, #8]
 82a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 82c:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			82c: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 830:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 834:	b25b      	sxtb	r3, r3
}
 836:	4618      	mov	r0, r3
 838:	f107 0730 	add.w	r7, r7, #48	; 0x30
 83c:	46bd      	mov	sp, r7
 83e:	bd80      	pop	{r7, pc}
 840:	00000000 	.word	0x00000000
			840: R_ARM_ABS32	do_write

00000844 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 844:	b580      	push	{r7, lr}
 846:	b08a      	sub	sp, #40	; 0x28
 848:	af00      	add	r7, sp, #0
 84a:	6078      	str	r0, [r7, #4]
 84c:	460b      	mov	r3, r1
 84e:	70fb      	strb	r3, [r7, #3]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 850:	687b      	ldr	r3, [r7, #4]
 852:	2b00      	cmp	r3, #0
 854:	d102      	bne.n	85c <netconn_close_shutdown+0x18>
 856:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 85a:	e01f      	b.n	89c <netconn_close_shutdown+0x58>

  msg.function = do_close;
 85c:	4b12      	ldr	r3, [pc, #72]	; (8a8 <netconn_close_shutdown+0x64>)
 85e:	60bb      	str	r3, [r7, #8]
  msg.msg.conn = conn;
 860:	687b      	ldr	r3, [r7, #4]
 862:	60fb      	str	r3, [r7, #12]
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
 864:	78fb      	ldrb	r3, [r7, #3]
 866:	753b      	strb	r3, [r7, #20]
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 868:	f107 0308 	add.w	r3, r7, #8
 86c:	4618      	mov	r0, r3
 86e:	f7ff fffe 	bl	0 <tcpip_apimsg>
			86e: R_ARM_THM_CALL	tcpip_apimsg
 872:	4603      	mov	r3, r0
 874:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  NETCONN_SET_SAFE_ERR(conn, err);
 878:	f7ff fffe 	bl	0 <sys_arch_protect>
			878: R_ARM_THM_CALL	sys_arch_protect
 87c:	6238      	str	r0, [r7, #32]
 87e:	687b      	ldr	r3, [r7, #4]
 880:	7a1b      	ldrb	r3, [r3, #8]
 882:	b25b      	sxtb	r3, r3
 884:	f113 0f09 	cmn.w	r3, #9
 888:	db03      	blt.n	892 <netconn_close_shutdown+0x4e>
 88a:	687b      	ldr	r3, [r7, #4]
 88c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
 890:	721a      	strb	r2, [r3, #8]
 892:	6a38      	ldr	r0, [r7, #32]
 894:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			894: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 898:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 89c:	b25b      	sxtb	r3, r3
}
 89e:	4618      	mov	r0, r3
 8a0:	f107 0728 	add.w	r7, r7, #40	; 0x28
 8a4:	46bd      	mov	sp, r7
 8a6:	bd80      	pop	{r7, pc}
 8a8:	00000000 	.word	0x00000000
			8a8: R_ARM_ABS32	do_close

000008ac <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
 8ac:	b580      	push	{r7, lr}
 8ae:	b082      	sub	sp, #8
 8b0:	af00      	add	r7, sp, #0
 8b2:	6078      	str	r0, [r7, #4]
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 8b4:	6878      	ldr	r0, [r7, #4]
 8b6:	f04f 0103 	mov.w	r1, #3
 8ba:	f7ff ffc3 	bl	844 <netconn_close_shutdown>
 8be:	4603      	mov	r3, r0
}
 8c0:	4618      	mov	r0, r3
 8c2:	f107 0708 	add.w	r7, r7, #8
 8c6:	46bd      	mov	sp, r7
 8c8:	bd80      	pop	{r7, pc}
 8ca:	bf00      	nop

000008cc <netconn_shutdown>:
 * @param conn the TCP netconn to shut down
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
 8cc:	b580      	push	{r7, lr}
 8ce:	b082      	sub	sp, #8
 8d0:	af00      	add	r7, sp, #0
 8d2:	6078      	str	r0, [r7, #4]
 8d4:	4613      	mov	r3, r2
 8d6:	460a      	mov	r2, r1
 8d8:	70fa      	strb	r2, [r7, #3]
 8da:	70bb      	strb	r3, [r7, #2]
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
 8dc:	78fb      	ldrb	r3, [r7, #3]
 8de:	2b00      	cmp	r3, #0
 8e0:	bf0c      	ite	eq
 8e2:	2300      	moveq	r3, #0
 8e4:	2301      	movne	r3, #1
 8e6:	b2da      	uxtb	r2, r3
 8e8:	78bb      	ldrb	r3, [r7, #2]
 8ea:	2b00      	cmp	r3, #0
 8ec:	d002      	beq.n	8f4 <netconn_shutdown+0x28>
 8ee:	f04f 0302 	mov.w	r3, #2
 8f2:	e001      	b.n	8f8 <netconn_shutdown+0x2c>
 8f4:	f04f 0300 	mov.w	r3, #0
 8f8:	ea42 0303 	orr.w	r3, r2, r3
 8fc:	b2db      	uxtb	r3, r3
 8fe:	b2db      	uxtb	r3, r3
 900:	6878      	ldr	r0, [r7, #4]
 902:	4619      	mov	r1, r3
 904:	f7ff ff9e 	bl	844 <netconn_close_shutdown>
 908:	4603      	mov	r3, r0
}
 90a:	4618      	mov	r0, r3
 90c:	f107 0708 	add.w	r7, r7, #8
 910:	46bd      	mov	sp, r7
 912:	bd80      	pop	{r7, pc}

00000914 <netconn_join_leave_group>:
err_t
netconn_join_leave_group(struct netconn *conn,
                         ip_addr_t *multiaddr,
                         ip_addr_t *netif_addr,
                         enum netconn_igmp join_or_leave)
{
 914:	b580      	push	{r7, lr}
 916:	b08c      	sub	sp, #48	; 0x30
 918:	af00      	add	r7, sp, #0
 91a:	60f8      	str	r0, [r7, #12]
 91c:	60b9      	str	r1, [r7, #8]
 91e:	607a      	str	r2, [r7, #4]
 920:	70fb      	strb	r3, [r7, #3]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_join_leave_group: invalid conn",  (conn != NULL), return ERR_ARG;);
 922:	68fb      	ldr	r3, [r7, #12]
 924:	2b00      	cmp	r3, #0
 926:	d102      	bne.n	92e <netconn_join_leave_group+0x1a>
 928:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 92c:	e024      	b.n	978 <netconn_join_leave_group+0x64>

  msg.function = do_join_leave_group;
 92e:	4b15      	ldr	r3, [pc, #84]	; (984 <netconn_join_leave_group+0x70>)
 930:	613b      	str	r3, [r7, #16]
  msg.msg.conn = conn;
 932:	68fb      	ldr	r3, [r7, #12]
 934:	617b      	str	r3, [r7, #20]
  msg.msg.msg.jl.multiaddr = multiaddr;
 936:	68bb      	ldr	r3, [r7, #8]
 938:	61fb      	str	r3, [r7, #28]
  msg.msg.msg.jl.netif_addr = netif_addr;
 93a:	687b      	ldr	r3, [r7, #4]
 93c:	623b      	str	r3, [r7, #32]
  msg.msg.msg.jl.join_or_leave = join_or_leave;
 93e:	78fb      	ldrb	r3, [r7, #3]
 940:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  err = TCPIP_APIMSG(&msg);
 944:	f107 0310 	add.w	r3, r7, #16
 948:	4618      	mov	r0, r3
 94a:	f7ff fffe 	bl	0 <tcpip_apimsg>
			94a: R_ARM_THM_CALL	tcpip_apimsg
 94e:	4603      	mov	r3, r0
 950:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  NETCONN_SET_SAFE_ERR(conn, err);
 954:	f7ff fffe 	bl	0 <sys_arch_protect>
			954: R_ARM_THM_CALL	sys_arch_protect
 958:	62b8      	str	r0, [r7, #40]	; 0x28
 95a:	68fb      	ldr	r3, [r7, #12]
 95c:	7a1b      	ldrb	r3, [r3, #8]
 95e:	b25b      	sxtb	r3, r3
 960:	f113 0f09 	cmn.w	r3, #9
 964:	db03      	blt.n	96e <netconn_join_leave_group+0x5a>
 966:	68fb      	ldr	r3, [r7, #12]
 968:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 96c:	721a      	strb	r2, [r3, #8]
 96e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 970:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			970: R_ARM_THM_CALL	sys_arch_unprotect
  return err;
 974:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 978:	b25b      	sxtb	r3, r3
}
 97a:	4618      	mov	r0, r3
 97c:	f107 0730 	add.w	r7, r7, #48	; 0x30
 980:	46bd      	mov	sp, r7
 982:	bd80      	pop	{r7, pc}
 984:	00000000 	.word	0x00000000
			984: R_ARM_ABS32	do_join_leave_group

00000988 <netconn_gethostbyname>:
 *         ERR_ARG: dns client not initialized or invalid hostname
 *         ERR_VAL: dns server response was invalid
 */
err_t
netconn_gethostbyname(const char *name, ip_addr_t *addr)
{
 988:	b580      	push	{r7, lr}
 98a:	b08a      	sub	sp, #40	; 0x28
 98c:	af00      	add	r7, sp, #0
 98e:	6078      	str	r0, [r7, #4]
 990:	6039      	str	r1, [r7, #0]
  struct dns_api_msg msg;
  err_t err;
  sys_sem_t sem;

  LWIP_ERROR("netconn_gethostbyname: invalid name", (name != NULL), return ERR_ARG;);
 992:	687b      	ldr	r3, [r7, #4]
 994:	2b00      	cmp	r3, #0
 996:	d102      	bne.n	99e <netconn_gethostbyname+0x16>
 998:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 99c:	e032      	b.n	a04 <netconn_gethostbyname+0x7c>
  LWIP_ERROR("netconn_gethostbyname: invalid addr", (addr != NULL), return ERR_ARG;);
 99e:	683b      	ldr	r3, [r7, #0]
 9a0:	2b00      	cmp	r3, #0
 9a2:	d102      	bne.n	9aa <netconn_gethostbyname+0x22>
 9a4:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 9a8:	e02c      	b.n	a04 <netconn_gethostbyname+0x7c>

  err = sys_sem_new(&sem, 0);
 9aa:	f107 030c 	add.w	r3, r7, #12
 9ae:	4618      	mov	r0, r3
 9b0:	f04f 0100 	mov.w	r1, #0
 9b4:	f7ff fffe 	bl	0 <sys_sem_new>
			9b4: R_ARM_THM_CALL	sys_sem_new
 9b8:	4603      	mov	r3, r0
 9ba:	75fb      	strb	r3, [r7, #23]
  if (err != ERR_OK) {
 9bc:	7dfb      	ldrb	r3, [r7, #23]
 9be:	2b00      	cmp	r3, #0
 9c0:	d001      	beq.n	9c6 <netconn_gethostbyname+0x3e>
    return err;
 9c2:	7dfb      	ldrb	r3, [r7, #23]
 9c4:	e01e      	b.n	a04 <netconn_gethostbyname+0x7c>
  }

  msg.name = name;
 9c6:	687b      	ldr	r3, [r7, #4]
 9c8:	61bb      	str	r3, [r7, #24]
  msg.addr = addr;
 9ca:	683b      	ldr	r3, [r7, #0]
 9cc:	61fb      	str	r3, [r7, #28]
  msg.err = &err;
 9ce:	f107 0317 	add.w	r3, r7, #23
 9d2:	627b      	str	r3, [r7, #36]	; 0x24
  msg.sem = &sem;
 9d4:	f107 030c 	add.w	r3, r7, #12
 9d8:	623b      	str	r3, [r7, #32]

  tcpip_callback(do_gethostbyname, &msg);
 9da:	f107 0318 	add.w	r3, r7, #24
 9de:	480c      	ldr	r0, [pc, #48]	; (a10 <netconn_gethostbyname+0x88>)
 9e0:	4619      	mov	r1, r3
 9e2:	f04f 0201 	mov.w	r2, #1
 9e6:	f7ff fffe 	bl	0 <tcpip_callback_with_block>
			9e6: R_ARM_THM_CALL	tcpip_callback_with_block
  sys_sem_wait(&sem);
 9ea:	f107 030c 	add.w	r3, r7, #12
 9ee:	4618      	mov	r0, r3
 9f0:	f04f 0100 	mov.w	r1, #0
 9f4:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			9f4: R_ARM_THM_CALL	sys_arch_sem_wait
  sys_sem_free(&sem);
 9f8:	f107 030c 	add.w	r3, r7, #12
 9fc:	4618      	mov	r0, r3
 9fe:	f7ff fffe 	bl	0 <sys_sem_free>
			9fe: R_ARM_THM_CALL	sys_sem_free

  return err;
 a02:	7dfb      	ldrb	r3, [r7, #23]
 a04:	b25b      	sxtb	r3, r3
}
 a06:	4618      	mov	r0, r3
 a08:	f107 0728 	add.w	r7, r7, #40	; 0x28
 a0c:	46bd      	mov	sp, r7
 a0e:	bd80      	pop	{r7, pc}
 a10:	00000000 	.word	0x00000000
			a10: R_ARM_ABS32	do_gethostbyname

api_msg.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  84580 Jul 30 19:07 2021 api_msg.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000018c4  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000018f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000018f8  2**0
                  ALLOC
  3 .debug_abbrev 00000238  00000000  00000000  000018f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000189a  00000000  00000000  00001b30  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000b2c  00000000  00000000  000033ca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000ccf6  00000000  00000000  00003ef6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000658  00000000  00000000  00010bec  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000fc  00000000  00000000  00011244  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000259  00000000  00000000  00011340  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00011599  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  000115b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000ac7  00000000  00000000  000115d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  00012098  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  000120c3  2**0
                  CONTENTS, READONLY
 15 .debug_frame  000003b0  00000000  00000000  000120f4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 api_msg.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     F .text	0000013c recv_raw
0000013c l     F .text	00000124 recv_udp
00000260 l     F .text	000000de recv_tcp
00000340 l     F .text	00000098 poll_tcp
00001340 l     F .text	000001f0 do_writemore
00000a48 l     F .text	000001bc do_close_internal
000003d8 l     F .text	00000092 sent_tcp
0000046c l     F .text	00000126 err_tcp
00000594 l     F .text	00000054 setup_tcp
000005e8 l     F .text	000000fe accept_function
000006e8 l     F .text	000000f0 pcb_new
00000940 l     F .text	00000106 netconn_drain
00000df8 l     F .text	000000e0 do_connected
00001824 l     F .text	00000054 do_dns_found
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000         *UND*	00000000 sys_mbox_valid
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 pbuf_copy
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 sys_mbox_trypost
00000000         *UND*	00000000 netbuf_delete
00000000         *UND*	00000000 current_iphdr_src
00000000         *UND*	00000000 current_header
00000000         *UND*	00000000 current_iphdr_dest
00000000         *UND*	00000000 tcp_recved
00000000         *UND*	00000000 sys_sem_signal
00000000         *UND*	00000000 tcp_arg
00000000         *UND*	00000000 tcp_recv
00000000         *UND*	00000000 tcp_sent
00000000         *UND*	00000000 tcp_poll
00000000         *UND*	00000000 tcp_err
00000810 g     F .text	000000e2 netconn_alloc
00000000         *UND*	00000000 sys_mbox_free
00000000         *UND*	00000000 sys_mbox_set_invalid
000008f4 g     F .text	0000004a netconn_free
00000000         *UND*	00000000 raw_new
00000000         *UND*	00000000 raw_recv
00000000         *UND*	00000000 udp_new
00000000         *UND*	00000000 udp_recv
00000000         *UND*	00000000 tcp_new
000007d8 g     F .text	00000036 do_newconn
00000000         *UND*	00000000 sys_sem_new
00000000         *UND*	00000000 sys_mbox_new
00000000         *UND*	00000000 sys_sem_free
00000000         *UND*	00000000 memp_free
00000000         *UND*	00000000 sys_sem_set_invalid
00000000         *UND*	00000000 sys_arch_mbox_tryfetch
00000000         *UND*	00000000 tcp_abort
00000000         *UND*	00000000 tcp_accept
00000000         *UND*	00000000 tcp_close
00000000         *UND*	00000000 tcp_shutdown
00000c04 g     F .text	0000012e do_delconn
00000000         *UND*	00000000 raw_remove
00000000         *UND*	00000000 udp_remove
00000000         *UND*	00000000 sys_sem_valid
00000d34 g     F .text	000000c2 do_bind
00000000         *UND*	00000000 raw_bind
00000000         *UND*	00000000 udp_bind
00000000         *UND*	00000000 tcp_bind
00000ed8 g     F .text	00000150 do_connect
00000000         *UND*	00000000 raw_connect
00000000         *UND*	00000000 udp_connect
00000000         *UND*	00000000 tcp_connect
00001028 g     F .text	0000004a do_disconnect
00000000         *UND*	00000000 udp_disconnect
00001074 g     F .text	00000140 do_listen
00000000         *UND*	00000000 tcp_listen_with_backlog
000011b4 g     F .text	00000116 do_send
00000000         *UND*	00000000 raw_send
00000000         *UND*	00000000 raw_sendto
00000000         *UND*	00000000 udp_send
00000000         *UND*	00000000 udp_sendto
000012cc g     F .text	00000074 do_recv
00000000         *UND*	00000000 tcp_write
00000000         *UND*	00000000 tcp_output
00001530 g     F .text	000000a2 do_write
000015d4 g     F .text	000000fa do_getaddr
000016d0 g     F .text	000000b2 do_close
00001784 g     F .text	0000009e do_join_leave_group
00000000         *UND*	00000000 igmp_joingroup
00000000         *UND*	00000000 igmp_leavegroup
00000000         *UND*	00000000 strcmp
00001878 g     F .text	0000004c do_gethostbyname
00000000         *UND*	00000000 dns_gethostbyname



Disassembly of section .text:

00000000 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr)
{
       0:	b580      	push	{r7, lr}
       2:	b08c      	sub	sp, #48	; 0x30
       4:	af00      	add	r7, sp, #0
       6:	60f8      	str	r0, [r7, #12]
       8:	60b9      	str	r1, [r7, #8]
       a:	607a      	str	r2, [r7, #4]
       c:	603b      	str	r3, [r7, #0]
  struct pbuf *q;
  struct netbuf *buf;
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
       e:	68fb      	ldr	r3, [r7, #12]
      10:	62bb      	str	r3, [r7, #40]	; 0x28

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
      12:	6abb      	ldr	r3, [r7, #40]	; 0x28
      14:	2b00      	cmp	r3, #0
      16:	f000 8087 	beq.w	128 <recv_raw+0x128>
      1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
      1c:	f103 0314 	add.w	r3, r3, #20
      20:	4618      	mov	r0, r3
      22:	f7ff fffe 	bl	0 <sys_mbox_valid>
			22: R_ARM_THM_CALL	sys_mbox_valid
      26:	4603      	mov	r3, r0
      28:	2b00      	cmp	r3, #0
      2a:	d07d      	beq.n	128 <recv_raw+0x128>
#if LWIP_SO_RCVBUF
    int recv_avail;
    SYS_ARCH_GET(conn->recv_avail, recv_avail);
      2c:	f7ff fffe 	bl	0 <sys_arch_protect>
			2c: R_ARM_THM_CALL	sys_arch_protect
      30:	6278      	str	r0, [r7, #36]	; 0x24
      32:	6abb      	ldr	r3, [r7, #40]	; 0x28
      34:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
      36:	b21b      	sxth	r3, r3
      38:	623b      	str	r3, [r7, #32]
      3a:	6a78      	ldr	r0, [r7, #36]	; 0x24
      3c:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			3c: R_ARM_THM_CALL	sys_arch_unprotect
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      40:	687b      	ldr	r3, [r7, #4]
      42:	891b      	ldrh	r3, [r3, #8]
      44:	461a      	mov	r2, r3
      46:	6a3b      	ldr	r3, [r7, #32]
      48:	18d2      	adds	r2, r2, r3
      4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
      4c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      4e:	429a      	cmp	r2, r3
      50:	dd02      	ble.n	58 <recv_raw+0x58>
      return 0;
      52:	f04f 0300 	mov.w	r3, #0
      56:	e069      	b.n	12c <recv_raw+0x12c>
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
      58:	687b      	ldr	r3, [r7, #4]
      5a:	891b      	ldrh	r3, [r3, #8]
      5c:	f04f 0003 	mov.w	r0, #3
      60:	4619      	mov	r1, r3
      62:	f04f 0200 	mov.w	r2, #0
      66:	f7ff fffe 	bl	0 <pbuf_alloc>
			66: R_ARM_THM_CALL	pbuf_alloc
      6a:	62f8      	str	r0, [r7, #44]	; 0x2c
    if(q != NULL) {
      6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
      6e:	2b00      	cmp	r3, #0
      70:	d00c      	beq.n	8c <recv_raw+0x8c>
      if (pbuf_copy(q, p) != ERR_OK) {
      72:	6af8      	ldr	r0, [r7, #44]	; 0x2c
      74:	6879      	ldr	r1, [r7, #4]
      76:	f7ff fffe 	bl	0 <pbuf_copy>
			76: R_ARM_THM_CALL	pbuf_copy
      7a:	4603      	mov	r3, r0
      7c:	2b00      	cmp	r3, #0
      7e:	d005      	beq.n	8c <recv_raw+0x8c>
        pbuf_free(q);
      80:	6af8      	ldr	r0, [r7, #44]	; 0x2c
      82:	f7ff fffe 	bl	0 <pbuf_free>
			82: R_ARM_THM_CALL	pbuf_free
        q = NULL;
      86:	f04f 0300 	mov.w	r3, #0
      8a:	62fb      	str	r3, [r7, #44]	; 0x2c
      }
    }

    if (q != NULL) {
      8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
      8e:	2b00      	cmp	r3, #0
      90:	d04a      	beq.n	128 <recv_raw+0x128>
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
      92:	f04f 0006 	mov.w	r0, #6
      96:	f7ff fffe 	bl	0 <memp_malloc>
			96: R_ARM_THM_CALL	memp_malloc
      9a:	4603      	mov	r3, r0
      9c:	61fb      	str	r3, [r7, #28]
      if (buf == NULL) {
      9e:	69fb      	ldr	r3, [r7, #28]
      a0:	2b00      	cmp	r3, #0
      a2:	d105      	bne.n	b0 <recv_raw+0xb0>
        pbuf_free(q);
      a4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
      a6:	f7ff fffe 	bl	0 <pbuf_free>
			a6: R_ARM_THM_CALL	pbuf_free
        return 0;
      aa:	f04f 0300 	mov.w	r3, #0
      ae:	e03d      	b.n	12c <recv_raw+0x12c>
      }

      buf->p = q;
      b0:	69fb      	ldr	r3, [r7, #28]
      b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
      b4:	601a      	str	r2, [r3, #0]
      buf->ptr = q;
      b6:	69fb      	ldr	r3, [r7, #28]
      b8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
      ba:	605a      	str	r2, [r3, #4]
      ip_addr_copy(buf->addr, *ip_current_src_addr());
      bc:	4b1e      	ldr	r3, [pc, #120]	; (138 <recv_raw+0x138>)
      be:	681a      	ldr	r2, [r3, #0]
      c0:	69fb      	ldr	r3, [r7, #28]
      c2:	609a      	str	r2, [r3, #8]
      buf->port = pcb->protocol;
      c4:	68bb      	ldr	r3, [r7, #8]
      c6:	7c1b      	ldrb	r3, [r3, #16]
      c8:	461a      	mov	r2, r3
      ca:	69fb      	ldr	r3, [r7, #28]
      cc:	819a      	strh	r2, [r3, #12]

      len = q->tot_len;
      ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
      d0:	891b      	ldrh	r3, [r3, #8]
      d2:	837b      	strh	r3, [r7, #26]
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
      d4:	6abb      	ldr	r3, [r7, #40]	; 0x28
      d6:	f103 0314 	add.w	r3, r3, #20
      da:	4618      	mov	r0, r3
      dc:	69f9      	ldr	r1, [r7, #28]
      de:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			de: R_ARM_THM_CALL	sys_mbox_trypost
      e2:	4603      	mov	r3, r0
      e4:	2b00      	cmp	r3, #0
      e6:	d005      	beq.n	f4 <recv_raw+0xf4>
        netbuf_delete(buf);
      e8:	69f8      	ldr	r0, [r7, #28]
      ea:	f7ff fffe 	bl	0 <netbuf_delete>
			ea: R_ARM_THM_CALL	netbuf_delete
        return 0;
      ee:	f04f 0300 	mov.w	r3, #0
      f2:	e01b      	b.n	3a <sys_arch_protect+0x3a>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
      f4:	f7ff fffe 	bl	0 <sys_arch_protect>
			f4: R_ARM_THM_CALL	sys_arch_protect
      f8:	6178      	str	r0, [r7, #20]
      fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
      fc:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
      fe:	b29a      	uxth	r2, r3
     100:	8b7b      	ldrh	r3, [r7, #26]
     102:	18d3      	adds	r3, r2, r3
     104:	b29b      	uxth	r3, r3
     106:	b29a      	uxth	r2, r3
     108:	6abb      	ldr	r3, [r7, #40]	; 0x28
     10a:	859a      	strh	r2, [r3, #44]	; 0x2c
     10c:	6978      	ldr	r0, [r7, #20]
     10e:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			10e: R_ARM_THM_CALL	sys_arch_unprotect
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
     112:	6abb      	ldr	r3, [r7, #40]	; 0x28
     114:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     116:	2b00      	cmp	r3, #0
     118:	d006      	beq.n	128 <recv_raw+0x128>
     11a:	6abb      	ldr	r3, [r7, #40]	; 0x28
     11c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     11e:	8b7a      	ldrh	r2, [r7, #26]
     120:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     122:	f04f 0100 	mov.w	r1, #0
     126:	4798      	blx	r3
      }
    }
  }

  return 0; /* do not eat the packet */
     128:	f04f 0300 	mov.w	r3, #0
}
     12c:	4618      	mov	r0, r3
     12e:	f107 0730 	add.w	r7, r7, #48	; 0x30
     132:	46bd      	mov	sp, r7
     134:	bd80      	pop	{r7, pc}
     136:	bf00      	nop
     138:	00000000 	.word	0x00000000
			138: R_ARM_ABS32	current_iphdr_src

0000013c <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   ip_addr_t *addr, u16_t port)
{
     13c:	b580      	push	{r7, lr}
     13e:	b08c      	sub	sp, #48	; 0x30
     140:	af00      	add	r7, sp, #0
     142:	60f8      	str	r0, [r7, #12]
     144:	60b9      	str	r1, [r7, #8]
     146:	607a      	str	r2, [r7, #4]
     148:	603b      	str	r3, [r7, #0]
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
     14a:	68fb      	ldr	r3, [r7, #12]
     14c:	62fb      	str	r3, [r7, #44]	; 0x2c
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);

#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
     14e:	f7ff fffe 	bl	0 <sys_arch_protect>
			14e: R_ARM_THM_CALL	sys_arch_protect
     152:	62b8      	str	r0, [r7, #40]	; 0x28
     154:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     156:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     158:	b21b      	sxth	r3, r3
     15a:	627b      	str	r3, [r7, #36]	; 0x24
     15c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     15e:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			15e: R_ARM_THM_CALL	sys_arch_unprotect
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
     162:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     164:	2b00      	cmp	r3, #0
     166:	d011      	beq.n	18c <recv_udp+0x50>
     168:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     16a:	f103 0314 	add.w	r3, r3, #20
     16e:	4618      	mov	r0, r3
     170:	f7ff fffe 	bl	0 <sys_mbox_valid>
			170: R_ARM_THM_CALL	sys_mbox_valid
     174:	4603      	mov	r3, r0
     176:	2b00      	cmp	r3, #0
     178:	d008      	beq.n	18c <recv_udp+0x50>
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
     17a:	687b      	ldr	r3, [r7, #4]
     17c:	891b      	ldrh	r3, [r3, #8]
     17e:	461a      	mov	r2, r3
     180:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     182:	18d2      	adds	r2, r2, r3
     184:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     186:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  conn = (struct netconn *)arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);

#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
     188:	429a      	cmp	r2, r3
     18a:	dd03      	ble.n	194 <recv_udp+0x58>
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
     18c:	6878      	ldr	r0, [r7, #4]
     18e:	f7ff fffe 	bl	0 <pbuf_free>
			18e: R_ARM_THM_CALL	pbuf_free
    return;
     192:	e05c      	b.n	24e <recv_udp+0x112>
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
     194:	f04f 0006 	mov.w	r0, #6
     198:	f7ff fffe 	bl	0 <memp_malloc>
			198: R_ARM_THM_CALL	memp_malloc
     19c:	4603      	mov	r3, r0
     19e:	623b      	str	r3, [r7, #32]
  if (buf == NULL) {
     1a0:	6a3b      	ldr	r3, [r7, #32]
     1a2:	2b00      	cmp	r3, #0
     1a4:	d103      	bne.n	1ae <recv_udp+0x72>
    pbuf_free(p);
     1a6:	6878      	ldr	r0, [r7, #4]
     1a8:	f7ff fffe 	bl	0 <pbuf_free>
			1a8: R_ARM_THM_CALL	pbuf_free
    return;
     1ac:	e04f      	b.n	24e <recv_udp+0x112>
  } else {
    buf->p = p;
     1ae:	6a3b      	ldr	r3, [r7, #32]
     1b0:	687a      	ldr	r2, [r7, #4]
     1b2:	601a      	str	r2, [r3, #0]
    buf->ptr = p;
     1b4:	6a3b      	ldr	r3, [r7, #32]
     1b6:	687a      	ldr	r2, [r7, #4]
     1b8:	605a      	str	r2, [r3, #4]
    ip_addr_set(&buf->addr, addr);
     1ba:	683b      	ldr	r3, [r7, #0]
     1bc:	2b00      	cmp	r3, #0
     1be:	d002      	beq.n	1c6 <recv_udp+0x8a>
     1c0:	683b      	ldr	r3, [r7, #0]
     1c2:	681b      	ldr	r3, [r3, #0]
     1c4:	e001      	b.n	1ca <recv_udp+0x8e>
     1c6:	f04f 0300 	mov.w	r3, #0
     1ca:	6a3a      	ldr	r2, [r7, #32]
     1cc:	6093      	str	r3, [r2, #8]
    buf->port = port;
     1ce:	6a3b      	ldr	r3, [r7, #32]
     1d0:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
     1d2:	819a      	strh	r2, [r3, #12]
#if LWIP_NETBUF_RECVINFO
    {
      const struct ip_hdr* iphdr = ip_current_header();
     1d4:	4b20      	ldr	r3, [pc, #128]	; (258 <recv_udp+0x11c>)
     1d6:	681b      	ldr	r3, [r3, #0]
     1d8:	61fb      	str	r3, [r7, #28]
      /* get the UDP header - always in the first pbuf, ensured by udp_input */
      const struct udp_hdr* udphdr = (void*)(((char*)iphdr) + IPH_LEN(iphdr));
     1da:	69fa      	ldr	r2, [r7, #28]
     1dc:	69fb      	ldr	r3, [r7, #28]
     1de:	885b      	ldrh	r3, [r3, #2]
     1e0:	b29b      	uxth	r3, r3
     1e2:	18d3      	adds	r3, r2, r3
     1e4:	61bb      	str	r3, [r7, #24]
#if LWIP_CHECKSUM_ON_COPY
      buf->flags = NETBUF_FLAG_DESTADDR;
#endif /* LWIP_CHECKSUM_ON_COPY */
      ip_addr_set(&buf->toaddr, ip_current_dest_addr());
     1e6:	4b1d      	ldr	r3, [pc, #116]	; (25c <recv_udp+0x120>)
     1e8:	681a      	ldr	r2, [r3, #0]
     1ea:	6a3b      	ldr	r3, [r7, #32]
     1ec:	611a      	str	r2, [r3, #16]
      buf->toport_chksum = udphdr->dest;
     1ee:	69bb      	ldr	r3, [r7, #24]
     1f0:	885b      	ldrh	r3, [r3, #2]
     1f2:	b29a      	uxth	r2, r3
     1f4:	6a3b      	ldr	r3, [r7, #32]
     1f6:	81da      	strh	r2, [r3, #14]
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
     1f8:	687b      	ldr	r3, [r7, #4]
     1fa:	891b      	ldrh	r3, [r3, #8]
     1fc:	82fb      	strh	r3, [r7, #22]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
     1fe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     200:	f103 0314 	add.w	r3, r3, #20
     204:	4618      	mov	r0, r3
     206:	6a39      	ldr	r1, [r7, #32]
     208:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			208: R_ARM_THM_CALL	sys_mbox_trypost
     20c:	4603      	mov	r3, r0
     20e:	2b00      	cmp	r3, #0
     210:	d003      	beq.n	21a <recv_udp+0xde>
    netbuf_delete(buf);
     212:	6a38      	ldr	r0, [r7, #32]
     214:	f7ff fffe 	bl	0 <netbuf_delete>
			214: R_ARM_THM_CALL	netbuf_delete
    return;
     218:	e019      	b.n	36 <sys_arch_protect+0x36>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
     21a:	f7ff fffe 	bl	0 <sys_arch_protect>
			21a: R_ARM_THM_CALL	sys_arch_protect
     21e:	6138      	str	r0, [r7, #16]
     220:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     222:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     224:	b29a      	uxth	r2, r3
     226:	8afb      	ldrh	r3, [r7, #22]
     228:	18d3      	adds	r3, r2, r3
     22a:	b29b      	uxth	r3, r3
     22c:	b29a      	uxth	r2, r3
     22e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     230:	859a      	strh	r2, [r3, #44]	; 0x2c
     232:	6938      	ldr	r0, [r7, #16]
     234:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			234: R_ARM_THM_CALL	sys_arch_unprotect
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
     238:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     23a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     23c:	2b00      	cmp	r3, #0
     23e:	d006      	beq.n	24e <recv_udp+0x112>
     240:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     242:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     244:	8afa      	ldrh	r2, [r7, #22]
     246:	6af8      	ldr	r0, [r7, #44]	; 0x2c
     248:	f04f 0100 	mov.w	r1, #0
     24c:	4798      	blx	r3
  }
}
     24e:	f107 0730 	add.w	r7, r7, #48	; 0x30
     252:	46bd      	mov	sp, r7
     254:	bd80      	pop	{r7, pc}
     256:	bf00      	nop
	...
			258: R_ARM_ABS32	current_header
			25c: R_ARM_ABS32	current_iphdr_dest

00000260 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
     260:	b580      	push	{r7, lr}
     262:	b088      	sub	sp, #32
     264:	af00      	add	r7, sp, #0
     266:	60f8      	str	r0, [r7, #12]
     268:	60b9      	str	r1, [r7, #8]
     26a:	607a      	str	r2, [r7, #4]
     26c:	70fb      	strb	r3, [r7, #3]
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = (struct netconn *)arg;
     26e:	68fb      	ldr	r3, [r7, #12]
     270:	61bb      	str	r3, [r7, #24]
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if (conn == NULL) {
     272:	69bb      	ldr	r3, [r7, #24]
     274:	2b00      	cmp	r3, #0
     276:	d102      	bne.n	27e <recv_tcp+0x1e>
    return ERR_VAL;
     278:	f04f 03fa 	mov.w	r3, #250	; 0xfa
     27c:	e059      	b.n	332 <recv_tcp+0xd2>
  }
  if (!sys_mbox_valid(&conn->recvmbox)) {
     27e:	69bb      	ldr	r3, [r7, #24]
     280:	f103 0314 	add.w	r3, r3, #20
     284:	4618      	mov	r0, r3
     286:	f7ff fffe 	bl	0 <sys_mbox_valid>
			286: R_ARM_THM_CALL	sys_mbox_valid
     28a:	4603      	mov	r3, r0
     28c:	2b00      	cmp	r3, #0
     28e:	d10e      	bne.n	2ae <recv_tcp+0x4e>
    /* recvmbox already deleted */
    if (p != NULL) {
     290:	687b      	ldr	r3, [r7, #4]
     292:	2b00      	cmp	r3, #0
     294:	d008      	beq.n	2a8 <recv_tcp+0x48>
      tcp_recved(pcb, p->tot_len);
     296:	687b      	ldr	r3, [r7, #4]
     298:	891b      	ldrh	r3, [r3, #8]
     29a:	68b8      	ldr	r0, [r7, #8]
     29c:	4619      	mov	r1, r3
     29e:	f7ff fffe 	bl	0 <tcp_recved>
			29e: R_ARM_THM_CALL	tcp_recved
      pbuf_free(p);
     2a2:	6878      	ldr	r0, [r7, #4]
     2a4:	f7ff fffe 	bl	0 <pbuf_free>
			2a4: R_ARM_THM_CALL	pbuf_free
    }
    return ERR_OK;
     2a8:	f04f 0300 	mov.w	r3, #0
     2ac:	e041      	b.n	86 <sys_arch_protect+0x86>
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  NETCONN_SET_SAFE_ERR(conn, err);
     2ae:	f7ff fffe 	bl	0 <sys_arch_protect>
			2ae: R_ARM_THM_CALL	sys_arch_protect
     2b2:	6178      	str	r0, [r7, #20]
     2b4:	69bb      	ldr	r3, [r7, #24]
     2b6:	7a1b      	ldrb	r3, [r3, #8]
     2b8:	b25b      	sxtb	r3, r3
     2ba:	f113 0f09 	cmn.w	r3, #9
     2be:	db02      	blt.n	2c6 <recv_tcp+0x66>
     2c0:	69bb      	ldr	r3, [r7, #24]
     2c2:	78fa      	ldrb	r2, [r7, #3]
     2c4:	721a      	strb	r2, [r3, #8]
     2c6:	6978      	ldr	r0, [r7, #20]
     2c8:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			2c8: R_ARM_THM_CALL	sys_arch_unprotect

  if (p != NULL) {
     2cc:	687b      	ldr	r3, [r7, #4]
     2ce:	2b00      	cmp	r3, #0
     2d0:	d003      	beq.n	2da <recv_tcp+0x7a>
    len = p->tot_len;
     2d2:	687b      	ldr	r3, [r7, #4]
     2d4:	891b      	ldrh	r3, [r3, #8]
     2d6:	83fb      	strh	r3, [r7, #30]
     2d8:	e002      	b.n	2e0 <recv_tcp+0x80>
  } else {
    len = 0;
     2da:	f04f 0300 	mov.w	r3, #0
     2de:	83fb      	strh	r3, [r7, #30]
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
     2e0:	69bb      	ldr	r3, [r7, #24]
     2e2:	f103 0314 	add.w	r3, r3, #20
     2e6:	4618      	mov	r0, r3
     2e8:	6879      	ldr	r1, [r7, #4]
     2ea:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			2ea: R_ARM_THM_CALL	sys_mbox_trypost
     2ee:	4603      	mov	r3, r0
     2f0:	2b00      	cmp	r3, #0
     2f2:	d002      	beq.n	2fa <recv_tcp+0x9a>
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
     2f4:	f04f 03ff 	mov.w	r3, #255	; 0xff
     2f8:	e01b      	b.n	3a <sys_arch_protect+0x3a>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
     2fa:	f7ff fffe 	bl	0 <sys_arch_protect>
			2fa: R_ARM_THM_CALL	sys_arch_protect
     2fe:	6138      	str	r0, [r7, #16]
     300:	69bb      	ldr	r3, [r7, #24]
     302:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
     304:	b29a      	uxth	r2, r3
     306:	8bfb      	ldrh	r3, [r7, #30]
     308:	18d3      	adds	r3, r2, r3
     30a:	b29b      	uxth	r3, r3
     30c:	b29a      	uxth	r2, r3
     30e:	69bb      	ldr	r3, [r7, #24]
     310:	859a      	strh	r2, [r3, #44]	; 0x2c
     312:	6938      	ldr	r0, [r7, #16]
     314:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			314: R_ARM_THM_CALL	sys_arch_unprotect
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
     318:	69bb      	ldr	r3, [r7, #24]
     31a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     31c:	2b00      	cmp	r3, #0
     31e:	d006      	beq.n	32e <recv_tcp+0xce>
     320:	69bb      	ldr	r3, [r7, #24]
     322:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     324:	8bfa      	ldrh	r2, [r7, #30]
     326:	69b8      	ldr	r0, [r7, #24]
     328:	f04f 0100 	mov.w	r1, #0
     32c:	4798      	blx	r3
  }

  return ERR_OK;
     32e:	f04f 0300 	mov.w	r3, #0
     332:	b25b      	sxtb	r3, r3
}
     334:	4618      	mov	r0, r3
     336:	f107 0720 	add.w	r7, r7, #32
     33a:	46bd      	mov	sp, r7
     33c:	bd80      	pop	{r7, pc}
     33e:	bf00      	nop

00000340 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
     340:	b580      	push	{r7, lr}
     342:	b084      	sub	sp, #16
     344:	af00      	add	r7, sp, #0
     346:	6078      	str	r0, [r7, #4]
     348:	6039      	str	r1, [r7, #0]
  struct netconn *conn = (struct netconn *)arg;
     34a:	687b      	ldr	r3, [r7, #4]
     34c:	60fb      	str	r3, [r7, #12]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
     34e:	68fb      	ldr	r3, [r7, #12]
     350:	785b      	ldrb	r3, [r3, #1]
     352:	2b01      	cmp	r3, #1
     354:	d103      	bne.n	35e <poll_tcp+0x1e>
    do_writemore(conn);
     356:	68f8      	ldr	r0, [r7, #12]
     358:	f000 fff2 	bl	1340 <do_writemore>
     35c:	e006      	b.n	36c <poll_tcp+0x2c>
  } else if (conn->state == NETCONN_CLOSE) {
     35e:	68fb      	ldr	r3, [r7, #12]
     360:	785b      	ldrb	r3, [r3, #1]
     362:	2b04      	cmp	r3, #4
     364:	d102      	bne.n	36c <poll_tcp+0x2c>
    do_close_internal(conn);
     366:	68f8      	ldr	r0, [r7, #12]
     368:	f000 fb6e 	bl	a48 <do_close_internal>
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
     36c:	68fb      	ldr	r3, [r7, #12]
     36e:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     372:	f003 0310 	and.w	r3, r3, #16
     376:	2b00      	cmp	r3, #0
     378:	d026      	beq.n	3c8 <poll_tcp+0x88>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
     37a:	68fb      	ldr	r3, [r7, #12]
     37c:	685b      	ldr	r3, [r3, #4]
     37e:	2b00      	cmp	r3, #0
     380:	d022      	beq.n	3c8 <poll_tcp+0x88>
     382:	68fb      	ldr	r3, [r7, #12]
     384:	685b      	ldr	r3, [r3, #4]
     386:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
     38a:	f240 53dc 	movw	r3, #1500	; 0x5dc
     38e:	429a      	cmp	r2, r3
     390:	d91a      	bls.n	3c8 <poll_tcp+0x88>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
     392:	68fb      	ldr	r3, [r7, #12]
     394:	685b      	ldr	r3, [r3, #4]
     396:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
     39a:	2b04      	cmp	r3, #4
     39c:	d814      	bhi.n	3c8 <poll_tcp+0x88>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
     39e:	68fb      	ldr	r3, [r7, #12]
     3a0:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     3a4:	f023 0310 	bic.w	r3, r3, #16
     3a8:	b2da      	uxtb	r2, r3
     3aa:	68fb      	ldr	r3, [r7, #12]
     3ac:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
     3b0:	68fb      	ldr	r3, [r7, #12]
     3b2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     3b4:	2b00      	cmp	r3, #0
     3b6:	d007      	beq.n	3c8 <poll_tcp+0x88>
     3b8:	68fb      	ldr	r3, [r7, #12]
     3ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     3bc:	68f8      	ldr	r0, [r7, #12]
     3be:	f04f 0102 	mov.w	r1, #2
     3c2:	f04f 0200 	mov.w	r2, #0
     3c6:	4798      	blx	r3
    }
  }

  return ERR_OK;
     3c8:	f04f 0300 	mov.w	r3, #0
     3cc:	b25b      	sxtb	r3, r3
}
     3ce:	4618      	mov	r0, r3
     3d0:	f107 0710 	add.w	r7, r7, #16
     3d4:	46bd      	mov	sp, r7
     3d6:	bd80      	pop	{r7, pc}

000003d8 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
     3d8:	b580      	push	{r7, lr}
     3da:	b086      	sub	sp, #24
     3dc:	af00      	add	r7, sp, #0
     3de:	60f8      	str	r0, [r7, #12]
     3e0:	60b9      	str	r1, [r7, #8]
     3e2:	4613      	mov	r3, r2
     3e4:	80fb      	strh	r3, [r7, #6]
  struct netconn *conn = (struct netconn *)arg;
     3e6:	68fb      	ldr	r3, [r7, #12]
     3e8:	617b      	str	r3, [r7, #20]

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
     3ea:	697b      	ldr	r3, [r7, #20]
     3ec:	785b      	ldrb	r3, [r3, #1]
     3ee:	2b01      	cmp	r3, #1
     3f0:	d103      	bne.n	3fa <sent_tcp+0x22>
    do_writemore(conn);
     3f2:	6978      	ldr	r0, [r7, #20]
     3f4:	f000 ffa4 	bl	1340 <do_writemore>
     3f8:	e006      	b.n	408 <sent_tcp+0x30>
  } else if (conn->state == NETCONN_CLOSE) {
     3fa:	697b      	ldr	r3, [r7, #20]
     3fc:	785b      	ldrb	r3, [r3, #1]
     3fe:	2b04      	cmp	r3, #4
     400:	d102      	bne.n	408 <sent_tcp+0x30>
    do_close_internal(conn);
     402:	6978      	ldr	r0, [r7, #20]
     404:	f000 fb20 	bl	a48 <do_close_internal>
  }

  if (conn) {
     408:	697b      	ldr	r3, [r7, #20]
     40a:	2b00      	cmp	r3, #0
     40c:	d025      	beq.n	45a <sent_tcp+0x82>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
     40e:	697b      	ldr	r3, [r7, #20]
     410:	685b      	ldr	r3, [r3, #4]
     412:	2b00      	cmp	r3, #0
     414:	d021      	beq.n	45a <sent_tcp+0x82>
     416:	697b      	ldr	r3, [r7, #20]
     418:	685b      	ldr	r3, [r3, #4]
     41a:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
     41e:	f240 53dc 	movw	r3, #1500	; 0x5dc
     422:	429a      	cmp	r2, r3
     424:	d919      	bls.n	45a <sent_tcp+0x82>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
     426:	697b      	ldr	r3, [r7, #20]
     428:	685b      	ldr	r3, [r3, #4]
     42a:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
  }

  if (conn) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
     42e:	2b04      	cmp	r3, #4
     430:	d813      	bhi.n	45a <sent_tcp+0x82>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
     432:	697b      	ldr	r3, [r7, #20]
     434:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     438:	f023 0310 	bic.w	r3, r3, #16
     43c:	b2da      	uxtb	r2, r3
     43e:	697b      	ldr	r3, [r7, #20]
     440:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
     444:	697b      	ldr	r3, [r7, #20]
     446:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     448:	2b00      	cmp	r3, #0
     44a:	d006      	beq.n	45a <sent_tcp+0x82>
     44c:	697b      	ldr	r3, [r7, #20]
     44e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     450:	88fa      	ldrh	r2, [r7, #6]
     452:	6978      	ldr	r0, [r7, #20]
     454:	f04f 0102 	mov.w	r1, #2
     458:	4798      	blx	r3
    }
  }
  
  return ERR_OK;
     45a:	f04f 0300 	mov.w	r3, #0
     45e:	b25b      	sxtb	r3, r3
}
     460:	4618      	mov	r0, r3
     462:	f107 0718 	add.w	r7, r7, #24
     466:	46bd      	mov	sp, r7
     468:	bd80      	pop	{r7, pc}
     46a:	bf00      	nop

0000046c <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
     46c:	b580      	push	{r7, lr}
     46e:	b086      	sub	sp, #24
     470:	af00      	add	r7, sp, #0
     472:	6078      	str	r0, [r7, #4]
     474:	460b      	mov	r3, r1
     476:	70fb      	strb	r3, [r7, #3]
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
     478:	687b      	ldr	r3, [r7, #4]
     47a:	617b      	str	r3, [r7, #20]
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  conn->pcb.tcp = NULL;
     47c:	697b      	ldr	r3, [r7, #20]
     47e:	f04f 0200 	mov.w	r2, #0
     482:	605a      	str	r2, [r3, #4]

  /* no check since this is always fatal! */
  SYS_ARCH_PROTECT(lev);
     484:	f7ff fffe 	bl	0 <sys_arch_protect>
			484: R_ARM_THM_CALL	sys_arch_protect
     488:	6138      	str	r0, [r7, #16]
  conn->last_err = err;
     48a:	697b      	ldr	r3, [r7, #20]
     48c:	78fa      	ldrb	r2, [r7, #3]
     48e:	721a      	strb	r2, [r3, #8]
  SYS_ARCH_UNPROTECT(lev);
     490:	6938      	ldr	r0, [r7, #16]
     492:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			492: R_ARM_THM_CALL	sys_arch_unprotect

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
     496:	697b      	ldr	r3, [r7, #20]
     498:	785b      	ldrb	r3, [r3, #1]
     49a:	73fb      	strb	r3, [r7, #15]
  conn->state = NETCONN_NONE;
     49c:	697b      	ldr	r3, [r7, #20]
     49e:	f04f 0200 	mov.w	r2, #0
     4a2:	705a      	strb	r2, [r3, #1]

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
     4a4:	697b      	ldr	r3, [r7, #20]
     4a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     4a8:	2b00      	cmp	r3, #0
     4aa:	d007      	beq.n	4bc <err_tcp+0x50>
     4ac:	697b      	ldr	r3, [r7, #20]
     4ae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     4b0:	6978      	ldr	r0, [r7, #20]
     4b2:	f04f 0104 	mov.w	r1, #4
     4b6:	f04f 0200 	mov.w	r2, #0
     4ba:	4798      	blx	r3
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
     4bc:	697b      	ldr	r3, [r7, #20]
     4be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     4c0:	2b00      	cmp	r3, #0
     4c2:	d007      	beq.n	4d4 <err_tcp+0x68>
     4c4:	697b      	ldr	r3, [r7, #20]
     4c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     4c8:	6978      	ldr	r0, [r7, #20]
     4ca:	f04f 0100 	mov.w	r1, #0
     4ce:	f04f 0200 	mov.w	r2, #0
     4d2:	4798      	blx	r3
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
     4d4:	697b      	ldr	r3, [r7, #20]
     4d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     4d8:	2b00      	cmp	r3, #0
     4da:	d007      	beq.n	4ec <err_tcp+0x80>
     4dc:	697b      	ldr	r3, [r7, #20]
     4de:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     4e0:	6978      	ldr	r0, [r7, #20]
     4e2:	f04f 0102 	mov.w	r1, #2
     4e6:	f04f 0200 	mov.w	r2, #0
     4ea:	4798      	blx	r3

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
     4ec:	697b      	ldr	r3, [r7, #20]
     4ee:	f103 0314 	add.w	r3, r3, #20
     4f2:	4618      	mov	r0, r3
     4f4:	f7ff fffe 	bl	0 <sys_mbox_valid>
			4f4: R_ARM_THM_CALL	sys_mbox_valid
     4f8:	4603      	mov	r3, r0
     4fa:	2b00      	cmp	r3, #0
     4fc:	d007      	beq.n	50e <err_tcp+0xa2>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
     4fe:	697b      	ldr	r3, [r7, #20]
     500:	f103 0314 	add.w	r3, r3, #20
     504:	4618      	mov	r0, r3
     506:	f04f 0100 	mov.w	r1, #0
     50a:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			50a: R_ARM_THM_CALL	sys_mbox_trypost
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
     50e:	697b      	ldr	r3, [r7, #20]
     510:	f103 031c 	add.w	r3, r3, #28
     514:	4618      	mov	r0, r3
     516:	f7ff fffe 	bl	0 <sys_mbox_valid>
			516: R_ARM_THM_CALL	sys_mbox_valid
     51a:	4603      	mov	r3, r0
     51c:	2b00      	cmp	r3, #0
     51e:	d007      	beq.n	530 <err_tcp+0xc4>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
     520:	697b      	ldr	r3, [r7, #20]
     522:	f103 031c 	add.w	r3, r3, #28
     526:	4618      	mov	r0, r3
     528:	f04f 0100 	mov.w	r1, #0
     52c:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			52c: R_ARM_THM_CALL	sys_mbox_trypost
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
     530:	7bfb      	ldrb	r3, [r7, #15]
     532:	2b01      	cmp	r3, #1
     534:	d005      	beq.n	542 <err_tcp+0xd6>
     536:	7bfb      	ldrb	r3, [r7, #15]
     538:	2b04      	cmp	r3, #4
     53a:	d002      	beq.n	542 <err_tcp+0xd6>
     53c:	7bfb      	ldrb	r3, [r7, #15]
     53e:	2b03      	cmp	r3, #3
     540:	d123      	bne.n	58a <err_tcp+0x11e>
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
     542:	697b      	ldr	r3, [r7, #20]
     544:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     548:	f003 0304 	and.w	r3, r3, #4
     54c:	2b00      	cmp	r3, #0
     54e:	bf0c      	ite	eq
     550:	2300      	moveq	r3, #0
     552:	2301      	movne	r3, #1
     554:	60bb      	str	r3, [r7, #8]
    SET_NONBLOCKING_CONNECT(conn, 0);
     556:	697b      	ldr	r3, [r7, #20]
     558:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     55c:	f023 0304 	bic.w	r3, r3, #4
     560:	b2da      	uxtb	r2, r3
     562:	697b      	ldr	r3, [r7, #20]
     564:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

    if (!was_nonblocking_connect) {
     568:	68bb      	ldr	r3, [r7, #8]
     56a:	2b00      	cmp	r3, #0
     56c:	d10d      	bne.n	58a <err_tcp+0x11e>
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
     56e:	697b      	ldr	r3, [r7, #20]
     570:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     572:	78fa      	ldrb	r2, [r7, #3]
     574:	711a      	strb	r2, [r3, #4]
      conn->current_msg = NULL;
     576:	697b      	ldr	r3, [r7, #20]
     578:	f04f 0200 	mov.w	r2, #0
     57c:	635a      	str	r2, [r3, #52]	; 0x34
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
     57e:	697b      	ldr	r3, [r7, #20]
     580:	f103 030c 	add.w	r3, r3, #12
     584:	4618      	mov	r0, r3
     586:	f7ff fffe 	bl	0 <sys_sem_signal>
			586: R_ARM_THM_CALL	sys_sem_signal
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
     58a:	f107 0718 	add.w	r7, r7, #24
     58e:	46bd      	mov	sp, r7
     590:	bd80      	pop	{r7, pc}
     592:	bf00      	nop

00000594 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
     594:	b580      	push	{r7, lr}
     596:	b084      	sub	sp, #16
     598:	af00      	add	r7, sp, #0
     59a:	6078      	str	r0, [r7, #4]
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
     59c:	687b      	ldr	r3, [r7, #4]
     59e:	685b      	ldr	r3, [r3, #4]
     5a0:	60fb      	str	r3, [r7, #12]
  tcp_arg(pcb, conn);
     5a2:	68f8      	ldr	r0, [r7, #12]
     5a4:	6879      	ldr	r1, [r7, #4]
     5a6:	f7ff fffe 	bl	0 <tcp_arg>
			5a6: R_ARM_THM_CALL	tcp_arg
  tcp_recv(pcb, recv_tcp);
     5aa:	68f8      	ldr	r0, [r7, #12]
     5ac:	490a      	ldr	r1, [pc, #40]	; (5d8 <setup_tcp+0x44>)
     5ae:	f7ff fffe 	bl	0 <tcp_recv>
			5ae: R_ARM_THM_CALL	tcp_recv
  tcp_sent(pcb, sent_tcp);
     5b2:	68f8      	ldr	r0, [r7, #12]
     5b4:	4909      	ldr	r1, [pc, #36]	; (5dc <setup_tcp+0x48>)
     5b6:	f7ff fffe 	bl	0 <tcp_sent>
			5b6: R_ARM_THM_CALL	tcp_sent
  tcp_poll(pcb, poll_tcp, 4);
     5ba:	68f8      	ldr	r0, [r7, #12]
     5bc:	4908      	ldr	r1, [pc, #32]	; (5e0 <setup_tcp+0x4c>)
     5be:	f04f 0204 	mov.w	r2, #4
     5c2:	f7ff fffe 	bl	0 <tcp_poll>
			5c2: R_ARM_THM_CALL	tcp_poll
  tcp_err(pcb, err_tcp);
     5c6:	68f8      	ldr	r0, [r7, #12]
     5c8:	4906      	ldr	r1, [pc, #24]	; (5e4 <setup_tcp+0x50>)
     5ca:	f7ff fffe 	bl	0 <tcp_err>
			5ca: R_ARM_THM_CALL	tcp_err
}
     5ce:	f107 0710 	add.w	r7, r7, #16
     5d2:	46bd      	mov	sp, r7
     5d4:	bd80      	pop	{r7, pc}
     5d6:	bf00      	nop
	...
			5d8: R_ARM_ABS32	recv_tcp
			5dc: R_ARM_ABS32	sent_tcp
			5e0: R_ARM_ABS32	poll_tcp
			5e4: R_ARM_ABS32	err_tcp

000005e8 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
     5e8:	b580      	push	{r7, lr}
     5ea:	b088      	sub	sp, #32
     5ec:	af00      	add	r7, sp, #0
     5ee:	60f8      	str	r0, [r7, #12]
     5f0:	60b9      	str	r1, [r7, #8]
     5f2:	4613      	mov	r3, r2
     5f4:	71fb      	strb	r3, [r7, #7]
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;
     5f6:	68fb      	ldr	r3, [r7, #12]
     5f8:	61fb      	str	r3, [r7, #28]

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
     5fa:	69fb      	ldr	r3, [r7, #28]
     5fc:	f103 031c 	add.w	r3, r3, #28
     600:	4618      	mov	r0, r3
     602:	f7ff fffe 	bl	0 <sys_mbox_valid>
			602: R_ARM_THM_CALL	sys_mbox_valid
     606:	4603      	mov	r3, r0
     608:	2b00      	cmp	r3, #0
     60a:	d102      	bne.n	612 <accept_function+0x2a>
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
     60c:	f04f 03fa 	mov.w	r3, #250	; 0xfa
     610:	e063      	b.n	6da <accept_function+0xf2>
  }

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
     612:	69fb      	ldr	r3, [r7, #28]
     614:	781a      	ldrb	r2, [r3, #0]
     616:	69fb      	ldr	r3, [r7, #28]
     618:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     61a:	4610      	mov	r0, r2
     61c:	4619      	mov	r1, r3
     61e:	f7ff fffe 	bl	810 <netconn_alloc>
			61e: R_ARM_THM_CALL	netconn_alloc
     622:	61b8      	str	r0, [r7, #24]
  if (newconn == NULL) {
     624:	69bb      	ldr	r3, [r7, #24]
     626:	2b00      	cmp	r3, #0
     628:	d102      	bne.n	630 <accept_function+0x48>
    return ERR_MEM;
     62a:	f04f 03ff 	mov.w	r3, #255	; 0xff
     62e:	e054      	b.n	6da <accept_function+0xf2>
  }
  newconn->pcb.tcp = newpcb;
     630:	69bb      	ldr	r3, [r7, #24]
     632:	68ba      	ldr	r2, [r7, #8]
     634:	605a      	str	r2, [r3, #4]
  setup_tcp(newconn);
     636:	69b8      	ldr	r0, [r7, #24]
     638:	f7ff ffac 	bl	594 <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
     63c:	69bb      	ldr	r3, [r7, #24]
     63e:	79fa      	ldrb	r2, [r7, #7]
     640:	721a      	strb	r2, [r3, #8]

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
     642:	69fb      	ldr	r3, [r7, #28]
     644:	f103 031c 	add.w	r3, r3, #28
     648:	4618      	mov	r0, r3
     64a:	69b9      	ldr	r1, [r7, #24]
     64c:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			64c: R_ARM_THM_CALL	sys_mbox_trypost
     650:	4603      	mov	r3, r0
     652:	2b00      	cmp	r3, #0
     654:	d033      	beq.n	6be <accept_function+0xd6>
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
     656:	69bb      	ldr	r3, [r7, #24]
     658:	685b      	ldr	r3, [r3, #4]
     65a:	617b      	str	r3, [r7, #20]
    tcp_arg(pcb, NULL);
     65c:	6978      	ldr	r0, [r7, #20]
     65e:	f04f 0100 	mov.w	r1, #0
     662:	f7ff fffe 	bl	0 <tcp_arg>
			662: R_ARM_THM_CALL	tcp_arg
    tcp_recv(pcb, NULL);
     666:	6978      	ldr	r0, [r7, #20]
     668:	f04f 0100 	mov.w	r1, #0
     66c:	f7ff fffe 	bl	0 <tcp_recv>
			66c: R_ARM_THM_CALL	tcp_recv
    tcp_sent(pcb, NULL);
     670:	6978      	ldr	r0, [r7, #20]
     672:	f04f 0100 	mov.w	r1, #0
     676:	f7ff fffe 	bl	0 <tcp_sent>
			676: R_ARM_THM_CALL	tcp_sent
    tcp_poll(pcb, NULL, 4);
     67a:	6978      	ldr	r0, [r7, #20]
     67c:	f04f 0100 	mov.w	r1, #0
     680:	f04f 0204 	mov.w	r2, #4
     684:	f7ff fffe 	bl	0 <tcp_poll>
			684: R_ARM_THM_CALL	tcp_poll
    tcp_err(pcb, NULL);
     688:	6978      	ldr	r0, [r7, #20]
     68a:	f04f 0100 	mov.w	r1, #0
     68e:	f7ff fffe 	bl	0 <tcp_err>
			68e: R_ARM_THM_CALL	tcp_err
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
     692:	69bb      	ldr	r3, [r7, #24]
     694:	f04f 0200 	mov.w	r2, #0
     698:	605a      	str	r2, [r3, #4]
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
     69a:	69bb      	ldr	r3, [r7, #24]
     69c:	f103 0314 	add.w	r3, r3, #20
     6a0:	4618      	mov	r0, r3
     6a2:	f7ff fffe 	bl	0 <sys_mbox_free>
			6a2: R_ARM_THM_CALL	sys_mbox_free
    sys_mbox_set_invalid(&newconn->recvmbox);
     6a6:	69bb      	ldr	r3, [r7, #24]
     6a8:	f103 0314 	add.w	r3, r3, #20
     6ac:	4618      	mov	r0, r3
     6ae:	f7ff fffe 	bl	0 <sys_mbox_set_invalid>
			6ae: R_ARM_THM_CALL	sys_mbox_set_invalid
    netconn_free(newconn);
     6b2:	69b8      	ldr	r0, [r7, #24]
     6b4:	f7ff fffe 	bl	8f4 <netconn_free>
			6b4: R_ARM_THM_CALL	netconn_free
    return ERR_MEM;
     6b8:	f04f 03ff 	mov.w	r3, #255	; 0xff
     6bc:	e00d      	b.n	6da <accept_function+0xf2>
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
     6be:	69fb      	ldr	r3, [r7, #28]
     6c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     6c2:	2b00      	cmp	r3, #0
     6c4:	d007      	beq.n	6d6 <accept_function+0xee>
     6c6:	69fb      	ldr	r3, [r7, #28]
     6c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     6ca:	69f8      	ldr	r0, [r7, #28]
     6cc:	f04f 0100 	mov.w	r1, #0
     6d0:	f04f 0200 	mov.w	r2, #0
     6d4:	4798      	blx	r3
  }

  return ERR_OK;
     6d6:	f04f 0300 	mov.w	r3, #0
     6da:	b25b      	sxtb	r3, r3
}
     6dc:	4618      	mov	r0, r3
     6de:	f107 0720 	add.w	r7, r7, #32
     6e2:	46bd      	mov	sp, r7
     6e4:	bd80      	pop	{r7, pc}
     6e6:	bf00      	nop

000006e8 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static void
pcb_new(struct api_msg_msg *msg)
{
     6e8:	b590      	push	{r4, r7, lr}
     6ea:	b083      	sub	sp, #12
     6ec:	af00      	add	r7, sp, #0
     6ee:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
     6f0:	687b      	ldr	r3, [r7, #4]
     6f2:	681b      	ldr	r3, [r3, #0]
     6f4:	781b      	ldrb	r3, [r3, #0]
     6f6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     6fa:	2b20      	cmp	r3, #32
     6fc:	d022      	beq.n	744 <pcb_new+0x5c>
     6fe:	2b40      	cmp	r3, #64	; 0x40
     700:	d002      	beq.n	708 <pcb_new+0x20>
     702:	2b10      	cmp	r3, #16
     704:	d044      	beq.n	790 <pcb_new+0xa8>
     706:	e059      	b.n	7bc <pcb_new+0xd4>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
     708:	687b      	ldr	r3, [r7, #4]
     70a:	681c      	ldr	r4, [r3, #0]
     70c:	687b      	ldr	r3, [r7, #4]
     70e:	7a1b      	ldrb	r3, [r3, #8]
     710:	4618      	mov	r0, r3
     712:	f7ff fffe 	bl	0 <raw_new>
			712: R_ARM_THM_CALL	raw_new
     716:	4603      	mov	r3, r0
     718:	6063      	str	r3, [r4, #4]
    if(msg->conn->pcb.raw == NULL) {
     71a:	687b      	ldr	r3, [r7, #4]
     71c:	681b      	ldr	r3, [r3, #0]
     71e:	685b      	ldr	r3, [r3, #4]
     720:	2b00      	cmp	r3, #0
     722:	d104      	bne.n	72e <pcb_new+0x46>
      msg->err = ERR_MEM;
     724:	687b      	ldr	r3, [r7, #4]
     726:	f04f 02ff 	mov.w	r2, #255	; 0xff
     72a:	711a      	strb	r2, [r3, #4]
      break;
     72c:	e04b      	b.n	7c6 <pcb_new+0xde>
    }
    raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
     72e:	687b      	ldr	r3, [r7, #4]
     730:	681b      	ldr	r3, [r3, #0]
     732:	685a      	ldr	r2, [r3, #4]
     734:	687b      	ldr	r3, [r7, #4]
     736:	681b      	ldr	r3, [r3, #0]
     738:	4610      	mov	r0, r2
     73a:	4925      	ldr	r1, [pc, #148]	; (7d0 <pcb_new+0xe8>)
     73c:	461a      	mov	r2, r3
     73e:	f7ff fffe 	bl	0 <raw_recv>
			73e: R_ARM_THM_CALL	raw_recv
    break;
     742:	e040      	b.n	7c6 <pcb_new+0xde>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new();
     744:	687b      	ldr	r3, [r7, #4]
     746:	681c      	ldr	r4, [r3, #0]
     748:	f7ff fffe 	bl	0 <udp_new>
			748: R_ARM_THM_CALL	udp_new
     74c:	4603      	mov	r3, r0
     74e:	6063      	str	r3, [r4, #4]
    if(msg->conn->pcb.udp == NULL) {
     750:	687b      	ldr	r3, [r7, #4]
     752:	681b      	ldr	r3, [r3, #0]
     754:	685b      	ldr	r3, [r3, #4]
     756:	2b00      	cmp	r3, #0
     758:	d104      	bne.n	764 <pcb_new+0x7c>
      msg->err = ERR_MEM;
     75a:	687b      	ldr	r3, [r7, #4]
     75c:	f04f 02ff 	mov.w	r2, #255	; 0xff
     760:	711a      	strb	r2, [r3, #4]
      break;
     762:	e030      	b.n	7c6 <pcb_new+0xde>
#if LWIP_UDPLITE
    if (msg->conn->type==NETCONN_UDPLITE) {
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
    }
#endif /* LWIP_UDPLITE */
    if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
     764:	687b      	ldr	r3, [r7, #4]
     766:	681b      	ldr	r3, [r3, #0]
     768:	781b      	ldrb	r3, [r3, #0]
     76a:	2b22      	cmp	r3, #34	; 0x22
     76c:	d105      	bne.n	77a <pcb_new+0x92>
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
     76e:	687b      	ldr	r3, [r7, #4]
     770:	681b      	ldr	r3, [r3, #0]
     772:	685b      	ldr	r3, [r3, #4]
     774:	f04f 0201 	mov.w	r2, #1
     778:	741a      	strb	r2, [r3, #16]
    }
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
     77a:	687b      	ldr	r3, [r7, #4]
     77c:	681b      	ldr	r3, [r3, #0]
     77e:	685a      	ldr	r2, [r3, #4]
     780:	687b      	ldr	r3, [r7, #4]
     782:	681b      	ldr	r3, [r3, #0]
     784:	4610      	mov	r0, r2
     786:	4913      	ldr	r1, [pc, #76]	; (7d4 <pcb_new+0xec>)
     788:	461a      	mov	r2, r3
     78a:	f7ff fffe 	bl	0 <udp_recv>
			78a: R_ARM_THM_CALL	udp_recv
    break;
     78e:	e01a      	b.n	7c6 <pcb_new+0xde>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
     790:	687b      	ldr	r3, [r7, #4]
     792:	681c      	ldr	r4, [r3, #0]
     794:	f7ff fffe 	bl	0 <tcp_new>
			794: R_ARM_THM_CALL	tcp_new
     798:	4603      	mov	r3, r0
     79a:	6063      	str	r3, [r4, #4]
    if(msg->conn->pcb.tcp == NULL) {
     79c:	687b      	ldr	r3, [r7, #4]
     79e:	681b      	ldr	r3, [r3, #0]
     7a0:	685b      	ldr	r3, [r3, #4]
     7a2:	2b00      	cmp	r3, #0
     7a4:	d104      	bne.n	7b0 <pcb_new+0xc8>
      msg->err = ERR_MEM;
     7a6:	687b      	ldr	r3, [r7, #4]
     7a8:	f04f 02ff 	mov.w	r2, #255	; 0xff
     7ac:	711a      	strb	r2, [r3, #4]
      break;
     7ae:	e00a      	b.n	7c6 <pcb_new+0xde>
    }
    setup_tcp(msg->conn);
     7b0:	687b      	ldr	r3, [r7, #4]
     7b2:	681b      	ldr	r3, [r3, #0]
     7b4:	4618      	mov	r0, r3
     7b6:	f7ff feed 	bl	594 <setup_tcp>
    break;
     7ba:	e004      	b.n	7c6 <pcb_new+0xde>
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
     7bc:	687b      	ldr	r3, [r7, #4]
     7be:	f04f 02fa 	mov.w	r2, #250	; 0xfa
     7c2:	711a      	strb	r2, [r3, #4]
    break;
     7c4:	bf00      	nop
  }
}
     7c6:	f107 070c 	add.w	r7, r7, #12
     7ca:	46bd      	mov	sp, r7
     7cc:	bd90      	pop	{r4, r7, pc}
     7ce:	bf00      	nop
	...
			7d0: R_ARM_ABS32	recv_raw
			7d4: R_ARM_ABS32	recv_udp

000007d8 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
     7d8:	b580      	push	{r7, lr}
     7da:	b082      	sub	sp, #8
     7dc:	af00      	add	r7, sp, #0
     7de:	6078      	str	r0, [r7, #4]
  msg->err = ERR_OK;
     7e0:	687b      	ldr	r3, [r7, #4]
     7e2:	f04f 0200 	mov.w	r2, #0
     7e6:	711a      	strb	r2, [r3, #4]
  if(msg->conn->pcb.tcp == NULL) {
     7e8:	687b      	ldr	r3, [r7, #4]
     7ea:	681b      	ldr	r3, [r3, #0]
     7ec:	685b      	ldr	r3, [r3, #4]
     7ee:	2b00      	cmp	r3, #0
     7f0:	d102      	bne.n	7f8 <do_newconn+0x20>
    pcb_new(msg);
     7f2:	6878      	ldr	r0, [r7, #4]
     7f4:	f7ff ff78 	bl	6e8 <pcb_new>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
     7f8:	687b      	ldr	r3, [r7, #4]
     7fa:	681b      	ldr	r3, [r3, #0]
     7fc:	f103 030c 	add.w	r3, r3, #12
     800:	4618      	mov	r0, r3
     802:	f7ff fffe 	bl	0 <sys_sem_signal>
			802: R_ARM_THM_CALL	sys_sem_signal
}
     806:	f107 0708 	add.w	r7, r7, #8
     80a:	46bd      	mov	sp, r7
     80c:	bd80      	pop	{r7, pc}
     80e:	bf00      	nop

00000810 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
     810:	b580      	push	{r7, lr}
     812:	b084      	sub	sp, #16
     814:	af00      	add	r7, sp, #0
     816:	4603      	mov	r3, r0
     818:	6039      	str	r1, [r7, #0]
     81a:	71fb      	strb	r3, [r7, #7]
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
     81c:	f04f 0007 	mov.w	r0, #7
     820:	f7ff fffe 	bl	0 <memp_malloc>
			820: R_ARM_THM_CALL	memp_malloc
     824:	4603      	mov	r3, r0
     826:	60fb      	str	r3, [r7, #12]
  if (conn == NULL) {
     828:	68fb      	ldr	r3, [r7, #12]
     82a:	2b00      	cmp	r3, #0
     82c:	d102      	bne.n	834 <netconn_alloc+0x24>
    return NULL;
     82e:	f04f 0300 	mov.w	r3, #0
     832:	e059      	b.n	8e8 <netconn_alloc+0xd8>
  }

  conn->last_err = ERR_OK;
     834:	68fb      	ldr	r3, [r7, #12]
     836:	f04f 0200 	mov.w	r2, #0
     83a:	721a      	strb	r2, [r3, #8]
  conn->type = t;
     83c:	68fb      	ldr	r3, [r7, #12]
     83e:	79fa      	ldrb	r2, [r7, #7]
     840:	701a      	strb	r2, [r3, #0]
  conn->pcb.tcp = NULL;
     842:	68fb      	ldr	r3, [r7, #12]
     844:	f04f 0200 	mov.w	r2, #0
     848:	605a      	str	r2, [r3, #4]

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
     84a:	f04f 0300 	mov.w	r3, #0
     84e:	60bb      	str	r3, [r7, #8]
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
     850:	68fb      	ldr	r3, [r7, #12]
     852:	f103 030c 	add.w	r3, r3, #12
     856:	4618      	mov	r0, r3
     858:	f04f 0100 	mov.w	r1, #0
     85c:	f7ff fffe 	bl	0 <sys_sem_new>
			85c: R_ARM_THM_CALL	sys_sem_new
     860:	4603      	mov	r3, r0
     862:	2b00      	cmp	r3, #0
     864:	d138      	bne.n	8d8 <netconn_alloc+0xc8>
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
     866:	68fb      	ldr	r3, [r7, #12]
     868:	f103 0314 	add.w	r3, r3, #20
     86c:	4618      	mov	r0, r3
     86e:	68b9      	ldr	r1, [r7, #8]
     870:	f7ff fffe 	bl	0 <sys_mbox_new>
			870: R_ARM_THM_CALL	sys_mbox_new
     874:	4603      	mov	r3, r0
     876:	2b00      	cmp	r3, #0
     878:	d006      	beq.n	888 <netconn_alloc+0x78>
    sys_sem_free(&conn->op_completed);
     87a:	68fb      	ldr	r3, [r7, #12]
     87c:	f103 030c 	add.w	r3, r3, #12
     880:	4618      	mov	r0, r3
     882:	f7ff fffe 	bl	0 <sys_sem_free>
			882: R_ARM_THM_CALL	sys_sem_free
    goto free_and_return;
     886:	e028      	b.n	8da <netconn_alloc+0xca>
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
     888:	68fb      	ldr	r3, [r7, #12]
     88a:	f103 031c 	add.w	r3, r3, #28
     88e:	4618      	mov	r0, r3
     890:	f7ff fffe 	bl	0 <sys_mbox_set_invalid>
			890: R_ARM_THM_CALL	sys_mbox_set_invalid
#endif
  conn->state        = NETCONN_NONE;
     894:	68fb      	ldr	r3, [r7, #12]
     896:	f04f 0200 	mov.w	r2, #0
     89a:	705a      	strb	r2, [r3, #1]
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
     89c:	68fb      	ldr	r3, [r7, #12]
     89e:	f04f 32ff 	mov.w	r2, #4294967295
     8a2:	625a      	str	r2, [r3, #36]	; 0x24
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
     8a4:	68fb      	ldr	r3, [r7, #12]
     8a6:	683a      	ldr	r2, [r7, #0]
     8a8:	639a      	str	r2, [r3, #56]	; 0x38
#if LWIP_TCP
  conn->current_msg  = NULL;
     8aa:	68fb      	ldr	r3, [r7, #12]
     8ac:	f04f 0200 	mov.w	r2, #0
     8b0:	635a      	str	r2, [r3, #52]	; 0x34
  conn->write_offset = 0;
     8b2:	68fb      	ldr	r3, [r7, #12]
     8b4:	f04f 0200 	mov.w	r2, #0
     8b8:	631a      	str	r2, [r3, #48]	; 0x30
#endif /* LWIP_SO_SNDTIMEO */
#if LWIP_SO_RCVTIMEO
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
     8ba:	68fb      	ldr	r3, [r7, #12]
     8bc:	f647 72ff 	movw	r2, #32767	; 0x7fff
     8c0:	629a      	str	r2, [r3, #40]	; 0x28
  conn->recv_avail   = 0;
     8c2:	68fb      	ldr	r3, [r7, #12]
     8c4:	f04f 0200 	mov.w	r2, #0
     8c8:	859a      	strh	r2, [r3, #44]	; 0x2c
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
     8ca:	68fb      	ldr	r3, [r7, #12]
     8cc:	f04f 0200 	mov.w	r2, #0
     8d0:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
  return conn;
     8d4:	68fb      	ldr	r3, [r7, #12]
     8d6:	e007      	b.n	8e8 <netconn_alloc+0xd8>
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    goto free_and_return;
     8d8:	bf00      	nop
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
     8da:	f04f 0007 	mov.w	r0, #7
     8de:	68f9      	ldr	r1, [r7, #12]
     8e0:	f7ff fffe 	bl	0 <memp_free>
			8e0: R_ARM_THM_CALL	memp_free
  return NULL;
     8e4:	f04f 0300 	mov.w	r3, #0
}
     8e8:	4618      	mov	r0, r3
     8ea:	f107 0710 	add.w	r7, r7, #16
     8ee:	46bd      	mov	sp, r7
     8f0:	bd80      	pop	{r7, pc}
     8f2:	bf00      	nop

000008f4 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
     8f4:	b580      	push	{r7, lr}
     8f6:	b082      	sub	sp, #8
     8f8:	af00      	add	r7, sp, #0
     8fa:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
     8fc:	687b      	ldr	r3, [r7, #4]
     8fe:	f103 0314 	add.w	r3, r3, #20
     902:	4618      	mov	r0, r3
     904:	f7ff fffe 	bl	0 <sys_mbox_valid>
			904: R_ARM_THM_CALL	sys_mbox_valid
    !sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
     908:	687b      	ldr	r3, [r7, #4]
     90a:	f103 031c 	add.w	r3, r3, #28
     90e:	4618      	mov	r0, r3
     910:	f7ff fffe 	bl	0 <sys_mbox_valid>
			910: R_ARM_THM_CALL	sys_mbox_valid
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
     914:	687b      	ldr	r3, [r7, #4]
     916:	f103 030c 	add.w	r3, r3, #12
     91a:	4618      	mov	r0, r3
     91c:	f7ff fffe 	bl	0 <sys_sem_free>
			91c: R_ARM_THM_CALL	sys_sem_free
  sys_sem_set_invalid(&conn->op_completed);
     920:	687b      	ldr	r3, [r7, #4]
     922:	f103 030c 	add.w	r3, r3, #12
     926:	4618      	mov	r0, r3
     928:	f7ff fffe 	bl	0 <sys_sem_set_invalid>
			928: R_ARM_THM_CALL	sys_sem_set_invalid

  memp_free(MEMP_NETCONN, conn);
     92c:	f04f 0007 	mov.w	r0, #7
     930:	6879      	ldr	r1, [r7, #4]
     932:	f7ff fffe 	bl	0 <memp_free>
			932: R_ARM_THM_CALL	memp_free
}
     936:	f107 0708 	add.w	r7, r7, #8
     93a:	46bd      	mov	sp, r7
     93c:	bd80      	pop	{r7, pc}
     93e:	bf00      	nop

00000940 <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
     940:	b580      	push	{r7, lr}
     942:	b086      	sub	sp, #24
     944:	af00      	add	r7, sp, #0
     946:	6078      	str	r0, [r7, #4]
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
     948:	687b      	ldr	r3, [r7, #4]
     94a:	f103 0314 	add.w	r3, r3, #20
     94e:	4618      	mov	r0, r3
     950:	f7ff fffe 	bl	0 <sys_mbox_valid>
			950: R_ARM_THM_CALL	sys_mbox_valid
     954:	4603      	mov	r3, r0
     956:	2b00      	cmp	r3, #0
     958:	d036      	beq.n	9c8 <netconn_drain+0x88>
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
     95a:	e01c      	b.n	996 <netconn_drain+0x56>
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
     95c:	687b      	ldr	r3, [r7, #4]
     95e:	781b      	ldrb	r3, [r3, #0]
     960:	2b10      	cmp	r3, #16
     962:	d114      	bne.n	98e <netconn_drain+0x4e>
        if(mem != NULL) {
     964:	68fb      	ldr	r3, [r7, #12]
     966:	2b00      	cmp	r3, #0
     968:	d015      	beq.n	996 <netconn_drain+0x56>
          p = (struct pbuf*)mem;
     96a:	68fb      	ldr	r3, [r7, #12]
     96c:	617b      	str	r3, [r7, #20]
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
     96e:	687b      	ldr	r3, [r7, #4]
     970:	685b      	ldr	r3, [r3, #4]
     972:	2b00      	cmp	r3, #0
     974:	d007      	beq.n	986 <netconn_drain+0x46>
            tcp_recved(conn->pcb.tcp, p->tot_len);
     976:	687b      	ldr	r3, [r7, #4]
     978:	685a      	ldr	r2, [r3, #4]
     97a:	697b      	ldr	r3, [r7, #20]
     97c:	891b      	ldrh	r3, [r3, #8]
     97e:	4610      	mov	r0, r2
     980:	4619      	mov	r1, r3
     982:	f7ff fffe 	bl	0 <tcp_recved>
			982: R_ARM_THM_CALL	tcp_recved
          }
          pbuf_free(p);
     986:	6978      	ldr	r0, [r7, #20]
     988:	f7ff fffe 	bl	0 <pbuf_free>
			988: R_ARM_THM_CALL	pbuf_free
     98c:	e003      	b.n	996 <netconn_drain+0x56>
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
     98e:	68fb      	ldr	r3, [r7, #12]
     990:	4618      	mov	r0, r3
     992:	f7ff fffe 	bl	0 <netbuf_delete>
			992: R_ARM_THM_CALL	netbuf_delete

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
     996:	687b      	ldr	r3, [r7, #4]
     998:	f103 0214 	add.w	r2, r3, #20
     99c:	f107 030c 	add.w	r3, r7, #12
     9a0:	4610      	mov	r0, r2
     9a2:	4619      	mov	r1, r3
     9a4:	f7ff fffe 	bl	0 <sys_arch_mbox_tryfetch>
			9a4: R_ARM_THM_CALL	sys_arch_mbox_tryfetch
     9a8:	4603      	mov	r3, r0
     9aa:	f1b3 3fff 	cmp.w	r3, #4294967295
     9ae:	d1d5      	bne.n	95c <netconn_drain+0x1c>
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(&conn->recvmbox);
     9b0:	687b      	ldr	r3, [r7, #4]
     9b2:	f103 0314 	add.w	r3, r3, #20
     9b6:	4618      	mov	r0, r3
     9b8:	f7ff fffe 	bl	0 <sys_mbox_free>
			9b8: R_ARM_THM_CALL	sys_mbox_free
    sys_mbox_set_invalid(&conn->recvmbox);
     9bc:	687b      	ldr	r3, [r7, #4]
     9be:	f103 0314 	add.w	r3, r3, #20
     9c2:	4618      	mov	r0, r3
     9c4:	f7ff fffe 	bl	0 <sys_mbox_set_invalid>
			9c4: R_ARM_THM_CALL	sys_mbox_set_invalid
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
     9c8:	687b      	ldr	r3, [r7, #4]
     9ca:	f103 031c 	add.w	r3, r3, #28
     9ce:	4618      	mov	r0, r3
     9d0:	f7ff fffe 	bl	0 <sys_mbox_valid>
			9d0: R_ARM_THM_CALL	sys_mbox_valid
     9d4:	4603      	mov	r3, r0
     9d6:	2b00      	cmp	r3, #0
     9d8:	d031      	beq.n	a3e <netconn_drain+0xfe>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
     9da:	e017      	b.n	a0c <netconn_drain+0xcc>
      struct netconn *newconn = (struct netconn *)mem;
     9dc:	68fb      	ldr	r3, [r7, #12]
     9de:	613b      	str	r3, [r7, #16]
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
     9e0:	687b      	ldr	r3, [r7, #4]
     9e2:	685b      	ldr	r3, [r3, #4]
     9e4:	2b00      	cmp	r3, #0
        tcp_accepted(conn->pcb.tcp);
      }
      /* drain recvmbox */
      netconn_drain(newconn);
     9e6:	6938      	ldr	r0, [r7, #16]
     9e8:	f7ff ffaa 	bl	940 <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
     9ec:	693b      	ldr	r3, [r7, #16]
     9ee:	685b      	ldr	r3, [r3, #4]
     9f0:	2b00      	cmp	r3, #0
     9f2:	d008      	beq.n	a06 <netconn_drain+0xc6>
        tcp_abort(newconn->pcb.tcp);
     9f4:	693b      	ldr	r3, [r7, #16]
     9f6:	685b      	ldr	r3, [r3, #4]
     9f8:	4618      	mov	r0, r3
     9fa:	f7ff fffe 	bl	0 <tcp_abort>
			9fa: R_ARM_THM_CALL	tcp_abort
        newconn->pcb.tcp = NULL;
     9fe:	693b      	ldr	r3, [r7, #16]
     a00:	f04f 0200 	mov.w	r2, #0
     a04:	605a      	str	r2, [r3, #4]
      }
      netconn_free(newconn);
     a06:	6938      	ldr	r0, [r7, #16]
     a08:	f7ff fffe 	bl	8f4 <netconn_free>
			a08: R_ARM_THM_CALL	netconn_free
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
     a0c:	687b      	ldr	r3, [r7, #4]
     a0e:	f103 021c 	add.w	r2, r3, #28
     a12:	f107 030c 	add.w	r3, r7, #12
     a16:	4610      	mov	r0, r2
     a18:	4619      	mov	r1, r3
     a1a:	f7ff fffe 	bl	0 <sys_arch_mbox_tryfetch>
			a1a: R_ARM_THM_CALL	sys_arch_mbox_tryfetch
     a1e:	4603      	mov	r3, r0
     a20:	f1b3 3fff 	cmp.w	r3, #4294967295
     a24:	d1da      	bne.n	9dc <netconn_drain+0x9c>
        tcp_abort(newconn->pcb.tcp);
        newconn->pcb.tcp = NULL;
      }
      netconn_free(newconn);
    }
    sys_mbox_free(&conn->acceptmbox);
     a26:	687b      	ldr	r3, [r7, #4]
     a28:	f103 031c 	add.w	r3, r3, #28
     a2c:	4618      	mov	r0, r3
     a2e:	f7ff fffe 	bl	0 <sys_mbox_free>
			a2e: R_ARM_THM_CALL	sys_mbox_free
    sys_mbox_set_invalid(&conn->acceptmbox);
     a32:	687b      	ldr	r3, [r7, #4]
     a34:	f103 031c 	add.w	r3, r3, #28
     a38:	4618      	mov	r0, r3
     a3a:	f7ff fffe 	bl	0 <sys_mbox_set_invalid>
			a3a: R_ARM_THM_CALL	sys_mbox_set_invalid
  }
#endif /* LWIP_TCP */
}
     a3e:	f107 0718 	add.w	r7, r7, #24
     a42:	46bd      	mov	sp, r7
     a44:	bd80      	pop	{r7, pc}
     a46:	bf00      	nop

00000a48 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
     a48:	b580      	push	{r7, lr}
     a4a:	b084      	sub	sp, #16
     a4c:	af00      	add	r7, sp, #0
     a4e:	6078      	str	r0, [r7, #4]
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
     a50:	687b      	ldr	r3, [r7, #4]
     a52:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     a54:	7a1b      	ldrb	r3, [r3, #8]
     a56:	73bb      	strb	r3, [r7, #14]
  shut_rx = shut & NETCONN_SHUT_RD;
     a58:	7bbb      	ldrb	r3, [r7, #14]
     a5a:	f003 0301 	and.w	r3, r3, #1
     a5e:	737b      	strb	r3, [r7, #13]
  shut_tx = shut & NETCONN_SHUT_WR;
     a60:	7bbb      	ldrb	r3, [r7, #14]
     a62:	f003 0302 	and.w	r3, r3, #2
     a66:	733b      	strb	r3, [r7, #12]
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;
     a68:	7bbb      	ldrb	r3, [r7, #14]
     a6a:	2b03      	cmp	r3, #3
     a6c:	bf14      	ite	ne
     a6e:	2300      	movne	r3, #0
     a70:	2301      	moveq	r3, #1
     a72:	72fb      	strb	r3, [r7, #11]

  /* Set back some callback pointers */
  if (close) {
     a74:	7afb      	ldrb	r3, [r7, #11]
     a76:	2b00      	cmp	r3, #0
     a78:	d006      	beq.n	a88 <do_close_internal+0x40>
    tcp_arg(conn->pcb.tcp, NULL);
     a7a:	687b      	ldr	r3, [r7, #4]
     a7c:	685b      	ldr	r3, [r3, #4]
     a7e:	4618      	mov	r0, r3
     a80:	f04f 0100 	mov.w	r1, #0
     a84:	f7ff fffe 	bl	0 <tcp_arg>
			a84: R_ARM_THM_CALL	tcp_arg
  }
  if (conn->pcb.tcp->state == LISTEN) {
     a88:	687b      	ldr	r3, [r7, #4]
     a8a:	685b      	ldr	r3, [r3, #4]
     a8c:	7e1b      	ldrb	r3, [r3, #24]
     a8e:	2b01      	cmp	r3, #1
     a90:	d107      	bne.n	aa2 <do_close_internal+0x5a>
    tcp_accept(conn->pcb.tcp, NULL);
     a92:	687b      	ldr	r3, [r7, #4]
     a94:	685b      	ldr	r3, [r3, #4]
     a96:	4618      	mov	r0, r3
     a98:	f04f 0100 	mov.w	r1, #0
     a9c:	f7ff fffe 	bl	0 <tcp_accept>
			a9c: R_ARM_THM_CALL	tcp_accept
     aa0:	e02d      	b.n	afe <do_close_internal+0xb6>
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
     aa2:	7b7b      	ldrb	r3, [r7, #13]
     aa4:	2b00      	cmp	r3, #0
     aa6:	d00d      	beq.n	ac4 <do_close_internal+0x7c>
      tcp_recv(conn->pcb.tcp, NULL);
     aa8:	687b      	ldr	r3, [r7, #4]
     aaa:	685b      	ldr	r3, [r3, #4]
     aac:	4618      	mov	r0, r3
     aae:	f04f 0100 	mov.w	r1, #0
     ab2:	f7ff fffe 	bl	0 <tcp_recv>
			ab2: R_ARM_THM_CALL	tcp_recv
      tcp_accept(conn->pcb.tcp, NULL);
     ab6:	687b      	ldr	r3, [r7, #4]
     ab8:	685b      	ldr	r3, [r3, #4]
     aba:	4618      	mov	r0, r3
     abc:	f04f 0100 	mov.w	r1, #0
     ac0:	f7ff fffe 	bl	0 <tcp_accept>
			ac0: R_ARM_THM_CALL	tcp_accept
    }
    if (shut_tx) {
     ac4:	7b3b      	ldrb	r3, [r7, #12]
     ac6:	2b00      	cmp	r3, #0
     ac8:	d006      	beq.n	ad8 <do_close_internal+0x90>
      tcp_sent(conn->pcb.tcp, NULL);
     aca:	687b      	ldr	r3, [r7, #4]
     acc:	685b      	ldr	r3, [r3, #4]
     ace:	4618      	mov	r0, r3
     ad0:	f04f 0100 	mov.w	r1, #0
     ad4:	f7ff fffe 	bl	0 <tcp_sent>
			ad4: R_ARM_THM_CALL	tcp_sent
    }
    if (close) {
     ad8:	7afb      	ldrb	r3, [r7, #11]
     ada:	2b00      	cmp	r3, #0
     adc:	d00f      	beq.n	afe <do_close_internal+0xb6>
      tcp_poll(conn->pcb.tcp, NULL, 4);
     ade:	687b      	ldr	r3, [r7, #4]
     ae0:	685b      	ldr	r3, [r3, #4]
     ae2:	4618      	mov	r0, r3
     ae4:	f04f 0100 	mov.w	r1, #0
     ae8:	f04f 0204 	mov.w	r2, #4
     aec:	f7ff fffe 	bl	0 <tcp_poll>
			aec: R_ARM_THM_CALL	tcp_poll
      tcp_err(conn->pcb.tcp, NULL);
     af0:	687b      	ldr	r3, [r7, #4]
     af2:	685b      	ldr	r3, [r3, #4]
     af4:	4618      	mov	r0, r3
     af6:	f04f 0100 	mov.w	r1, #0
     afa:	f7ff fffe 	bl	0 <tcp_err>
			afa: R_ARM_THM_CALL	tcp_err
    }
  }
  /* Try to close the connection */
  if (close) {
     afe:	7afb      	ldrb	r3, [r7, #11]
     b00:	2b00      	cmp	r3, #0
     b02:	d007      	beq.n	b14 <do_close_internal+0xcc>
    err = tcp_close(conn->pcb.tcp);
     b04:	687b      	ldr	r3, [r7, #4]
     b06:	685b      	ldr	r3, [r3, #4]
     b08:	4618      	mov	r0, r3
     b0a:	f7ff fffe 	bl	0 <tcp_close>
			b0a: R_ARM_THM_CALL	tcp_close
     b0e:	4603      	mov	r3, r0
     b10:	73fb      	strb	r3, [r7, #15]
     b12:	e00a      	b.n	b2a <do_close_internal+0xe2>
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
     b14:	687b      	ldr	r3, [r7, #4]
     b16:	6859      	ldr	r1, [r3, #4]
     b18:	7b7a      	ldrb	r2, [r7, #13]
     b1a:	7b3b      	ldrb	r3, [r7, #12]
     b1c:	4608      	mov	r0, r1
     b1e:	4611      	mov	r1, r2
     b20:	461a      	mov	r2, r3
     b22:	f7ff fffe 	bl	0 <tcp_shutdown>
			b22: R_ARM_THM_CALL	tcp_shutdown
     b26:	4603      	mov	r3, r0
     b28:	73fb      	strb	r3, [r7, #15]
  }
  if (err == ERR_OK) {
     b2a:	f997 300f 	ldrsb.w	r3, [r7, #15]
     b2e:	2b00      	cmp	r3, #0
     b30:	d144      	bne.n	bbc <do_close_internal+0x174>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
     b32:	687b      	ldr	r3, [r7, #4]
     b34:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     b36:	f04f 0200 	mov.w	r2, #0
     b3a:	711a      	strb	r2, [r3, #4]
    conn->current_msg = NULL;
     b3c:	687b      	ldr	r3, [r7, #4]
     b3e:	f04f 0200 	mov.w	r2, #0
     b42:	635a      	str	r2, [r3, #52]	; 0x34
    conn->state = NETCONN_NONE;
     b44:	687b      	ldr	r3, [r7, #4]
     b46:	f04f 0200 	mov.w	r2, #0
     b4a:	705a      	strb	r2, [r3, #1]
    if (close) {
     b4c:	7afb      	ldrb	r3, [r7, #11]
     b4e:	2b00      	cmp	r3, #0
     b50:	d00f      	beq.n	b72 <do_close_internal+0x12a>
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
     b52:	687b      	ldr	r3, [r7, #4]
     b54:	f04f 0200 	mov.w	r2, #0
     b58:	605a      	str	r2, [r3, #4]
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
     b5a:	687b      	ldr	r3, [r7, #4]
     b5c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b5e:	2b00      	cmp	r3, #0
     b60:	d007      	beq.n	b72 <do_close_internal+0x12a>
     b62:	687b      	ldr	r3, [r7, #4]
     b64:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b66:	6878      	ldr	r0, [r7, #4]
     b68:	f04f 0104 	mov.w	r1, #4
     b6c:	f04f 0200 	mov.w	r2, #0
     b70:	4798      	blx	r3
    }
    if (shut_rx) {
     b72:	7b7b      	ldrb	r3, [r7, #13]
     b74:	2b00      	cmp	r3, #0
     b76:	d00b      	beq.n	b90 <do_close_internal+0x148>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
     b78:	687b      	ldr	r3, [r7, #4]
     b7a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b7c:	2b00      	cmp	r3, #0
     b7e:	d007      	beq.n	b90 <do_close_internal+0x148>
     b80:	687b      	ldr	r3, [r7, #4]
     b82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b84:	6878      	ldr	r0, [r7, #4]
     b86:	f04f 0100 	mov.w	r1, #0
     b8a:	f04f 0200 	mov.w	r2, #0
     b8e:	4798      	blx	r3
    }
    if (shut_tx) {
     b90:	7b3b      	ldrb	r3, [r7, #12]
     b92:	2b00      	cmp	r3, #0
     b94:	d00b      	beq.n	bae <do_close_internal+0x166>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
     b96:	687b      	ldr	r3, [r7, #4]
     b98:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     b9a:	2b00      	cmp	r3, #0
     b9c:	d007      	beq.n	bae <do_close_internal+0x166>
     b9e:	687b      	ldr	r3, [r7, #4]
     ba0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     ba2:	6878      	ldr	r0, [r7, #4]
     ba4:	f04f 0102 	mov.w	r1, #2
     ba8:	f04f 0200 	mov.w	r2, #0
     bac:	4798      	blx	r3
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
     bae:	687b      	ldr	r3, [r7, #4]
     bb0:	f103 030c 	add.w	r3, r3, #12
     bb4:	4618      	mov	r0, r3
     bb6:	f7ff fffe 	bl	0 <sys_sem_signal>
			bb6: R_ARM_THM_CALL	sys_sem_signal
     bba:	e019      	b.n	bf0 <do_close_internal+0x1a8>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
    tcp_sent(conn->pcb.tcp, sent_tcp);
     bbc:	687b      	ldr	r3, [r7, #4]
     bbe:	685b      	ldr	r3, [r3, #4]
     bc0:	4618      	mov	r0, r3
     bc2:	490d      	ldr	r1, [pc, #52]	; (bf8 <do_close_internal+0x1b0>)
     bc4:	f7ff fffe 	bl	0 <tcp_sent>
			bc4: R_ARM_THM_CALL	tcp_sent
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
     bc8:	687b      	ldr	r3, [r7, #4]
     bca:	685b      	ldr	r3, [r3, #4]
     bcc:	4618      	mov	r0, r3
     bce:	490b      	ldr	r1, [pc, #44]	; (bfc <do_close_internal+0x1b4>)
     bd0:	f04f 0204 	mov.w	r2, #4
     bd4:	f7ff fffe 	bl	0 <tcp_poll>
			bd4: R_ARM_THM_CALL	tcp_poll
    tcp_err(conn->pcb.tcp, err_tcp);
     bd8:	687b      	ldr	r3, [r7, #4]
     bda:	685b      	ldr	r3, [r3, #4]
     bdc:	4618      	mov	r0, r3
     bde:	4908      	ldr	r1, [pc, #32]	; (c00 <do_close_internal+0x1b8>)
     be0:	f7ff fffe 	bl	0 <tcp_err>
			be0: R_ARM_THM_CALL	tcp_err
    tcp_arg(conn->pcb.tcp, conn);
     be4:	687b      	ldr	r3, [r7, #4]
     be6:	685b      	ldr	r3, [r3, #4]
     be8:	4618      	mov	r0, r3
     bea:	6879      	ldr	r1, [r7, #4]
     bec:	f7ff fffe 	bl	0 <tcp_arg>
			bec: R_ARM_THM_CALL	tcp_arg
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
     bf0:	f107 0710 	add.w	r7, r7, #16
     bf4:	46bd      	mov	sp, r7
     bf6:	bd80      	pop	{r7, pc}
	...
			bf8: R_ARM_ABS32	sent_tcp
			bfc: R_ARM_ABS32	poll_tcp
			c00: R_ARM_ABS32	err_tcp

00000c04 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
     c04:	b580      	push	{r7, lr}
     c06:	b082      	sub	sp, #8
     c08:	af00      	add	r7, sp, #0
     c0a:	6078      	str	r0, [r7, #4]
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
     c0c:	687b      	ldr	r3, [r7, #4]
     c0e:	681b      	ldr	r3, [r3, #0]
     c10:	785b      	ldrb	r3, [r3, #1]
     c12:	2b00      	cmp	r3, #0
     c14:	d00e      	beq.n	c34 <do_delconn+0x30>
     (msg->conn->state != NETCONN_LISTEN) &&
     c16:	687b      	ldr	r3, [r7, #4]
     c18:	681b      	ldr	r3, [r3, #0]
     c1a:	785b      	ldrb	r3, [r3, #1]
 */
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
     c1c:	2b02      	cmp	r3, #2
     c1e:	d009      	beq.n	c34 <do_delconn+0x30>
     (msg->conn->state != NETCONN_LISTEN) &&
     (msg->conn->state != NETCONN_CONNECT)) {
     c20:	687b      	ldr	r3, [r7, #4]
     c22:	681b      	ldr	r3, [r3, #0]
     c24:	785b      	ldrb	r3, [r3, #1]
void
do_delconn(struct api_msg_msg *msg)
{
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
     (msg->conn->state != NETCONN_LISTEN) &&
     c26:	2b03      	cmp	r3, #3
     c28:	d004      	beq.n	c34 <do_delconn+0x30>
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
     c2a:	687b      	ldr	r3, [r7, #4]
     c2c:	f04f 02fb 	mov.w	r2, #251	; 0xfb
     c30:	711a      	strb	r2, [r3, #4]
     c32:	e069      	b.n	d08 <do_delconn+0x104>
  } else {
    LWIP_ASSERT("blocking connect in progress",
     c34:	687b      	ldr	r3, [r7, #4]
     c36:	681b      	ldr	r3, [r3, #0]
     c38:	785b      	ldrb	r3, [r3, #1]
     c3a:	2b03      	cmp	r3, #3
      (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
     c3c:	687b      	ldr	r3, [r7, #4]
     c3e:	681b      	ldr	r3, [r3, #0]
     c40:	4618      	mov	r0, r3
     c42:	f7ff fe7d 	bl	940 <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
     c46:	687b      	ldr	r3, [r7, #4]
     c48:	681b      	ldr	r3, [r3, #0]
     c4a:	685b      	ldr	r3, [r3, #4]
     c4c:	2b00      	cmp	r3, #0
     c4e:	d03b      	beq.n	cc8 <do_delconn+0xc4>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
     c50:	687b      	ldr	r3, [r7, #4]
     c52:	681b      	ldr	r3, [r3, #0]
     c54:	781b      	ldrb	r3, [r3, #0]
     c56:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     c5a:	2b20      	cmp	r3, #32
     c5c:	d00b      	beq.n	c76 <do_delconn+0x72>
     c5e:	2b40      	cmp	r3, #64	; 0x40
     c60:	d002      	beq.n	c68 <do_delconn+0x64>
     c62:	2b10      	cmp	r3, #16
     c64:	d014      	beq.n	c90 <do_delconn+0x8c>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
#endif /* LWIP_TCP */
      default:
        break;
     c66:	e02a      	b.n	cbe <do_delconn+0xba>
    if (msg->conn->pcb.tcp != NULL) {

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        raw_remove(msg->conn->pcb.raw);
     c68:	687b      	ldr	r3, [r7, #4]
     c6a:	681b      	ldr	r3, [r3, #0]
     c6c:	685b      	ldr	r3, [r3, #4]
     c6e:	4618      	mov	r0, r3
     c70:	f7ff fffe 	bl	0 <raw_remove>
			c70: R_ARM_THM_CALL	raw_remove
        break;
     c74:	e023      	b.n	cbe <do_delconn+0xba>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->pcb.udp->recv_arg = NULL;
     c76:	687b      	ldr	r3, [r7, #4]
     c78:	681b      	ldr	r3, [r3, #0]
     c7a:	685b      	ldr	r3, [r3, #4]
     c7c:	f04f 0200 	mov.w	r2, #0
     c80:	621a      	str	r2, [r3, #32]
        udp_remove(msg->conn->pcb.udp);
     c82:	687b      	ldr	r3, [r7, #4]
     c84:	681b      	ldr	r3, [r3, #0]
     c86:	685b      	ldr	r3, [r3, #4]
     c88:	4618      	mov	r0, r3
     c8a:	f7ff fffe 	bl	0 <udp_remove>
			c8a: R_ARM_THM_CALL	udp_remove
        break;
     c8e:	e016      	b.n	cbe <do_delconn+0xba>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
     c90:	687b      	ldr	r3, [r7, #4]
     c92:	681b      	ldr	r3, [r3, #0]
     c94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     c96:	2b00      	cmp	r3, #0
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
     c98:	687b      	ldr	r3, [r7, #4]
     c9a:	681b      	ldr	r3, [r3, #0]
     c9c:	f04f 0204 	mov.w	r2, #4
     ca0:	705a      	strb	r2, [r3, #1]
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
     ca2:	687b      	ldr	r3, [r7, #4]
     ca4:	f04f 0203 	mov.w	r2, #3
     ca8:	721a      	strb	r2, [r3, #8]
        msg->conn->current_msg = msg;
     caa:	687b      	ldr	r3, [r7, #4]
     cac:	681b      	ldr	r3, [r3, #0]
     cae:	687a      	ldr	r2, [r7, #4]
     cb0:	635a      	str	r2, [r3, #52]	; 0x34
        do_close_internal(msg->conn);
     cb2:	687b      	ldr	r3, [r7, #4]
     cb4:	681b      	ldr	r3, [r3, #0]
     cb6:	4618      	mov	r0, r3
     cb8:	f7ff fec6 	bl	a48 <do_close_internal>
        /* API_EVENT is called inside do_close_internal, before releasing
           the application thread, so we can return at this point! */
        return;
     cbc:	e035      	b.n	d2a <do_delconn+0x126>
#endif /* LWIP_TCP */
      default:
        break;
      }
      msg->conn->pcb.tcp = NULL;
     cbe:	687b      	ldr	r3, [r7, #4]
     cc0:	681b      	ldr	r3, [r3, #0]
     cc2:	f04f 0200 	mov.w	r2, #0
     cc6:	605a      	str	r2, [r3, #4]
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
     cc8:	687b      	ldr	r3, [r7, #4]
     cca:	681b      	ldr	r3, [r3, #0]
     ccc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     cce:	2b00      	cmp	r3, #0
     cd0:	d00a      	beq.n	ce8 <do_delconn+0xe4>
     cd2:	687b      	ldr	r3, [r7, #4]
     cd4:	681b      	ldr	r3, [r3, #0]
     cd6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     cd8:	687a      	ldr	r2, [r7, #4]
     cda:	6812      	ldr	r2, [r2, #0]
     cdc:	4610      	mov	r0, r2
     cde:	f04f 0100 	mov.w	r1, #0
     ce2:	f04f 0200 	mov.w	r2, #0
     ce6:	4798      	blx	r3
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
     ce8:	687b      	ldr	r3, [r7, #4]
     cea:	681b      	ldr	r3, [r3, #0]
     cec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     cee:	2b00      	cmp	r3, #0
     cf0:	d00a      	beq.n	d08 <do_delconn+0x104>
     cf2:	687b      	ldr	r3, [r7, #4]
     cf4:	681b      	ldr	r3, [r3, #0]
     cf6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     cf8:	687a      	ldr	r2, [r7, #4]
     cfa:	6812      	ldr	r2, [r2, #0]
     cfc:	4610      	mov	r0, r2
     cfe:	f04f 0102 	mov.w	r1, #2
     d02:	f04f 0200 	mov.w	r2, #0
     d06:	4798      	blx	r3
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
     d08:	687b      	ldr	r3, [r7, #4]
     d0a:	681b      	ldr	r3, [r3, #0]
     d0c:	f103 030c 	add.w	r3, r3, #12
     d10:	4618      	mov	r0, r3
     d12:	f7ff fffe 	bl	0 <sys_sem_valid>
			d12: R_ARM_THM_CALL	sys_sem_valid
     d16:	4603      	mov	r3, r0
     d18:	2b00      	cmp	r3, #0
     d1a:	d006      	beq.n	d2a <do_delconn+0x126>
    sys_sem_signal(&msg->conn->op_completed);
     d1c:	687b      	ldr	r3, [r7, #4]
     d1e:	681b      	ldr	r3, [r3, #0]
     d20:	f103 030c 	add.w	r3, r3, #12
     d24:	4618      	mov	r0, r3
     d26:	f7ff fffe 	bl	0 <sys_sem_signal>
			d26: R_ARM_THM_CALL	sys_sem_signal
  }
}
     d2a:	f107 0708 	add.w	r7, r7, #8
     d2e:	46bd      	mov	sp, r7
     d30:	bd80      	pop	{r7, pc}
     d32:	bf00      	nop

00000d34 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
     d34:	b580      	push	{r7, lr}
     d36:	b082      	sub	sp, #8
     d38:	af00      	add	r7, sp, #0
     d3a:	6078      	str	r0, [r7, #4]
  if (ERR_IS_FATAL(msg->conn->last_err)) {
     d3c:	687b      	ldr	r3, [r7, #4]
     d3e:	681b      	ldr	r3, [r3, #0]
     d40:	7a1b      	ldrb	r3, [r3, #8]
     d42:	b25b      	sxtb	r3, r3
     d44:	f113 0f09 	cmn.w	r3, #9
     d48:	da05      	bge.n	d56 <do_bind+0x22>
    msg->err = msg->conn->last_err;
     d4a:	687b      	ldr	r3, [r7, #4]
     d4c:	681b      	ldr	r3, [r3, #0]
     d4e:	7a1a      	ldrb	r2, [r3, #8]
     d50:	687b      	ldr	r3, [r7, #4]
     d52:	711a      	strb	r2, [r3, #4]
     d54:	e044      	b.n	de0 <do_bind+0xac>
  } else {
    msg->err = ERR_VAL;
     d56:	687b      	ldr	r3, [r7, #4]
     d58:	f04f 02fa 	mov.w	r2, #250	; 0xfa
     d5c:	711a      	strb	r2, [r3, #4]
    if (msg->conn->pcb.tcp != NULL) {
     d5e:	687b      	ldr	r3, [r7, #4]
     d60:	681b      	ldr	r3, [r3, #0]
     d62:	685b      	ldr	r3, [r3, #4]
     d64:	2b00      	cmp	r3, #0
     d66:	d03b      	beq.n	de0 <do_bind+0xac>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
     d68:	687b      	ldr	r3, [r7, #4]
     d6a:	681b      	ldr	r3, [r3, #0]
     d6c:	781b      	ldrb	r3, [r3, #0]
     d6e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     d72:	2b20      	cmp	r3, #32
     d74:	d012      	beq.n	d9c <do_bind+0x68>
     d76:	2b40      	cmp	r3, #64	; 0x40
     d78:	d002      	beq.n	d80 <do_bind+0x4c>
     d7a:	2b10      	cmp	r3, #16
     d7c:	d01f      	beq.n	dbe <do_bind+0x8a>
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_TCP */
      default:
        break;
     d7e:	e02f      	b.n	de0 <do_bind+0xac>
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
     d80:	687b      	ldr	r3, [r7, #4]
     d82:	681b      	ldr	r3, [r3, #0]
     d84:	685a      	ldr	r2, [r3, #4]
     d86:	687b      	ldr	r3, [r7, #4]
     d88:	689b      	ldr	r3, [r3, #8]
     d8a:	4610      	mov	r0, r2
     d8c:	4619      	mov	r1, r3
     d8e:	f7ff fffe 	bl	0 <raw_bind>
			d8e: R_ARM_THM_CALL	raw_bind
     d92:	4603      	mov	r3, r0
     d94:	461a      	mov	r2, r3
     d96:	687b      	ldr	r3, [r7, #4]
     d98:	711a      	strb	r2, [r3, #4]
        break;
     d9a:	e021      	b.n	de0 <do_bind+0xac>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
     d9c:	687b      	ldr	r3, [r7, #4]
     d9e:	681b      	ldr	r3, [r3, #0]
     da0:	6859      	ldr	r1, [r3, #4]
     da2:	687b      	ldr	r3, [r7, #4]
     da4:	689a      	ldr	r2, [r3, #8]
     da6:	687b      	ldr	r3, [r7, #4]
     da8:	899b      	ldrh	r3, [r3, #12]
     daa:	4608      	mov	r0, r1
     dac:	4611      	mov	r1, r2
     dae:	461a      	mov	r2, r3
     db0:	f7ff fffe 	bl	0 <udp_bind>
			db0: R_ARM_THM_CALL	udp_bind
     db4:	4603      	mov	r3, r0
     db6:	461a      	mov	r2, r3
     db8:	687b      	ldr	r3, [r7, #4]
     dba:	711a      	strb	r2, [r3, #4]
        break;
     dbc:	e010      	b.n	de0 <do_bind+0xac>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
     dbe:	687b      	ldr	r3, [r7, #4]
     dc0:	681b      	ldr	r3, [r3, #0]
     dc2:	6859      	ldr	r1, [r3, #4]
     dc4:	687b      	ldr	r3, [r7, #4]
     dc6:	689a      	ldr	r2, [r3, #8]
     dc8:	687b      	ldr	r3, [r7, #4]
     dca:	899b      	ldrh	r3, [r3, #12]
     dcc:	4608      	mov	r0, r1
     dce:	4611      	mov	r1, r2
     dd0:	461a      	mov	r2, r3
     dd2:	f7ff fffe 	bl	0 <tcp_bind>
			dd2: R_ARM_THM_CALL	tcp_bind
     dd6:	4603      	mov	r3, r0
     dd8:	461a      	mov	r2, r3
     dda:	687b      	ldr	r3, [r7, #4]
     ddc:	711a      	strb	r2, [r3, #4]
        break;
     dde:	bf00      	nop
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
     de0:	687b      	ldr	r3, [r7, #4]
     de2:	681b      	ldr	r3, [r3, #0]
     de4:	f103 030c 	add.w	r3, r3, #12
     de8:	4618      	mov	r0, r3
     dea:	f7ff fffe 	bl	0 <sys_sem_signal>
			dea: R_ARM_THM_CALL	sys_sem_signal
}
     dee:	f107 0708 	add.w	r7, r7, #8
     df2:	46bd      	mov	sp, r7
     df4:	bd80      	pop	{r7, pc}
     df6:	bf00      	nop

00000df8 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
     df8:	b580      	push	{r7, lr}
     dfa:	b088      	sub	sp, #32
     dfc:	af00      	add	r7, sp, #0
     dfe:	60f8      	str	r0, [r7, #12]
     e00:	60b9      	str	r1, [r7, #8]
     e02:	4613      	mov	r3, r2
     e04:	71fb      	strb	r3, [r7, #7]
  struct netconn *conn;
  int was_blocking;

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;
     e06:	68fb      	ldr	r3, [r7, #12]
     e08:	61fb      	str	r3, [r7, #28]

  if (conn == NULL) {
     e0a:	69fb      	ldr	r3, [r7, #28]
     e0c:	2b00      	cmp	r3, #0
     e0e:	d102      	bne.n	e16 <do_connected+0x1e>
    return ERR_VAL;
     e10:	f04f 03fa 	mov.w	r3, #250	; 0xfa
     e14:	e05a      	b.n	ecc <do_connected+0xd4>
  }

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
     e16:	69fb      	ldr	r3, [r7, #28]
     e18:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     e1a:	2b00      	cmp	r3, #0
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
     e1c:	69fb      	ldr	r3, [r7, #28]
     e1e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     e20:	2b00      	cmp	r3, #0
     e22:	d003      	beq.n	e2c <do_connected+0x34>
    conn->current_msg->err = err;
     e24:	69fb      	ldr	r3, [r7, #28]
     e26:	6b5b      	ldr	r3, [r3, #52]	; 0x34
     e28:	79fa      	ldrb	r2, [r7, #7]
     e2a:	711a      	strb	r2, [r3, #4]
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
     e2c:	69fb      	ldr	r3, [r7, #28]
     e2e:	781b      	ldrb	r3, [r3, #0]
     e30:	2b10      	cmp	r3, #16
     e32:	d106      	bne.n	e42 <do_connected+0x4a>
     e34:	f997 3007 	ldrsb.w	r3, [r7, #7]
     e38:	2b00      	cmp	r3, #0
     e3a:	d102      	bne.n	e42 <do_connected+0x4a>
    setup_tcp(conn);
     e3c:	69f8      	ldr	r0, [r7, #28]
     e3e:	f7ff fba9 	bl	594 <setup_tcp>
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
     e42:	69fb      	ldr	r3, [r7, #28]
     e44:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     e48:	f003 0304 	and.w	r3, r3, #4
     e4c:	2b00      	cmp	r3, #0
     e4e:	bf14      	ite	ne
     e50:	2300      	movne	r3, #0
     e52:	2301      	moveq	r3, #1
     e54:	61bb      	str	r3, [r7, #24]
  SET_NONBLOCKING_CONNECT(conn, 0);
     e56:	69fb      	ldr	r3, [r7, #28]
     e58:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     e5c:	f023 0304 	bic.w	r3, r3, #4
     e60:	b2da      	uxtb	r2, r3
     e62:	69fb      	ldr	r3, [r7, #28]
     e64:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
  conn->current_msg = NULL;
     e68:	69fb      	ldr	r3, [r7, #28]
     e6a:	f04f 0200 	mov.w	r2, #0
     e6e:	635a      	str	r2, [r3, #52]	; 0x34
  conn->state = NETCONN_NONE;
     e70:	69fb      	ldr	r3, [r7, #28]
     e72:	f04f 0200 	mov.w	r2, #0
     e76:	705a      	strb	r2, [r3, #1]
  if (!was_blocking) {
     e78:	69bb      	ldr	r3, [r7, #24]
     e7a:	2b00      	cmp	r3, #0
     e7c:	d10f      	bne.n	e9e <do_connected+0xa6>
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
     e7e:	f7ff fffe 	bl	0 <sys_arch_protect>
			e7e: R_ARM_THM_CALL	sys_arch_protect
     e82:	6178      	str	r0, [r7, #20]
     e84:	69fb      	ldr	r3, [r7, #28]
     e86:	7a1b      	ldrb	r3, [r3, #8]
     e88:	b25b      	sxtb	r3, r3
     e8a:	f113 0f09 	cmn.w	r3, #9
     e8e:	db03      	blt.n	e98 <do_connected+0xa0>
     e90:	69fb      	ldr	r3, [r7, #28]
     e92:	f04f 0200 	mov.w	r2, #0
     e96:	721a      	strb	r2, [r3, #8]
     e98:	6978      	ldr	r0, [r7, #20]
     e9a:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			e9a: R_ARM_THM_CALL	sys_arch_unprotect
  }
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
     e9e:	69fb      	ldr	r3, [r7, #28]
     ea0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     ea2:	2b00      	cmp	r3, #0
     ea4:	d007      	beq.n	eb6 <do_connected+0xbe>
     ea6:	69fb      	ldr	r3, [r7, #28]
     ea8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
     eaa:	69f8      	ldr	r0, [r7, #28]
     eac:	f04f 0102 	mov.w	r1, #2
     eb0:	f04f 0200 	mov.w	r2, #0
     eb4:	4798      	blx	r3

  if (was_blocking) {
     eb6:	69bb      	ldr	r3, [r7, #24]
     eb8:	2b00      	cmp	r3, #0
     eba:	d005      	beq.n	ec8 <do_connected+0xd0>
    sys_sem_signal(&conn->op_completed);
     ebc:	69fb      	ldr	r3, [r7, #28]
     ebe:	f103 030c 	add.w	r3, r3, #12
     ec2:	4618      	mov	r0, r3
     ec4:	f7ff fffe 	bl	0 <sys_sem_signal>
			ec4: R_ARM_THM_CALL	sys_sem_signal
  }
  return ERR_OK;
     ec8:	f04f 0300 	mov.w	r3, #0
     ecc:	b25b      	sxtb	r3, r3
}
     ece:	4618      	mov	r0, r3
     ed0:	f107 0720 	add.w	r7, r7, #32
     ed4:	46bd      	mov	sp, r7
     ed6:	bd80      	pop	{r7, pc}

00000ed8 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
     ed8:	b580      	push	{r7, lr}
     eda:	b084      	sub	sp, #16
     edc:	af00      	add	r7, sp, #0
     ede:	6078      	str	r0, [r7, #4]
  if (msg->conn->pcb.tcp == NULL) {
     ee0:	687b      	ldr	r3, [r7, #4]
     ee2:	681b      	ldr	r3, [r3, #0]
     ee4:	685b      	ldr	r3, [r3, #4]
     ee6:	2b00      	cmp	r3, #0
     ee8:	d104      	bne.n	ef4 <do_connect+0x1c>
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
     eea:	687b      	ldr	r3, [r7, #4]
     eec:	f04f 02f4 	mov.w	r2, #244	; 0xf4
     ef0:	711a      	strb	r2, [r3, #4]
     ef2:	e08b      	b.n	100c <do_connect+0x134>
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
     ef4:	687b      	ldr	r3, [r7, #4]
     ef6:	681b      	ldr	r3, [r3, #0]
     ef8:	781b      	ldrb	r3, [r3, #0]
     efa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     efe:	2b20      	cmp	r3, #32
     f00:	d012      	beq.n	f28 <do_connect+0x50>
     f02:	2b40      	cmp	r3, #64	; 0x40
     f04:	d002      	beq.n	f0c <do_connect+0x34>
     f06:	2b10      	cmp	r3, #16
     f08:	d01f      	beq.n	f4a <do_connect+0x72>
     f0a:	e079      	b.n	1000 <do_connect+0x128>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
     f0c:	687b      	ldr	r3, [r7, #4]
     f0e:	681b      	ldr	r3, [r3, #0]
     f10:	685a      	ldr	r2, [r3, #4]
     f12:	687b      	ldr	r3, [r7, #4]
     f14:	689b      	ldr	r3, [r3, #8]
     f16:	4610      	mov	r0, r2
     f18:	4619      	mov	r1, r3
     f1a:	f7ff fffe 	bl	0 <raw_connect>
			f1a: R_ARM_THM_CALL	raw_connect
     f1e:	4603      	mov	r3, r0
     f20:	461a      	mov	r2, r3
     f22:	687b      	ldr	r3, [r7, #4]
     f24:	711a      	strb	r2, [r3, #4]
    break;
     f26:	e071      	b.n	100c <do_connect+0x134>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
     f28:	687b      	ldr	r3, [r7, #4]
     f2a:	681b      	ldr	r3, [r3, #0]
     f2c:	6859      	ldr	r1, [r3, #4]
     f2e:	687b      	ldr	r3, [r7, #4]
     f30:	689a      	ldr	r2, [r3, #8]
     f32:	687b      	ldr	r3, [r7, #4]
     f34:	899b      	ldrh	r3, [r3, #12]
     f36:	4608      	mov	r0, r1
     f38:	4611      	mov	r1, r2
     f3a:	461a      	mov	r2, r3
     f3c:	f7ff fffe 	bl	0 <udp_connect>
			f3c: R_ARM_THM_CALL	udp_connect
     f40:	4603      	mov	r3, r0
     f42:	461a      	mov	r2, r3
     f44:	687b      	ldr	r3, [r7, #4]
     f46:	711a      	strb	r2, [r3, #4]
    break;
     f48:	e060      	b.n	100c <do_connect+0x134>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
     f4a:	687b      	ldr	r3, [r7, #4]
     f4c:	681b      	ldr	r3, [r3, #0]
     f4e:	785b      	ldrb	r3, [r3, #1]
     f50:	2b00      	cmp	r3, #0
     f52:	d004      	beq.n	f5e <do_connect+0x86>
      msg->err = ERR_ISCONN;
     f54:	687b      	ldr	r3, [r7, #4]
     f56:	f04f 02f7 	mov.w	r2, #247	; 0xf7
     f5a:	711a      	strb	r2, [r3, #4]
          * when the connection is established! */
          return;
        }
      }
    }
    break;
     f5c:	e056      	b.n	100c <do_connect+0x134>
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
     f5e:	687b      	ldr	r3, [r7, #4]
     f60:	681b      	ldr	r3, [r3, #0]
     f62:	4618      	mov	r0, r3
     f64:	f7ff fb16 	bl	594 <setup_tcp>
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
     f68:	687b      	ldr	r3, [r7, #4]
     f6a:	681b      	ldr	r3, [r3, #0]
     f6c:	6859      	ldr	r1, [r3, #4]
     f6e:	687b      	ldr	r3, [r7, #4]
     f70:	689a      	ldr	r2, [r3, #8]
        msg->msg.bc.port, do_connected);
     f72:	687b      	ldr	r3, [r7, #4]
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
     f74:	899b      	ldrh	r3, [r3, #12]
     f76:	4608      	mov	r0, r1
     f78:	4611      	mov	r1, r2
     f7a:	461a      	mov	r2, r3
     f7c:	4b29      	ldr	r3, [pc, #164]	; (1024 <do_connect+0x14c>)
     f7e:	f7ff fffe 	bl	0 <tcp_connect>
			f7e: R_ARM_THM_CALL	tcp_connect
     f82:	4603      	mov	r3, r0
     f84:	461a      	mov	r2, r3
     f86:	687b      	ldr	r3, [r7, #4]
     f88:	711a      	strb	r2, [r3, #4]
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
     f8a:	687b      	ldr	r3, [r7, #4]
     f8c:	791b      	ldrb	r3, [r3, #4]
     f8e:	2b00      	cmp	r3, #0
     f90:	d13b      	bne.n	100a <do_connect+0x132>
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
     f92:	687b      	ldr	r3, [r7, #4]
     f94:	681b      	ldr	r3, [r3, #0]
     f96:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     f9a:	f003 0302 	and.w	r3, r3, #2
     f9e:	2b00      	cmp	r3, #0
     fa0:	bf0c      	ite	eq
     fa2:	2300      	moveq	r3, #0
     fa4:	2301      	movne	r3, #1
     fa6:	73fb      	strb	r3, [r7, #15]
        msg->conn->state = NETCONN_CONNECT;
     fa8:	687b      	ldr	r3, [r7, #4]
     faa:	681b      	ldr	r3, [r3, #0]
     fac:	f04f 0203 	mov.w	r2, #3
     fb0:	705a      	strb	r2, [r3, #1]
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
     fb2:	7bfb      	ldrb	r3, [r7, #15]
     fb4:	2b00      	cmp	r3, #0
     fb6:	d00b      	beq.n	fd0 <do_connect+0xf8>
     fb8:	687b      	ldr	r3, [r7, #4]
     fba:	681b      	ldr	r3, [r3, #0]
     fbc:	687a      	ldr	r2, [r7, #4]
     fbe:	6812      	ldr	r2, [r2, #0]
     fc0:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
     fc4:	f042 0204 	orr.w	r2, r2, #4
     fc8:	b2d2      	uxtb	r2, r2
     fca:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
     fce:	e00a      	b.n	fe6 <do_connect+0x10e>
     fd0:	687b      	ldr	r3, [r7, #4]
     fd2:	681b      	ldr	r3, [r3, #0]
     fd4:	687a      	ldr	r2, [r7, #4]
     fd6:	6812      	ldr	r2, [r2, #0]
     fd8:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
     fdc:	f022 0204 	bic.w	r2, r2, #4
     fe0:	b2d2      	uxtb	r2, r2
     fe2:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
        if (non_blocking) {
     fe6:	7bfb      	ldrb	r3, [r7, #15]
     fe8:	2b00      	cmp	r3, #0
     fea:	d004      	beq.n	ff6 <do_connect+0x11e>
          msg->err = ERR_INPROGRESS;
     fec:	687b      	ldr	r3, [r7, #4]
     fee:	f04f 02fb 	mov.w	r2, #251	; 0xfb
     ff2:	711a      	strb	r2, [r3, #4]
          * when the connection is established! */
          return;
        }
      }
    }
    break;
     ff4:	e00a      	b.n	100c <do_connect+0x134>
        msg->conn->state = NETCONN_CONNECT;
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
        if (non_blocking) {
          msg->err = ERR_INPROGRESS;
        } else {
          msg->conn->current_msg = msg;
     ff6:	687b      	ldr	r3, [r7, #4]
     ff8:	681b      	ldr	r3, [r3, #0]
     ffa:	687a      	ldr	r2, [r7, #4]
     ffc:	635a      	str	r2, [r3, #52]	; 0x34
          /* sys_sem_signal() is called from do_connected (or err_tcp()),
          * when the connection is established! */
          return;
     ffe:	e00c      	b.n	101a <do_connect+0x142>
      }
    }
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    1000:	687b      	ldr	r3, [r7, #4]
    1002:	f04f 02fa 	mov.w	r2, #250	; 0xfa
    1006:	711a      	strb	r2, [r3, #4]
    break;
    1008:	e000      	b.n	100c <do_connect+0x134>
          * when the connection is established! */
          return;
        }
      }
    }
    break;
    100a:	bf00      	nop
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
    100c:	687b      	ldr	r3, [r7, #4]
    100e:	681b      	ldr	r3, [r3, #0]
    1010:	f103 030c 	add.w	r3, r3, #12
    1014:	4618      	mov	r0, r3
    1016:	f7ff fffe 	bl	0 <sys_sem_signal>
			1016: R_ARM_THM_CALL	sys_sem_signal
}
    101a:	f107 0710 	add.w	r7, r7, #16
    101e:	46bd      	mov	sp, r7
    1020:	bd80      	pop	{r7, pc}
    1022:	bf00      	nop
    1024:	00000000 	.word	0x00000000
			1024: R_ARM_ABS32	do_connected

00001028 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
    1028:	b580      	push	{r7, lr}
    102a:	b082      	sub	sp, #8
    102c:	af00      	add	r7, sp, #0
    102e:	6078      	str	r0, [r7, #4]
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
    1030:	687b      	ldr	r3, [r7, #4]
    1032:	681b      	ldr	r3, [r3, #0]
    1034:	781b      	ldrb	r3, [r3, #0]
    1036:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    103a:	2b20      	cmp	r3, #32
    103c:	d10a      	bne.n	1054 <do_disconnect+0x2c>
    udp_disconnect(msg->conn->pcb.udp);
    103e:	687b      	ldr	r3, [r7, #4]
    1040:	681b      	ldr	r3, [r3, #0]
    1042:	685b      	ldr	r3, [r3, #4]
    1044:	4618      	mov	r0, r3
    1046:	f7ff fffe 	bl	0 <udp_disconnect>
			1046: R_ARM_THM_CALL	udp_disconnect
    msg->err = ERR_OK;
    104a:	687b      	ldr	r3, [r7, #4]
    104c:	f04f 0200 	mov.w	r2, #0
    1050:	711a      	strb	r2, [r3, #4]
    1052:	e003      	b.n	105c <do_disconnect+0x34>
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
    1054:	687b      	ldr	r3, [r7, #4]
    1056:	f04f 02fa 	mov.w	r2, #250	; 0xfa
    105a:	711a      	strb	r2, [r3, #4]
  }
  TCPIP_APIMSG_ACK(msg);
    105c:	687b      	ldr	r3, [r7, #4]
    105e:	681b      	ldr	r3, [r3, #0]
    1060:	f103 030c 	add.w	r3, r3, #12
    1064:	4618      	mov	r0, r3
    1066:	f7ff fffe 	bl	0 <sys_sem_signal>
			1066: R_ARM_THM_CALL	sys_sem_signal
}
    106a:	f107 0708 	add.w	r7, r7, #8
    106e:	46bd      	mov	sp, r7
    1070:	bd80      	pop	{r7, pc}
    1072:	bf00      	nop

00001074 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
    1074:	b580      	push	{r7, lr}
    1076:	b084      	sub	sp, #16
    1078:	af00      	add	r7, sp, #0
    107a:	6078      	str	r0, [r7, #4]
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    107c:	687b      	ldr	r3, [r7, #4]
    107e:	681b      	ldr	r3, [r3, #0]
    1080:	7a1b      	ldrb	r3, [r3, #8]
    1082:	b25b      	sxtb	r3, r3
    1084:	f113 0f09 	cmn.w	r3, #9
    1088:	da05      	bge.n	1096 <do_listen+0x22>
    msg->err = msg->conn->last_err;
    108a:	687b      	ldr	r3, [r7, #4]
    108c:	681b      	ldr	r3, [r3, #0]
    108e:	7a1a      	ldrb	r2, [r3, #8]
    1090:	687b      	ldr	r3, [r7, #4]
    1092:	711a      	strb	r2, [r3, #4]
    1094:	e081      	b.n	119a <do_listen+0x126>
  } else {
    msg->err = ERR_CONN;
    1096:	687b      	ldr	r3, [r7, #4]
    1098:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    109c:	711a      	strb	r2, [r3, #4]
    if (msg->conn->pcb.tcp != NULL) {
    109e:	687b      	ldr	r3, [r7, #4]
    10a0:	681b      	ldr	r3, [r3, #0]
    10a2:	685b      	ldr	r3, [r3, #4]
    10a4:	2b00      	cmp	r3, #0
    10a6:	d078      	beq.n	119a <do_listen+0x126>
      if (msg->conn->type == NETCONN_TCP) {
    10a8:	687b      	ldr	r3, [r7, #4]
    10aa:	681b      	ldr	r3, [r3, #0]
    10ac:	781b      	ldrb	r3, [r3, #0]
    10ae:	2b10      	cmp	r3, #16
    10b0:	d16f      	bne.n	1192 <do_listen+0x11e>
        if (msg->conn->state == NETCONN_NONE) {
    10b2:	687b      	ldr	r3, [r7, #4]
    10b4:	681b      	ldr	r3, [r3, #0]
    10b6:	785b      	ldrb	r3, [r3, #1]
    10b8:	2b00      	cmp	r3, #0
    10ba:	d16e      	bne.n	119a <do_listen+0x126>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
    10bc:	687b      	ldr	r3, [r7, #4]
    10be:	681b      	ldr	r3, [r3, #0]
    10c0:	685b      	ldr	r3, [r3, #4]
    10c2:	4618      	mov	r0, r3
    10c4:	f04f 0100 	mov.w	r1, #0
    10c8:	f7ff fffe 	bl	0 <tcp_listen_with_backlog>
			10c8: R_ARM_THM_CALL	tcp_listen_with_backlog
    10cc:	60f8      	str	r0, [r7, #12]
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
    10ce:	68fb      	ldr	r3, [r7, #12]
    10d0:	2b00      	cmp	r3, #0
    10d2:	d104      	bne.n	10de <do_listen+0x6a>
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
    10d4:	687b      	ldr	r3, [r7, #4]
    10d6:	f04f 02ff 	mov.w	r2, #255	; 0xff
    10da:	711a      	strb	r2, [r3, #4]
    10dc:	e05d      	b.n	119a <do_listen+0x126>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
    10de:	687b      	ldr	r3, [r7, #4]
    10e0:	681b      	ldr	r3, [r3, #0]
    10e2:	f103 0314 	add.w	r3, r3, #20
    10e6:	4618      	mov	r0, r3
    10e8:	f7ff fffe 	bl	0 <sys_mbox_valid>
			10e8: R_ARM_THM_CALL	sys_mbox_valid
    10ec:	4603      	mov	r3, r0
    10ee:	2b00      	cmp	r3, #0
    10f0:	d00d      	beq.n	110e <do_listen+0x9a>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
    10f2:	687b      	ldr	r3, [r7, #4]
    10f4:	681b      	ldr	r3, [r3, #0]
    10f6:	f103 0314 	add.w	r3, r3, #20
    10fa:	4618      	mov	r0, r3
    10fc:	f7ff fffe 	bl	0 <sys_mbox_free>
			10fc: R_ARM_THM_CALL	sys_mbox_free
              sys_mbox_set_invalid(&msg->conn->recvmbox);
    1100:	687b      	ldr	r3, [r7, #4]
    1102:	681b      	ldr	r3, [r3, #0]
    1104:	f103 0314 	add.w	r3, r3, #20
    1108:	4618      	mov	r0, r3
    110a:	f7ff fffe 	bl	0 <sys_mbox_set_invalid>
			110a: R_ARM_THM_CALL	sys_mbox_set_invalid
            }
            msg->err = ERR_OK;
    110e:	687b      	ldr	r3, [r7, #4]
    1110:	f04f 0200 	mov.w	r2, #0
    1114:	711a      	strb	r2, [r3, #4]
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
    1116:	687b      	ldr	r3, [r7, #4]
    1118:	681b      	ldr	r3, [r3, #0]
    111a:	f103 031c 	add.w	r3, r3, #28
    111e:	4618      	mov	r0, r3
    1120:	f7ff fffe 	bl	0 <sys_mbox_valid>
			1120: R_ARM_THM_CALL	sys_mbox_valid
    1124:	4603      	mov	r3, r0
    1126:	2b00      	cmp	r3, #0
    1128:	d10c      	bne.n	1144 <do_listen+0xd0>
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
    112a:	687b      	ldr	r3, [r7, #4]
    112c:	681b      	ldr	r3, [r3, #0]
    112e:	f103 031c 	add.w	r3, r3, #28
    1132:	4618      	mov	r0, r3
    1134:	f04f 0100 	mov.w	r1, #0
    1138:	f7ff fffe 	bl	0 <sys_mbox_new>
			1138: R_ARM_THM_CALL	sys_mbox_new
    113c:	4603      	mov	r3, r0
    113e:	461a      	mov	r2, r3
    1140:	687b      	ldr	r3, [r7, #4]
    1142:	711a      	strb	r2, [r3, #4]
            }
            if (msg->err == ERR_OK) {
    1144:	687b      	ldr	r3, [r7, #4]
    1146:	791b      	ldrb	r3, [r3, #4]
    1148:	2b00      	cmp	r3, #0
    114a:	d119      	bne.n	1180 <do_listen+0x10c>
              msg->conn->state = NETCONN_LISTEN;
    114c:	687b      	ldr	r3, [r7, #4]
    114e:	681b      	ldr	r3, [r3, #0]
    1150:	f04f 0202 	mov.w	r2, #2
    1154:	705a      	strb	r2, [r3, #1]
              msg->conn->pcb.tcp = lpcb;
    1156:	687b      	ldr	r3, [r7, #4]
    1158:	681b      	ldr	r3, [r3, #0]
    115a:	68fa      	ldr	r2, [r7, #12]
    115c:	605a      	str	r2, [r3, #4]
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
    115e:	687b      	ldr	r3, [r7, #4]
    1160:	681b      	ldr	r3, [r3, #0]
    1162:	685a      	ldr	r2, [r3, #4]
    1164:	687b      	ldr	r3, [r7, #4]
    1166:	681b      	ldr	r3, [r3, #0]
    1168:	4610      	mov	r0, r2
    116a:	4619      	mov	r1, r3
    116c:	f7ff fffe 	bl	0 <tcp_arg>
			116c: R_ARM_THM_CALL	tcp_arg
              tcp_accept(msg->conn->pcb.tcp, accept_function);
    1170:	687b      	ldr	r3, [r7, #4]
    1172:	681b      	ldr	r3, [r3, #0]
    1174:	685b      	ldr	r3, [r3, #4]
    1176:	4618      	mov	r0, r3
    1178:	490d      	ldr	r1, [pc, #52]	; (11b0 <do_listen+0x13c>)
    117a:	f7ff fffe 	bl	0 <tcp_accept>
			117a: R_ARM_THM_CALL	tcp_accept
    117e:	e00c      	b.n	119a <do_listen+0x126>
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
    1180:	68f8      	ldr	r0, [r7, #12]
    1182:	f7ff fffe 	bl	0 <tcp_close>
			1182: R_ARM_THM_CALL	tcp_close
              msg->conn->pcb.tcp = NULL;
    1186:	687b      	ldr	r3, [r7, #4]
    1188:	681b      	ldr	r3, [r3, #0]
    118a:	f04f 0200 	mov.w	r2, #0
    118e:	605a      	str	r2, [r3, #4]
    1190:	e003      	b.n	119a <do_listen+0x126>
            }
          }
        }
      } else {
        msg->err = ERR_ARG;
    1192:	687b      	ldr	r3, [r7, #4]
    1194:	f04f 02f2 	mov.w	r2, #242	; 0xf2
    1198:	711a      	strb	r2, [r3, #4]
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
    119a:	687b      	ldr	r3, [r7, #4]
    119c:	681b      	ldr	r3, [r3, #0]
    119e:	f103 030c 	add.w	r3, r3, #12
    11a2:	4618      	mov	r0, r3
    11a4:	f7ff fffe 	bl	0 <sys_sem_signal>
			11a4: R_ARM_THM_CALL	sys_sem_signal
}
    11a8:	f107 0710 	add.w	r7, r7, #16
    11ac:	46bd      	mov	sp, r7
    11ae:	bd80      	pop	{r7, pc}
    11b0:	00000000 	.word	0x00000000
			11b0: R_ARM_ABS32	accept_function

000011b4 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
    11b4:	b580      	push	{r7, lr}
    11b6:	b082      	sub	sp, #8
    11b8:	af00      	add	r7, sp, #0
    11ba:	6078      	str	r0, [r7, #4]
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    11bc:	687b      	ldr	r3, [r7, #4]
    11be:	681b      	ldr	r3, [r3, #0]
    11c0:	7a1b      	ldrb	r3, [r3, #8]
    11c2:	b25b      	sxtb	r3, r3
    11c4:	f113 0f09 	cmn.w	r3, #9
    11c8:	da05      	bge.n	11d6 <do_send+0x22>
    msg->err = msg->conn->last_err;
    11ca:	687b      	ldr	r3, [r7, #4]
    11cc:	681b      	ldr	r3, [r3, #0]
    11ce:	7a1a      	ldrb	r2, [r3, #8]
    11d0:	687b      	ldr	r3, [r7, #4]
    11d2:	711a      	strb	r2, [r3, #4]
    11d4:	e06e      	b.n	12b4 <do_send+0x100>
  } else {
    msg->err = ERR_CONN;
    11d6:	687b      	ldr	r3, [r7, #4]
    11d8:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    11dc:	711a      	strb	r2, [r3, #4]
    if (msg->conn->pcb.tcp != NULL) {
    11de:	687b      	ldr	r3, [r7, #4]
    11e0:	681b      	ldr	r3, [r3, #0]
    11e2:	685b      	ldr	r3, [r3, #4]
    11e4:	2b00      	cmp	r3, #0
    11e6:	d065      	beq.n	12b4 <do_send+0x100>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    11e8:	687b      	ldr	r3, [r7, #4]
    11ea:	681b      	ldr	r3, [r3, #0]
    11ec:	781b      	ldrb	r3, [r3, #0]
    11ee:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    11f2:	2b20      	cmp	r3, #32
    11f4:	d02f      	beq.n	1256 <do_send+0xa2>
    11f6:	2b40      	cmp	r3, #64	; 0x40
    11f8:	d15b      	bne.n	12b2 <do_send+0xfe>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
    11fa:	687b      	ldr	r3, [r7, #4]
    11fc:	689b      	ldr	r3, [r3, #8]
    11fe:	f103 0308 	add.w	r3, r3, #8
    1202:	2b00      	cmp	r3, #0
    1204:	d004      	beq.n	1210 <do_send+0x5c>
    1206:	687b      	ldr	r3, [r7, #4]
    1208:	689b      	ldr	r3, [r3, #8]
    120a:	689b      	ldr	r3, [r3, #8]
    120c:	2b00      	cmp	r3, #0
    120e:	d10e      	bne.n	122e <do_send+0x7a>
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
    1210:	687b      	ldr	r3, [r7, #4]
    1212:	681b      	ldr	r3, [r3, #0]
    1214:	685a      	ldr	r2, [r3, #4]
    1216:	687b      	ldr	r3, [r7, #4]
    1218:	689b      	ldr	r3, [r3, #8]
    121a:	681b      	ldr	r3, [r3, #0]
    121c:	4610      	mov	r0, r2
    121e:	4619      	mov	r1, r3
    1220:	f7ff fffe 	bl	0 <raw_send>
			1220: R_ARM_THM_CALL	raw_send
    1224:	4603      	mov	r3, r0
    1226:	461a      	mov	r2, r3
    1228:	687b      	ldr	r3, [r7, #4]
    122a:	711a      	strb	r2, [r3, #4]
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
        }
        break;
    122c:	e042      	b.n	12b4 <do_send+0x100>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
    122e:	687b      	ldr	r3, [r7, #4]
    1230:	681b      	ldr	r3, [r3, #0]
    1232:	6859      	ldr	r1, [r3, #4]
    1234:	687b      	ldr	r3, [r7, #4]
    1236:	689b      	ldr	r3, [r3, #8]
    1238:	681a      	ldr	r2, [r3, #0]
    123a:	687b      	ldr	r3, [r7, #4]
    123c:	689b      	ldr	r3, [r3, #8]
    123e:	f103 0308 	add.w	r3, r3, #8
    1242:	4608      	mov	r0, r1
    1244:	4611      	mov	r1, r2
    1246:	461a      	mov	r2, r3
    1248:	f7ff fffe 	bl	0 <raw_sendto>
			1248: R_ARM_THM_CALL	raw_sendto
    124c:	4603      	mov	r3, r0
    124e:	461a      	mov	r2, r3
    1250:	687b      	ldr	r3, [r7, #4]
    1252:	711a      	strb	r2, [r3, #4]
        }
        break;
    1254:	e02e      	b.n	12b4 <do_send+0x100>
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        }
#else /* LWIP_CHECKSUM_ON_COPY */
        if (ip_addr_isany(&msg->msg.b->addr)) {
    1256:	687b      	ldr	r3, [r7, #4]
    1258:	689b      	ldr	r3, [r3, #8]
    125a:	f103 0308 	add.w	r3, r3, #8
    125e:	2b00      	cmp	r3, #0
    1260:	d004      	beq.n	126c <do_send+0xb8>
    1262:	687b      	ldr	r3, [r7, #4]
    1264:	689b      	ldr	r3, [r3, #8]
    1266:	689b      	ldr	r3, [r3, #8]
    1268:	2b00      	cmp	r3, #0
    126a:	d10e      	bne.n	128a <do_send+0xd6>
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
    126c:	687b      	ldr	r3, [r7, #4]
    126e:	681b      	ldr	r3, [r3, #0]
    1270:	685a      	ldr	r2, [r3, #4]
    1272:	687b      	ldr	r3, [r7, #4]
    1274:	689b      	ldr	r3, [r3, #8]
    1276:	681b      	ldr	r3, [r3, #0]
    1278:	4610      	mov	r0, r2
    127a:	4619      	mov	r1, r3
    127c:	f7ff fffe 	bl	0 <udp_send>
			127c: R_ARM_THM_CALL	udp_send
    1280:	4603      	mov	r3, r0
    1282:	461a      	mov	r2, r3
    1284:	687b      	ldr	r3, [r7, #4]
    1286:	711a      	strb	r2, [r3, #4]
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
    1288:	e014      	b.n	12b4 <do_send+0x100>
        }
#else /* LWIP_CHECKSUM_ON_COPY */
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
    128a:	687b      	ldr	r3, [r7, #4]
    128c:	681b      	ldr	r3, [r3, #0]
    128e:	6858      	ldr	r0, [r3, #4]
    1290:	687b      	ldr	r3, [r7, #4]
    1292:	689b      	ldr	r3, [r3, #8]
    1294:	6819      	ldr	r1, [r3, #0]
    1296:	687b      	ldr	r3, [r7, #4]
    1298:	689b      	ldr	r3, [r3, #8]
    129a:	f103 0208 	add.w	r2, r3, #8
    129e:	687b      	ldr	r3, [r7, #4]
    12a0:	689b      	ldr	r3, [r3, #8]
    12a2:	899b      	ldrh	r3, [r3, #12]
    12a4:	f7ff fffe 	bl	0 <udp_sendto>
			12a4: R_ARM_THM_CALL	udp_sendto
    12a8:	4603      	mov	r3, r0
    12aa:	461a      	mov	r2, r3
    12ac:	687b      	ldr	r3, [r7, #4]
    12ae:	711a      	strb	r2, [r3, #4]
        }
#endif /* LWIP_CHECKSUM_ON_COPY */
        break;
    12b0:	e000      	b.n	12b4 <do_send+0x100>
#endif /* LWIP_UDP */
      default:
        break;
    12b2:	bf00      	nop
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
    12b4:	687b      	ldr	r3, [r7, #4]
    12b6:	681b      	ldr	r3, [r3, #0]
    12b8:	f103 030c 	add.w	r3, r3, #12
    12bc:	4618      	mov	r0, r3
    12be:	f7ff fffe 	bl	0 <sys_sem_signal>
			12be: R_ARM_THM_CALL	sys_sem_signal
}
    12c2:	f107 0708 	add.w	r7, r7, #8
    12c6:	46bd      	mov	sp, r7
    12c8:	bd80      	pop	{r7, pc}
    12ca:	bf00      	nop

000012cc <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
    12cc:	b580      	push	{r7, lr}
    12ce:	b084      	sub	sp, #16
    12d0:	af00      	add	r7, sp, #0
    12d2:	6078      	str	r0, [r7, #4]
  msg->err = ERR_OK;
    12d4:	687b      	ldr	r3, [r7, #4]
    12d6:	f04f 0200 	mov.w	r2, #0
    12da:	711a      	strb	r2, [r3, #4]
  if (msg->conn->pcb.tcp != NULL) {
    12dc:	687b      	ldr	r3, [r7, #4]
    12de:	681b      	ldr	r3, [r3, #0]
    12e0:	685b      	ldr	r3, [r3, #4]
    12e2:	2b00      	cmp	r3, #0
    12e4:	d021      	beq.n	132a <do_recv+0x5e>
    if (msg->conn->type == NETCONN_TCP) {
    12e6:	687b      	ldr	r3, [r7, #4]
    12e8:	681b      	ldr	r3, [r3, #0]
    12ea:	781b      	ldrb	r3, [r3, #0]
    12ec:	2b10      	cmp	r3, #16
    12ee:	d11c      	bne.n	132a <do_recv+0x5e>
      if (msg->conn->pcb.tcp->state == LISTEN) {
        tcp_accepted(msg->conn->pcb.tcp);
      } else
#endif /* TCP_LISTEN_BACKLOG */
      {
        u32_t remaining = msg->msg.r.len;
    12f0:	687b      	ldr	r3, [r7, #4]
    12f2:	689b      	ldr	r3, [r3, #8]
    12f4:	60fb      	str	r3, [r7, #12]
        do {
          u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
    12f6:	68fa      	ldr	r2, [r7, #12]
    12f8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    12fc:	429a      	cmp	r2, r3
    12fe:	d802      	bhi.n	1306 <do_recv+0x3a>
    1300:	68fb      	ldr	r3, [r7, #12]
    1302:	b29b      	uxth	r3, r3
    1304:	e001      	b.n	130a <do_recv+0x3e>
    1306:	f64f 73ff 	movw	r3, #65535	; 0xffff
    130a:	817b      	strh	r3, [r7, #10]
          tcp_recved(msg->conn->pcb.tcp, recved);
    130c:	687b      	ldr	r3, [r7, #4]
    130e:	681b      	ldr	r3, [r3, #0]
    1310:	685a      	ldr	r2, [r3, #4]
    1312:	897b      	ldrh	r3, [r7, #10]
    1314:	4610      	mov	r0, r2
    1316:	4619      	mov	r1, r3
    1318:	f7ff fffe 	bl	0 <tcp_recved>
			1318: R_ARM_THM_CALL	tcp_recved
          remaining -= recved;
    131c:	897b      	ldrh	r3, [r7, #10]
    131e:	68fa      	ldr	r2, [r7, #12]
    1320:	1ad3      	subs	r3, r2, r3
    1322:	60fb      	str	r3, [r7, #12]
        }while(remaining != 0);
    1324:	68fb      	ldr	r3, [r7, #12]
    1326:	2b00      	cmp	r3, #0
    1328:	d1e5      	bne.n	12f6 <do_recv+0x2a>
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
    132a:	687b      	ldr	r3, [r7, #4]
    132c:	681b      	ldr	r3, [r3, #0]
    132e:	f103 030c 	add.w	r3, r3, #12
    1332:	4618      	mov	r0, r3
    1334:	f7ff fffe 	bl	0 <sys_sem_signal>
			1334: R_ARM_THM_CALL	sys_sem_signal
}
    1338:	f107 0710 	add.w	r7, r7, #16
    133c:	46bd      	mov	sp, r7
    133e:	bd80      	pop	{r7, pc}

00001340 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
    1340:	b580      	push	{r7, lr}
    1342:	b088      	sub	sp, #32
    1344:	af00      	add	r7, sp, #0
    1346:	6078      	str	r0, [r7, #4]
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
    1348:	f04f 0300 	mov.w	r3, #0
    134c:	76fb      	strb	r3, [r7, #27]
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
    134e:	687b      	ldr	r3, [r7, #4]
    1350:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
    1354:	f003 0302 	and.w	r3, r3, #2
    1358:	2b00      	cmp	r3, #0
    135a:	d106      	bne.n	136a <do_writemore+0x2a>
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
    135c:	687b      	ldr	r3, [r7, #4]
    135e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1360:	7c1b      	ldrb	r3, [r3, #16]
    1362:	f003 0304 	and.w	r3, r3, #4
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
    1366:	2b00      	cmp	r3, #0
    1368:	d002      	beq.n	1370 <do_writemore+0x30>
    136a:	f04f 0301 	mov.w	r3, #1
    136e:	e001      	b.n	1374 <do_writemore+0x34>
    1370:	f04f 0300 	mov.w	r3, #0
    1374:	767b      	strb	r3, [r7, #25]
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;
    1376:	687b      	ldr	r3, [r7, #4]
    1378:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    137a:	7c1b      	ldrb	r3, [r3, #16]
    137c:	76bb      	strb	r3, [r7, #26]
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
    137e:	687b      	ldr	r3, [r7, #4]
    1380:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1382:	689a      	ldr	r2, [r3, #8]
    1384:	687b      	ldr	r3, [r7, #4]
    1386:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1388:	18d3      	adds	r3, r2, r3
    138a:	617b      	str	r3, [r7, #20]
    diff = conn->current_msg->msg.w.len - conn->write_offset;
    138c:	687b      	ldr	r3, [r7, #4]
    138e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1390:	68da      	ldr	r2, [r3, #12]
    1392:	687b      	ldr	r3, [r7, #4]
    1394:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    1396:	1ad3      	subs	r3, r2, r3
    1398:	613b      	str	r3, [r7, #16]
    if (diff > 0xffffUL) { /* max_u16_t */
    139a:	693a      	ldr	r2, [r7, #16]
    139c:	f64f 73ff 	movw	r3, #65535	; 0xffff
    13a0:	429a      	cmp	r2, r3
    13a2:	d907      	bls.n	13b4 <do_writemore+0x74>
      len = 0xffff;
    13a4:	f64f 73ff 	movw	r3, #65535	; 0xffff
    13a8:	83bb      	strh	r3, [r7, #28]
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    13aa:	7ebb      	ldrb	r3, [r7, #26]
    13ac:	f043 0302 	orr.w	r3, r3, #2
    13b0:	76bb      	strb	r3, [r7, #26]
    13b2:	e001      	b.n	13b8 <do_writemore+0x78>
    } else {
      len = (u16_t)diff;
    13b4:	693b      	ldr	r3, [r7, #16]
    13b6:	83bb      	strh	r3, [r7, #28]
    }
    available = tcp_sndbuf(conn->pcb.tcp);
    13b8:	687b      	ldr	r3, [r7, #4]
    13ba:	685b      	ldr	r3, [r3, #4]
    13bc:	f8b3 3066 	ldrh.w	r3, [r3, #102]	; 0x66
    13c0:	81fb      	strh	r3, [r7, #14]
    if (available < len) {
    13c2:	89fa      	ldrh	r2, [r7, #14]
    13c4:	8bbb      	ldrh	r3, [r7, #28]
    13c6:	429a      	cmp	r2, r3
    13c8:	d20f      	bcs.n	13ea <do_writemore+0xaa>
      /* don't try to write more than sendbuf */
      len = available;
    13ca:	89fb      	ldrh	r3, [r7, #14]
    13cc:	83bb      	strh	r3, [r7, #28]
      if (dontblock){ 
    13ce:	7e7b      	ldrb	r3, [r7, #25]
    13d0:	2b00      	cmp	r3, #0
    13d2:	d006      	beq.n	13e2 <do_writemore+0xa2>
        if (!len) {
    13d4:	8bbb      	ldrh	r3, [r7, #28]
    13d6:	2b00      	cmp	r3, #0
    13d8:	d107      	bne.n	13ea <do_writemore+0xaa>
          err = ERR_WOULDBLOCK;
    13da:	f04f 03f9 	mov.w	r3, #249	; 0xf9
    13de:	77fb      	strb	r3, [r7, #31]
          goto err_mem;
    13e0:	e016      	b.n	1410 <do_writemore+0xd0>
        }
      } else {
#if LWIP_TCPIP_CORE_LOCKING
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
    13e2:	7ebb      	ldrb	r3, [r7, #26]
    13e4:	f043 0302 	orr.w	r3, r3, #2
    13e8:	76bb      	strb	r3, [r7, #26]
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    13ea:	687b      	ldr	r3, [r7, #4]
    13ec:	6859      	ldr	r1, [r3, #4]
    13ee:	8bba      	ldrh	r2, [r7, #28]
    13f0:	7ebb      	ldrb	r3, [r7, #26]
    13f2:	4608      	mov	r0, r1
    13f4:	6979      	ldr	r1, [r7, #20]
    13f6:	f7ff fffe 	bl	0 <tcp_write>
			13f6: R_ARM_THM_CALL	tcp_write
    13fa:	4603      	mov	r3, r0
    13fc:	77fb      	strb	r3, [r7, #31]
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
    13fe:	f997 301f 	ldrsb.w	r3, [r7, #31]
    1402:	2b00      	cmp	r3, #0
    1404:	d004      	beq.n	1410 <do_writemore+0xd0>
    1406:	f997 301f 	ldrsb.w	r3, [r7, #31]
    140a:	f1b3 3fff 	cmp.w	r3, #4294967295
    140e:	d136      	bne.n	147e <do_writemore+0x13e>
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
    1410:	7e7b      	ldrb	r3, [r7, #25]
    1412:	2b00      	cmp	r3, #0
    1414:	d01a      	beq.n	144c <do_writemore+0x10c>
    1416:	8bba      	ldrh	r2, [r7, #28]
    1418:	687b      	ldr	r3, [r7, #4]
    141a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    141c:	68db      	ldr	r3, [r3, #12]
    141e:	429a      	cmp	r2, r3
    1420:	d214      	bcs.n	144c <do_writemore+0x10c>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    1422:	687b      	ldr	r3, [r7, #4]
    1424:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1426:	2b00      	cmp	r3, #0
    1428:	d006      	beq.n	1438 <do_writemore+0xf8>
    142a:	687b      	ldr	r3, [r7, #4]
    142c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    142e:	8bba      	ldrh	r2, [r7, #28]
    1430:	6878      	ldr	r0, [r7, #4]
    1432:	f04f 0103 	mov.w	r1, #3
    1436:	4798      	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
    1438:	687b      	ldr	r3, [r7, #4]
    143a:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
    143e:	f043 0310 	orr.w	r3, r3, #16
    1442:	b2da      	uxtb	r2, r3
    1444:	687b      	ldr	r3, [r7, #4]
    1446:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    144a:	e018      	b.n	147e <do_writemore+0x13e>
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
    144c:	687b      	ldr	r3, [r7, #4]
    144e:	685b      	ldr	r3, [r3, #4]
    1450:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
    1454:	f240 53dc 	movw	r3, #1500	; 0x5dc
    1458:	429a      	cmp	r2, r3
    145a:	d905      	bls.n	1468 <do_writemore+0x128>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
    145c:	687b      	ldr	r3, [r7, #4]
    145e:	685b      	ldr	r3, [r3, #4]
    1460:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
    1464:	2b04      	cmp	r3, #4
    1466:	d90a      	bls.n	147e <do_writemore+0x13e>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
    1468:	687b      	ldr	r3, [r7, #4]
    146a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    146c:	2b00      	cmp	r3, #0
    146e:	d006      	beq.n	147e <do_writemore+0x13e>
    1470:	687b      	ldr	r3, [r7, #4]
    1472:	6b9b      	ldr	r3, [r3, #56]	; 0x38
    1474:	8bba      	ldrh	r2, [r7, #28]
    1476:	6878      	ldr	r0, [r7, #4]
    1478:	f04f 0103 	mov.w	r1, #3
    147c:	4798      	blx	r3
      }
    }

    if (err == ERR_OK) {
    147e:	f997 301f 	ldrsb.w	r3, [r7, #31]
    1482:	2b00      	cmp	r3, #0
    1484:	d121      	bne.n	14ca <do_writemore+0x18a>
      conn->write_offset += len;
    1486:	687b      	ldr	r3, [r7, #4]
    1488:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    148a:	8bbb      	ldrh	r3, [r7, #28]
    148c:	18d2      	adds	r2, r2, r3
    148e:	687b      	ldr	r3, [r7, #4]
    1490:	631a      	str	r2, [r3, #48]	; 0x30
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
    1492:	687b      	ldr	r3, [r7, #4]
    1494:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    1496:	687b      	ldr	r3, [r7, #4]
    1498:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    149a:	68db      	ldr	r3, [r3, #12]
    149c:	429a      	cmp	r2, r3
    149e:	d002      	beq.n	14a6 <do_writemore+0x166>
    14a0:	7e7b      	ldrb	r3, [r7, #25]
    14a2:	2b00      	cmp	r3, #0
    14a4:	d00b      	beq.n	14be <do_writemore+0x17e>
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
    14a6:	687b      	ldr	r3, [r7, #4]
    14a8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    14aa:	687a      	ldr	r2, [r7, #4]
    14ac:	6b12      	ldr	r2, [r2, #48]	; 0x30
    14ae:	60da      	str	r2, [r3, #12]
        /* everything was written */
        write_finished = 1;
    14b0:	f04f 0301 	mov.w	r3, #1
    14b4:	76fb      	strb	r3, [r7, #27]
        conn->write_offset = 0;
    14b6:	687b      	ldr	r3, [r7, #4]
    14b8:	f04f 0200 	mov.w	r2, #0
    14bc:	631a      	str	r2, [r3, #48]	; 0x30
      }
      tcp_output(conn->pcb.tcp);
    14be:	687b      	ldr	r3, [r7, #4]
    14c0:	685b      	ldr	r3, [r3, #4]
    14c2:	4618      	mov	r0, r3
    14c4:	f7ff fffe 	bl	0 <tcp_output>
			14c4: R_ARM_THM_CALL	tcp_output
    14c8:	e015      	b.n	14f6 <do_writemore+0x1b6>
    } else if ((err == ERR_MEM) && !dontblock) {
    14ca:	f997 301f 	ldrsb.w	r3, [r7, #31]
    14ce:	f1b3 3fff 	cmp.w	r3, #4294967295
    14d2:	d108      	bne.n	14e6 <do_writemore+0x1a6>
    14d4:	7e7b      	ldrb	r3, [r7, #25]
    14d6:	2b00      	cmp	r3, #0
    14d8:	d105      	bne.n	14e6 <do_writemore+0x1a6>
      /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
         we do NOT return to the application thread, since ERR_MEM is
         only a temporary error! */

      /* tcp_write returned ERR_MEM, try tcp_output anyway */
      tcp_output(conn->pcb.tcp);
    14da:	687b      	ldr	r3, [r7, #4]
    14dc:	685b      	ldr	r3, [r3, #4]
    14de:	4618      	mov	r0, r3
    14e0:	f7ff fffe 	bl	0 <tcp_output>
			14e0: R_ARM_THM_CALL	tcp_output
    14e4:	e007      	b.n	14f6 <do_writemore+0x1b6>
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
    14e6:	f04f 0301 	mov.w	r3, #1
    14ea:	76fb      	strb	r3, [r7, #27]
      conn->current_msg->msg.w.len = 0;
    14ec:	687b      	ldr	r3, [r7, #4]
    14ee:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    14f0:	f04f 0200 	mov.w	r2, #0
    14f4:	60da      	str	r2, [r3, #12]
    }
  }
  if (write_finished) {
    14f6:	7efb      	ldrb	r3, [r7, #27]
    14f8:	2b00      	cmp	r3, #0
    14fa:	d011      	beq.n	1520 <do_writemore+0x1e0>
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
    14fc:	687b      	ldr	r3, [r7, #4]
    14fe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1500:	7ffa      	ldrb	r2, [r7, #31]
    1502:	711a      	strb	r2, [r3, #4]
    conn->current_msg = NULL;
    1504:	687b      	ldr	r3, [r7, #4]
    1506:	f04f 0200 	mov.w	r2, #0
    150a:	635a      	str	r2, [r3, #52]	; 0x34
    conn->state = NETCONN_NONE;
    150c:	687b      	ldr	r3, [r7, #4]
    150e:	f04f 0200 	mov.w	r2, #0
    1512:	705a      	strb	r2, [r3, #1]
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
    1514:	687b      	ldr	r3, [r7, #4]
    1516:	f103 030c 	add.w	r3, r3, #12
    151a:	4618      	mov	r0, r3
    151c:	f7ff fffe 	bl	0 <sys_sem_signal>
			151c: R_ARM_THM_CALL	sys_sem_signal
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
    1520:	f04f 0300 	mov.w	r3, #0
    1524:	b25b      	sxtb	r3, r3
}
    1526:	4618      	mov	r0, r3
    1528:	f107 0720 	add.w	r7, r7, #32
    152c:	46bd      	mov	sp, r7
    152e:	bd80      	pop	{r7, pc}

00001530 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
    1530:	b580      	push	{r7, lr}
    1532:	b082      	sub	sp, #8
    1534:	af00      	add	r7, sp, #0
    1536:	6078      	str	r0, [r7, #4]
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    1538:	687b      	ldr	r3, [r7, #4]
    153a:	681b      	ldr	r3, [r3, #0]
    153c:	7a1b      	ldrb	r3, [r3, #8]
    153e:	b25b      	sxtb	r3, r3
    1540:	f113 0f09 	cmn.w	r3, #9
    1544:	da05      	bge.n	1552 <do_write+0x22>
    msg->err = msg->conn->last_err;
    1546:	687b      	ldr	r3, [r7, #4]
    1548:	681b      	ldr	r3, [r3, #0]
    154a:	7a1a      	ldrb	r2, [r3, #8]
    154c:	687b      	ldr	r3, [r7, #4]
    154e:	711a      	strb	r2, [r3, #4]
    1550:	e034      	b.n	15bc <do_write+0x8c>
  } else {
    if (msg->conn->type == NETCONN_TCP) {
    1552:	687b      	ldr	r3, [r7, #4]
    1554:	681b      	ldr	r3, [r3, #0]
    1556:	781b      	ldrb	r3, [r3, #0]
    1558:	2b10      	cmp	r3, #16
    155a:	d12b      	bne.n	15b4 <do_write+0x84>
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
    155c:	687b      	ldr	r3, [r7, #4]
    155e:	681b      	ldr	r3, [r3, #0]
    1560:	785b      	ldrb	r3, [r3, #1]
    1562:	2b00      	cmp	r3, #0
    1564:	d004      	beq.n	1570 <do_write+0x40>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
    1566:	687b      	ldr	r3, [r7, #4]
    1568:	f04f 02fb 	mov.w	r2, #251	; 0xfb
    156c:	711a      	strb	r2, [r3, #4]
    156e:	e025      	b.n	15bc <do_write+0x8c>
      } else if (msg->conn->pcb.tcp != NULL) {
    1570:	687b      	ldr	r3, [r7, #4]
    1572:	681b      	ldr	r3, [r3, #0]
    1574:	685b      	ldr	r3, [r3, #4]
    1576:	2b00      	cmp	r3, #0
    1578:	d017      	beq.n	15aa <do_write+0x7a>
        msg->conn->state = NETCONN_WRITE;
    157a:	687b      	ldr	r3, [r7, #4]
    157c:	681b      	ldr	r3, [r3, #0]
    157e:	f04f 0201 	mov.w	r2, #1
    1582:	705a      	strb	r2, [r3, #1]
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
    1584:	687b      	ldr	r3, [r7, #4]
    1586:	681b      	ldr	r3, [r3, #0]
    1588:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    158a:	2b00      	cmp	r3, #0
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
    158c:	687b      	ldr	r3, [r7, #4]
    158e:	681b      	ldr	r3, [r3, #0]
    1590:	687a      	ldr	r2, [r7, #4]
    1592:	635a      	str	r2, [r3, #52]	; 0x34
        msg->conn->write_offset = 0;
    1594:	687b      	ldr	r3, [r7, #4]
    1596:	681b      	ldr	r3, [r3, #0]
    1598:	f04f 0200 	mov.w	r2, #0
    159c:	631a      	str	r2, [r3, #48]	; 0x30
          sys_arch_sem_wait(&msg->conn->op_completed, 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        do_writemore(msg->conn);
    159e:	687b      	ldr	r3, [r7, #4]
    15a0:	681b      	ldr	r3, [r3, #0]
    15a2:	4618      	mov	r0, r3
    15a4:	f7ff fecc 	bl	1340 <do_writemore>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if do_writemore was called, don't ACK the APIMSG
           since do_writemore ACKs it! */
        return;
    15a8:	e00f      	b.n	15ca <do_write+0x9a>
      } else {
        msg->err = ERR_CONN;
    15aa:	687b      	ldr	r3, [r7, #4]
    15ac:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    15b0:	711a      	strb	r2, [r3, #4]
    15b2:	e003      	b.n	15bc <do_write+0x8c>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
    15b4:	687b      	ldr	r3, [r7, #4]
    15b6:	f04f 02fa 	mov.w	r2, #250	; 0xfa
    15ba:	711a      	strb	r2, [r3, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
    15bc:	687b      	ldr	r3, [r7, #4]
    15be:	681b      	ldr	r3, [r3, #0]
    15c0:	f103 030c 	add.w	r3, r3, #12
    15c4:	4618      	mov	r0, r3
    15c6:	f7ff fffe 	bl	0 <sys_sem_signal>
			15c6: R_ARM_THM_CALL	sys_sem_signal
}
    15ca:	f107 0708 	add.w	r7, r7, #8
    15ce:	46bd      	mov	sp, r7
    15d0:	bd80      	pop	{r7, pc}
    15d2:	bf00      	nop

000015d4 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
    15d4:	b580      	push	{r7, lr}
    15d6:	b082      	sub	sp, #8
    15d8:	af00      	add	r7, sp, #0
    15da:	6078      	str	r0, [r7, #4]
  if (msg->conn->pcb.ip != NULL) {
    15dc:	687b      	ldr	r3, [r7, #4]
    15de:	681b      	ldr	r3, [r3, #0]
    15e0:	685b      	ldr	r3, [r3, #4]
    15e2:	2b00      	cmp	r3, #0
    15e4:	d064      	beq.n	16b0 <do_getaddr+0xdc>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
    15e6:	687b      	ldr	r3, [r7, #4]
    15e8:	689b      	ldr	r3, [r3, #8]
    15ea:	687a      	ldr	r2, [r7, #4]
    15ec:	7c12      	ldrb	r2, [r2, #16]
    15ee:	2a00      	cmp	r2, #0
    15f0:	d005      	beq.n	15fe <do_getaddr+0x2a>
    15f2:	687a      	ldr	r2, [r7, #4]
    15f4:	6812      	ldr	r2, [r2, #0]
    15f6:	6852      	ldr	r2, [r2, #4]
    15f8:	6812      	ldr	r2, [r2, #0]
    15fa:	601a      	str	r2, [r3, #0]
    15fc:	e004      	b.n	1608 <do_getaddr+0x34>
                             msg->conn->pcb.ip->remote_ip);
    15fe:	687a      	ldr	r2, [r7, #4]
    1600:	6812      	ldr	r2, [r2, #0]
    1602:	6852      	ldr	r2, [r2, #4]
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.ip != NULL) {
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
    1604:	6852      	ldr	r2, [r2, #4]
    1606:	601a      	str	r2, [r3, #0]
                             msg->conn->pcb.ip->remote_ip);

    msg->err = ERR_OK;
    1608:	687b      	ldr	r3, [r7, #4]
    160a:	f04f 0200 	mov.w	r2, #0
    160e:	711a      	strb	r2, [r3, #4]
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
    1610:	687b      	ldr	r3, [r7, #4]
    1612:	681b      	ldr	r3, [r3, #0]
    1614:	781b      	ldrb	r3, [r3, #0]
    1616:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    161a:	2b20      	cmp	r3, #32
    161c:	d015      	beq.n	164a <do_getaddr+0x76>
    161e:	2b40      	cmp	r3, #64	; 0x40
    1620:	d002      	beq.n	1628 <do_getaddr+0x54>
    1622:	2b10      	cmp	r3, #16
    1624:	d032      	beq.n	168c <do_getaddr+0xb8>
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
      break;
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
    1626:	e047      	b.n	16b8 <do_getaddr+0xe4>

    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
    1628:	687b      	ldr	r3, [r7, #4]
    162a:	7c1b      	ldrb	r3, [r3, #16]
    162c:	2b00      	cmp	r3, #0
    162e:	d007      	beq.n	1640 <do_getaddr+0x6c>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
    1630:	687b      	ldr	r3, [r7, #4]
    1632:	68db      	ldr	r3, [r3, #12]
    1634:	687a      	ldr	r2, [r7, #4]
    1636:	6812      	ldr	r2, [r2, #0]
    1638:	6852      	ldr	r2, [r2, #4]
    163a:	7c12      	ldrb	r2, [r2, #16]
    163c:	801a      	strh	r2, [r3, #0]
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
      }
      break;
    163e:	e03b      	b.n	16b8 <do_getaddr+0xe4>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->err = ERR_CONN;
    1640:	687b      	ldr	r3, [r7, #4]
    1642:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    1646:	711a      	strb	r2, [r3, #4]
      }
      break;
    1648:	e036      	b.n	16b8 <do_getaddr+0xe4>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
    164a:	687b      	ldr	r3, [r7, #4]
    164c:	7c1b      	ldrb	r3, [r3, #16]
    164e:	2b00      	cmp	r3, #0
    1650:	d007      	beq.n	1662 <do_getaddr+0x8e>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
    1652:	687b      	ldr	r3, [r7, #4]
    1654:	68db      	ldr	r3, [r3, #12]
    1656:	687a      	ldr	r2, [r7, #4]
    1658:	6812      	ldr	r2, [r2, #0]
    165a:	6852      	ldr	r2, [r2, #4]
    165c:	8a52      	ldrh	r2, [r2, #18]
    165e:	801a      	strh	r2, [r3, #0]
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
    1660:	e02a      	b.n	16b8 <do_getaddr+0xe4>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
    1662:	687b      	ldr	r3, [r7, #4]
    1664:	681b      	ldr	r3, [r3, #0]
    1666:	685b      	ldr	r3, [r3, #4]
    1668:	7c1b      	ldrb	r3, [r3, #16]
    166a:	f003 0304 	and.w	r3, r3, #4
    166e:	2b00      	cmp	r3, #0
    1670:	d104      	bne.n	167c <do_getaddr+0xa8>
          msg->err = ERR_CONN;
    1672:	687b      	ldr	r3, [r7, #4]
    1674:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    1678:	711a      	strb	r2, [r3, #4]
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
    167a:	e01d      	b.n	16b8 <do_getaddr+0xe4>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
    167c:	687b      	ldr	r3, [r7, #4]
    167e:	68db      	ldr	r3, [r3, #12]
    1680:	687a      	ldr	r2, [r7, #4]
    1682:	6812      	ldr	r2, [r2, #0]
    1684:	6852      	ldr	r2, [r2, #4]
    1686:	8a92      	ldrh	r2, [r2, #20]
    1688:	801a      	strh	r2, [r3, #0]
        }
      }
      break;
    168a:	e015      	b.n	16b8 <do_getaddr+0xe4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
    168c:	687b      	ldr	r3, [r7, #4]
    168e:	68da      	ldr	r2, [r3, #12]
    1690:	687b      	ldr	r3, [r7, #4]
    1692:	7c1b      	ldrb	r3, [r3, #16]
    1694:	2b00      	cmp	r3, #0
    1696:	d004      	beq.n	16a2 <do_getaddr+0xce>
    1698:	687b      	ldr	r3, [r7, #4]
    169a:	681b      	ldr	r3, [r3, #0]
    169c:	685b      	ldr	r3, [r3, #4]
    169e:	8b5b      	ldrh	r3, [r3, #26]
    16a0:	e003      	b.n	16aa <do_getaddr+0xd6>
    16a2:	687b      	ldr	r3, [r7, #4]
    16a4:	681b      	ldr	r3, [r3, #0]
    16a6:	685b      	ldr	r3, [r3, #4]
    16a8:	8b9b      	ldrh	r3, [r3, #28]
    16aa:	8013      	strh	r3, [r2, #0]
      break;
    16ac:	bf00      	nop
    16ae:	e003      	b.n	16b8 <do_getaddr+0xe4>
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
    }
  } else {
    msg->err = ERR_CONN;
    16b0:	687b      	ldr	r3, [r7, #4]
    16b2:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    16b6:	711a      	strb	r2, [r3, #4]
  }
  TCPIP_APIMSG_ACK(msg);
    16b8:	687b      	ldr	r3, [r7, #4]
    16ba:	681b      	ldr	r3, [r3, #0]
    16bc:	f103 030c 	add.w	r3, r3, #12
    16c0:	4618      	mov	r0, r3
    16c2:	f7ff fffe 	bl	0 <sys_sem_signal>
			16c2: R_ARM_THM_CALL	sys_sem_signal
}
    16c6:	f107 0708 	add.w	r7, r7, #8
    16ca:	46bd      	mov	sp, r7
    16cc:	bd80      	pop	{r7, pc}
    16ce:	bf00      	nop

000016d0 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
    16d0:	b580      	push	{r7, lr}
    16d2:	b082      	sub	sp, #8
    16d4:	af00      	add	r7, sp, #0
    16d6:	6078      	str	r0, [r7, #4]
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    16d8:	687b      	ldr	r3, [r7, #4]
    16da:	681b      	ldr	r3, [r3, #0]
    16dc:	785b      	ldrb	r3, [r3, #1]
    16de:	2b00      	cmp	r3, #0
    16e0:	d009      	beq.n	16f6 <do_close+0x26>
    16e2:	687b      	ldr	r3, [r7, #4]
    16e4:	681b      	ldr	r3, [r3, #0]
    16e6:	785b      	ldrb	r3, [r3, #1]
    16e8:	2b02      	cmp	r3, #2
    16ea:	d004      	beq.n	16f6 <do_close+0x26>
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
    16ec:	687b      	ldr	r3, [r7, #4]
    16ee:	f04f 02fb 	mov.w	r2, #251	; 0xfb
    16f2:	711a      	strb	r2, [r3, #4]
    16f4:	e03a      	b.n	176c <do_close+0x9c>
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    16f6:	687b      	ldr	r3, [r7, #4]
    16f8:	681b      	ldr	r3, [r3, #0]
    16fa:	685b      	ldr	r3, [r3, #4]
    16fc:	2b00      	cmp	r3, #0
    16fe:	d031      	beq.n	1764 <do_close+0x94>
    1700:	687b      	ldr	r3, [r7, #4]
    1702:	681b      	ldr	r3, [r3, #0]
    1704:	781b      	ldrb	r3, [r3, #0]
    1706:	2b10      	cmp	r3, #16
    1708:	d12c      	bne.n	1764 <do_close+0x94>
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
    170a:	687b      	ldr	r3, [r7, #4]
    170c:	7a1b      	ldrb	r3, [r3, #8]
    170e:	2b03      	cmp	r3, #3
    1710:	d009      	beq.n	1726 <do_close+0x56>
    1712:	687b      	ldr	r3, [r7, #4]
    1714:	681b      	ldr	r3, [r3, #0]
    1716:	785b      	ldrb	r3, [r3, #1]
    1718:	2b02      	cmp	r3, #2
    171a:	d104      	bne.n	1726 <do_close+0x56>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    171c:	687b      	ldr	r3, [r7, #4]
    171e:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    1722:	711a      	strb	r2, [r3, #4]
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
    1724:	e022      	b.n	176c <do_close+0x9c>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
    1726:	687b      	ldr	r3, [r7, #4]
    1728:	7a1b      	ldrb	r3, [r3, #8]
    172a:	f003 0301 	and.w	r3, r3, #1
    172e:	b2db      	uxtb	r3, r3
    1730:	2b00      	cmp	r3, #0
    1732:	d004      	beq.n	173e <do_close+0x6e>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
    1734:	687b      	ldr	r3, [r7, #4]
    1736:	681b      	ldr	r3, [r3, #0]
    1738:	4618      	mov	r0, r3
    173a:	f7ff f901 	bl	940 <netconn_drain>
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
    173e:	687b      	ldr	r3, [r7, #4]
    1740:	681b      	ldr	r3, [r3, #0]
    1742:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    1744:	2b00      	cmp	r3, #0
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
    1746:	687b      	ldr	r3, [r7, #4]
    1748:	681b      	ldr	r3, [r3, #0]
    174a:	f04f 0204 	mov.w	r2, #4
    174e:	705a      	strb	r2, [r3, #1]
      msg->conn->current_msg = msg;
    1750:	687b      	ldr	r3, [r7, #4]
    1752:	681b      	ldr	r3, [r3, #0]
    1754:	687a      	ldr	r2, [r7, #4]
    1756:	635a      	str	r2, [r3, #52]	; 0x34
      do_close_internal(msg->conn);
    1758:	687b      	ldr	r3, [r7, #4]
    175a:	681b      	ldr	r3, [r3, #0]
    175c:	4618      	mov	r0, r3
    175e:	f7ff f973 	bl	a48 <do_close_internal>
      /* for tcp netconns, do_close_internal ACKs the message */
      return;
    1762:	e00a      	b.n	177a <do_close+0xaa>
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
    1764:	687b      	ldr	r3, [r7, #4]
    1766:	f04f 02fa 	mov.w	r2, #250	; 0xfa
    176a:	711a      	strb	r2, [r3, #4]
  }
  sys_sem_signal(&msg->conn->op_completed);
    176c:	687b      	ldr	r3, [r7, #4]
    176e:	681b      	ldr	r3, [r3, #0]
    1770:	f103 030c 	add.w	r3, r3, #12
    1774:	4618      	mov	r0, r3
    1776:	f7ff fffe 	bl	0 <sys_sem_signal>
			1776: R_ARM_THM_CALL	sys_sem_signal
}
    177a:	f107 0708 	add.w	r7, r7, #8
    177e:	46bd      	mov	sp, r7
    1780:	bd80      	pop	{r7, pc}
    1782:	bf00      	nop

00001784 <do_join_leave_group>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_join_leave_group(struct api_msg_msg *msg)
{ 
    1784:	b580      	push	{r7, lr}
    1786:	b082      	sub	sp, #8
    1788:	af00      	add	r7, sp, #0
    178a:	6078      	str	r0, [r7, #4]
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    178c:	687b      	ldr	r3, [r7, #4]
    178e:	681b      	ldr	r3, [r3, #0]
    1790:	7a1b      	ldrb	r3, [r3, #8]
    1792:	b25b      	sxtb	r3, r3
    1794:	f113 0f09 	cmn.w	r3, #9
    1798:	da05      	bge.n	17a6 <do_join_leave_group+0x22>
    msg->err = msg->conn->last_err;
    179a:	687b      	ldr	r3, [r7, #4]
    179c:	681b      	ldr	r3, [r3, #0]
    179e:	7a1a      	ldrb	r2, [r3, #8]
    17a0:	687b      	ldr	r3, [r7, #4]
    17a2:	711a      	strb	r2, [r3, #4]
    17a4:	e032      	b.n	180c <do_join_leave_group+0x88>
  } else {
    if (msg->conn->pcb.tcp != NULL) {
    17a6:	687b      	ldr	r3, [r7, #4]
    17a8:	681b      	ldr	r3, [r3, #0]
    17aa:	685b      	ldr	r3, [r3, #4]
    17ac:	2b00      	cmp	r3, #0
    17ae:	d029      	beq.n	1804 <do_join_leave_group+0x80>
      if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
    17b0:	687b      	ldr	r3, [r7, #4]
    17b2:	681b      	ldr	r3, [r3, #0]
    17b4:	781b      	ldrb	r3, [r3, #0]
    17b6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    17ba:	2b20      	cmp	r3, #32
    17bc:	d11d      	bne.n	17fa <do_join_leave_group+0x76>
#if LWIP_UDP
        if (msg->msg.jl.join_or_leave == NETCONN_JOIN) {
    17be:	687b      	ldr	r3, [r7, #4]
    17c0:	7c1b      	ldrb	r3, [r3, #16]
    17c2:	2b00      	cmp	r3, #0
    17c4:	d10c      	bne.n	17e0 <do_join_leave_group+0x5c>
          msg->err = igmp_joingroup(msg->msg.jl.netif_addr, msg->msg.jl.multiaddr);
    17c6:	687b      	ldr	r3, [r7, #4]
    17c8:	68da      	ldr	r2, [r3, #12]
    17ca:	687b      	ldr	r3, [r7, #4]
    17cc:	689b      	ldr	r3, [r3, #8]
    17ce:	4610      	mov	r0, r2
    17d0:	4619      	mov	r1, r3
    17d2:	f7ff fffe 	bl	0 <igmp_joingroup>
			17d2: R_ARM_THM_CALL	igmp_joingroup
    17d6:	4603      	mov	r3, r0
    17d8:	461a      	mov	r2, r3
    17da:	687b      	ldr	r3, [r7, #4]
    17dc:	711a      	strb	r2, [r3, #4]
    17de:	e015      	b.n	180c <do_join_leave_group+0x88>
        } else {
          msg->err = igmp_leavegroup(msg->msg.jl.netif_addr, msg->msg.jl.multiaddr);
    17e0:	687b      	ldr	r3, [r7, #4]
    17e2:	68da      	ldr	r2, [r3, #12]
    17e4:	687b      	ldr	r3, [r7, #4]
    17e6:	689b      	ldr	r3, [r3, #8]
    17e8:	4610      	mov	r0, r2
    17ea:	4619      	mov	r1, r3
    17ec:	f7ff fffe 	bl	0 <igmp_leavegroup>
			17ec: R_ARM_THM_CALL	igmp_leavegroup
    17f0:	4603      	mov	r3, r0
    17f2:	461a      	mov	r2, r3
    17f4:	687b      	ldr	r3, [r7, #4]
    17f6:	711a      	strb	r2, [r3, #4]
    17f8:	e008      	b.n	180c <do_join_leave_group+0x88>
        }
#endif /* LWIP_UDP */
#if (LWIP_TCP || LWIP_RAW)
      } else {
        msg->err = ERR_VAL;
    17fa:	687b      	ldr	r3, [r7, #4]
    17fc:	f04f 02fa 	mov.w	r2, #250	; 0xfa
    1800:	711a      	strb	r2, [r3, #4]
    1802:	e003      	b.n	180c <do_join_leave_group+0x88>
#endif /* (LWIP_TCP || LWIP_RAW) */
      }
    } else {
      msg->err = ERR_CONN;
    1804:	687b      	ldr	r3, [r7, #4]
    1806:	f04f 02f3 	mov.w	r2, #243	; 0xf3
    180a:	711a      	strb	r2, [r3, #4]
    }
  }
  TCPIP_APIMSG_ACK(msg);
    180c:	687b      	ldr	r3, [r7, #4]
    180e:	681b      	ldr	r3, [r3, #0]
    1810:	f103 030c 	add.w	r3, r3, #12
    1814:	4618      	mov	r0, r3
    1816:	f7ff fffe 	bl	0 <sys_sem_signal>
			1816: R_ARM_THM_CALL	sys_sem_signal
}
    181a:	f107 0708 	add.w	r7, r7, #8
    181e:	46bd      	mov	sp, r7
    1820:	bd80      	pop	{r7, pc}
    1822:	bf00      	nop

00001824 <do_dns_found>:
 * (or on timeout). A waiting application thread is waked up by
 * signaling the semaphore.
 */
static void
do_dns_found(const char *name, ip_addr_t *ipaddr, void *arg)
{
    1824:	b580      	push	{r7, lr}
    1826:	b086      	sub	sp, #24
    1828:	af00      	add	r7, sp, #0
    182a:	60f8      	str	r0, [r7, #12]
    182c:	60b9      	str	r1, [r7, #8]
    182e:	607a      	str	r2, [r7, #4]
  struct dns_api_msg *msg = (struct dns_api_msg*)arg;
    1830:	687b      	ldr	r3, [r7, #4]
    1832:	617b      	str	r3, [r7, #20]

  LWIP_ASSERT("DNS response for wrong host name", strcmp(msg->name, name) == 0);
    1834:	697b      	ldr	r3, [r7, #20]
    1836:	681b      	ldr	r3, [r3, #0]
    1838:	4618      	mov	r0, r3
    183a:	68f9      	ldr	r1, [r7, #12]
    183c:	f7ff fffe 	bl	0 <strcmp>
			183c: R_ARM_THM_CALL	strcmp
  LWIP_UNUSED_ARG(name);

  if (ipaddr == NULL) {
    1840:	68bb      	ldr	r3, [r7, #8]
    1842:	2b00      	cmp	r3, #0
    1844:	d105      	bne.n	1852 <do_dns_found+0x2e>
    /* timeout or memory error */
    *msg->err = ERR_VAL;
    1846:	697b      	ldr	r3, [r7, #20]
    1848:	68db      	ldr	r3, [r3, #12]
    184a:	f04f 02fa 	mov.w	r2, #250	; 0xfa
    184e:	701a      	strb	r2, [r3, #0]
    1850:	e009      	b.n	1866 <do_dns_found+0x42>
  } else {
    /* address was resolved */
    *msg->err = ERR_OK;
    1852:	697b      	ldr	r3, [r7, #20]
    1854:	68db      	ldr	r3, [r3, #12]
    1856:	f04f 0200 	mov.w	r2, #0
    185a:	701a      	strb	r2, [r3, #0]
    *msg->addr = *ipaddr;
    185c:	697b      	ldr	r3, [r7, #20]
    185e:	685b      	ldr	r3, [r3, #4]
    1860:	68ba      	ldr	r2, [r7, #8]
    1862:	6812      	ldr	r2, [r2, #0]
    1864:	601a      	str	r2, [r3, #0]
  }
  /* wake up the application task waiting in netconn_gethostbyname */
  sys_sem_signal(msg->sem);
    1866:	697b      	ldr	r3, [r7, #20]
    1868:	689b      	ldr	r3, [r3, #8]
    186a:	4618      	mov	r0, r3
    186c:	f7ff fffe 	bl	0 <sys_sem_signal>
			186c: R_ARM_THM_CALL	sys_sem_signal
}
    1870:	f107 0718 	add.w	r7, r7, #24
    1874:	46bd      	mov	sp, r7
    1876:	bd80      	pop	{r7, pc}

00001878 <do_gethostbyname>:
 *
 * @param arg the dns_api_msg pointing to the query
 */
void
do_gethostbyname(void *arg)
{
    1878:	b590      	push	{r4, r7, lr}
    187a:	b085      	sub	sp, #20
    187c:	af00      	add	r7, sp, #0
    187e:	6078      	str	r0, [r7, #4]
  struct dns_api_msg *msg = (struct dns_api_msg*)arg;
    1880:	687b      	ldr	r3, [r7, #4]
    1882:	60fb      	str	r3, [r7, #12]

  *msg->err = dns_gethostbyname(msg->name, msg->addr, do_dns_found, msg);
    1884:	68fb      	ldr	r3, [r7, #12]
    1886:	68dc      	ldr	r4, [r3, #12]
    1888:	68fb      	ldr	r3, [r7, #12]
    188a:	681a      	ldr	r2, [r3, #0]
    188c:	68fb      	ldr	r3, [r7, #12]
    188e:	685b      	ldr	r3, [r3, #4]
    1890:	4610      	mov	r0, r2
    1892:	4619      	mov	r1, r3
    1894:	4a0a      	ldr	r2, [pc, #40]	; (18c0 <do_gethostbyname+0x48>)
    1896:	68fb      	ldr	r3, [r7, #12]
    1898:	f7ff fffe 	bl	0 <dns_gethostbyname>
			1898: R_ARM_THM_CALL	dns_gethostbyname
    189c:	4603      	mov	r3, r0
    189e:	7023      	strb	r3, [r4, #0]
  if (*msg->err != ERR_INPROGRESS) {
    18a0:	68fb      	ldr	r3, [r7, #12]
    18a2:	68db      	ldr	r3, [r3, #12]
    18a4:	781b      	ldrb	r3, [r3, #0]
    18a6:	b25b      	sxtb	r3, r3
    18a8:	f113 0f05 	cmn.w	r3, #5
    18ac:	d004      	beq.n	18b8 <do_gethostbyname+0x40>
    /* on error or immediate success, wake up the application
     * task waiting in netconn_gethostbyname */
    sys_sem_signal(msg->sem);
    18ae:	68fb      	ldr	r3, [r7, #12]
    18b0:	689b      	ldr	r3, [r3, #8]
    18b2:	4618      	mov	r0, r3
    18b4:	f7ff fffe 	bl	0 <sys_sem_signal>
			18b4: R_ARM_THM_CALL	sys_sem_signal
  }
}
    18b8:	f107 0714 	add.w	r7, r7, #20
    18bc:	46bd      	mov	sp, r7
    18be:	bd90      	pop	{r4, r7, pc}
    18c0:	00000000 	.word	0x00000000
			18c0: R_ARM_ABS32	do_dns_found

err.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  20300 Jul 30 19:07 2021 err.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 0000002a  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000057  00000000  00000000  0000005e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000193  00000000  00000000  000000b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 00004755  00000000  00000000  00000248  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubtypes 00000012  00000000  00000000  0000499d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000b1  00000000  00000000  000049af  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002b  00000000  00000000  00004a60  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  00004a8b  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 err.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes



netbuf.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  39696 Jul 30 19:07 2021 netbuf.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002dc  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000310  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000310  2**0
                  ALLOC
  3 .debug_abbrev 00000101  00000000  00000000  00000310  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000043c  00000000  00000000  00000411  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000503  00000000  00000000  0000084d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 000079e7  00000000  00000000  00000d50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000001f8  00000000  00000000  00008737  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000a5  00000000  00000000  0000892f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000070  00000000  00000000  000089d4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00008a44  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    0000032e  00000000  00000000  00008a64  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00008d92  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00008dbd  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000124  00000000  00000000  00008df0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 netbuf.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	0000005a netbuf_new
00000000         *UND*	00000000 memp_malloc
0000005c g     F .text	00000042 netbuf_delete
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 memp_free
000000a0 g     F .text	00000066 netbuf_alloc
00000000         *UND*	00000000 pbuf_alloc
00000108 g     F .text	00000038 netbuf_free
00000140 g     F .text	00000088 netbuf_ref
000001c8 g     F .text	00000040 netbuf_chain
00000000         *UND*	00000000 pbuf_cat
00000208 g     F .text	00000064 netbuf_data
0000026c g     F .text	00000050 netbuf_next
000002bc g     F .text	00000020 netbuf_first



Disassembly of section .text:

00000000 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
   6:	f04f 0006 	mov.w	r0, #6
   a:	f7ff fffe 	bl	0 <memp_malloc>
			a: R_ARM_THM_CALL	memp_malloc
   e:	4603      	mov	r3, r0
  10:	607b      	str	r3, [r7, #4]
  if (buf != NULL) {
  12:	687b      	ldr	r3, [r7, #4]
  14:	2b00      	cmp	r3, #0
  16:	d019      	beq.n	4c <netbuf_new+0x4c>
    buf->p = NULL;
  18:	687b      	ldr	r3, [r7, #4]
  1a:	f04f 0200 	mov.w	r2, #0
  1e:	601a      	str	r2, [r3, #0]
    buf->ptr = NULL;
  20:	687b      	ldr	r3, [r7, #4]
  22:	f04f 0200 	mov.w	r2, #0
  26:	605a      	str	r2, [r3, #4]
    ip_addr_set_any(&buf->addr);
  28:	687b      	ldr	r3, [r7, #4]
  2a:	f04f 0200 	mov.w	r2, #0
  2e:	609a      	str	r2, [r3, #8]
    buf->port = 0;
  30:	687b      	ldr	r3, [r7, #4]
  32:	f04f 0200 	mov.w	r2, #0
  36:	819a      	strh	r2, [r3, #12]
#if LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY
#if LWIP_CHECKSUM_ON_COPY
    buf->flags = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
    buf->toport_chksum = 0;
  38:	687b      	ldr	r3, [r7, #4]
  3a:	f04f 0200 	mov.w	r2, #0
  3e:	81da      	strh	r2, [r3, #14]
#if LWIP_NETBUF_RECVINFO
    ip_addr_set_any(&buf->toaddr);
  40:	687b      	ldr	r3, [r7, #4]
  42:	f04f 0200 	mov.w	r2, #0
  46:	611a      	str	r2, [r3, #16]
#endif /* LWIP_NETBUF_RECVINFO */
#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
    return buf;
  48:	687b      	ldr	r3, [r7, #4]
  4a:	e001      	b.n	50 <netbuf_new+0x50>
  } else {
    return NULL;
  4c:	f04f 0300 	mov.w	r3, #0
  }
}
  50:	4618      	mov	r0, r3
  52:	f107 0708 	add.w	r7, r7, #8
  56:	46bd      	mov	sp, r7
  58:	bd80      	pop	{r7, pc}
  5a:	bf00      	nop

0000005c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  5c:	b580      	push	{r7, lr}
  5e:	b082      	sub	sp, #8
  60:	af00      	add	r7, sp, #0
  62:	6078      	str	r0, [r7, #4]
  if (buf != NULL) {
  64:	687b      	ldr	r3, [r7, #4]
  66:	2b00      	cmp	r3, #0
  68:	d015      	beq.n	96 <netbuf_delete+0x3a>
    if (buf->p != NULL) {
  6a:	687b      	ldr	r3, [r7, #4]
  6c:	681b      	ldr	r3, [r3, #0]
  6e:	2b00      	cmp	r3, #0
  70:	d00c      	beq.n	8c <netbuf_delete+0x30>
      pbuf_free(buf->p);
  72:	687b      	ldr	r3, [r7, #4]
  74:	681b      	ldr	r3, [r3, #0]
  76:	4618      	mov	r0, r3
  78:	f7ff fffe 	bl	0 <pbuf_free>
			78: R_ARM_THM_CALL	pbuf_free
      buf->p = buf->ptr = NULL;
  7c:	687b      	ldr	r3, [r7, #4]
  7e:	f04f 0200 	mov.w	r2, #0
  82:	605a      	str	r2, [r3, #4]
  84:	687b      	ldr	r3, [r7, #4]
  86:	685a      	ldr	r2, [r3, #4]
  88:	687b      	ldr	r3, [r7, #4]
  8a:	601a      	str	r2, [r3, #0]
    }
    memp_free(MEMP_NETBUF, buf);
  8c:	f04f 0006 	mov.w	r0, #6
  90:	6879      	ldr	r1, [r7, #4]
  92:	f7ff fffe 	bl	0 <memp_free>
			92: R_ARM_THM_CALL	memp_free
  }
}
  96:	f107 0708 	add.w	r7, r7, #8
  9a:	46bd      	mov	sp, r7
  9c:	bd80      	pop	{r7, pc}
  9e:	bf00      	nop

000000a0 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  a0:	b580      	push	{r7, lr}
  a2:	b082      	sub	sp, #8
  a4:	af00      	add	r7, sp, #0
  a6:	6078      	str	r0, [r7, #4]
  a8:	460b      	mov	r3, r1
  aa:	807b      	strh	r3, [r7, #2]
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  ac:	687b      	ldr	r3, [r7, #4]
  ae:	2b00      	cmp	r3, #0
  b0:	d102      	bne.n	b8 <netbuf_alloc+0x18>
  b2:	f04f 0300 	mov.w	r3, #0
  b6:	e021      	b.n	fc <netbuf_alloc+0x5c>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  b8:	687b      	ldr	r3, [r7, #4]
  ba:	681b      	ldr	r3, [r3, #0]
  bc:	2b00      	cmp	r3, #0
  be:	d004      	beq.n	ca <netbuf_alloc+0x2a>
    pbuf_free(buf->p);
  c0:	687b      	ldr	r3, [r7, #4]
  c2:	681b      	ldr	r3, [r3, #0]
  c4:	4618      	mov	r0, r3
  c6:	f7ff fffe 	bl	0 <pbuf_free>
			c6: R_ARM_THM_CALL	pbuf_free
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  ca:	887b      	ldrh	r3, [r7, #2]
  cc:	f04f 0000 	mov.w	r0, #0
  d0:	4619      	mov	r1, r3
  d2:	f04f 0200 	mov.w	r2, #0
  d6:	f7ff fffe 	bl	0 <pbuf_alloc>
			d6: R_ARM_THM_CALL	pbuf_alloc
  da:	4602      	mov	r2, r0
  dc:	687b      	ldr	r3, [r7, #4]
  de:	601a      	str	r2, [r3, #0]
  if (buf->p == NULL) {
  e0:	687b      	ldr	r3, [r7, #4]
  e2:	681b      	ldr	r3, [r3, #0]
  e4:	2b00      	cmp	r3, #0
  e6:	d102      	bne.n	ee <netbuf_alloc+0x4e>
     return NULL;
  e8:	f04f 0300 	mov.w	r3, #0
  ec:	e006      	b.n	fc <netbuf_alloc+0x5c>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  ee:	687b      	ldr	r3, [r7, #4]
  f0:	681a      	ldr	r2, [r3, #0]
  f2:	687b      	ldr	r3, [r7, #4]
  f4:	605a      	str	r2, [r3, #4]
  return buf->p->payload;
  f6:	687b      	ldr	r3, [r7, #4]
  f8:	681b      	ldr	r3, [r3, #0]
  fa:	685b      	ldr	r3, [r3, #4]
}
  fc:	4618      	mov	r0, r3
  fe:	f107 0708 	add.w	r7, r7, #8
 102:	46bd      	mov	sp, r7
 104:	bd80      	pop	{r7, pc}
 106:	bf00      	nop

00000108 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
 108:	b580      	push	{r7, lr}
 10a:	b082      	sub	sp, #8
 10c:	af00      	add	r7, sp, #0
 10e:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 110:	687b      	ldr	r3, [r7, #4]
 112:	2b00      	cmp	r3, #0
 114:	d010      	beq.n	138 <netbuf_free+0x30>
  if (buf->p != NULL) {
 116:	687b      	ldr	r3, [r7, #4]
 118:	681b      	ldr	r3, [r3, #0]
 11a:	2b00      	cmp	r3, #0
 11c:	d004      	beq.n	128 <netbuf_free+0x20>
    pbuf_free(buf->p);
 11e:	687b      	ldr	r3, [r7, #4]
 120:	681b      	ldr	r3, [r3, #0]
 122:	4618      	mov	r0, r3
 124:	f7ff fffe 	bl	0 <pbuf_free>
			124: R_ARM_THM_CALL	pbuf_free
  }
  buf->p = buf->ptr = NULL;
 128:	687b      	ldr	r3, [r7, #4]
 12a:	f04f 0200 	mov.w	r2, #0
 12e:	605a      	str	r2, [r3, #4]
 130:	687b      	ldr	r3, [r7, #4]
 132:	685a      	ldr	r2, [r3, #4]
 134:	687b      	ldr	r3, [r7, #4]
 136:	601a      	str	r2, [r3, #0]
}
 138:	f107 0708 	add.w	r7, r7, #8
 13c:	46bd      	mov	sp, r7
 13e:	bd80      	pop	{r7, pc}

00000140 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
 140:	b580      	push	{r7, lr}
 142:	b084      	sub	sp, #16
 144:	af00      	add	r7, sp, #0
 146:	60f8      	str	r0, [r7, #12]
 148:	60b9      	str	r1, [r7, #8]
 14a:	4613      	mov	r3, r2
 14c:	80fb      	strh	r3, [r7, #6]
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 14e:	68fb      	ldr	r3, [r7, #12]
 150:	2b00      	cmp	r3, #0
 152:	d102      	bne.n	15a <netbuf_ref+0x1a>
 154:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 158:	e030      	b.n	1bc <netbuf_ref+0x7c>
  if (buf->p != NULL) {
 15a:	68fb      	ldr	r3, [r7, #12]
 15c:	681b      	ldr	r3, [r3, #0]
 15e:	2b00      	cmp	r3, #0
 160:	d004      	beq.n	16c <netbuf_ref+0x2c>
    pbuf_free(buf->p);
 162:	68fb      	ldr	r3, [r7, #12]
 164:	681b      	ldr	r3, [r3, #0]
 166:	4618      	mov	r0, r3
 168:	f7ff fffe 	bl	0 <pbuf_free>
			168: R_ARM_THM_CALL	pbuf_free
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 16c:	f04f 0000 	mov.w	r0, #0
 170:	f04f 0100 	mov.w	r1, #0
 174:	f04f 0202 	mov.w	r2, #2
 178:	f7ff fffe 	bl	0 <pbuf_alloc>
			178: R_ARM_THM_CALL	pbuf_alloc
 17c:	4602      	mov	r2, r0
 17e:	68fb      	ldr	r3, [r7, #12]
 180:	601a      	str	r2, [r3, #0]
  if (buf->p == NULL) {
 182:	68fb      	ldr	r3, [r7, #12]
 184:	681b      	ldr	r3, [r3, #0]
 186:	2b00      	cmp	r3, #0
 188:	d106      	bne.n	198 <netbuf_ref+0x58>
    buf->ptr = NULL;
 18a:	68fb      	ldr	r3, [r7, #12]
 18c:	f04f 0200 	mov.w	r2, #0
 190:	605a      	str	r2, [r3, #4]
    return ERR_MEM;
 192:	f04f 03ff 	mov.w	r3, #255	; 0xff
 196:	e011      	b.n	1bc <netbuf_ref+0x7c>
  }
  buf->p->payload = (void*)dataptr;
 198:	68fb      	ldr	r3, [r7, #12]
 19a:	681b      	ldr	r3, [r3, #0]
 19c:	68ba      	ldr	r2, [r7, #8]
 19e:	605a      	str	r2, [r3, #4]
  buf->p->len = buf->p->tot_len = size;
 1a0:	68fb      	ldr	r3, [r7, #12]
 1a2:	681a      	ldr	r2, [r3, #0]
 1a4:	68fb      	ldr	r3, [r7, #12]
 1a6:	681b      	ldr	r3, [r3, #0]
 1a8:	88f9      	ldrh	r1, [r7, #6]
 1aa:	8119      	strh	r1, [r3, #8]
 1ac:	891b      	ldrh	r3, [r3, #8]
 1ae:	8153      	strh	r3, [r2, #10]
  buf->ptr = buf->p;
 1b0:	68fb      	ldr	r3, [r7, #12]
 1b2:	681a      	ldr	r2, [r3, #0]
 1b4:	68fb      	ldr	r3, [r7, #12]
 1b6:	605a      	str	r2, [r3, #4]
  return ERR_OK;
 1b8:	f04f 0300 	mov.w	r3, #0
 1bc:	b25b      	sxtb	r3, r3
}
 1be:	4618      	mov	r0, r3
 1c0:	f107 0710 	add.w	r7, r7, #16
 1c4:	46bd      	mov	sp, r7
 1c6:	bd80      	pop	{r7, pc}

000001c8 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
 1c8:	b580      	push	{r7, lr}
 1ca:	b082      	sub	sp, #8
 1cc:	af00      	add	r7, sp, #0
 1ce:	6078      	str	r0, [r7, #4]
 1d0:	6039      	str	r1, [r7, #0]
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
 1d2:	687b      	ldr	r3, [r7, #4]
 1d4:	2b00      	cmp	r3, #0
 1d6:	d013      	beq.n	200 <netbuf_chain+0x38>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 1d8:	683b      	ldr	r3, [r7, #0]
 1da:	2b00      	cmp	r3, #0
 1dc:	d010      	beq.n	200 <netbuf_chain+0x38>
  pbuf_cat(head->p, tail->p);
 1de:	687b      	ldr	r3, [r7, #4]
 1e0:	681a      	ldr	r2, [r3, #0]
 1e2:	683b      	ldr	r3, [r7, #0]
 1e4:	681b      	ldr	r3, [r3, #0]
 1e6:	4610      	mov	r0, r2
 1e8:	4619      	mov	r1, r3
 1ea:	f7ff fffe 	bl	0 <pbuf_cat>
			1ea: R_ARM_THM_CALL	pbuf_cat
  head->ptr = head->p;
 1ee:	687b      	ldr	r3, [r7, #4]
 1f0:	681a      	ldr	r2, [r3, #0]
 1f2:	687b      	ldr	r3, [r7, #4]
 1f4:	605a      	str	r2, [r3, #4]
  memp_free(MEMP_NETBUF, tail);
 1f6:	f04f 0006 	mov.w	r0, #6
 1fa:	6839      	ldr	r1, [r7, #0]
 1fc:	f7ff fffe 	bl	0 <memp_free>
			1fc: R_ARM_THM_CALL	memp_free
}
 200:	f107 0708 	add.w	r7, r7, #8
 204:	46bd      	mov	sp, r7
 206:	bd80      	pop	{r7, pc}

00000208 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 208:	b480      	push	{r7}
 20a:	b085      	sub	sp, #20
 20c:	af00      	add	r7, sp, #0
 20e:	60f8      	str	r0, [r7, #12]
 210:	60b9      	str	r1, [r7, #8]
 212:	607a      	str	r2, [r7, #4]
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 214:	68fb      	ldr	r3, [r7, #12]
 216:	2b00      	cmp	r3, #0
 218:	d102      	bne.n	220 <netbuf_data+0x18>
 21a:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 21e:	e01e      	b.n	25e <netbuf_data+0x56>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 220:	68bb      	ldr	r3, [r7, #8]
 222:	2b00      	cmp	r3, #0
 224:	d102      	bne.n	22c <netbuf_data+0x24>
 226:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 22a:	e018      	b.n	25e <netbuf_data+0x56>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 22c:	687b      	ldr	r3, [r7, #4]
 22e:	2b00      	cmp	r3, #0
 230:	d102      	bne.n	238 <netbuf_data+0x30>
 232:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 236:	e012      	b.n	25e <netbuf_data+0x56>

  if (buf->ptr == NULL) {
 238:	68fb      	ldr	r3, [r7, #12]
 23a:	685b      	ldr	r3, [r3, #4]
 23c:	2b00      	cmp	r3, #0
 23e:	d102      	bne.n	246 <netbuf_data+0x3e>
    return ERR_BUF;
 240:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 244:	e00b      	b.n	25e <netbuf_data+0x56>
  }
  *dataptr = buf->ptr->payload;
 246:	68fb      	ldr	r3, [r7, #12]
 248:	685b      	ldr	r3, [r3, #4]
 24a:	685a      	ldr	r2, [r3, #4]
 24c:	68bb      	ldr	r3, [r7, #8]
 24e:	601a      	str	r2, [r3, #0]
  *len = buf->ptr->len;
 250:	68fb      	ldr	r3, [r7, #12]
 252:	685b      	ldr	r3, [r3, #4]
 254:	895a      	ldrh	r2, [r3, #10]
 256:	687b      	ldr	r3, [r7, #4]
 258:	801a      	strh	r2, [r3, #0]
  return ERR_OK;
 25a:	f04f 0300 	mov.w	r3, #0
 25e:	b25b      	sxtb	r3, r3
}
 260:	4618      	mov	r0, r3
 262:	f107 0714 	add.w	r7, r7, #20
 266:	46bd      	mov	sp, r7
 268:	bc80      	pop	{r7}
 26a:	4770      	bx	lr

0000026c <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
 26c:	b480      	push	{r7}
 26e:	b083      	sub	sp, #12
 270:	af00      	add	r7, sp, #0
 272:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 274:	687b      	ldr	r3, [r7, #4]
 276:	2b00      	cmp	r3, #0
 278:	d102      	bne.n	280 <netbuf_next+0x14>
 27a:	f04f 03ff 	mov.w	r3, #255	; 0xff
 27e:	e016      	b.n	2ae <netbuf_next+0x42>
  if (buf->ptr->next == NULL) {
 280:	687b      	ldr	r3, [r7, #4]
 282:	685b      	ldr	r3, [r3, #4]
 284:	681b      	ldr	r3, [r3, #0]
 286:	2b00      	cmp	r3, #0
 288:	d102      	bne.n	290 <netbuf_next+0x24>
    return -1;
 28a:	f04f 03ff 	mov.w	r3, #255	; 0xff
 28e:	e00e      	b.n	2ae <netbuf_next+0x42>
  }
  buf->ptr = buf->ptr->next;
 290:	687b      	ldr	r3, [r7, #4]
 292:	685b      	ldr	r3, [r3, #4]
 294:	681a      	ldr	r2, [r3, #0]
 296:	687b      	ldr	r3, [r7, #4]
 298:	605a      	str	r2, [r3, #4]
  if (buf->ptr->next == NULL) {
 29a:	687b      	ldr	r3, [r7, #4]
 29c:	685b      	ldr	r3, [r3, #4]
 29e:	681b      	ldr	r3, [r3, #0]
 2a0:	2b00      	cmp	r3, #0
 2a2:	d102      	bne.n	2aa <netbuf_next+0x3e>
    return 1;
 2a4:	f04f 0301 	mov.w	r3, #1
 2a8:	e001      	b.n	2ae <netbuf_next+0x42>
  }
  return 0;
 2aa:	f04f 0300 	mov.w	r3, #0
 2ae:	b25b      	sxtb	r3, r3
}
 2b0:	4618      	mov	r0, r3
 2b2:	f107 070c 	add.w	r7, r7, #12
 2b6:	46bd      	mov	sp, r7
 2b8:	bc80      	pop	{r7}
 2ba:	4770      	bx	lr

000002bc <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
 2bc:	b480      	push	{r7}
 2be:	b083      	sub	sp, #12
 2c0:	af00      	add	r7, sp, #0
 2c2:	6078      	str	r0, [r7, #4]
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 2c4:	687b      	ldr	r3, [r7, #4]
 2c6:	2b00      	cmp	r3, #0
 2c8:	d003      	beq.n	2d2 <netbuf_first+0x16>
  buf->ptr = buf->p;
 2ca:	687b      	ldr	r3, [r7, #4]
 2cc:	681a      	ldr	r2, [r3, #0]
 2ce:	687b      	ldr	r3, [r7, #4]
 2d0:	605a      	str	r2, [r3, #4]
}
 2d2:	f107 070c 	add.w	r7, r7, #12
 2d6:	46bd      	mov	sp, r7
 2d8:	bc80      	pop	{r7}
 2da:	4770      	bx	lr

netdb.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  63164 Jul 30 19:07 2021 netdb.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000035c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000390  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000024  00000000  00000000  00000390  2**2
                  ALLOC
  3 .debug_abbrev 0000017d  00000000  00000000  00000390  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000603  00000000  00000000  0000050d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000070c  00000000  00000000  00000b10  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000cfb1  00000000  00000000  0000121c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000000e0  00000000  00000000  0000e1cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000079  00000000  00000000  0000e2ad  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000000ef  00000000  00000000  0000e326  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000e415  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000454  00000000  00000000  0000e435  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000e889  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000e8b4  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000090  00000000  00000000  0000e8e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 netdb.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 s_hostent_addr.5468
00000004 l       .bss	00000000 s_phostent_addr.5469
0000000c l       .bss	00000000 s_hostent.5466
00000020 l       .bss	00000000 s_aliases.5467
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 h_errno
00000000 g     F .text	00000084 lwip_gethostbyname
00000000         *UND*	00000000 netconn_gethostbyname
00000084 g     F .text	00000122 lwip_gethostbyname_r
00000000         *UND*	00000000 strlen
00000000         *UND*	00000000 memcpy
000001a8 g     F .text	0000002c lwip_freeaddrinfo
00000000         *UND*	00000000 memp_free
000001d4 g     F .text	00000188 lwip_getaddrinfo
00000000         *UND*	00000000 atoi
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 memset
00000000         *UND*	00000000 lwip_htons



Disassembly of section .text:

00000000 <lwip_gethostbyname>:
 * @return an entry containing addresses of address family AF_INET
 *         for the host with name name
 */
struct hostent*
lwip_gethostbyname(const char *name)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
  HOSTENT_STORAGE char *s_aliases;
  HOSTENT_STORAGE ip_addr_t s_hostent_addr;
  HOSTENT_STORAGE ip_addr_t *s_phostent_addr[2];

  /* query host IP address */
  err = netconn_gethostbyname(name, &addr);
   8:	f107 0308 	add.w	r3, r7, #8
   c:	6878      	ldr	r0, [r7, #4]
   e:	4619      	mov	r1, r3
  10:	f7ff fffe 	bl	0 <netconn_gethostbyname>
			10: R_ARM_THM_CALL	netconn_gethostbyname
  14:	4603      	mov	r3, r0
  16:	73fb      	strb	r3, [r7, #15]
  if (err != ERR_OK) {
  18:	f997 300f 	ldrsb.w	r3, [r7, #15]
  1c:	2b00      	cmp	r3, #0
  1e:	d006      	beq.n	2e <lwip_gethostbyname+0x2e>
    LWIP_DEBUGF(DNS_DEBUG, ("lwip_gethostbyname(%s) failed, err=%d\n", name, err));
    h_errno = HOST_NOT_FOUND;
  20:	4b13      	ldr	r3, [pc, #76]	; (70 <lwip_gethostbyname+0x70>)
  22:	f04f 02d2 	mov.w	r2, #210	; 0xd2
  26:	601a      	str	r2, [r3, #0]
    return NULL;
  28:	f04f 0300 	mov.w	r3, #0
  2c:	e01b      	b.n	66 <lwip_gethostbyname+0x66>
  }

  /* fill hostent */
  s_hostent_addr = addr;
  2e:	4b11      	ldr	r3, [pc, #68]	; (74 <lwip_gethostbyname+0x74>)
  30:	68ba      	ldr	r2, [r7, #8]
  32:	601a      	str	r2, [r3, #0]
  s_phostent_addr[0] = &s_hostent_addr;
  34:	4b10      	ldr	r3, [pc, #64]	; (78 <lwip_gethostbyname+0x78>)
  36:	4a0f      	ldr	r2, [pc, #60]	; (74 <lwip_gethostbyname+0x74>)
  38:	601a      	str	r2, [r3, #0]
  s_phostent_addr[1] = NULL;
  3a:	4b0f      	ldr	r3, [pc, #60]	; (78 <lwip_gethostbyname+0x78>)
  3c:	f04f 0200 	mov.w	r2, #0
  40:	605a      	str	r2, [r3, #4]
  s_hostent.h_name = (char*)name;
  42:	4b0e      	ldr	r3, [pc, #56]	; (7c <lwip_gethostbyname+0x7c>)
  44:	687a      	ldr	r2, [r7, #4]
  46:	601a      	str	r2, [r3, #0]
  s_hostent.h_aliases = &s_aliases;
  48:	4b0c      	ldr	r3, [pc, #48]	; (7c <lwip_gethostbyname+0x7c>)
  4a:	4a0d      	ldr	r2, [pc, #52]	; (80 <lwip_gethostbyname+0x80>)
  4c:	605a      	str	r2, [r3, #4]
  s_hostent.h_addrtype = AF_INET;
  4e:	4b0b      	ldr	r3, [pc, #44]	; (7c <lwip_gethostbyname+0x7c>)
  50:	f04f 0202 	mov.w	r2, #2
  54:	609a      	str	r2, [r3, #8]
  s_hostent.h_length = sizeof(ip_addr_t);
  56:	4b09      	ldr	r3, [pc, #36]	; (7c <lwip_gethostbyname+0x7c>)
  58:	f04f 0204 	mov.w	r2, #4
  5c:	60da      	str	r2, [r3, #12]
  s_hostent.h_addr_list = (char**)&s_phostent_addr;
  5e:	4a06      	ldr	r2, [pc, #24]	; (78 <lwip_gethostbyname+0x78>)
  60:	4b06      	ldr	r3, [pc, #24]	; (7c <lwip_gethostbyname+0x7c>)
  62:	611a      	str	r2, [r3, #16]

#if LWIP_DNS_API_HOSTENT_STORAGE
  /* this function should return the "per-thread" hostent after copy from s_hostent */
  return sys_thread_hostent(&s_hostent);
#else
  return &s_hostent;
  64:	4b05      	ldr	r3, [pc, #20]	; (7c <lwip_gethostbyname+0x7c>)
#endif /* LWIP_DNS_API_HOSTENT_STORAGE */
}
  66:	4618      	mov	r0, r3
  68:	f107 0710 	add.w	r7, r7, #16
  6c:	46bd      	mov	sp, r7
  6e:	bd80      	pop	{r7, pc}
	...
			70: R_ARM_ABS32	h_errno
			74: R_ARM_ABS32	.bss
  78:	00000004 	.word	0x00000004
			78: R_ARM_ABS32	.bss
  7c:	0000000c 	.word	0x0000000c
			7c: R_ARM_ABS32	.bss
  80:	00000020 	.word	0x00000020
			80: R_ARM_ABS32	.bss

00000084 <lwip_gethostbyname_r>:
 *         is stored in *h_errnop instead of h_errno to be thread-safe
 */
int
lwip_gethostbyname_r(const char *name, struct hostent *ret, char *buf,
                size_t buflen, struct hostent **result, int *h_errnop)
{
  84:	b580      	push	{r7, lr}
  86:	b08a      	sub	sp, #40	; 0x28
  88:	af00      	add	r7, sp, #0
  8a:	60f8      	str	r0, [r7, #12]
  8c:	60b9      	str	r1, [r7, #8]
  8e:	607a      	str	r2, [r7, #4]
  90:	603b      	str	r3, [r7, #0]
  struct gethostbyname_r_helper *h;
  char *hostname;
  size_t namelen;
  int lh_errno;

  if (h_errnop == NULL) {
  92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  94:	2b00      	cmp	r3, #0
  96:	d102      	bne.n	9e <lwip_gethostbyname_r+0x1a>
    /* ensure h_errnop is never NULL */
    h_errnop = &lh_errno;
  98:	f107 0314 	add.w	r3, r7, #20
  9c:	637b      	str	r3, [r7, #52]	; 0x34
  }

  if (result == NULL) {
  9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  a0:	2b00      	cmp	r3, #0
  a2:	d106      	bne.n	b2 <lwip_gethostbyname_r+0x2e>
    /* not all arguments given */
    *h_errnop = EINVAL;
  a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  a6:	f04f 0216 	mov.w	r2, #22
  aa:	601a      	str	r2, [r3, #0]
    return -1;
  ac:	f04f 33ff 	mov.w	r3, #4294967295
  b0:	e074      	b.n	19c <lwip_gethostbyname_r+0x118>
  }
  /* first thing to do: set *result to nothing */
  *result = NULL;
  b2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  b4:	f04f 0200 	mov.w	r2, #0
  b8:	601a      	str	r2, [r3, #0]
  if ((name == NULL) || (ret == NULL) || (buf == NULL)) {
  ba:	68fb      	ldr	r3, [r7, #12]
  bc:	2b00      	cmp	r3, #0
  be:	d005      	beq.n	cc <lwip_gethostbyname_r+0x48>
  c0:	68bb      	ldr	r3, [r7, #8]
  c2:	2b00      	cmp	r3, #0
  c4:	d002      	beq.n	cc <lwip_gethostbyname_r+0x48>
  c6:	687b      	ldr	r3, [r7, #4]
  c8:	2b00      	cmp	r3, #0
  ca:	d106      	bne.n	da <lwip_gethostbyname_r+0x56>
    /* not all arguments given */
    *h_errnop = EINVAL;
  cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  ce:	f04f 0216 	mov.w	r2, #22
  d2:	601a      	str	r2, [r3, #0]
    return -1;
  d4:	f04f 33ff 	mov.w	r3, #4294967295
  d8:	e060      	b.n	19c <lwip_gethostbyname_r+0x118>
  }

  namelen = strlen(name);
  da:	68f8      	ldr	r0, [r7, #12]
  dc:	f7ff fffe 	bl	0 <strlen>
			dc: R_ARM_THM_CALL	strlen
  e0:	4603      	mov	r3, r0
  e2:	627b      	str	r3, [r7, #36]	; 0x24
  if (buflen < (sizeof(struct gethostbyname_r_helper) + namelen + 1 + (MEM_ALIGNMENT - 1))) {
  e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  e6:	f103 0214 	add.w	r2, r3, #20
  ea:	683b      	ldr	r3, [r7, #0]
  ec:	429a      	cmp	r2, r3
  ee:	d906      	bls.n	fe <lwip_gethostbyname_r+0x7a>
    /* buf can't hold the data needed + a copy of name */
    *h_errnop = ERANGE;
  f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  f2:	f04f 0222 	mov.w	r2, #34	; 0x22
  f6:	601a      	str	r2, [r3, #0]
    return -1;
  f8:	f04f 33ff 	mov.w	r3, #4294967295
  fc:	e04e      	b.n	19c <lwip_gethostbyname_r+0x118>
  }

  h = (struct gethostbyname_r_helper*)LWIP_MEM_ALIGN(buf);
  fe:	687b      	ldr	r3, [r7, #4]
 100:	f103 0303 	add.w	r3, r3, #3
 104:	f023 0303 	bic.w	r3, r3, #3
 108:	623b      	str	r3, [r7, #32]
  hostname = ((char*)h) + sizeof(struct gethostbyname_r_helper);
 10a:	6a3b      	ldr	r3, [r7, #32]
 10c:	f103 0310 	add.w	r3, r3, #16
 110:	61fb      	str	r3, [r7, #28]

  /* query host IP address */
  err = netconn_gethostbyname(name, &h->addr);
 112:	6a3b      	ldr	r3, [r7, #32]
 114:	f103 0308 	add.w	r3, r3, #8
 118:	68f8      	ldr	r0, [r7, #12]
 11a:	4619      	mov	r1, r3
 11c:	f7ff fffe 	bl	0 <netconn_gethostbyname>
			11c: R_ARM_THM_CALL	netconn_gethostbyname
 120:	4603      	mov	r3, r0
 122:	76fb      	strb	r3, [r7, #27]
  if (err != ERR_OK) {
 124:	f997 301b 	ldrsb.w	r3, [r7, #27]
 128:	2b00      	cmp	r3, #0
 12a:	d006      	beq.n	13a <lwip_gethostbyname_r+0xb6>
    LWIP_DEBUGF(DNS_DEBUG, ("lwip_gethostbyname(%s) failed, err=%d\n", name, err));
    *h_errnop = HOST_NOT_FOUND;
 12c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 12e:	f04f 02d2 	mov.w	r2, #210	; 0xd2
 132:	601a      	str	r2, [r3, #0]
    return -1;
 134:	f04f 33ff 	mov.w	r3, #4294967295
 138:	e030      	b.n	19c <lwip_gethostbyname_r+0x118>
  }

  /* copy the hostname into buf */
  MEMCPY(hostname, name, namelen);
 13a:	69f8      	ldr	r0, [r7, #28]
 13c:	68f9      	ldr	r1, [r7, #12]
 13e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 140:	f7ff fffe 	bl	0 <memcpy>
			140: R_ARM_THM_CALL	memcpy
  hostname[namelen] = 0;
 144:	69fa      	ldr	r2, [r7, #28]
 146:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 148:	18d3      	adds	r3, r2, r3
 14a:	f04f 0200 	mov.w	r2, #0
 14e:	701a      	strb	r2, [r3, #0]

  /* fill hostent */
  h->addr_list[0] = &h->addr;
 150:	6a3b      	ldr	r3, [r7, #32]
 152:	f103 0208 	add.w	r2, r3, #8
 156:	6a3b      	ldr	r3, [r7, #32]
 158:	601a      	str	r2, [r3, #0]
  h->addr_list[1] = NULL;
 15a:	6a3b      	ldr	r3, [r7, #32]
 15c:	f04f 0200 	mov.w	r2, #0
 160:	605a      	str	r2, [r3, #4]
  h->aliases = NULL;
 162:	6a3b      	ldr	r3, [r7, #32]
 164:	f04f 0200 	mov.w	r2, #0
 168:	60da      	str	r2, [r3, #12]
  ret->h_name = hostname;
 16a:	68bb      	ldr	r3, [r7, #8]
 16c:	69fa      	ldr	r2, [r7, #28]
 16e:	601a      	str	r2, [r3, #0]
  ret->h_aliases = &h->aliases;
 170:	6a3b      	ldr	r3, [r7, #32]
 172:	f103 020c 	add.w	r2, r3, #12
 176:	68bb      	ldr	r3, [r7, #8]
 178:	605a      	str	r2, [r3, #4]
  ret->h_addrtype = AF_INET;
 17a:	68bb      	ldr	r3, [r7, #8]
 17c:	f04f 0202 	mov.w	r2, #2
 180:	609a      	str	r2, [r3, #8]
  ret->h_length = sizeof(ip_addr_t);
 182:	68bb      	ldr	r3, [r7, #8]
 184:	f04f 0204 	mov.w	r2, #4
 188:	60da      	str	r2, [r3, #12]
  ret->h_addr_list = (char**)&h->addr_list;
 18a:	6a3b      	ldr	r3, [r7, #32]
 18c:	461a      	mov	r2, r3
 18e:	68bb      	ldr	r3, [r7, #8]
 190:	611a      	str	r2, [r3, #16]

  /* set result != NULL */
  *result = ret;
 192:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 194:	68ba      	ldr	r2, [r7, #8]
 196:	601a      	str	r2, [r3, #0]

  /* return success */
  return 0;
 198:	f04f 0300 	mov.w	r3, #0
}
 19c:	4618      	mov	r0, r3
 19e:	f107 0728 	add.w	r7, r7, #40	; 0x28
 1a2:	46bd      	mov	sp, r7
 1a4:	bd80      	pop	{r7, pc}
 1a6:	bf00      	nop

000001a8 <lwip_freeaddrinfo>:
 *
 * @param ai struct addrinfo to free
 */
void
lwip_freeaddrinfo(struct addrinfo *ai)
{
 1a8:	b580      	push	{r7, lr}
 1aa:	b084      	sub	sp, #16
 1ac:	af00      	add	r7, sp, #0
 1ae:	6078      	str	r0, [r7, #4]
  struct addrinfo *next;

  while (ai != NULL) {
 1b0:	e009      	b.n	1c6 <lwip_freeaddrinfo+0x1e>
    next = ai->ai_next;
 1b2:	687b      	ldr	r3, [r7, #4]
 1b4:	69db      	ldr	r3, [r3, #28]
 1b6:	60fb      	str	r3, [r7, #12]
    memp_free(MEMP_NETDB, ai);
 1b8:	f04f 000d 	mov.w	r0, #13
 1bc:	6879      	ldr	r1, [r7, #4]
 1be:	f7ff fffe 	bl	0 <memp_free>
			1be: R_ARM_THM_CALL	memp_free
    ai = next;
 1c2:	68fb      	ldr	r3, [r7, #12]
 1c4:	607b      	str	r3, [r7, #4]
void
lwip_freeaddrinfo(struct addrinfo *ai)
{
  struct addrinfo *next;

  while (ai != NULL) {
 1c6:	687b      	ldr	r3, [r7, #4]
 1c8:	2b00      	cmp	r3, #0
 1ca:	d1f2      	bne.n	1b2 <lwip_freeaddrinfo+0xa>
    next = ai->ai_next;
    memp_free(MEMP_NETDB, ai);
    ai = next;
  }
}
 1cc:	f107 0710 	add.w	r7, r7, #16
 1d0:	46bd      	mov	sp, r7
 1d2:	bd80      	pop	{r7, pc}

000001d4 <lwip_getaddrinfo>:
 * @return 0 on success, non-zero on failure
 */
int
lwip_getaddrinfo(const char *nodename, const char *servname,
       const struct addrinfo *hints, struct addrinfo **res)
{
 1d4:	b580      	push	{r7, lr}
 1d6:	b08c      	sub	sp, #48	; 0x30
 1d8:	af00      	add	r7, sp, #0
 1da:	60f8      	str	r0, [r7, #12]
 1dc:	60b9      	str	r1, [r7, #8]
 1de:	607a      	str	r2, [r7, #4]
 1e0:	603b      	str	r3, [r7, #0]
  err_t err;
  ip_addr_t addr;
  struct addrinfo *ai;
  struct sockaddr_in *sa = NULL;
 1e2:	f04f 0300 	mov.w	r3, #0
 1e6:	623b      	str	r3, [r7, #32]
  int port_nr = 0;
 1e8:	f04f 0300 	mov.w	r3, #0
 1ec:	62fb      	str	r3, [r7, #44]	; 0x2c
  size_t total_size;
  size_t namelen = 0;
 1ee:	f04f 0300 	mov.w	r3, #0
 1f2:	627b      	str	r3, [r7, #36]	; 0x24

  if (res == NULL) {
 1f4:	683b      	ldr	r3, [r7, #0]
 1f6:	2b00      	cmp	r3, #0
 1f8:	d102      	bne.n	200 <lwip_getaddrinfo+0x2c>
    return EAI_FAIL;
 1fa:	f04f 03ca 	mov.w	r3, #202	; 0xca
 1fe:	e0a6      	b.n	34e <lwip_getaddrinfo+0x17a>
  }
  *res = NULL;
 200:	683b      	ldr	r3, [r7, #0]
 202:	f04f 0200 	mov.w	r2, #0
 206:	601a      	str	r2, [r3, #0]
  if ((nodename == NULL) && (servname == NULL)) {
 208:	68fb      	ldr	r3, [r7, #12]
 20a:	2b00      	cmp	r3, #0
 20c:	d105      	bne.n	21a <lwip_getaddrinfo+0x46>
 20e:	68bb      	ldr	r3, [r7, #8]
 210:	2b00      	cmp	r3, #0
 212:	d102      	bne.n	21a <lwip_getaddrinfo+0x46>
    return EAI_NONAME;
 214:	f04f 03c8 	mov.w	r3, #200	; 0xc8
 218:	e099      	b.n	34e <lwip_getaddrinfo+0x17a>
  }

  if (servname != NULL) {
 21a:	68bb      	ldr	r3, [r7, #8]
 21c:	2b00      	cmp	r3, #0
 21e:	d00e      	beq.n	23e <lwip_getaddrinfo+0x6a>
    /* service name specified: convert to port number
     * @todo?: currently, only ASCII integers (port numbers) are supported! */
    port_nr = atoi(servname);
 220:	68b8      	ldr	r0, [r7, #8]
 222:	f7ff fffe 	bl	0 <atoi>
			222: R_ARM_THM_CALL	atoi
 226:	62f8      	str	r0, [r7, #44]	; 0x2c
    if ((port_nr <= 0) || (port_nr > 0xffff)) {
 228:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 22a:	2b00      	cmp	r3, #0
 22c:	dd04      	ble.n	238 <lwip_getaddrinfo+0x64>
 22e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 230:	f64f 73ff 	movw	r3, #65535	; 0xffff
 234:	429a      	cmp	r2, r3
 236:	dd02      	ble.n	23e <lwip_getaddrinfo+0x6a>
      return EAI_SERVICE;
 238:	f04f 03c9 	mov.w	r3, #201	; 0xc9
 23c:	e087      	b.n	34e <lwip_getaddrinfo+0x17a>
    }
  }

  if (nodename != NULL) {
 23e:	68fb      	ldr	r3, [r7, #12]
 240:	2b00      	cmp	r3, #0
 242:	d00e      	beq.n	262 <lwip_getaddrinfo+0x8e>
    /* service location specified, try to resolve */
    err = netconn_gethostbyname(nodename, &addr);
 244:	f107 0314 	add.w	r3, r7, #20
 248:	68f8      	ldr	r0, [r7, #12]
 24a:	4619      	mov	r1, r3
 24c:	f7ff fffe 	bl	0 <netconn_gethostbyname>
			24c: R_ARM_THM_CALL	netconn_gethostbyname
 250:	4603      	mov	r3, r0
 252:	77fb      	strb	r3, [r7, #31]
    if (err != ERR_OK) {
 254:	f997 301f 	ldrsb.w	r3, [r7, #31]
 258:	2b00      	cmp	r3, #0
 25a:	d004      	beq.n	266 <lwip_getaddrinfo+0x92>
      return EAI_FAIL;
 25c:	f04f 03ca 	mov.w	r3, #202	; 0xca
 260:	e075      	b.n	34e <lwip_getaddrinfo+0x17a>
    }
  } else {
    /* service location specified, use loopback address */
    ip_addr_set_loopback(&addr);
 262:	4b3d      	ldr	r3, [pc, #244]	; (358 <lwip_getaddrinfo+0x184>)
 264:	617b      	str	r3, [r7, #20]
  }

  total_size = sizeof(struct addrinfo) + sizeof(struct sockaddr_in);
 266:	f04f 0330 	mov.w	r3, #48	; 0x30
 26a:	62bb      	str	r3, [r7, #40]	; 0x28
  if (nodename != NULL) {
 26c:	68fb      	ldr	r3, [r7, #12]
 26e:	2b00      	cmp	r3, #0
 270:	d009      	beq.n	286 <lwip_getaddrinfo+0xb2>
    namelen = strlen(nodename);
 272:	68f8      	ldr	r0, [r7, #12]
 274:	f7ff fffe 	bl	0 <strlen>
			274: R_ARM_THM_CALL	strlen
 278:	6278      	str	r0, [r7, #36]	; 0x24
    LWIP_ASSERT("namelen is too long", (namelen + 1) <= (mem_size_t)-1);
    total_size += namelen + 1;
 27a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 27c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 27e:	18d3      	adds	r3, r2, r3
 280:	f103 0301 	add.w	r3, r3, #1
 284:	62bb      	str	r3, [r7, #40]	; 0x28
  }
  /* If this fails, please report to lwip-devel! :-) */
  LWIP_ASSERT("total_size <= NETDB_ELEM_SIZE: please report this!",
    total_size <= NETDB_ELEM_SIZE);
  ai = (struct addrinfo *)memp_malloc(MEMP_NETDB);
 286:	f04f 000d 	mov.w	r0, #13
 28a:	f7ff fffe 	bl	0 <memp_malloc>
			28a: R_ARM_THM_CALL	memp_malloc
 28e:	4603      	mov	r3, r0
 290:	61bb      	str	r3, [r7, #24]
  if (ai == NULL) {
 292:	69bb      	ldr	r3, [r7, #24]
 294:	2b00      	cmp	r3, #0
 296:	d04f      	beq.n	338 <lwip_getaddrinfo+0x164>
    goto memerr;
  }
  memset(ai, 0, total_size);
 298:	69b8      	ldr	r0, [r7, #24]
 29a:	f04f 0100 	mov.w	r1, #0
 29e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 2a0:	f7ff fffe 	bl	0 <memset>
			2a0: R_ARM_THM_CALL	memset
  sa = (struct sockaddr_in*)((u8_t*)ai + sizeof(struct addrinfo));
 2a4:	69bb      	ldr	r3, [r7, #24]
 2a6:	f103 0320 	add.w	r3, r3, #32
 2aa:	623b      	str	r3, [r7, #32]
  /* set up sockaddr */
  inet_addr_from_ipaddr(&sa->sin_addr, &addr);
 2ac:	697a      	ldr	r2, [r7, #20]
 2ae:	6a3b      	ldr	r3, [r7, #32]
 2b0:	605a      	str	r2, [r3, #4]
  sa->sin_family = AF_INET;
 2b2:	6a3b      	ldr	r3, [r7, #32]
 2b4:	f04f 0202 	mov.w	r2, #2
 2b8:	705a      	strb	r2, [r3, #1]
  sa->sin_len = sizeof(struct sockaddr_in);
 2ba:	6a3b      	ldr	r3, [r7, #32]
 2bc:	f04f 0210 	mov.w	r2, #16
 2c0:	701a      	strb	r2, [r3, #0]
  sa->sin_port = htons((u16_t)port_nr);
 2c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 2c4:	b29b      	uxth	r3, r3
 2c6:	4618      	mov	r0, r3
 2c8:	f7ff fffe 	bl	0 <lwip_htons>
			2c8: R_ARM_THM_CALL	lwip_htons
 2cc:	4603      	mov	r3, r0
 2ce:	461a      	mov	r2, r3
 2d0:	6a3b      	ldr	r3, [r7, #32]
 2d2:	805a      	strh	r2, [r3, #2]

  /* set up addrinfo */
  ai->ai_family = AF_INET;
 2d4:	69bb      	ldr	r3, [r7, #24]
 2d6:	f04f 0202 	mov.w	r2, #2
 2da:	605a      	str	r2, [r3, #4]
  if (hints != NULL) {
 2dc:	687b      	ldr	r3, [r7, #4]
 2de:	2b00      	cmp	r3, #0
 2e0:	d007      	beq.n	2f2 <lwip_getaddrinfo+0x11e>
    /* copy socktype & protocol from hints if specified */
    ai->ai_socktype = hints->ai_socktype;
 2e2:	687b      	ldr	r3, [r7, #4]
 2e4:	689a      	ldr	r2, [r3, #8]
 2e6:	69bb      	ldr	r3, [r7, #24]
 2e8:	609a      	str	r2, [r3, #8]
    ai->ai_protocol = hints->ai_protocol;
 2ea:	687b      	ldr	r3, [r7, #4]
 2ec:	68da      	ldr	r2, [r3, #12]
 2ee:	69bb      	ldr	r3, [r7, #24]
 2f0:	60da      	str	r2, [r3, #12]
  }
  if (nodename != NULL) {
 2f2:	68fb      	ldr	r3, [r7, #12]
 2f4:	2b00      	cmp	r3, #0
 2f6:	d012      	beq.n	31e <lwip_getaddrinfo+0x14a>
    /* copy nodename to canonname if specified */
    ai->ai_canonname = ((char*)ai + sizeof(struct addrinfo) + sizeof(struct sockaddr_in));
 2f8:	69bb      	ldr	r3, [r7, #24]
 2fa:	f103 0230 	add.w	r2, r3, #48	; 0x30
 2fe:	69bb      	ldr	r3, [r7, #24]
 300:	619a      	str	r2, [r3, #24]
    MEMCPY(ai->ai_canonname, nodename, namelen);
 302:	69bb      	ldr	r3, [r7, #24]
 304:	699b      	ldr	r3, [r3, #24]
 306:	4618      	mov	r0, r3
 308:	68f9      	ldr	r1, [r7, #12]
 30a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 30c:	f7ff fffe 	bl	0 <memcpy>
			30c: R_ARM_THM_CALL	memcpy
    ai->ai_canonname[namelen] = 0;
 310:	69bb      	ldr	r3, [r7, #24]
 312:	699a      	ldr	r2, [r3, #24]
 314:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 316:	18d3      	adds	r3, r2, r3
 318:	f04f 0200 	mov.w	r2, #0
 31c:	701a      	strb	r2, [r3, #0]
  }
  ai->ai_addrlen = sizeof(struct sockaddr_in);
 31e:	69bb      	ldr	r3, [r7, #24]
 320:	f04f 0210 	mov.w	r2, #16
 324:	611a      	str	r2, [r3, #16]
  ai->ai_addr = (struct sockaddr*)sa;
 326:	6a3a      	ldr	r2, [r7, #32]
 328:	69bb      	ldr	r3, [r7, #24]
 32a:	615a      	str	r2, [r3, #20]

  *res = ai;
 32c:	683b      	ldr	r3, [r7, #0]
 32e:	69ba      	ldr	r2, [r7, #24]
 330:	601a      	str	r2, [r3, #0]

  return 0;
 332:	f04f 0300 	mov.w	r3, #0
 336:	e00a      	b.n	34e <lwip_getaddrinfo+0x17a>
  /* If this fails, please report to lwip-devel! :-) */
  LWIP_ASSERT("total_size <= NETDB_ELEM_SIZE: please report this!",
    total_size <= NETDB_ELEM_SIZE);
  ai = (struct addrinfo *)memp_malloc(MEMP_NETDB);
  if (ai == NULL) {
    goto memerr;
 338:	bf00      	nop

  *res = ai;

  return 0;
memerr:
  if (ai != NULL) {
 33a:	69bb      	ldr	r3, [r7, #24]
 33c:	2b00      	cmp	r3, #0
 33e:	d004      	beq.n	34a <lwip_getaddrinfo+0x176>
    memp_free(MEMP_NETDB, ai);
 340:	f04f 000d 	mov.w	r0, #13
 344:	69b9      	ldr	r1, [r7, #24]
 346:	f7ff fffe 	bl	0 <memp_free>
			346: R_ARM_THM_CALL	memp_free
  }
  return EAI_MEMORY;
 34a:	f04f 03cb 	mov.w	r3, #203	; 0xcb
}
 34e:	4618      	mov	r0, r3
 350:	f107 0730 	add.w	r7, r7, #48	; 0x30
 354:	46bd      	mov	sp, r7
 356:	bd80      	pop	{r7, pc}
 358:	0100007f 	.word	0x0100007f

netifapi.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  19988 Jul 30 19:07 2021 netifapi.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 0000002a  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000057  00000000  00000000  0000005e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000018f  00000000  00000000  000000b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0000461b  00000000  00000000  00000244  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubtypes 00000012  00000000  00000000  0000485f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000b6  00000000  00000000  00004871  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002b  00000000  00000000  00004927  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  00004952  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 netifapi.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes



sockets.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  94512 Jul 30 19:07 2021 sockets.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002280  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000022b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000c8  00000000  00000000  000022b4  2**2
                  ALLOC
  3 .debug_abbrev 00000231  00000000  00000000  000022b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00001f96  00000000  00000000  000024e5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000d27  00000000  00000000  0000447b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000dbd7  00000000  00000000  000051a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000040  00000000  00000000  00012d7c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    0000068e  00000000  00000000  00012dbc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000172  00000000  00000000  0001344a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 000002bf  00000000  00000000  000135bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  0001387b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    00000bee  00000000  00000000  0001389b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  00014489  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  000144b4  2**0
                  CONTENTS, READONLY
 15 .debug_frame  000003c0  00000000  00000000  000144e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 sockets.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 sockets
000000c0 l       .bss	00000000 select_cb_list
000000c4 l       .bss	00000000 select_cb_ctr
00000000 l    d  .rodata	00000000 .rodata
00000000 l     O .rodata	00000040 err_to_errno_table
0000000c l     F .text	00000050 get_socket
0000005c l     F .text	0000005c tryget_socket
000000b8 l     F .text	00000154 alloc_socket
0000020c l     F .text	00000062 free_socket
0000135c l     F .text	0000022c event_callback
00000d90 l     F .text	0000023c lwip_selscan
00001678 l     F .text	0000009e lwip_getaddrname
000019ac l     F .text	00000220 lwip_getsockopt_internal
00001e38 l     F .text	0000025e lwip_setsockopt_internal
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	0000000a lwip_socket_init
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 netbuf_delete
00000270 g     F .text	000001f4 lwip_accept
00000000         *UND*	00000000 netconn_accept
00000000         *UND*	00000000 netconn_getaddr
00000000         *UND*	00000000 netconn_delete
00000000         *UND*	00000000 memset
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 memcpy
00000464 g     F .text	000000c4 lwip_bind
00000000         *UND*	00000000 lwip_ntohs
00000000         *UND*	00000000 netconn_bind
00000528 g     F .text	0000005a lwip_close
00000584 g     F .text	000000e0 lwip_connect
00000000         *UND*	00000000 netconn_disconnect
00000000         *UND*	00000000 netconn_connect
00000664 g     F .text	000000ac lwip_listen
00000000         *UND*	00000000 netconn_listen_with_backlog
00000710 g     F .text	0000031c lwip_recvfrom
00000000         *UND*	00000000 netconn_recved
00000000         *UND*	00000000 netconn_recv_tcp_pbuf
00000000         *UND*	00000000 netconn_recv
00000000         *UND*	00000000 pbuf_copy_partial
00000a2c g     F .text	00000032 lwip_read
00000a60 g     F .text	00000032 lwip_recv
00000a94 g     F .text	000000dc lwip_send
00000b70 g     F .text	00000134 lwip_sendto
00000000         *UND*	00000000 netconn_write_partly
00000000         *UND*	00000000 netbuf_ref
00000000         *UND*	00000000 netconn_send
00000000         *UND*	00000000 netbuf_free
00000ca4 g     F .text	000000c4 lwip_socket
00000000         *UND*	00000000 netconn_new_with_proto_and_callback
00000d68 g     F .text	00000026 lwip_write
00000fcc g     F .text	00000390 lwip_select
00000000         *UND*	00000000 sys_sem_new
00000000         *UND*	00000000 sys_arch_sem_wait
00000000         *UND*	00000000 sys_sem_free
00000000         *UND*	00000000 sys_sem_signal
00001588 g     F .text	000000f0 lwip_shutdown
00000000         *UND*	00000000 netconn_shutdown
00001718 g     F .text	00000026 lwip_getpeername
00001740 g     F .text	00000026 lwip_getsockname
00001768 g     F .text	00000244 lwip_getsockopt
00000000         *UND*	00000000 tcpip_callback_with_block
00001bcc g     F .text	0000026c lwip_setsockopt
00000000         *UND*	00000000 igmp_joingroup
00000000         *UND*	00000000 igmp_leavegroup
00002098 g     F .text	0000013c lwip_ioctl
000021d4 g     F .text	000000ac lwip_fcntl



Disassembly of section .text:

00000000 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
       0:	b480      	push	{r7}
       2:	af00      	add	r7, sp, #0
}
       4:	46bd      	mov	sp, r7
       6:	bc80      	pop	{r7}
       8:	4770      	bx	lr
       a:	bf00      	nop

0000000c <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
get_socket(int s)
{
       c:	b480      	push	{r7}
       e:	b085      	sub	sp, #20
      10:	af00      	add	r7, sp, #0
      12:	6078      	str	r0, [r7, #4]
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
      14:	687b      	ldr	r3, [r7, #4]
      16:	2b00      	cmp	r3, #0
      18:	db02      	blt.n	20 <get_socket+0x14>
      1a:	687b      	ldr	r3, [r7, #4]
      1c:	2b07      	cmp	r3, #7
      1e:	dd02      	ble.n	26 <get_socket+0x1a>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
      20:	f04f 0300 	mov.w	r3, #0
      24:	e012      	b.n	4c <get_socket+0x40>
  }

  sock = &sockets[s];
      26:	687a      	ldr	r2, [r7, #4]
      28:	4613      	mov	r3, r2
      2a:	ea4f 0343 	mov.w	r3, r3, lsl #1
      2e:	189b      	adds	r3, r3, r2
      30:	ea4f 03c3 	mov.w	r3, r3, lsl #3
      34:	461a      	mov	r2, r3
      36:	4b08      	ldr	r3, [pc, #32]	; (58 <get_socket+0x4c>)
      38:	18d3      	adds	r3, r2, r3
      3a:	60fb      	str	r3, [r7, #12]

  if (!sock->conn) {
      3c:	68fb      	ldr	r3, [r7, #12]
      3e:	681b      	ldr	r3, [r3, #0]
      40:	2b00      	cmp	r3, #0
      42:	d102      	bne.n	4a <get_socket+0x3e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
    return NULL;
      44:	f04f 0300 	mov.w	r3, #0
      48:	e000      	b.n	4c <get_socket+0x40>
  }

  return sock;
      4a:	68fb      	ldr	r3, [r7, #12]
}
      4c:	4618      	mov	r0, r3
      4e:	f107 0714 	add.w	r7, r7, #20
      52:	46bd      	mov	sp, r7
      54:	bc80      	pop	{r7}
      56:	4770      	bx	lr
      58:	00000000 	.word	0x00000000
			58: R_ARM_ABS32	.bss

0000005c <tryget_socket>:
 * @param s externally used socket index
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
      5c:	b480      	push	{r7}
      5e:	b083      	sub	sp, #12
      60:	af00      	add	r7, sp, #0
      62:	6078      	str	r0, [r7, #4]
  if ((s < 0) || (s >= NUM_SOCKETS)) {
      64:	687b      	ldr	r3, [r7, #4]
      66:	2b00      	cmp	r3, #0
      68:	db02      	blt.n	70 <tryget_socket+0x14>
      6a:	687b      	ldr	r3, [r7, #4]
      6c:	2b07      	cmp	r3, #7
      6e:	dd02      	ble.n	76 <tryget_socket+0x1a>
    return NULL;
      70:	f04f 0300 	mov.w	r3, #0
      74:	e018      	b.n	a8 <tryget_socket+0x4c>
  }
  if (!sockets[s].conn) {
      76:	490f      	ldr	r1, [pc, #60]	; (b4 <tryget_socket+0x58>)
      78:	687a      	ldr	r2, [r7, #4]
      7a:	4613      	mov	r3, r2
      7c:	ea4f 0343 	mov.w	r3, r3, lsl #1
      80:	189b      	adds	r3, r3, r2
      82:	ea4f 03c3 	mov.w	r3, r3, lsl #3
      86:	18cb      	adds	r3, r1, r3
      88:	681b      	ldr	r3, [r3, #0]
      8a:	2b00      	cmp	r3, #0
      8c:	d102      	bne.n	94 <tryget_socket+0x38>
    return NULL;
      8e:	f04f 0300 	mov.w	r3, #0
      92:	e009      	b.n	a8 <tryget_socket+0x4c>
  }
  return &sockets[s];
      94:	687a      	ldr	r2, [r7, #4]
      96:	4613      	mov	r3, r2
      98:	ea4f 0343 	mov.w	r3, r3, lsl #1
      9c:	189b      	adds	r3, r3, r2
      9e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
      a2:	461a      	mov	r2, r3
      a4:	4b03      	ldr	r3, [pc, #12]	; (b4 <tryget_socket+0x58>)
      a6:	18d3      	adds	r3, r2, r3
}
      a8:	4618      	mov	r0, r3
      aa:	f107 070c 	add.w	r7, r7, #12
      ae:	46bd      	mov	sp, r7
      b0:	bc80      	pop	{r7}
      b2:	4770      	bx	lr
      b4:	00000000 	.word	0x00000000
			b4: R_ARM_ABS32	.bss

000000b8 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
      b8:	b580      	push	{r7, lr}
      ba:	b084      	sub	sp, #16
      bc:	af00      	add	r7, sp, #0
      be:	6078      	str	r0, [r7, #4]
      c0:	6039      	str	r1, [r7, #0]
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
      c2:	f04f 0300 	mov.w	r3, #0
      c6:	60fb      	str	r3, [r7, #12]
      c8:	e093      	b.n	1f2 <alloc_socket+0x13a>
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
      ca:	f7ff fffe 	bl	0 <sys_arch_protect>
			ca: R_ARM_THM_CALL	sys_arch_protect
      ce:	60b8      	str	r0, [r7, #8]
    if (!sockets[i].conn) {
      d0:	494d      	ldr	r1, [pc, #308]	; (208 <alloc_socket+0x150>)
      d2:	68fa      	ldr	r2, [r7, #12]
      d4:	4613      	mov	r3, r2
      d6:	ea4f 0343 	mov.w	r3, r3, lsl #1
      da:	189b      	adds	r3, r3, r2
      dc:	ea4f 03c3 	mov.w	r3, r3, lsl #3
      e0:	18cb      	adds	r3, r1, r3
      e2:	681b      	ldr	r3, [r3, #0]
      e4:	2b00      	cmp	r3, #0
      e6:	d17d      	bne.n	1e4 <alloc_socket+0x12c>
      sockets[i].conn       = newconn;
      e8:	4947      	ldr	r1, [pc, #284]	; (208 <alloc_socket+0x150>)
      ea:	68fa      	ldr	r2, [r7, #12]
      ec:	4613      	mov	r3, r2
      ee:	ea4f 0343 	mov.w	r3, r3, lsl #1
      f2:	189b      	adds	r3, r3, r2
      f4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
      f8:	18cb      	adds	r3, r1, r3
      fa:	687a      	ldr	r2, [r7, #4]
      fc:	601a      	str	r2, [r3, #0]
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
      fe:	68b8      	ldr	r0, [r7, #8]
     100:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			100: R_ARM_THM_CALL	sys_arch_unprotect
      sockets[i].lastdata   = NULL;
     104:	4940      	ldr	r1, [pc, #256]	; (208 <alloc_socket+0x150>)
     106:	68fa      	ldr	r2, [r7, #12]
     108:	4613      	mov	r3, r2
     10a:	ea4f 0343 	mov.w	r3, r3, lsl #1
     10e:	189b      	adds	r3, r3, r2
     110:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     114:	18cb      	adds	r3, r1, r3
     116:	f103 0304 	add.w	r3, r3, #4
     11a:	f04f 0200 	mov.w	r2, #0
     11e:	601a      	str	r2, [r3, #0]
      sockets[i].lastoffset = 0;
     120:	4939      	ldr	r1, [pc, #228]	; (208 <alloc_socket+0x150>)
     122:	68fa      	ldr	r2, [r7, #12]
     124:	4613      	mov	r3, r2
     126:	ea4f 0343 	mov.w	r3, r3, lsl #1
     12a:	189b      	adds	r3, r3, r2
     12c:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     130:	18cb      	adds	r3, r1, r3
     132:	f103 0308 	add.w	r3, r3, #8
     136:	f04f 0200 	mov.w	r2, #0
     13a:	801a      	strh	r2, [r3, #0]
      sockets[i].rcvevent   = 0;
     13c:	4932      	ldr	r1, [pc, #200]	; (208 <alloc_socket+0x150>)
     13e:	68fa      	ldr	r2, [r7, #12]
     140:	4613      	mov	r3, r2
     142:	ea4f 0343 	mov.w	r3, r3, lsl #1
     146:	189b      	adds	r3, r3, r2
     148:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     14c:	18cb      	adds	r3, r1, r3
     14e:	f103 0308 	add.w	r3, r3, #8
     152:	f04f 0200 	mov.w	r2, #0
     156:	805a      	strh	r2, [r3, #2]
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
     158:	687b      	ldr	r3, [r7, #4]
     15a:	781b      	ldrb	r3, [r3, #0]
     15c:	2b10      	cmp	r3, #16
     15e:	d102      	bne.n	166 <alloc_socket+0xae>
     160:	683b      	ldr	r3, [r7, #0]
     162:	2b00      	cmp	r3, #0
     164:	d002      	beq.n	16c <alloc_socket+0xb4>
     166:	f04f 0301 	mov.w	r3, #1
     16a:	e001      	b.n	170 <alloc_socket+0xb8>
     16c:	f04f 0300 	mov.w	r3, #0
     170:	b299      	uxth	r1, r3
     172:	4825      	ldr	r0, [pc, #148]	; (208 <alloc_socket+0x150>)
     174:	68fa      	ldr	r2, [r7, #12]
     176:	4613      	mov	r3, r2
     178:	ea4f 0343 	mov.w	r3, r3, lsl #1
     17c:	189b      	adds	r3, r3, r2
     17e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     182:	18c3      	adds	r3, r0, r3
     184:	f103 0308 	add.w	r3, r3, #8
     188:	460a      	mov	r2, r1
     18a:	809a      	strh	r2, [r3, #4]
      sockets[i].errevent   = 0;
     18c:	491e      	ldr	r1, [pc, #120]	; (208 <alloc_socket+0x150>)
     18e:	68fa      	ldr	r2, [r7, #12]
     190:	4613      	mov	r3, r2
     192:	ea4f 0343 	mov.w	r3, r3, lsl #1
     196:	189b      	adds	r3, r3, r2
     198:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     19c:	18cb      	adds	r3, r1, r3
     19e:	f103 0308 	add.w	r3, r3, #8
     1a2:	f04f 0200 	mov.w	r2, #0
     1a6:	80da      	strh	r2, [r3, #6]
      sockets[i].err        = 0;
     1a8:	4917      	ldr	r1, [pc, #92]	; (208 <alloc_socket+0x150>)
     1aa:	68fa      	ldr	r2, [r7, #12]
     1ac:	4613      	mov	r3, r2
     1ae:	ea4f 0343 	mov.w	r3, r3, lsl #1
     1b2:	189b      	adds	r3, r3, r2
     1b4:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     1b8:	18cb      	adds	r3, r1, r3
     1ba:	f103 0310 	add.w	r3, r3, #16
     1be:	f04f 0200 	mov.w	r2, #0
     1c2:	601a      	str	r2, [r3, #0]
      sockets[i].select_waiting = 0;
     1c4:	4910      	ldr	r1, [pc, #64]	; (208 <alloc_socket+0x150>)
     1c6:	68fa      	ldr	r2, [r7, #12]
     1c8:	4613      	mov	r3, r2
     1ca:	ea4f 0343 	mov.w	r3, r3, lsl #1
     1ce:	189b      	adds	r3, r3, r2
     1d0:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     1d4:	18cb      	adds	r3, r1, r3
     1d6:	f103 0314 	add.w	r3, r3, #20
     1da:	f04f 0200 	mov.w	r2, #0
     1de:	601a      	str	r2, [r3, #0]
      return i;
     1e0:	68fb      	ldr	r3, [r7, #12]
     1e2:	e00c      	b.n	1fe <alloc_socket+0x146>
    }
    SYS_ARCH_UNPROTECT(lev);
     1e4:	68b8      	ldr	r0, [r7, #8]
     1e6:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			1e6: R_ARM_THM_CALL	sys_arch_unprotect
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
     1ea:	68fb      	ldr	r3, [r7, #12]
     1ec:	f103 0301 	add.w	r3, r3, #1
     1f0:	60fb      	str	r3, [r7, #12]
     1f2:	68fb      	ldr	r3, [r7, #12]
     1f4:	2b07      	cmp	r3, #7
     1f6:	f77f af68 	ble.w	ca <alloc_socket+0x12>
      sockets[i].select_waiting = 0;
      return i;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
     1fa:	f04f 33ff 	mov.w	r3, #4294967295
}
     1fe:	4618      	mov	r0, r3
     200:	f107 0710 	add.w	r7, r7, #16
     204:	46bd      	mov	sp, r7
     206:	bd80      	pop	{r7, pc}
     208:	00000000 	.word	0x00000000
			208: R_ARM_ABS32	.bss

0000020c <free_socket>:
 * @param sock the socket to free
 * @param is_tcp != 0 for TCP sockets, used to free lastdata
 */
static void
free_socket(struct lwip_sock *sock, int is_tcp)
{
     20c:	b580      	push	{r7, lr}
     20e:	b084      	sub	sp, #16
     210:	af00      	add	r7, sp, #0
     212:	6078      	str	r0, [r7, #4]
     214:	6039      	str	r1, [r7, #0]
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
     216:	687b      	ldr	r3, [r7, #4]
     218:	685b      	ldr	r3, [r3, #4]
     21a:	60fb      	str	r3, [r7, #12]
  sock->lastdata   = NULL;
     21c:	687b      	ldr	r3, [r7, #4]
     21e:	f04f 0200 	mov.w	r2, #0
     222:	605a      	str	r2, [r3, #4]
  sock->lastoffset = 0;
     224:	687b      	ldr	r3, [r7, #4]
     226:	f04f 0200 	mov.w	r2, #0
     22a:	811a      	strh	r2, [r3, #8]
  sock->err        = 0;
     22c:	687b      	ldr	r3, [r7, #4]
     22e:	f04f 0200 	mov.w	r2, #0
     232:	611a      	str	r2, [r3, #16]

  /* Protect socket array */
  SYS_ARCH_PROTECT(lev);
     234:	f7ff fffe 	bl	0 <sys_arch_protect>
			234: R_ARM_THM_CALL	sys_arch_protect
     238:	60b8      	str	r0, [r7, #8]
  sock->conn       = NULL;
     23a:	687b      	ldr	r3, [r7, #4]
     23c:	f04f 0200 	mov.w	r2, #0
     240:	601a      	str	r2, [r3, #0]
  SYS_ARCH_UNPROTECT(lev);
     242:	68b8      	ldr	r0, [r7, #8]
     244:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			244: R_ARM_THM_CALL	sys_arch_unprotect
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
     248:	68fb      	ldr	r3, [r7, #12]
     24a:	2b00      	cmp	r3, #0
     24c:	d00b      	beq.n	266 <free_socket+0x5a>
    if (is_tcp) {
     24e:	683b      	ldr	r3, [r7, #0]
     250:	2b00      	cmp	r3, #0
     252:	d004      	beq.n	25e <free_socket+0x52>
      pbuf_free((struct pbuf *)lastdata);
     254:	68fb      	ldr	r3, [r7, #12]
     256:	4618      	mov	r0, r3
     258:	f7ff fffe 	bl	0 <pbuf_free>
			258: R_ARM_THM_CALL	pbuf_free
     25c:	e003      	b.n	266 <free_socket+0x5a>
    } else {
      netbuf_delete((struct netbuf *)lastdata);
     25e:	68fb      	ldr	r3, [r7, #12]
     260:	4618      	mov	r0, r3
     262:	f7ff fffe 	bl	0 <netbuf_delete>
			262: R_ARM_THM_CALL	netbuf_delete
    }
  }
}
     266:	f107 0710 	add.w	r7, r7, #16
     26a:	46bd      	mov	sp, r7
     26c:	bd80      	pop	{r7, pc}
     26e:	bf00      	nop

00000270 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
     270:	b580      	push	{r7, lr}
     272:	b090      	sub	sp, #64	; 0x40
     274:	af00      	add	r7, sp, #0
     276:	60f8      	str	r0, [r7, #12]
     278:	60b9      	str	r1, [r7, #8]
     27a:	607a      	str	r2, [r7, #4]
  struct sockaddr_in sin;
  err_t err;
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
     27c:	68f8      	ldr	r0, [r7, #12]
     27e:	f7ff fec5 	bl	c <get_socket>
     282:	63f8      	str	r0, [r7, #60]	; 0x3c
  if (!sock) {
     284:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     286:	2b00      	cmp	r3, #0
     288:	d102      	bne.n	290 <lwip_accept+0x20>
    return -1;
     28a:	f04f 33ff 	mov.w	r3, #4294967295
     28e:	e0e0      	b.n	452 <lwip_accept+0x1e2>
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
     290:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     292:	681b      	ldr	r3, [r3, #0]
     294:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     298:	f003 0302 	and.w	r3, r3, #2
     29c:	2b00      	cmp	r3, #0
     29e:	d00b      	beq.n	2b8 <lwip_accept+0x48>
     2a0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     2a2:	895b      	ldrh	r3, [r3, #10]
     2a4:	b21b      	sxth	r3, r3
     2a6:	2b00      	cmp	r3, #0
     2a8:	dc06      	bgt.n	2b8 <lwip_accept+0x48>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
    sock_set_errno(sock, EWOULDBLOCK);
     2aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     2ac:	f04f 020b 	mov.w	r2, #11
     2b0:	611a      	str	r2, [r3, #16]
    return -1;
     2b2:	f04f 33ff 	mov.w	r3, #4294967295
     2b6:	e0cc      	b.n	452 <lwip_accept+0x1e2>
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
     2b8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     2ba:	681a      	ldr	r2, [r3, #0]
     2bc:	f107 0328 	add.w	r3, r7, #40	; 0x28
     2c0:	4610      	mov	r0, r2
     2c2:	4619      	mov	r1, r3
     2c4:	f7ff fffe 	bl	0 <netconn_accept>
			2c4: R_ARM_THM_CALL	netconn_accept
     2c8:	4603      	mov	r3, r0
     2ca:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
  if (err != ERR_OK) {
     2ce:	f997 303b 	ldrsb.w	r3, [r7, #59]	; 0x3b
     2d2:	2b00      	cmp	r3, #0
     2d4:	d020      	beq.n	318 <lwip_accept+0xa8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
     2d6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     2d8:	681b      	ldr	r3, [r3, #0]
     2da:	781b      	ldrb	r3, [r3, #0]
     2dc:	2b10      	cmp	r3, #16
     2de:	d006      	beq.n	2ee <lwip_accept+0x7e>
      sock_set_errno(sock, EOPNOTSUPP);
     2e0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     2e2:	f04f 025f 	mov.w	r2, #95	; 0x5f
     2e6:	611a      	str	r2, [r3, #16]
      return EOPNOTSUPP;
     2e8:	f04f 035f 	mov.w	r3, #95	; 0x5f
     2ec:	e0b1      	b.n	452 <lwip_accept+0x1e2>
    }
    sock_set_errno(sock, err_to_errno(err));
     2ee:	f997 303b 	ldrsb.w	r3, [r7, #59]	; 0x3b
     2f2:	f1c3 0300 	rsb	r3, r3, #0
     2f6:	2b0f      	cmp	r3, #15
     2f8:	d807      	bhi.n	30a <lwip_accept+0x9a>
     2fa:	f997 303b 	ldrsb.w	r3, [r7, #59]	; 0x3b
     2fe:	f1c3 0200 	rsb	r2, r3, #0
     302:	4b56      	ldr	r3, [pc, #344]	; (45c <lwip_accept+0x1ec>)
     304:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     308:	e001      	b.n	30e <lwip_accept+0x9e>
     30a:	f04f 0305 	mov.w	r3, #5
     30e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     310:	6113      	str	r3, [r2, #16]
    return -1;
     312:	f04f 33ff 	mov.w	r3, #4294967295
     316:	e09c      	b.n	452 <lwip_accept+0x1e2>
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
  /* Prevent automatic window updates, we do this on our own! */
  netconn_set_noautorecved(newconn, 1);
     318:	6abb      	ldr	r3, [r7, #40]	; 0x28
     31a:	6aba      	ldr	r2, [r7, #40]	; 0x28
     31c:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
     320:	f042 0208 	orr.w	r2, r2, #8
     324:	b2d2      	uxtb	r2, r2
     326:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
     32a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
     32c:	f107 0224 	add.w	r2, r7, #36	; 0x24
     330:	f107 0322 	add.w	r3, r7, #34	; 0x22
     334:	4608      	mov	r0, r1
     336:	4611      	mov	r1, r2
     338:	461a      	mov	r2, r3
     33a:	f04f 0300 	mov.w	r3, #0
     33e:	f7ff fffe 	bl	0 <netconn_getaddr>
			33e: R_ARM_THM_CALL	netconn_getaddr
     342:	4603      	mov	r3, r0
     344:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
  if (err != ERR_OK) {
     348:	f997 303b 	ldrsb.w	r3, [r7, #59]	; 0x3b
     34c:	2b00      	cmp	r3, #0
     34e:	d018      	beq.n	382 <lwip_accept+0x112>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
     350:	6abb      	ldr	r3, [r7, #40]	; 0x28
     352:	4618      	mov	r0, r3
     354:	f7ff fffe 	bl	0 <netconn_delete>
			354: R_ARM_THM_CALL	netconn_delete
    sock_set_errno(sock, err_to_errno(err));
     358:	f997 303b 	ldrsb.w	r3, [r7, #59]	; 0x3b
     35c:	f1c3 0300 	rsb	r3, r3, #0
     360:	2b0f      	cmp	r3, #15
     362:	d807      	bhi.n	374 <lwip_accept+0x104>
     364:	f997 303b 	ldrsb.w	r3, [r7, #59]	; 0x3b
     368:	f1c3 0200 	rsb	r2, r3, #0
     36c:	4b3b      	ldr	r3, [pc, #236]	; (45c <lwip_accept+0x1ec>)
     36e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     372:	e001      	b.n	378 <lwip_accept+0x108>
     374:	f04f 0305 	mov.w	r3, #5
     378:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
     37a:	6113      	str	r3, [r2, #16]
    return -1;
     37c:	f04f 33ff 	mov.w	r3, #4294967295
     380:	e067      	b.n	452 <lwip_accept+0x1e2>
  }

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
     382:	68bb      	ldr	r3, [r7, #8]
     384:	2b00      	cmp	r3, #0
     386:	d027      	beq.n	3d8 <lwip_accept+0x168>
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
     388:	f107 0310 	add.w	r3, r7, #16
     38c:	4618      	mov	r0, r3
     38e:	f04f 0100 	mov.w	r1, #0
     392:	f04f 0210 	mov.w	r2, #16
     396:	f7ff fffe 	bl	0 <memset>
			396: R_ARM_THM_CALL	memset
    sin.sin_len = sizeof(sin);
     39a:	f04f 0310 	mov.w	r3, #16
     39e:	743b      	strb	r3, [r7, #16]
    sin.sin_family = AF_INET;
     3a0:	f04f 0302 	mov.w	r3, #2
     3a4:	747b      	strb	r3, [r7, #17]
    sin.sin_port = htons(port);
     3a6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
     3a8:	4618      	mov	r0, r3
     3aa:	f7ff fffe 	bl	0 <lwip_htons>
			3aa: R_ARM_THM_CALL	lwip_htons
     3ae:	4603      	mov	r3, r0
     3b0:	827b      	strh	r3, [r7, #18]
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
     3b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     3b4:	617b      	str	r3, [r7, #20]

    if (*addrlen > sizeof(sin))
     3b6:	687b      	ldr	r3, [r7, #4]
     3b8:	681b      	ldr	r3, [r3, #0]
     3ba:	2b10      	cmp	r3, #16
     3bc:	d903      	bls.n	3c6 <lwip_accept+0x156>
      *addrlen = sizeof(sin);
     3be:	687b      	ldr	r3, [r7, #4]
     3c0:	f04f 0210 	mov.w	r2, #16
     3c4:	601a      	str	r2, [r3, #0]

    MEMCPY(addr, &sin, *addrlen);
     3c6:	687b      	ldr	r3, [r7, #4]
     3c8:	681b      	ldr	r3, [r3, #0]
     3ca:	f107 0210 	add.w	r2, r7, #16
     3ce:	68b8      	ldr	r0, [r7, #8]
     3d0:	4611      	mov	r1, r2
     3d2:	461a      	mov	r2, r3
     3d4:	f7ff fffe 	bl	0 <memcpy>
			3d4: R_ARM_THM_CALL	memcpy
  }

  newsock = alloc_socket(newconn, 1);
     3d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
     3da:	4618      	mov	r0, r3
     3dc:	f04f 0101 	mov.w	r1, #1
     3e0:	f7ff fe6a 	bl	b8 <alloc_socket>
     3e4:	6378      	str	r0, [r7, #52]	; 0x34
  if (newsock == -1) {
     3e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     3e8:	f1b3 3fff 	cmp.w	r3, #4294967295
     3ec:	d10a      	bne.n	404 <lwip_accept+0x194>
    netconn_delete(newconn);
     3ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
     3f0:	4618      	mov	r0, r3
     3f2:	f7ff fffe 	bl	0 <netconn_delete>
			3f2: R_ARM_THM_CALL	netconn_delete
    sock_set_errno(sock, ENFILE);
     3f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     3f8:	f04f 0217 	mov.w	r2, #23
     3fc:	611a      	str	r2, [r3, #16]
    return -1;
     3fe:	f04f 33ff 	mov.w	r3, #4294967295
     402:	e026      	b.n	452 <lwip_accept+0x1e2>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
  nsock = &sockets[newsock];
     404:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     406:	4613      	mov	r3, r2
     408:	ea4f 0343 	mov.w	r3, r3, lsl #1
     40c:	189b      	adds	r3, r3, r2
     40e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
     412:	461a      	mov	r2, r3
     414:	4b12      	ldr	r3, [pc, #72]	; (460 <lwip_accept+0x1f0>)
     416:	18d3      	adds	r3, r2, r3
     418:	633b      	str	r3, [r7, #48]	; 0x30
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
     41a:	f7ff fffe 	bl	0 <sys_arch_protect>
			41a: R_ARM_THM_CALL	sys_arch_protect
     41e:	62f8      	str	r0, [r7, #44]	; 0x2c
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
     420:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     422:	895b      	ldrh	r3, [r3, #10]
     424:	b29a      	uxth	r2, r3
     426:	6abb      	ldr	r3, [r7, #40]	; 0x28
     428:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     42a:	b29b      	uxth	r3, r3
     42c:	ea6f 0303 	mvn.w	r3, r3
     430:	b29b      	uxth	r3, r3
     432:	18d3      	adds	r3, r2, r3
     434:	b29b      	uxth	r3, r3
     436:	b29a      	uxth	r2, r3
     438:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     43a:	815a      	strh	r2, [r3, #10]
  newconn->socket = newsock;
     43c:	6abb      	ldr	r3, [r7, #40]	; 0x28
     43e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     440:	625a      	str	r2, [r3, #36]	; 0x24
  SYS_ARCH_UNPROTECT(lev);
     442:	6af8      	ldr	r0, [r7, #44]	; 0x2c
     444:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			444: R_ARM_THM_CALL	sys_arch_unprotect

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
     448:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
     44a:	f04f 0200 	mov.w	r2, #0
     44e:	611a      	str	r2, [r3, #16]
  return newsock;
     450:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
     452:	4618      	mov	r0, r3
     454:	f107 0740 	add.w	r7, r7, #64	; 0x40
     458:	46bd      	mov	sp, r7
     45a:	bd80      	pop	{r7, pc}
	...
			45c: R_ARM_ABS32	.rodata
			460: R_ARM_ABS32	.bss

00000464 <lwip_bind>:

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
     464:	b590      	push	{r4, r7, lr}
     466:	b089      	sub	sp, #36	; 0x24
     468:	af00      	add	r7, sp, #0
     46a:	60f8      	str	r0, [r7, #12]
     46c:	60b9      	str	r1, [r7, #8]
     46e:	607a      	str	r2, [r7, #4]
  ip_addr_t local_addr;
  u16_t local_port;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
     470:	68f8      	ldr	r0, [r7, #12]
     472:	f7ff fdcb 	bl	c <get_socket>
     476:	61f8      	str	r0, [r7, #28]
  if (!sock) {
     478:	69fb      	ldr	r3, [r7, #28]
     47a:	2b00      	cmp	r3, #0
     47c:	d102      	bne.n	484 <lwip_bind+0x20>
    return -1;
     47e:	f04f 33ff 	mov.w	r3, #4294967295
     482:	e049      	b.n	518 <lwip_bind+0xb4>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
     484:	687b      	ldr	r3, [r7, #4]
     486:	2b10      	cmp	r3, #16
     488:	d108      	bne.n	49c <lwip_bind+0x38>
     48a:	68bb      	ldr	r3, [r7, #8]
     48c:	785b      	ldrb	r3, [r3, #1]
     48e:	2b02      	cmp	r3, #2
     490:	d104      	bne.n	49c <lwip_bind+0x38>
     492:	68bb      	ldr	r3, [r7, #8]
     494:	f003 0303 	and.w	r3, r3, #3
     498:	2b00      	cmp	r3, #0
     49a:	d006      	beq.n	4aa <lwip_bind+0x46>
     49c:	4b21      	ldr	r3, [pc, #132]	; (524 <lwip_bind+0xc0>)
     49e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     4a0:	69fb      	ldr	r3, [r7, #28]
     4a2:	611a      	str	r2, [r3, #16]
     4a4:	f04f 33ff 	mov.w	r3, #4294967295
     4a8:	e036      	b.n	518 <lwip_bind+0xb4>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
     4aa:	68bb      	ldr	r3, [r7, #8]
     4ac:	61bb      	str	r3, [r7, #24]

  inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
     4ae:	69bb      	ldr	r3, [r7, #24]
     4b0:	685b      	ldr	r3, [r3, #4]
     4b2:	613b      	str	r3, [r7, #16]
  local_port = name_in->sin_port;
     4b4:	69bb      	ldr	r3, [r7, #24]
     4b6:	885b      	ldrh	r3, [r3, #2]
     4b8:	82fb      	strh	r3, [r7, #22]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
     4ba:	69fb      	ldr	r3, [r7, #28]
     4bc:	681c      	ldr	r4, [r3, #0]
     4be:	8afb      	ldrh	r3, [r7, #22]
     4c0:	4618      	mov	r0, r3
     4c2:	f7ff fffe 	bl	0 <lwip_ntohs>
			4c2: R_ARM_THM_CALL	lwip_ntohs
     4c6:	4603      	mov	r3, r0
     4c8:	f107 0210 	add.w	r2, r7, #16
     4cc:	4620      	mov	r0, r4
     4ce:	4611      	mov	r1, r2
     4d0:	461a      	mov	r2, r3
     4d2:	f7ff fffe 	bl	0 <netconn_bind>
			4d2: R_ARM_THM_CALL	netconn_bind
     4d6:	4603      	mov	r3, r0
     4d8:	757b      	strb	r3, [r7, #21]

  if (err != ERR_OK) {
     4da:	f997 3015 	ldrsb.w	r3, [r7, #21]
     4de:	2b00      	cmp	r3, #0
     4e0:	d014      	beq.n	50c <lwip_bind+0xa8>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
     4e2:	f997 3015 	ldrsb.w	r3, [r7, #21]
     4e6:	f1c3 0300 	rsb	r3, r3, #0
     4ea:	2b0f      	cmp	r3, #15
     4ec:	d807      	bhi.n	4fe <lwip_bind+0x9a>
     4ee:	f997 3015 	ldrsb.w	r3, [r7, #21]
     4f2:	f1c3 0200 	rsb	r2, r3, #0
     4f6:	4b0b      	ldr	r3, [pc, #44]	; (524 <lwip_bind+0xc0>)
     4f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     4fc:	e001      	b.n	502 <lwip_bind+0x9e>
     4fe:	f04f 0305 	mov.w	r3, #5
     502:	69fa      	ldr	r2, [r7, #28]
     504:	6113      	str	r3, [r2, #16]
    return -1;
     506:	f04f 33ff 	mov.w	r3, #4294967295
     50a:	e005      	b.n	518 <lwip_bind+0xb4>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
     50c:	69fb      	ldr	r3, [r7, #28]
     50e:	f04f 0200 	mov.w	r2, #0
     512:	611a      	str	r2, [r3, #16]
  return 0;
     514:	f04f 0300 	mov.w	r3, #0
}
     518:	4618      	mov	r0, r3
     51a:	f107 0724 	add.w	r7, r7, #36	; 0x24
     51e:	46bd      	mov	sp, r7
     520:	bd90      	pop	{r4, r7, pc}
     522:	bf00      	nop
     524:	00000000 	.word	0x00000000
			524: R_ARM_ABS32	.rodata

00000528 <lwip_close>:

int
lwip_close(int s)
{
     528:	b580      	push	{r7, lr}
     52a:	b084      	sub	sp, #16
     52c:	af00      	add	r7, sp, #0
     52e:	6078      	str	r0, [r7, #4]
  struct lwip_sock *sock;
  int is_tcp = 0;
     530:	f04f 0300 	mov.w	r3, #0
     534:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
     536:	6878      	ldr	r0, [r7, #4]
     538:	f7ff fd68 	bl	c <get_socket>
     53c:	60b8      	str	r0, [r7, #8]
  if (!sock) {
     53e:	68bb      	ldr	r3, [r7, #8]
     540:	2b00      	cmp	r3, #0
     542:	d102      	bne.n	54a <lwip_close+0x22>
    return -1;
     544:	f04f 33ff 	mov.w	r3, #4294967295
     548:	e016      	b.n	578 <lwip_close+0x50>
  }

  if(sock->conn != NULL) {
     54a:	68bb      	ldr	r3, [r7, #8]
     54c:	681b      	ldr	r3, [r3, #0]
     54e:	2b00      	cmp	r3, #0
     550:	d007      	beq.n	562 <lwip_close+0x3a>
    is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
     552:	68bb      	ldr	r3, [r7, #8]
     554:	681b      	ldr	r3, [r3, #0]
     556:	781b      	ldrb	r3, [r3, #0]
     558:	2b10      	cmp	r3, #16
     55a:	bf14      	ite	ne
     55c:	2300      	movne	r3, #0
     55e:	2301      	moveq	r3, #1
     560:	60fb      	str	r3, [r7, #12]
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  }

  netconn_delete(sock->conn);
     562:	68bb      	ldr	r3, [r7, #8]
     564:	681b      	ldr	r3, [r3, #0]
     566:	4618      	mov	r0, r3
     568:	f7ff fffe 	bl	0 <netconn_delete>
			568: R_ARM_THM_CALL	netconn_delete

  free_socket(sock, is_tcp);
     56c:	68b8      	ldr	r0, [r7, #8]
     56e:	68f9      	ldr	r1, [r7, #12]
     570:	f7ff fe4c 	bl	20c <free_socket>
  set_errno(0);
  return 0;
     574:	f04f 0300 	mov.w	r3, #0
}
     578:	4618      	mov	r0, r3
     57a:	f107 0710 	add.w	r7, r7, #16
     57e:	46bd      	mov	sp, r7
     580:	bd80      	pop	{r7, pc}
     582:	bf00      	nop

00000584 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
     584:	b590      	push	{r4, r7, lr}
     586:	b08b      	sub	sp, #44	; 0x2c
     588:	af00      	add	r7, sp, #0
     58a:	60f8      	str	r0, [r7, #12]
     58c:	60b9      	str	r1, [r7, #8]
     58e:	607a      	str	r2, [r7, #4]
  struct lwip_sock *sock;
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
     590:	68f8      	ldr	r0, [r7, #12]
     592:	f7ff fd3b 	bl	c <get_socket>
     596:	6238      	str	r0, [r7, #32]
  if (!sock) {
     598:	6a3b      	ldr	r3, [r7, #32]
     59a:	2b00      	cmp	r3, #0
     59c:	d102      	bne.n	5a4 <lwip_connect+0x20>
    return -1;
     59e:	f04f 33ff 	mov.w	r3, #4294967295
     5a2:	e057      	b.n	654 <lwip_connect+0xd0>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
     5a4:	687b      	ldr	r3, [r7, #4]
     5a6:	2b10      	cmp	r3, #16
     5a8:	d108      	bne.n	5bc <lwip_connect+0x38>
     5aa:	68bb      	ldr	r3, [r7, #8]
     5ac:	785b      	ldrb	r3, [r3, #1]
     5ae:	2b02      	cmp	r3, #2
     5b0:	d104      	bne.n	5bc <lwip_connect+0x38>
     5b2:	68bb      	ldr	r3, [r7, #8]
     5b4:	f003 0303 	and.w	r3, r3, #3
     5b8:	2b00      	cmp	r3, #0
     5ba:	d006      	beq.n	5ca <lwip_connect+0x46>
     5bc:	4b28      	ldr	r3, [pc, #160]	; (660 <lwip_connect+0xdc>)
     5be:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     5c0:	6a3b      	ldr	r3, [r7, #32]
     5c2:	611a      	str	r2, [r3, #16]
     5c4:	f04f 33ff 	mov.w	r3, #4294967295
     5c8:	e044      	b.n	654 <lwip_connect+0xd0>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;
     5ca:	68bb      	ldr	r3, [r7, #8]
     5cc:	61fb      	str	r3, [r7, #28]

  if (name_in->sin_family == AF_UNSPEC) {
     5ce:	69fb      	ldr	r3, [r7, #28]
     5d0:	785b      	ldrb	r3, [r3, #1]
     5d2:	2b00      	cmp	r3, #0
     5d4:	d108      	bne.n	5e8 <lwip_connect+0x64>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
     5d6:	6a3b      	ldr	r3, [r7, #32]
     5d8:	681b      	ldr	r3, [r3, #0]
     5da:	4618      	mov	r0, r3
     5dc:	f7ff fffe 	bl	0 <netconn_disconnect>
			5dc: R_ARM_THM_CALL	netconn_disconnect
     5e0:	4603      	mov	r3, r0
     5e2:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
     5e6:	e016      	b.n	616 <lwip_connect+0x92>
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
     5e8:	69fb      	ldr	r3, [r7, #28]
     5ea:	685b      	ldr	r3, [r3, #4]
     5ec:	617b      	str	r3, [r7, #20]
    remote_port = name_in->sin_port;
     5ee:	69fb      	ldr	r3, [r7, #28]
     5f0:	885b      	ldrh	r3, [r3, #2]
     5f2:	837b      	strh	r3, [r7, #26]

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
     5f4:	6a3b      	ldr	r3, [r7, #32]
     5f6:	681c      	ldr	r4, [r3, #0]
     5f8:	8b7b      	ldrh	r3, [r7, #26]
     5fa:	4618      	mov	r0, r3
     5fc:	f7ff fffe 	bl	0 <lwip_ntohs>
			5fc: R_ARM_THM_CALL	lwip_ntohs
     600:	4603      	mov	r3, r0
     602:	f107 0214 	add.w	r2, r7, #20
     606:	4620      	mov	r0, r4
     608:	4611      	mov	r1, r2
     60a:	461a      	mov	r2, r3
     60c:	f7ff fffe 	bl	0 <netconn_connect>
			60c: R_ARM_THM_CALL	netconn_connect
     610:	4603      	mov	r3, r0
     612:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  if (err != ERR_OK) {
     616:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
     61a:	2b00      	cmp	r3, #0
     61c:	d014      	beq.n	648 <lwip_connect+0xc4>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
     61e:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
     622:	f1c3 0300 	rsb	r3, r3, #0
     626:	2b0f      	cmp	r3, #15
     628:	d807      	bhi.n	63a <lwip_connect+0xb6>
     62a:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
     62e:	f1c3 0200 	rsb	r2, r3, #0
     632:	4b0b      	ldr	r3, [pc, #44]	; (660 <lwip_connect+0xdc>)
     634:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     638:	e001      	b.n	63e <lwip_connect+0xba>
     63a:	f04f 0305 	mov.w	r3, #5
     63e:	6a3a      	ldr	r2, [r7, #32]
     640:	6113      	str	r3, [r2, #16]
    return -1;
     642:	f04f 33ff 	mov.w	r3, #4294967295
     646:	e005      	b.n	654 <lwip_connect+0xd0>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
     648:	6a3b      	ldr	r3, [r7, #32]
     64a:	f04f 0200 	mov.w	r2, #0
     64e:	611a      	str	r2, [r3, #16]
  return 0;
     650:	f04f 0300 	mov.w	r3, #0
}
     654:	4618      	mov	r0, r3
     656:	f107 072c 	add.w	r7, r7, #44	; 0x2c
     65a:	46bd      	mov	sp, r7
     65c:	bd90      	pop	{r4, r7, pc}
     65e:	bf00      	nop
     660:	00000000 	.word	0x00000000
			660: R_ARM_ABS32	.rodata

00000664 <lwip_listen>:
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
     664:	b580      	push	{r7, lr}
     666:	b084      	sub	sp, #16
     668:	af00      	add	r7, sp, #0
     66a:	6078      	str	r0, [r7, #4]
     66c:	6039      	str	r1, [r7, #0]
  struct lwip_sock *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
     66e:	6878      	ldr	r0, [r7, #4]
     670:	f7ff fccc 	bl	c <get_socket>
     674:	60f8      	str	r0, [r7, #12]
  if (!sock) {
     676:	68fb      	ldr	r3, [r7, #12]
     678:	2b00      	cmp	r3, #0
     67a:	d102      	bne.n	682 <lwip_listen+0x1e>
    return -1;
     67c:	f04f 33ff 	mov.w	r3, #4294967295
     680:	e03e      	b.n	700 <lwip_listen+0x9c>
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
     682:	683b      	ldr	r3, [r7, #0]
     684:	2bfe      	cmp	r3, #254	; 0xfe
     686:	dc03      	bgt.n	690 <lwip_listen+0x2c>
     688:	683b      	ldr	r3, [r7, #0]
     68a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
     68e:	e001      	b.n	694 <lwip_listen+0x30>
     690:	f04f 03ff 	mov.w	r3, #255	; 0xff
     694:	603b      	str	r3, [r7, #0]

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
     696:	68fb      	ldr	r3, [r7, #12]
     698:	681a      	ldr	r2, [r3, #0]
     69a:	683b      	ldr	r3, [r7, #0]
     69c:	b2db      	uxtb	r3, r3
     69e:	4610      	mov	r0, r2
     6a0:	4619      	mov	r1, r3
     6a2:	f7ff fffe 	bl	0 <netconn_listen_with_backlog>
			6a2: R_ARM_THM_CALL	netconn_listen_with_backlog
     6a6:	4603      	mov	r3, r0
     6a8:	72fb      	strb	r3, [r7, #11]

  if (err != ERR_OK) {
     6aa:	f997 300b 	ldrsb.w	r3, [r7, #11]
     6ae:	2b00      	cmp	r3, #0
     6b0:	d020      	beq.n	6f4 <lwip_listen+0x90>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
     6b2:	68fb      	ldr	r3, [r7, #12]
     6b4:	681b      	ldr	r3, [r3, #0]
     6b6:	781b      	ldrb	r3, [r3, #0]
     6b8:	2b10      	cmp	r3, #16
     6ba:	d006      	beq.n	6ca <lwip_listen+0x66>
      sock_set_errno(sock, EOPNOTSUPP);
     6bc:	68fb      	ldr	r3, [r7, #12]
     6be:	f04f 025f 	mov.w	r2, #95	; 0x5f
     6c2:	611a      	str	r2, [r3, #16]
      return EOPNOTSUPP;
     6c4:	f04f 035f 	mov.w	r3, #95	; 0x5f
     6c8:	e01a      	b.n	700 <lwip_listen+0x9c>
    }
    sock_set_errno(sock, err_to_errno(err));
     6ca:	f997 300b 	ldrsb.w	r3, [r7, #11]
     6ce:	f1c3 0300 	rsb	r3, r3, #0
     6d2:	2b0f      	cmp	r3, #15
     6d4:	d807      	bhi.n	6e6 <lwip_listen+0x82>
     6d6:	f997 300b 	ldrsb.w	r3, [r7, #11]
     6da:	f1c3 0200 	rsb	r2, r3, #0
     6de:	4b0b      	ldr	r3, [pc, #44]	; (70c <lwip_listen+0xa8>)
     6e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     6e4:	e001      	b.n	6ea <lwip_listen+0x86>
     6e6:	f04f 0305 	mov.w	r3, #5
     6ea:	68fa      	ldr	r2, [r7, #12]
     6ec:	6113      	str	r3, [r2, #16]
    return -1;
     6ee:	f04f 33ff 	mov.w	r3, #4294967295
     6f2:	e005      	b.n	700 <lwip_listen+0x9c>
  }

  sock_set_errno(sock, 0);
     6f4:	68fb      	ldr	r3, [r7, #12]
     6f6:	f04f 0200 	mov.w	r2, #0
     6fa:	611a      	str	r2, [r3, #16]
  return 0;
     6fc:	f04f 0300 	mov.w	r3, #0
}
     700:	4618      	mov	r0, r3
     702:	f107 0710 	add.w	r7, r7, #16
     706:	46bd      	mov	sp, r7
     708:	bd80      	pop	{r7, pc}
     70a:	bf00      	nop
     70c:	00000000 	.word	0x00000000
			70c: R_ARM_ABS32	.rodata

00000710 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
     710:	b580      	push	{r7, lr}
     712:	b094      	sub	sp, #80	; 0x50
     714:	af00      	add	r7, sp, #0
     716:	60f8      	str	r0, [r7, #12]
     718:	60b9      	str	r1, [r7, #8]
     71a:	607a      	str	r2, [r7, #4]
     71c:	603b      	str	r3, [r7, #0]
  struct lwip_sock *sock;
  void             *buf = NULL;
     71e:	f04f 0300 	mov.w	r3, #0
     722:	62fb      	str	r3, [r7, #44]	; 0x2c
  struct pbuf      *p;
  u16_t            buflen, copylen;
  int              off = 0;
     724:	f04f 0300 	mov.w	r3, #0
     728:	647b      	str	r3, [r7, #68]	; 0x44
  ip_addr_t        *addr;
  u16_t            port;
  u8_t             done = 0;
     72a:	f04f 0300 	mov.w	r3, #0
     72e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  err_t            err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
     732:	68f8      	ldr	r0, [r7, #12]
     734:	f7ff fc6a 	bl	c <get_socket>
     738:	63b8      	str	r0, [r7, #56]	; 0x38
  if (!sock) {
     73a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     73c:	2b00      	cmp	r3, #0
     73e:	d102      	bne.n	746 <lwip_recvfrom+0x36>
    return -1;
     740:	f04f 33ff 	mov.w	r3, #4294967295
     744:	e16b      	b.n	a1e <lwip_recvfrom+0x30e>
  }

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
     746:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     748:	685b      	ldr	r3, [r3, #4]
     74a:	2b00      	cmp	r3, #0
     74c:	d003      	beq.n	756 <lwip_recvfrom+0x46>
      buf = sock->lastdata;
     74e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     750:	685b      	ldr	r3, [r3, #4]
     752:	62fb      	str	r3, [r7, #44]	; 0x2c
     754:	e078      	b.n	848 <lwip_recvfrom+0x138>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
     756:	683b      	ldr	r3, [r7, #0]
     758:	f003 0308 	and.w	r3, r3, #8
     75c:	2b00      	cmp	r3, #0
     75e:	d107      	bne.n	770 <lwip_recvfrom+0x60>
     760:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     762:	681b      	ldr	r3, [r3, #0]
     764:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     768:	f003 0302 	and.w	r3, r3, #2
     76c:	2b00      	cmp	r3, #0
     76e:	d01b      	beq.n	7a8 <lwip_recvfrom+0x98>
          (sock->rcvevent <= 0)) {
     770:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     772:	895b      	ldrh	r3, [r3, #10]
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
     774:	b21b      	sxth	r3, r3
     776:	2b00      	cmp	r3, #0
     778:	dc16      	bgt.n	7a8 <lwip_recvfrom+0x98>
          (sock->rcvevent <= 0)) {
        if (off > 0) {
     77a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     77c:	2b00      	cmp	r3, #0
     77e:	dd0c      	ble.n	79a <lwip_recvfrom+0x8a>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
     780:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     782:	681a      	ldr	r2, [r3, #0]
     784:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     786:	4610      	mov	r0, r2
     788:	4619      	mov	r1, r3
     78a:	f7ff fffe 	bl	0 <netconn_recved>
			78a: R_ARM_THM_CALL	netconn_recved
          /* already received data, return that */
          sock_set_errno(sock, 0);
     78e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     790:	f04f 0200 	mov.w	r2, #0
     794:	611a      	str	r2, [r3, #16]
          return off;
     796:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     798:	e141      	b.n	a1e <lwip_recvfrom+0x30e>
        }
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
     79a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     79c:	f04f 020b 	mov.w	r2, #11
     7a0:	611a      	str	r2, [r3, #16]
        return -1;
     7a2:	f04f 33ff 	mov.w	r3, #4294967295
     7a6:	e13a      	b.n	a1e <lwip_recvfrom+0x30e>
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
     7a8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     7aa:	681b      	ldr	r3, [r3, #0]
     7ac:	781b      	ldrb	r3, [r3, #0]
     7ae:	2b10      	cmp	r3, #16
     7b0:	d10b      	bne.n	7ca <lwip_recvfrom+0xba>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
     7b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     7b4:	681a      	ldr	r2, [r3, #0]
     7b6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
     7ba:	4610      	mov	r0, r2
     7bc:	4619      	mov	r1, r3
     7be:	f7ff fffe 	bl	0 <netconn_recv_tcp_pbuf>
			7be: R_ARM_THM_CALL	netconn_recv_tcp_pbuf
     7c2:	4603      	mov	r3, r0
     7c4:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
     7c8:	e00a      	b.n	7e0 <lwip_recvfrom+0xd0>
      } else {
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
     7ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     7cc:	681a      	ldr	r2, [r3, #0]
     7ce:	f107 032c 	add.w	r3, r7, #44	; 0x2c
     7d2:	4610      	mov	r0, r2
     7d4:	4619      	mov	r1, r3
     7d6:	f7ff fffe 	bl	0 <netconn_recv>
			7d6: R_ARM_THM_CALL	netconn_recv
     7da:	4603      	mov	r3, r0
     7dc:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
     7e0:	f997 303e 	ldrsb.w	r3, [r7, #62]	; 0x3e
     7e4:	2b00      	cmp	r3, #0
     7e6:	d02c      	beq.n	842 <lwip_recvfrom+0x132>
        if (off > 0) {
     7e8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     7ea:	2b00      	cmp	r3, #0
     7ec:	dd0c      	ble.n	808 <lwip_recvfrom+0xf8>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
     7ee:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     7f0:	681a      	ldr	r2, [r3, #0]
     7f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     7f4:	4610      	mov	r0, r2
     7f6:	4619      	mov	r1, r3
     7f8:	f7ff fffe 	bl	0 <netconn_recved>
			7f8: R_ARM_THM_CALL	netconn_recved
          /* already received data, return that */
          sock_set_errno(sock, 0);
     7fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     7fe:	f04f 0200 	mov.w	r2, #0
     802:	611a      	str	r2, [r3, #16]
          return off;
     804:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     806:	e10a      	b.n	a1e <lwip_recvfrom+0x30e>
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
     808:	f997 303e 	ldrsb.w	r3, [r7, #62]	; 0x3e
     80c:	f1c3 0300 	rsb	r3, r3, #0
     810:	2b0f      	cmp	r3, #15
     812:	d807      	bhi.n	824 <lwip_recvfrom+0x114>
     814:	f997 303e 	ldrsb.w	r3, [r7, #62]	; 0x3e
     818:	f1c3 0200 	rsb	r2, r3, #0
     81c:	4b82      	ldr	r3, [pc, #520]	; (a28 <lwip_recvfrom+0x318>)
     81e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     822:	e001      	b.n	828 <lwip_recvfrom+0x118>
     824:	f04f 0305 	mov.w	r3, #5
     828:	6bba      	ldr	r2, [r7, #56]	; 0x38
     82a:	6113      	str	r3, [r2, #16]
        if (err == ERR_CLSD) {
     82c:	f997 303e 	ldrsb.w	r3, [r7, #62]	; 0x3e
     830:	f113 0f0c 	cmn.w	r3, #12
     834:	d102      	bne.n	83c <lwip_recvfrom+0x12c>
          return 0;
     836:	f04f 0300 	mov.w	r3, #0
     83a:	e0f0      	b.n	a1e <lwip_recvfrom+0x30e>
        } else {
          return -1;
     83c:	f04f 33ff 	mov.w	r3, #4294967295
     840:	e0ed      	b.n	a1e <lwip_recvfrom+0x30e>
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
     842:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     844:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     846:	605a      	str	r2, [r3, #4]
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
     848:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     84a:	681b      	ldr	r3, [r3, #0]
     84c:	781b      	ldrb	r3, [r3, #0]
     84e:	2b10      	cmp	r3, #16
     850:	d102      	bne.n	858 <lwip_recvfrom+0x148>
      p = (struct pbuf *)buf;
     852:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     854:	64fb      	str	r3, [r7, #76]	; 0x4c
     856:	e002      	b.n	85e <lwip_recvfrom+0x14e>
    } else {
      p = ((struct netbuf *)buf)->p;
     858:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     85a:	681b      	ldr	r3, [r3, #0]
     85c:	64fb      	str	r3, [r7, #76]	; 0x4c
    }
    buflen = p->tot_len;
     85e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     860:	891b      	ldrh	r3, [r3, #8]
     862:	86fb      	strh	r3, [r7, #54]	; 0x36
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
     864:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     866:	891b      	ldrh	r3, [r3, #8]
     868:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     86a:	1ad3      	subs	r3, r2, r3
     86c:	86fb      	strh	r3, [r7, #54]	; 0x36

    if (len > buflen) {
     86e:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     870:	687b      	ldr	r3, [r7, #4]
     872:	429a      	cmp	r2, r3
     874:	d203      	bcs.n	87e <lwip_recvfrom+0x16e>
      copylen = buflen;
     876:	8efb      	ldrh	r3, [r7, #54]	; 0x36
     878:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
     87c:	e002      	b.n	884 <lwip_recvfrom+0x174>
    } else {
      copylen = (u16_t)len;
     87e:	687b      	ldr	r3, [r7, #4]
     880:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
     884:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     886:	68ba      	ldr	r2, [r7, #8]
     888:	18d1      	adds	r1, r2, r3
     88a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     88c:	891b      	ldrh	r3, [r3, #8]
     88e:	f8b7 204a 	ldrh.w	r2, [r7, #74]	; 0x4a
     892:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
     894:	f7ff fffe 	bl	0 <pbuf_copy_partial>
			894: R_ARM_THM_CALL	pbuf_copy_partial

    off += copylen;
     898:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
     89c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
     89e:	18d3      	adds	r3, r2, r3
     8a0:	647b      	str	r3, [r7, #68]	; 0x44

    if (netconn_type(sock->conn) == NETCONN_TCP) {
     8a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     8a4:	681b      	ldr	r3, [r3, #0]
     8a6:	781b      	ldrb	r3, [r3, #0]
     8a8:	2b10      	cmp	r3, #16
     8aa:	d11e      	bne.n	8ea <lwip_recvfrom+0x1da>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
     8ac:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
     8b0:	687a      	ldr	r2, [r7, #4]
     8b2:	1ad3      	subs	r3, r2, r3
     8b4:	607b      	str	r3, [r7, #4]
      if ( (len <= 0) || 
     8b6:	687b      	ldr	r3, [r7, #4]
     8b8:	2b00      	cmp	r3, #0
     8ba:	d011      	beq.n	8e0 <lwip_recvfrom+0x1d0>
           (p->flags & PBUF_FLAG_PUSH) || 
     8bc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     8be:	7b5b      	ldrb	r3, [r3, #13]
    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
     8c0:	f003 0301 	and.w	r3, r3, #1
     8c4:	b2db      	uxtb	r3, r3
     8c6:	2b00      	cmp	r3, #0
     8c8:	d10a      	bne.n	8e0 <lwip_recvfrom+0x1d0>
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
     8ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     8cc:	895b      	ldrh	r3, [r3, #10]

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
     8ce:	b21b      	sxth	r3, r3
     8d0:	2b00      	cmp	r3, #0
     8d2:	dd05      	ble.n	8e0 <lwip_recvfrom+0x1d0>
           (sock->rcvevent <= 0) || 
           ((flags & MSG_PEEK)!=0)) {
     8d4:	683b      	ldr	r3, [r7, #0]
     8d6:	f003 0301 	and.w	r3, r3, #1
     8da:	b2db      	uxtb	r3, r3
    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
      len -= copylen;
      if ( (len <= 0) || 
           (p->flags & PBUF_FLAG_PUSH) || 
           (sock->rcvevent <= 0) || 
     8dc:	2b00      	cmp	r3, #0
     8de:	d008      	beq.n	8f2 <lwip_recvfrom+0x1e2>
           ((flags & MSG_PEEK)!=0)) {
        done = 1;
     8e0:	f04f 0301 	mov.w	r3, #1
     8e4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
     8e8:	e003      	b.n	8f2 <lwip_recvfrom+0x1e2>
      }
    } else {
      done = 1;
     8ea:	f04f 0301 	mov.w	r3, #1
     8ee:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    }

    /* Check to see from where the data was.*/
    if (done) {
     8f2:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
     8f6:	2b00      	cmp	r3, #0
     8f8:	d04b      	beq.n	992 <lwip_recvfrom+0x282>
      ip_addr_t fromaddr;
      if (from && fromlen) {
     8fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
     8fc:	2b00      	cmp	r3, #0
     8fe:	d048      	beq.n	992 <lwip_recvfrom+0x282>
     900:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     902:	2b00      	cmp	r3, #0
     904:	d045      	beq.n	992 <lwip_recvfrom+0x282>
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
     906:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     908:	681b      	ldr	r3, [r3, #0]
     90a:	781b      	ldrb	r3, [r3, #0]
     90c:	2b10      	cmp	r3, #16
     90e:	d10e      	bne.n	92e <lwip_recvfrom+0x21e>
          addr = &fromaddr;
     910:	f107 0324 	add.w	r3, r7, #36	; 0x24
     914:	643b      	str	r3, [r7, #64]	; 0x40
          netconn_getaddr(sock->conn, addr, &port, 0);
     916:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     918:	681a      	ldr	r2, [r3, #0]
     91a:	f107 032a 	add.w	r3, r7, #42	; 0x2a
     91e:	4610      	mov	r0, r2
     920:	6c39      	ldr	r1, [r7, #64]	; 0x40
     922:	461a      	mov	r2, r3
     924:	f04f 0300 	mov.w	r3, #0
     928:	f7ff fffe 	bl	0 <netconn_getaddr>
			928: R_ARM_THM_CALL	netconn_getaddr
     92c:	e008      	b.n	940 <lwip_recvfrom+0x230>
          // IP address of the sender is put into the "sin" struct.
          // Unfortunately, there is no official way in lwIP to determine the
          // destination address when using sockets.
          //
          //
          struct netbuf *nb = (struct netbuf *)buf;
     92e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     930:	633b      	str	r3, [r7, #48]	; 0x30
          addr = netbuf_destaddr(nb);
     932:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     934:	f103 0310 	add.w	r3, r3, #16
     938:	643b      	str	r3, [r7, #64]	; 0x40
          port = nb->toport_chksum;
     93a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     93c:	89db      	ldrh	r3, [r3, #14]
     93e:	857b      	strh	r3, [r7, #42]	; 0x2a
        }

        memset(&sin, 0, sizeof(sin));
     940:	f107 0314 	add.w	r3, r7, #20
     944:	4618      	mov	r0, r3
     946:	f04f 0100 	mov.w	r1, #0
     94a:	f04f 0210 	mov.w	r2, #16
     94e:	f7ff fffe 	bl	0 <memset>
			94e: R_ARM_THM_CALL	memset
        sin.sin_len = sizeof(sin);
     952:	f04f 0310 	mov.w	r3, #16
     956:	753b      	strb	r3, [r7, #20]
        sin.sin_family = AF_INET;
     958:	f04f 0302 	mov.w	r3, #2
     95c:	757b      	strb	r3, [r7, #21]
        sin.sin_port = htons(port);
     95e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
     960:	4618      	mov	r0, r3
     962:	f7ff fffe 	bl	0 <lwip_htons>
			962: R_ARM_THM_CALL	lwip_htons
     966:	4603      	mov	r3, r0
     968:	82fb      	strh	r3, [r7, #22]
        inet_addr_from_ipaddr(&sin.sin_addr, addr);
     96a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     96c:	681b      	ldr	r3, [r3, #0]
     96e:	61bb      	str	r3, [r7, #24]

        if (*fromlen > sizeof(sin)) {
     970:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     972:	681b      	ldr	r3, [r3, #0]
     974:	2b10      	cmp	r3, #16
     976:	d903      	bls.n	980 <lwip_recvfrom+0x270>
          *fromlen = sizeof(sin);
     978:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     97a:	f04f 0210 	mov.w	r2, #16
     97e:	601a      	str	r2, [r3, #0]
        }

        MEMCPY(from, &sin, *fromlen);
     980:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     982:	681b      	ldr	r3, [r3, #0]
     984:	f107 0214 	add.w	r2, r7, #20
     988:	6db8      	ldr	r0, [r7, #88]	; 0x58
     98a:	4611      	mov	r1, r2
     98c:	461a      	mov	r2, r3
     98e:	f7ff fffe 	bl	0 <memcpy>
			98e: R_ARM_THM_CALL	memcpy
#endif /*  SOCKETS_DEBUG */
      }
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
     992:	683b      	ldr	r3, [r7, #0]
     994:	f003 0301 	and.w	r3, r3, #1
     998:	2b00      	cmp	r3, #0
     99a:	d12c      	bne.n	9f6 <lwip_recvfrom+0x2e6>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
     99c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     99e:	681b      	ldr	r3, [r3, #0]
     9a0:	781b      	ldrb	r3, [r3, #0]
     9a2:	2b10      	cmp	r3, #16
     9a4:	d111      	bne.n	9ca <lwip_recvfrom+0x2ba>
     9a6:	8efa      	ldrh	r2, [r7, #54]	; 0x36
     9a8:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
     9ac:	1ad3      	subs	r3, r2, r3
     9ae:	2b00      	cmp	r3, #0
     9b0:	dd0b      	ble.n	9ca <lwip_recvfrom+0x2ba>
        sock->lastdata = buf;
     9b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     9b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     9b6:	605a      	str	r2, [r3, #4]
        sock->lastoffset += copylen;
     9b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     9ba:	891a      	ldrh	r2, [r3, #8]
     9bc:	f8b7 304a 	ldrh.w	r3, [r7, #74]	; 0x4a
     9c0:	18d3      	adds	r3, r2, r3
     9c2:	b29a      	uxth	r2, r3
     9c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     9c6:	811a      	strh	r2, [r3, #8]
     9c8:	e015      	b.n	9f6 <lwip_recvfrom+0x2e6>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
     9ca:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     9cc:	f04f 0200 	mov.w	r2, #0
     9d0:	605a      	str	r2, [r3, #4]
        sock->lastoffset = 0;
     9d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     9d4:	f04f 0200 	mov.w	r2, #0
     9d8:	811a      	strh	r2, [r3, #8]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
     9da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     9dc:	681b      	ldr	r3, [r3, #0]
     9de:	781b      	ldrb	r3, [r3, #0]
     9e0:	2b10      	cmp	r3, #16
     9e2:	d104      	bne.n	9ee <lwip_recvfrom+0x2de>
          pbuf_free((struct pbuf *)buf);
     9e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     9e6:	4618      	mov	r0, r3
     9e8:	f7ff fffe 	bl	0 <pbuf_free>
			9e8: R_ARM_THM_CALL	pbuf_free
     9ec:	e003      	b.n	9f6 <lwip_recvfrom+0x2e6>
        } else {
          netbuf_delete((struct netbuf *)buf);
     9ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     9f0:	4618      	mov	r0, r3
     9f2:	f7ff fffe 	bl	0 <netbuf_delete>
			9f2: R_ARM_THM_CALL	netbuf_delete
        }
      }
    }
  } while (!done);
     9f6:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
     9fa:	2b00      	cmp	r3, #0
     9fc:	f43f aea3 	beq.w	746 <lwip_recvfrom+0x36>

  if (off > 0) {
     a00:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     a02:	2b00      	cmp	r3, #0
     a04:	dd06      	ble.n	a14 <lwip_recvfrom+0x304>
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
     a06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     a08:	681a      	ldr	r2, [r3, #0]
     a0a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     a0c:	4610      	mov	r0, r2
     a0e:	4619      	mov	r1, r3
     a10:	f7ff fffe 	bl	0 <netconn_recved>
			a10: R_ARM_THM_CALL	netconn_recved
  }
  sock_set_errno(sock, 0);
     a14:	6bbb      	ldr	r3, [r7, #56]	; 0x38
     a16:	f04f 0200 	mov.w	r2, #0
     a1a:	611a      	str	r2, [r3, #16]
  return off;
     a1c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
     a1e:	4618      	mov	r0, r3
     a20:	f107 0750 	add.w	r7, r7, #80	; 0x50
     a24:	46bd      	mov	sp, r7
     a26:	bd80      	pop	{r7, pc}
     a28:	00000000 	.word	0x00000000
			a28: R_ARM_ABS32	.rodata

00000a2c <lwip_read>:

int
lwip_read(int s, void *mem, size_t len)
{
     a2c:	b580      	push	{r7, lr}
     a2e:	b086      	sub	sp, #24
     a30:	af02      	add	r7, sp, #8
     a32:	60f8      	str	r0, [r7, #12]
     a34:	60b9      	str	r1, [r7, #8]
     a36:	607a      	str	r2, [r7, #4]
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
     a38:	f04f 0300 	mov.w	r3, #0
     a3c:	9300      	str	r3, [sp, #0]
     a3e:	f04f 0300 	mov.w	r3, #0
     a42:	9301      	str	r3, [sp, #4]
     a44:	68f8      	ldr	r0, [r7, #12]
     a46:	68b9      	ldr	r1, [r7, #8]
     a48:	687a      	ldr	r2, [r7, #4]
     a4a:	f04f 0300 	mov.w	r3, #0
     a4e:	f7ff fffe 	bl	710 <lwip_recvfrom>
			a4e: R_ARM_THM_CALL	lwip_recvfrom
     a52:	4603      	mov	r3, r0
}
     a54:	4618      	mov	r0, r3
     a56:	f107 0710 	add.w	r7, r7, #16
     a5a:	46bd      	mov	sp, r7
     a5c:	bd80      	pop	{r7, pc}
     a5e:	bf00      	nop

00000a60 <lwip_recv>:

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
     a60:	b580      	push	{r7, lr}
     a62:	b086      	sub	sp, #24
     a64:	af02      	add	r7, sp, #8
     a66:	60f8      	str	r0, [r7, #12]
     a68:	60b9      	str	r1, [r7, #8]
     a6a:	607a      	str	r2, [r7, #4]
     a6c:	603b      	str	r3, [r7, #0]
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
     a6e:	f04f 0300 	mov.w	r3, #0
     a72:	9300      	str	r3, [sp, #0]
     a74:	f04f 0300 	mov.w	r3, #0
     a78:	9301      	str	r3, [sp, #4]
     a7a:	68f8      	ldr	r0, [r7, #12]
     a7c:	68b9      	ldr	r1, [r7, #8]
     a7e:	687a      	ldr	r2, [r7, #4]
     a80:	683b      	ldr	r3, [r7, #0]
     a82:	f7ff fffe 	bl	710 <lwip_recvfrom>
			a82: R_ARM_THM_CALL	lwip_recvfrom
     a86:	4603      	mov	r3, r0
}
     a88:	4618      	mov	r0, r3
     a8a:	f107 0710 	add.w	r7, r7, #16
     a8e:	46bd      	mov	sp, r7
     a90:	bd80      	pop	{r7, pc}
     a92:	bf00      	nop

00000a94 <lwip_send>:

int
lwip_send(int s, const void *data, size_t size, int flags)
{
     a94:	b580      	push	{r7, lr}
     a96:	b08a      	sub	sp, #40	; 0x28
     a98:	af02      	add	r7, sp, #8
     a9a:	60f8      	str	r0, [r7, #12]
     a9c:	60b9      	str	r1, [r7, #8]
     a9e:	607a      	str	r2, [r7, #4]
     aa0:	603b      	str	r3, [r7, #0]
  size_t written;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
     aa2:	68f8      	ldr	r0, [r7, #12]
     aa4:	f7ff fab2 	bl	c <get_socket>
     aa8:	61f8      	str	r0, [r7, #28]
  if (!sock) {
     aaa:	69fb      	ldr	r3, [r7, #28]
     aac:	2b00      	cmp	r3, #0
     aae:	d102      	bne.n	ab6 <lwip_send+0x22>
    return -1;
     ab0:	f04f 33ff 	mov.w	r3, #4294967295
     ab4:	e054      	b.n	b60 <lwip_send+0xcc>
  }

  if (sock->conn->type != NETCONN_TCP) {
     ab6:	69fb      	ldr	r3, [r7, #28]
     ab8:	681b      	ldr	r3, [r3, #0]
     aba:	781b      	ldrb	r3, [r3, #0]
     abc:	2b10      	cmp	r3, #16
     abe:	d00d      	beq.n	adc <lwip_send+0x48>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
     ac0:	f04f 0300 	mov.w	r3, #0
     ac4:	9300      	str	r3, [sp, #0]
     ac6:	f04f 0300 	mov.w	r3, #0
     aca:	9301      	str	r3, [sp, #4]
     acc:	68f8      	ldr	r0, [r7, #12]
     ace:	68b9      	ldr	r1, [r7, #8]
     ad0:	687a      	ldr	r2, [r7, #4]
     ad2:	683b      	ldr	r3, [r7, #0]
     ad4:	f7ff fffe 	bl	b70 <lwip_sendto>
			ad4: R_ARM_THM_CALL	lwip_sendto
     ad8:	4603      	mov	r3, r0
     ada:	e041      	b.n	b60 <lwip_send+0xcc>
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
     adc:	683b      	ldr	r3, [r7, #0]
     ade:	f003 0310 	and.w	r3, r3, #16
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
     ae2:	2b00      	cmp	r3, #0
     ae4:	d002      	beq.n	aec <lwip_send+0x58>
     ae6:	f04f 0203 	mov.w	r2, #3
     aea:	e001      	b.n	af0 <lwip_send+0x5c>
     aec:	f04f 0201 	mov.w	r2, #1
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
     af0:	683b      	ldr	r3, [r7, #0]
     af2:	f003 0308 	and.w	r3, r3, #8
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
     af6:	2b00      	cmp	r3, #0
     af8:	d002      	beq.n	b00 <lwip_send+0x6c>
     afa:	f04f 0304 	mov.w	r3, #4
     afe:	e001      	b.n	b04 <lwip_send+0x70>
     b00:	f04f 0300 	mov.w	r3, #0
     b04:	ea42 0303 	orr.w	r3, r2, r3
     b08:	b2db      	uxtb	r3, r3
     b0a:	76fb      	strb	r3, [r7, #27]
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
     b0c:	f04f 0300 	mov.w	r3, #0
     b10:	617b      	str	r3, [r7, #20]
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
     b12:	69fb      	ldr	r3, [r7, #28]
     b14:	681a      	ldr	r2, [r3, #0]
     b16:	7efb      	ldrb	r3, [r7, #27]
     b18:	f107 0114 	add.w	r1, r7, #20
     b1c:	9100      	str	r1, [sp, #0]
     b1e:	4610      	mov	r0, r2
     b20:	68b9      	ldr	r1, [r7, #8]
     b22:	687a      	ldr	r2, [r7, #4]
     b24:	f7ff fffe 	bl	0 <netconn_write_partly>
			b24: R_ARM_THM_CALL	netconn_write_partly
     b28:	4603      	mov	r3, r0
     b2a:	76bb      	strb	r3, [r7, #26]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
     b2c:	f997 301a 	ldrsb.w	r3, [r7, #26]
     b30:	f1c3 0300 	rsb	r3, r3, #0
     b34:	2b0f      	cmp	r3, #15
     b36:	d807      	bhi.n	b48 <lwip_send+0xb4>
     b38:	f997 301a 	ldrsb.w	r3, [r7, #26]
     b3c:	f1c3 0200 	rsb	r2, r3, #0
     b40:	4b0a      	ldr	r3, [pc, #40]	; (b6c <lwip_send+0xd8>)
     b42:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     b46:	e001      	b.n	b4c <lwip_send+0xb8>
     b48:	f04f 0305 	mov.w	r3, #5
     b4c:	69fa      	ldr	r2, [r7, #28]
     b4e:	6113      	str	r3, [r2, #16]
  return (err == ERR_OK ? (int)written : -1);
     b50:	f997 301a 	ldrsb.w	r3, [r7, #26]
     b54:	2b00      	cmp	r3, #0
     b56:	d101      	bne.n	b5c <lwip_send+0xc8>
     b58:	697b      	ldr	r3, [r7, #20]
     b5a:	e001      	b.n	b60 <lwip_send+0xcc>
     b5c:	f04f 33ff 	mov.w	r3, #4294967295
}
     b60:	4618      	mov	r0, r3
     b62:	f107 0720 	add.w	r7, r7, #32
     b66:	46bd      	mov	sp, r7
     b68:	bd80      	pop	{r7, pc}
     b6a:	bf00      	nop
     b6c:	00000000 	.word	0x00000000
			b6c: R_ARM_ABS32	.rodata

00000b70 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
     b70:	b580      	push	{r7, lr}
     b72:	b08e      	sub	sp, #56	; 0x38
     b74:	af00      	add	r7, sp, #0
     b76:	60f8      	str	r0, [r7, #12]
     b78:	60b9      	str	r1, [r7, #8]
     b7a:	607a      	str	r2, [r7, #4]
     b7c:	603b      	str	r3, [r7, #0]
  u16_t remote_port;
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
#endif

  sock = get_socket(s);
     b7e:	68f8      	ldr	r0, [r7, #12]
     b80:	f7ff fa44 	bl	c <get_socket>
     b84:	6338      	str	r0, [r7, #48]	; 0x30
  if (!sock) {
     b86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     b88:	2b00      	cmp	r3, #0
     b8a:	d102      	bne.n	b92 <lwip_sendto+0x22>
    return -1;
     b8c:	f04f 33ff 	mov.w	r3, #4294967295
     b90:	e080      	b.n	c94 <lwip_sendto+0x124>
  }

  if (sock->conn->type == NETCONN_TCP) {
     b92:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     b94:	681b      	ldr	r3, [r3, #0]
     b96:	781b      	ldrb	r3, [r3, #0]
     b98:	2b10      	cmp	r3, #16
     b9a:	d107      	bne.n	bac <lwip_sendto+0x3c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
     b9c:	68f8      	ldr	r0, [r7, #12]
     b9e:	68b9      	ldr	r1, [r7, #8]
     ba0:	687a      	ldr	r2, [r7, #4]
     ba2:	683b      	ldr	r3, [r7, #0]
     ba4:	f7ff fffe 	bl	a94 <lwip_send>
			ba4: R_ARM_THM_CALL	lwip_send
     ba8:	4603      	mov	r3, r0
     baa:	e073      	b.n	c94 <lwip_sendto+0x124>
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
  short_size = (u16_t)size;
     bac:	687b      	ldr	r3, [r7, #4]
     bae:	85fb      	strh	r3, [r7, #46]	; 0x2e
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
     bb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     bb2:	2b00      	cmp	r3, #0
     bb4:	d102      	bne.n	bbc <lwip_sendto+0x4c>
     bb6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     bb8:	2b00      	cmp	r3, #0
     bba:	d012      	beq.n	be2 <lwip_sendto+0x72>
     bbc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     bbe:	2b10      	cmp	r3, #16
     bc0:	d108      	bne.n	bd4 <lwip_sendto+0x64>
     bc2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     bc4:	785b      	ldrb	r3, [r3, #1]
     bc6:	2b02      	cmp	r3, #2
     bc8:	d104      	bne.n	bd4 <lwip_sendto+0x64>
     bca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     bcc:	f003 0303 	and.w	r3, r3, #3
     bd0:	2b00      	cmp	r3, #0
     bd2:	d006      	beq.n	be2 <lwip_sendto+0x72>
     bd4:	4b32      	ldr	r3, [pc, #200]	; (ca0 <lwip_sendto+0x130>)
     bd6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     bd8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     bda:	611a      	str	r2, [r3, #16]
     bdc:	f04f 33ff 	mov.w	r3, #4294967295
     be0:	e058      	b.n	c94 <lwip_sendto+0x124>
             ((tolen == sizeof(struct sockaddr_in)) &&
             ((to->sa_family) == AF_INET) && ((((mem_ptr_t)to) % 4) == 0))),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  to_in = (const struct sockaddr_in *)(void*)to;
     be2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     be4:	62bb      	str	r3, [r7, #40]	; 0x28
      err = ERR_MEM;
    }
  }
#else /* LWIP_TCPIP_CORE_LOCKING */
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
     be6:	f04f 0300 	mov.w	r3, #0
     bea:	617b      	str	r3, [r7, #20]
     bec:	697b      	ldr	r3, [r7, #20]
     bee:	613b      	str	r3, [r7, #16]
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
     bf0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     bf2:	2b00      	cmp	r3, #0
     bf4:	d00c      	beq.n	c10 <lwip_sendto+0xa0>
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
     bf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
     bf8:	685b      	ldr	r3, [r3, #4]
     bfa:	61bb      	str	r3, [r7, #24]
    remote_port           = ntohs(to_in->sin_port);
     bfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
     bfe:	885b      	ldrh	r3, [r3, #2]
     c00:	4618      	mov	r0, r3
     c02:	f7ff fffe 	bl	0 <lwip_ntohs>
			c02: R_ARM_THM_CALL	lwip_ntohs
     c06:	4603      	mov	r3, r0
     c08:	84fb      	strh	r3, [r7, #38]	; 0x26
    netbuf_fromport(&buf) = remote_port;
     c0a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
     c0c:	83bb      	strh	r3, [r7, #28]
     c0e:	e008      	b.n	c22 <lwip_sendto+0xb2>
  } else {
    remote_port           = 0;
     c10:	f04f 0300 	mov.w	r3, #0
     c14:	84fb      	strh	r3, [r7, #38]	; 0x26
    ip_addr_set_any(&buf.addr);
     c16:	f04f 0300 	mov.w	r3, #0
     c1a:	61bb      	str	r3, [r7, #24]
    netbuf_fromport(&buf) = 0;
     c1c:	f04f 0300 	mov.w	r3, #0
     c20:	83bb      	strh	r3, [r7, #28]
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
     c22:	f107 0210 	add.w	r2, r7, #16
     c26:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
     c28:	4610      	mov	r0, r2
     c2a:	68b9      	ldr	r1, [r7, #8]
     c2c:	461a      	mov	r2, r3
     c2e:	f7ff fffe 	bl	0 <netbuf_ref>
			c2e: R_ARM_THM_CALL	netbuf_ref
     c32:	4603      	mov	r3, r0
     c34:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
     c38:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
     c3c:	2b00      	cmp	r3, #0
     c3e:	d10a      	bne.n	c56 <lwip_sendto+0xe6>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
     c40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     c42:	681a      	ldr	r2, [r3, #0]
     c44:	f107 0310 	add.w	r3, r7, #16
     c48:	4610      	mov	r0, r2
     c4a:	4619      	mov	r1, r3
     c4c:	f7ff fffe 	bl	0 <netconn_send>
			c4c: R_ARM_THM_CALL	netconn_send
     c50:	4603      	mov	r3, r0
     c52:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
     c56:	f107 0310 	add.w	r3, r7, #16
     c5a:	4618      	mov	r0, r3
     c5c:	f7ff fffe 	bl	0 <netbuf_free>
			c5c: R_ARM_THM_CALL	netbuf_free
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
     c60:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
     c64:	f1c3 0300 	rsb	r3, r3, #0
     c68:	2b0f      	cmp	r3, #15
     c6a:	d807      	bhi.n	c7c <lwip_sendto+0x10c>
     c6c:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
     c70:	f1c3 0200 	rsb	r2, r3, #0
     c74:	4b0a      	ldr	r3, [pc, #40]	; (ca0 <lwip_sendto+0x130>)
     c76:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
     c7a:	e001      	b.n	c80 <lwip_sendto+0x110>
     c7c:	f04f 0305 	mov.w	r3, #5
     c80:	6b3a      	ldr	r2, [r7, #48]	; 0x30
     c82:	6113      	str	r3, [r2, #16]
  return (err == ERR_OK ? short_size : -1);
     c84:	f997 3037 	ldrsb.w	r3, [r7, #55]	; 0x37
     c88:	2b00      	cmp	r3, #0
     c8a:	d101      	bne.n	c90 <lwip_sendto+0x120>
     c8c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
     c8e:	e001      	b.n	c94 <lwip_sendto+0x124>
     c90:	f04f 33ff 	mov.w	r3, #4294967295
}
     c94:	4618      	mov	r0, r3
     c96:	f107 0738 	add.w	r7, r7, #56	; 0x38
     c9a:	46bd      	mov	sp, r7
     c9c:	bd80      	pop	{r7, pc}
     c9e:	bf00      	nop
     ca0:	00000000 	.word	0x00000000
			ca0: R_ARM_ABS32	.rodata

00000ca4 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
     ca4:	b580      	push	{r7, lr}
     ca6:	b086      	sub	sp, #24
     ca8:	af00      	add	r7, sp, #0
     caa:	60f8      	str	r0, [r7, #12]
     cac:	60b9      	str	r1, [r7, #8]
     cae:	607a      	str	r2, [r7, #4]
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
     cb0:	68bb      	ldr	r3, [r7, #8]
     cb2:	2b02      	cmp	r3, #2
     cb4:	d00e      	beq.n	cd4 <lwip_socket+0x30>
     cb6:	2b03      	cmp	r3, #3
     cb8:	d002      	beq.n	cc0 <lwip_socket+0x1c>
     cba:	2b01      	cmp	r3, #1
     cbc:	d01a      	beq.n	cf4 <lwip_socket+0x50>
     cbe:	e02e      	b.n	d1e <lwip_socket+0x7a>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
     cc0:	687b      	ldr	r3, [r7, #4]
     cc2:	b2db      	uxtb	r3, r3
     cc4:	f04f 0040 	mov.w	r0, #64	; 0x40
     cc8:	4619      	mov	r1, r3
     cca:	4a26      	ldr	r2, [pc, #152]	; (d64 <lwip_socket+0xc0>)
     ccc:	f7ff fffe 	bl	0 <netconn_new_with_proto_and_callback>
			ccc: R_ARM_THM_CALL	netconn_new_with_proto_and_callback
     cd0:	6178      	str	r0, [r7, #20]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
     cd2:	e028      	b.n	d26 <lwip_socket+0x82>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
     cd4:	687b      	ldr	r3, [r7, #4]
     cd6:	2b88      	cmp	r3, #136	; 0x88
     cd8:	d102      	bne.n	ce0 <lwip_socket+0x3c>
     cda:	f04f 0321 	mov.w	r3, #33	; 0x21
     cde:	e001      	b.n	ce4 <lwip_socket+0x40>
     ce0:	f04f 0320 	mov.w	r3, #32
     ce4:	4618      	mov	r0, r3
     ce6:	f04f 0100 	mov.w	r1, #0
     cea:	4a1e      	ldr	r2, [pc, #120]	; (7c <netconn_new_with_proto_and_callback+0x7c>)
     cec:	f7ff fffe 	bl	0 <netconn_new_with_proto_and_callback>
			cec: R_ARM_THM_CALL	netconn_new_with_proto_and_callback
     cf0:	6178      	str	r0, [r7, #20]
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
     cf2:	e018      	b.n	d26 <lwip_socket+0x82>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
     cf4:	f04f 0010 	mov.w	r0, #16
     cf8:	f04f 0100 	mov.w	r1, #0
     cfc:	4a19      	ldr	r2, [pc, #100]	; (68 <netconn_new_with_proto_and_callback+0x68>)
     cfe:	f7ff fffe 	bl	0 <netconn_new_with_proto_and_callback>
			cfe: R_ARM_THM_CALL	netconn_new_with_proto_and_callback
     d02:	6178      	str	r0, [r7, #20]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
     d04:	697b      	ldr	r3, [r7, #20]
     d06:	2b00      	cmp	r3, #0
     d08:	d00c      	beq.n	d24 <lwip_socket+0x80>
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
     d0a:	697b      	ldr	r3, [r7, #20]
     d0c:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
     d10:	f043 0308 	orr.w	r3, r3, #8
     d14:	b2da      	uxtb	r2, r3
     d16:	697b      	ldr	r3, [r7, #20]
     d18:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    }
    break;
     d1c:	e003      	b.n	d26 <lwip_socket+0x82>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
     d1e:	f04f 33ff 	mov.w	r3, #4294967295
     d22:	e01a      	b.n	d5a <lwip_socket+0xb6>
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
    }
    break;
     d24:	bf00      	nop
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  }

  if (!conn) {
     d26:	697b      	ldr	r3, [r7, #20]
     d28:	2b00      	cmp	r3, #0
     d2a:	d102      	bne.n	d32 <lwip_socket+0x8e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
     d2c:	f04f 33ff 	mov.w	r3, #4294967295
     d30:	e013      	b.n	d5a <lwip_socket+0xb6>
  }

  i = alloc_socket(conn, 0);
     d32:	6978      	ldr	r0, [r7, #20]
     d34:	f04f 0100 	mov.w	r1, #0
     d38:	f7ff f9be 	bl	b8 <alloc_socket>
     d3c:	6138      	str	r0, [r7, #16]

  if (i == -1) {
     d3e:	693b      	ldr	r3, [r7, #16]
     d40:	f1b3 3fff 	cmp.w	r3, #4294967295
     d44:	d105      	bne.n	d52 <lwip_socket+0xae>
    netconn_delete(conn);
     d46:	6978      	ldr	r0, [r7, #20]
     d48:	f7ff fffe 	bl	0 <netconn_delete>
			d48: R_ARM_THM_CALL	netconn_delete
    set_errno(ENFILE);
    return -1;
     d4c:	f04f 33ff 	mov.w	r3, #4294967295
     d50:	e003      	b.n	d5a <lwip_socket+0xb6>
  }
  conn->socket = i;
     d52:	697b      	ldr	r3, [r7, #20]
     d54:	693a      	ldr	r2, [r7, #16]
     d56:	625a      	str	r2, [r3, #36]	; 0x24
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
     d58:	693b      	ldr	r3, [r7, #16]
}
     d5a:	4618      	mov	r0, r3
     d5c:	f107 0718 	add.w	r7, r7, #24
     d60:	46bd      	mov	sp, r7
     d62:	bd80      	pop	{r7, pc}
     d64:	00000000 	.word	0x00000000
			d64: R_ARM_ABS32	event_callback

00000d68 <lwip_write>:

int
lwip_write(int s, const void *data, size_t size)
{
     d68:	b580      	push	{r7, lr}
     d6a:	b084      	sub	sp, #16
     d6c:	af00      	add	r7, sp, #0
     d6e:	60f8      	str	r0, [r7, #12]
     d70:	60b9      	str	r1, [r7, #8]
     d72:	607a      	str	r2, [r7, #4]
  return lwip_send(s, data, size, 0);
     d74:	68f8      	ldr	r0, [r7, #12]
     d76:	68b9      	ldr	r1, [r7, #8]
     d78:	687a      	ldr	r2, [r7, #4]
     d7a:	f04f 0300 	mov.w	r3, #0
     d7e:	f7ff fffe 	bl	a94 <lwip_send>
			d7e: R_ARM_THM_CALL	lwip_send
     d82:	4603      	mov	r3, r0
}
     d84:	4618      	mov	r0, r3
     d86:	f107 0710 	add.w	r7, r7, #16
     d8a:	46bd      	mov	sp, r7
     d8c:	bd80      	pop	{r7, pc}
     d8e:	bf00      	nop

00000d90 <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
     d90:	b580      	push	{r7, lr}
     d92:	b08e      	sub	sp, #56	; 0x38
     d94:	af00      	add	r7, sp, #0
     d96:	60f8      	str	r0, [r7, #12]
     d98:	60b9      	str	r1, [r7, #8]
     d9a:	607a      	str	r2, [r7, #4]
     d9c:	603b      	str	r3, [r7, #0]
  int i, nready = 0;
     d9e:	f04f 0300 	mov.w	r3, #0
     da2:	633b      	str	r3, [r7, #48]	; 0x30
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
     da4:	f107 0318 	add.w	r3, r7, #24
     da8:	4618      	mov	r0, r3
     daa:	f04f 0100 	mov.w	r1, #0
     dae:	f04f 0201 	mov.w	r2, #1
     db2:	f7ff fffe 	bl	0 <memset>
			db2: R_ARM_THM_CALL	memset
  FD_ZERO(&lwriteset);
     db6:	f107 0314 	add.w	r3, r7, #20
     dba:	4618      	mov	r0, r3
     dbc:	f04f 0100 	mov.w	r1, #0
     dc0:	f04f 0201 	mov.w	r2, #1
     dc4:	f7ff fffe 	bl	0 <memset>
			dc4: R_ARM_THM_CALL	memset
  FD_ZERO(&lexceptset);
     dc8:	f107 0310 	add.w	r3, r7, #16
     dcc:	4618      	mov	r0, r3
     dce:	f04f 0100 	mov.w	r1, #0
     dd2:	f04f 0201 	mov.w	r2, #1
     dd6:	f7ff fffe 	bl	0 <memset>
			dd6: R_ARM_THM_CALL	memset

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
     dda:	f04f 0300 	mov.w	r3, #0
     dde:	637b      	str	r3, [r7, #52]	; 0x34
     de0:	e0e0      	b.n	fa4 <lwip_selscan+0x214>
    void* lastdata = NULL;
     de2:	f04f 0300 	mov.w	r3, #0
     de6:	62fb      	str	r3, [r7, #44]	; 0x2c
    s16_t rcvevent = 0;
     de8:	f04f 0300 	mov.w	r3, #0
     dec:	857b      	strh	r3, [r7, #42]	; 0x2a
    u16_t sendevent = 0;
     dee:	f04f 0300 	mov.w	r3, #0
     df2:	853b      	strh	r3, [r7, #40]	; 0x28
    u16_t errevent = 0;
     df4:	f04f 0300 	mov.w	r3, #0
     df8:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
     dfa:	f7ff fffe 	bl	0 <sys_arch_protect>
			dfa: R_ARM_THM_CALL	sys_arch_protect
     dfe:	6238      	str	r0, [r7, #32]
    sock = tryget_socket(i);
     e00:	6b78      	ldr	r0, [r7, #52]	; 0x34
     e02:	f7ff f92b 	bl	5c <tryget_socket>
     e06:	61f8      	str	r0, [r7, #28]
    if (sock != NULL) {
     e08:	69fb      	ldr	r3, [r7, #28]
     e0a:	2b00      	cmp	r3, #0
     e0c:	d00b      	beq.n	e26 <lwip_selscan+0x96>
      lastdata = sock->lastdata;
     e0e:	69fb      	ldr	r3, [r7, #28]
     e10:	685b      	ldr	r3, [r3, #4]
     e12:	62fb      	str	r3, [r7, #44]	; 0x2c
      rcvevent = sock->rcvevent;
     e14:	69fb      	ldr	r3, [r7, #28]
     e16:	895b      	ldrh	r3, [r3, #10]
     e18:	857b      	strh	r3, [r7, #42]	; 0x2a
      sendevent = sock->sendevent;
     e1a:	69fb      	ldr	r3, [r7, #28]
     e1c:	899b      	ldrh	r3, [r3, #12]
     e1e:	853b      	strh	r3, [r7, #40]	; 0x28
      errevent = sock->errevent;
     e20:	69fb      	ldr	r3, [r7, #28]
     e22:	89db      	ldrh	r3, [r3, #14]
     e24:	84fb      	strh	r3, [r7, #38]	; 0x26
    }
    SYS_ARCH_UNPROTECT(lev);
     e26:	6a38      	ldr	r0, [r7, #32]
     e28:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			e28: R_ARM_THM_CALL	sys_arch_unprotect
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
     e2c:	68bb      	ldr	r3, [r7, #8]
     e2e:	2b00      	cmp	r3, #0
     e30:	d03c      	beq.n	eac <lwip_selscan+0x11c>
     e32:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     e34:	2b00      	cmp	r3, #0
     e36:	da01      	bge.n	e3c <lwip_selscan+0xac>
     e38:	f103 0307 	add.w	r3, r3, #7
     e3c:	ea4f 03e3 	mov.w	r3, r3, asr #3
     e40:	68ba      	ldr	r2, [r7, #8]
     e42:	5cd3      	ldrb	r3, [r2, r3]
     e44:	461a      	mov	r2, r3
     e46:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     e48:	f003 0307 	and.w	r3, r3, #7
     e4c:	fa42 f303 	asr.w	r3, r2, r3
     e50:	f003 0301 	and.w	r3, r3, #1
     e54:	b2db      	uxtb	r3, r3
     e56:	2b00      	cmp	r3, #0
     e58:	d028      	beq.n	eac <lwip_selscan+0x11c>
     e5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     e5c:	2b00      	cmp	r3, #0
     e5e:	d103      	bne.n	e68 <lwip_selscan+0xd8>
     e60:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
     e64:	2b00      	cmp	r3, #0
     e66:	dd21      	ble.n	eac <lwip_selscan+0x11c>
      FD_SET(i, &lreadset);
     e68:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     e6a:	2b00      	cmp	r3, #0
     e6c:	da01      	bge.n	e72 <lwip_selscan+0xe2>
     e6e:	f103 0307 	add.w	r3, r3, #7
     e72:	ea4f 03e3 	mov.w	r3, r3, asr #3
     e76:	f107 0138 	add.w	r1, r7, #56	; 0x38
     e7a:	18ca      	adds	r2, r1, r3
     e7c:	f812 2c20 	ldrb.w	r2, [r2, #-32]
     e80:	b2d1      	uxtb	r1, r2
     e82:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     e84:	f002 0207 	and.w	r2, r2, #7
     e88:	f04f 0001 	mov.w	r0, #1
     e8c:	fa00 f202 	lsl.w	r2, r0, r2
     e90:	b2d2      	uxtb	r2, r2
     e92:	ea41 0202 	orr.w	r2, r1, r2
     e96:	b2d2      	uxtb	r2, r2
     e98:	b2d2      	uxtb	r2, r2
     e9a:	f107 0138 	add.w	r1, r7, #56	; 0x38
     e9e:	18cb      	adds	r3, r1, r3
     ea0:	f803 2c20 	strb.w	r2, [r3, #-32]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
     ea4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     ea6:	f103 0301 	add.w	r3, r3, #1
     eaa:	633b      	str	r3, [r7, #48]	; 0x30
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
     eac:	687b      	ldr	r3, [r7, #4]
     eae:	2b00      	cmp	r3, #0
     eb0:	d038      	beq.n	f24 <lwip_selscan+0x194>
     eb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     eb4:	2b00      	cmp	r3, #0
     eb6:	da01      	bge.n	ebc <lwip_selscan+0x12c>
     eb8:	f103 0307 	add.w	r3, r3, #7
     ebc:	ea4f 03e3 	mov.w	r3, r3, asr #3
     ec0:	687a      	ldr	r2, [r7, #4]
     ec2:	5cd3      	ldrb	r3, [r2, r3]
     ec4:	461a      	mov	r2, r3
     ec6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     ec8:	f003 0307 	and.w	r3, r3, #7
     ecc:	fa42 f303 	asr.w	r3, r2, r3
     ed0:	f003 0301 	and.w	r3, r3, #1
     ed4:	b2db      	uxtb	r3, r3
     ed6:	2b00      	cmp	r3, #0
     ed8:	d024      	beq.n	f24 <lwip_selscan+0x194>
     eda:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
     edc:	2b00      	cmp	r3, #0
     ede:	d021      	beq.n	f24 <lwip_selscan+0x194>
      FD_SET(i, &lwriteset);
     ee0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     ee2:	2b00      	cmp	r3, #0
     ee4:	da01      	bge.n	eea <lwip_selscan+0x15a>
     ee6:	f103 0307 	add.w	r3, r3, #7
     eea:	ea4f 03e3 	mov.w	r3, r3, asr #3
     eee:	f107 0138 	add.w	r1, r7, #56	; 0x38
     ef2:	18ca      	adds	r2, r1, r3
     ef4:	f812 2c24 	ldrb.w	r2, [r2, #-36]
     ef8:	b2d1      	uxtb	r1, r2
     efa:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     efc:	f002 0207 	and.w	r2, r2, #7
     f00:	f04f 0001 	mov.w	r0, #1
     f04:	fa00 f202 	lsl.w	r2, r0, r2
     f08:	b2d2      	uxtb	r2, r2
     f0a:	ea41 0202 	orr.w	r2, r1, r2
     f0e:	b2d2      	uxtb	r2, r2
     f10:	b2d2      	uxtb	r2, r2
     f12:	f107 0138 	add.w	r1, r7, #56	; 0x38
     f16:	18cb      	adds	r3, r1, r3
     f18:	f803 2c24 	strb.w	r2, [r3, #-36]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
     f1c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     f1e:	f103 0301 	add.w	r3, r3, #1
     f22:	633b      	str	r3, [r7, #48]	; 0x30
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
     f24:	683b      	ldr	r3, [r7, #0]
     f26:	2b00      	cmp	r3, #0
     f28:	d038      	beq.n	f9c <lwip_selscan+0x20c>
     f2a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     f2c:	2b00      	cmp	r3, #0
     f2e:	da01      	bge.n	f34 <lwip_selscan+0x1a4>
     f30:	f103 0307 	add.w	r3, r3, #7
     f34:	ea4f 03e3 	mov.w	r3, r3, asr #3
     f38:	683a      	ldr	r2, [r7, #0]
     f3a:	5cd3      	ldrb	r3, [r2, r3]
     f3c:	461a      	mov	r2, r3
     f3e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     f40:	f003 0307 	and.w	r3, r3, #7
     f44:	fa42 f303 	asr.w	r3, r2, r3
     f48:	f003 0301 	and.w	r3, r3, #1
     f4c:	b2db      	uxtb	r3, r3
     f4e:	2b00      	cmp	r3, #0
     f50:	d024      	beq.n	f9c <lwip_selscan+0x20c>
     f52:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
     f54:	2b00      	cmp	r3, #0
     f56:	d021      	beq.n	f9c <lwip_selscan+0x20c>
      FD_SET(i, &lexceptset);
     f58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     f5a:	2b00      	cmp	r3, #0
     f5c:	da01      	bge.n	f62 <lwip_selscan+0x1d2>
     f5e:	f103 0307 	add.w	r3, r3, #7
     f62:	ea4f 03e3 	mov.w	r3, r3, asr #3
     f66:	f107 0138 	add.w	r1, r7, #56	; 0x38
     f6a:	18ca      	adds	r2, r1, r3
     f6c:	f812 2c28 	ldrb.w	r2, [r2, #-40]
     f70:	b2d1      	uxtb	r1, r2
     f72:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     f74:	f002 0207 	and.w	r2, r2, #7
     f78:	f04f 0001 	mov.w	r0, #1
     f7c:	fa00 f202 	lsl.w	r2, r0, r2
     f80:	b2d2      	uxtb	r2, r2
     f82:	ea41 0202 	orr.w	r2, r1, r2
     f86:	b2d2      	uxtb	r2, r2
     f88:	b2d2      	uxtb	r2, r2
     f8a:	f107 0138 	add.w	r1, r7, #56	; 0x38
     f8e:	18cb      	adds	r3, r1, r3
     f90:	f803 2c28 	strb.w	r2, [r3, #-40]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
     f94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
     f96:	f103 0301 	add.w	r3, r3, #1
     f9a:	633b      	str	r3, [r7, #48]	; 0x30
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
     f9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
     f9e:	f103 0301 	add.w	r3, r3, #1
     fa2:	637b      	str	r3, [r7, #52]	; 0x34
     fa4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
     fa6:	68fb      	ldr	r3, [r7, #12]
     fa8:	429a      	cmp	r2, r3
     faa:	f6ff af1a 	blt.w	de2 <lwip_selscan+0x52>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
     fae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     fb0:	7e3a      	ldrb	r2, [r7, #24]
     fb2:	701a      	strb	r2, [r3, #0]
  *writeset_out = lwriteset;
     fb4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     fb6:	7d3a      	ldrb	r2, [r7, #20]
     fb8:	701a      	strb	r2, [r3, #0]
  *exceptset_out = lexceptset;
     fba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     fbc:	7c3a      	ldrb	r2, [r7, #16]
     fbe:	701a      	strb	r2, [r3, #0]

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
     fc0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
}
     fc2:	4618      	mov	r0, r3
     fc4:	f107 0738 	add.w	r7, r7, #56	; 0x38
     fc8:	46bd      	mov	sp, r7
     fca:	bd80      	pop	{r7, pc}

00000fcc <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
     fcc:	b580      	push	{r7, lr}
     fce:	b09c      	sub	sp, #112	; 0x70
     fd0:	af04      	add	r7, sp, #16
     fd2:	60f8      	str	r0, [r7, #12]
     fd4:	60b9      	str	r1, [r7, #8]
     fd6:	607a      	str	r2, [r7, #4]
     fd8:	603b      	str	r3, [r7, #0]
  u32_t waitres = 0;
     fda:	f04f 0300 	mov.w	r3, #0
     fde:	65fb      	str	r3, [r7, #92]	; 0x5c
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
     fe0:	f107 033c 	add.w	r3, r7, #60	; 0x3c
     fe4:	9300      	str	r3, [sp, #0]
     fe6:	f107 0338 	add.w	r3, r7, #56	; 0x38
     fea:	9301      	str	r3, [sp, #4]
     fec:	f107 0334 	add.w	r3, r7, #52	; 0x34
     ff0:	9302      	str	r3, [sp, #8]
     ff2:	68f8      	ldr	r0, [r7, #12]
     ff4:	68b9      	ldr	r1, [r7, #8]
     ff6:	687a      	ldr	r2, [r7, #4]
     ff8:	683b      	ldr	r3, [r7, #0]
     ffa:	f7ff fec9 	bl	d90 <lwip_selscan>
     ffe:	65b8      	str	r0, [r7, #88]	; 0x58

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
    1000:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1002:	2b00      	cmp	r3, #0
    1004:	f040 818d 	bne.w	1322 <lwip_select+0x356>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
    1008:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    100a:	2b00      	cmp	r3, #0
    100c:	d008      	beq.n	1020 <lwip_select+0x54>
    100e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1010:	681b      	ldr	r3, [r3, #0]
    1012:	2b00      	cmp	r3, #0
    1014:	d104      	bne.n	1020 <lwip_select+0x54>
    1016:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1018:	685b      	ldr	r3, [r3, #4]
    101a:	2b00      	cmp	r3, #0
    101c:	f000 817e 	beq.w	131c <lwip_select+0x350>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
    1020:	f04f 0300 	mov.w	r3, #0
    1024:	617b      	str	r3, [r7, #20]
    select_cb.prev = NULL;
    1026:	f04f 0300 	mov.w	r3, #0
    102a:	61bb      	str	r3, [r7, #24]
    select_cb.readset = readset;
    102c:	68bb      	ldr	r3, [r7, #8]
    102e:	61fb      	str	r3, [r7, #28]
    select_cb.writeset = writeset;
    1030:	687b      	ldr	r3, [r7, #4]
    1032:	623b      	str	r3, [r7, #32]
    select_cb.exceptset = exceptset;
    1034:	683b      	ldr	r3, [r7, #0]
    1036:	627b      	str	r3, [r7, #36]	; 0x24
    select_cb.sem_signalled = 0;
    1038:	f04f 0300 	mov.w	r3, #0
    103c:	62bb      	str	r3, [r7, #40]	; 0x28
    err = sys_sem_new(&select_cb.sem, 0);
    103e:	f107 0314 	add.w	r3, r7, #20
    1042:	f103 0318 	add.w	r3, r3, #24
    1046:	4618      	mov	r0, r3
    1048:	f04f 0100 	mov.w	r1, #0
    104c:	f7ff fffe 	bl	0 <sys_sem_new>
			104c: R_ARM_THM_CALL	sys_sem_new
    1050:	4603      	mov	r3, r0
    1052:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
    if (err != ERR_OK) {
    1056:	f997 304f 	ldrsb.w	r3, [r7, #79]	; 0x4f
    105a:	2b00      	cmp	r3, #0
    105c:	d002      	beq.n	1064 <lwip_select+0x98>
      /* failed to create semaphore */
      set_errno(ENOMEM);
      return -1;
    105e:	f04f 33ff 	mov.w	r3, #4294967295
    1062:	e174      	b.n	2ec <sys_arch_protect+0x2ec>
    }

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);
    1064:	f7ff fffe 	bl	0 <sys_arch_protect>
			1064: R_ARM_THM_CALL	sys_arch_protect
    1068:	64b8      	str	r0, [r7, #72]	; 0x48

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
    106a:	4b95      	ldr	r3, [pc, #596]	; (12c0 <lwip_select+0x2f4>)
    106c:	681b      	ldr	r3, [r3, #0]
    106e:	617b      	str	r3, [r7, #20]
    if (select_cb_list != NULL) {
    1070:	4b93      	ldr	r3, [pc, #588]	; (12c0 <lwip_select+0x2f4>)
    1072:	681b      	ldr	r3, [r3, #0]
    1074:	2b00      	cmp	r3, #0
    1076:	d004      	beq.n	1082 <lwip_select+0xb6>
      select_cb_list->prev = &select_cb;
    1078:	4b91      	ldr	r3, [pc, #580]	; (12c0 <lwip_select+0x2f4>)
    107a:	681b      	ldr	r3, [r3, #0]
    107c:	f107 0214 	add.w	r2, r7, #20
    1080:	605a      	str	r2, [r3, #4]
    }
    select_cb_list = &select_cb;
    1082:	4b8f      	ldr	r3, [pc, #572]	; (12c0 <lwip_select+0x2f4>)
    1084:	f107 0214 	add.w	r2, r7, #20
    1088:	601a      	str	r2, [r3, #0]
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
    108a:	4b8e      	ldr	r3, [pc, #568]	; (12c4 <lwip_select+0x2f8>)
    108c:	681b      	ldr	r3, [r3, #0]
    108e:	f103 0201 	add.w	r2, r3, #1
    1092:	4b8c      	ldr	r3, [pc, #560]	; (12c4 <lwip_select+0x2f8>)
    1094:	601a      	str	r2, [r3, #0]

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);
    1096:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    1098:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			1098: R_ARM_THM_CALL	sys_arch_unprotect

    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
    109c:	f04f 0300 	mov.w	r3, #0
    10a0:	653b      	str	r3, [r7, #80]	; 0x50
    10a2:	e058      	b.n	1156 <lwip_select+0x18a>
      if ((readset && FD_ISSET(i, readset)) ||
    10a4:	68bb      	ldr	r3, [r7, #8]
    10a6:	2b00      	cmp	r3, #0
    10a8:	d013      	beq.n	10d2 <lwip_select+0x106>
    10aa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    10ac:	2b00      	cmp	r3, #0
    10ae:	da01      	bge.n	10b4 <lwip_select+0xe8>
    10b0:	f103 0307 	add.w	r3, r3, #7
    10b4:	ea4f 03e3 	mov.w	r3, r3, asr #3
    10b8:	68ba      	ldr	r2, [r7, #8]
    10ba:	5cd3      	ldrb	r3, [r2, r3]
    10bc:	461a      	mov	r2, r3
    10be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    10c0:	f003 0307 	and.w	r3, r3, #7
    10c4:	fa42 f303 	asr.w	r3, r2, r3
    10c8:	f003 0301 	and.w	r3, r3, #1
    10cc:	b2db      	uxtb	r3, r3
    10ce:	2b00      	cmp	r3, #0
    10d0:	d12d      	bne.n	112e <lwip_select+0x162>
    10d2:	687b      	ldr	r3, [r7, #4]
    10d4:	2b00      	cmp	r3, #0
    10d6:	d013      	beq.n	1100 <lwip_select+0x134>
          (writeset && FD_ISSET(i, writeset)) ||
    10d8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    10da:	2b00      	cmp	r3, #0
    10dc:	da01      	bge.n	10e2 <lwip_select+0x116>
    10de:	f103 0307 	add.w	r3, r3, #7
    10e2:	ea4f 03e3 	mov.w	r3, r3, asr #3
    10e6:	687a      	ldr	r2, [r7, #4]
    10e8:	5cd3      	ldrb	r3, [r2, r3]
    10ea:	461a      	mov	r2, r3
    10ec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    10ee:	f003 0307 	and.w	r3, r3, #7
    10f2:	fa42 f303 	asr.w	r3, r2, r3
    10f6:	f003 0301 	and.w	r3, r3, #1
    10fa:	b2db      	uxtb	r3, r3
    10fc:	2b00      	cmp	r3, #0
    10fe:	d116      	bne.n	112e <lwip_select+0x162>
    1100:	683b      	ldr	r3, [r7, #0]
    1102:	2b00      	cmp	r3, #0
    1104:	d023      	beq.n	114e <lwip_select+0x182>
          (exceptset && FD_ISSET(i, exceptset))) {
    1106:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1108:	2b00      	cmp	r3, #0
    110a:	da01      	bge.n	1110 <lwip_select+0x144>
    110c:	f103 0307 	add.w	r3, r3, #7
    1110:	ea4f 03e3 	mov.w	r3, r3, asr #3
    1114:	683a      	ldr	r2, [r7, #0]
    1116:	5cd3      	ldrb	r3, [r2, r3]
    1118:	461a      	mov	r2, r3
    111a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    111c:	f003 0307 	and.w	r3, r3, #7
    1120:	fa42 f303 	asr.w	r3, r2, r3
    1124:	f003 0301 	and.w	r3, r3, #1
    1128:	b2db      	uxtb	r3, r3
    112a:	2b00      	cmp	r3, #0
    112c:	d00f      	beq.n	114e <lwip_select+0x182>
        struct lwip_sock *sock = tryget_socket(i);
    112e:	6d38      	ldr	r0, [r7, #80]	; 0x50
    1130:	f7fe ff94 	bl	5c <tryget_socket>
    1134:	6478      	str	r0, [r7, #68]	; 0x44
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
    1136:	f7ff fffe 	bl	0 <sys_arch_protect>
			1136: R_ARM_THM_CALL	sys_arch_protect
    113a:	64b8      	str	r0, [r7, #72]	; 0x48
        sock->select_waiting++;
    113c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    113e:	695b      	ldr	r3, [r3, #20]
    1140:	f103 0201 	add.w	r2, r3, #1
    1144:	6c7b      	ldr	r3, [r7, #68]	; 0x44
    1146:	615a      	str	r2, [r3, #20]
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
        SYS_ARCH_UNPROTECT(lev);
    1148:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    114a:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			114a: R_ARM_THM_CALL	sys_arch_unprotect

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);

    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
    114e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1150:	f103 0301 	add.w	r3, r3, #1
    1154:	653b      	str	r3, [r7, #80]	; 0x50
    1156:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    1158:	68fb      	ldr	r3, [r7, #12]
    115a:	429a      	cmp	r2, r3
    115c:	dba2      	blt.n	10a4 <lwip_select+0xd8>
      }
    }

    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
    115e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
    1162:	9300      	str	r3, [sp, #0]
    1164:	f107 0338 	add.w	r3, r7, #56	; 0x38
    1168:	9301      	str	r3, [sp, #4]
    116a:	f107 0334 	add.w	r3, r7, #52	; 0x34
    116e:	9302      	str	r3, [sp, #8]
    1170:	68f8      	ldr	r0, [r7, #12]
    1172:	68b9      	ldr	r1, [r7, #8]
    1174:	687a      	ldr	r2, [r7, #4]
    1176:	683b      	ldr	r3, [r7, #0]
    1178:	f7ff fe0a 	bl	d90 <lwip_selscan>
    117c:	65b8      	str	r0, [r7, #88]	; 0x58
    if (!nready) {
    117e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
    1180:	2b00      	cmp	r3, #0
    1182:	d129      	bne.n	11d8 <lwip_select+0x20c>
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
    1184:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1186:	2b00      	cmp	r3, #0
    1188:	d103      	bne.n	1192 <lwip_select+0x1c6>
        /* Wait forever */
        msectimeout = 0;
    118a:	f04f 0300 	mov.w	r3, #0
    118e:	657b      	str	r3, [r7, #84]	; 0x54
    1190:	e019      	b.n	11c6 <lwip_select+0x1fa>
      } else {
        msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
    1192:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    1194:	681b      	ldr	r3, [r3, #0]
    1196:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    119a:	fb02 f203 	mul.w	r2, r2, r3
    119e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
    11a0:	685b      	ldr	r3, [r3, #4]
    11a2:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
    11a6:	4948      	ldr	r1, [pc, #288]	; (12c8 <lwip_select+0x2fc>)
    11a8:	fb81 0103 	smull	r0, r1, r1, r3
    11ac:	ea4f 11a1 	mov.w	r1, r1, asr #6
    11b0:	ea4f 73e3 	mov.w	r3, r3, asr #31
    11b4:	1acb      	subs	r3, r1, r3
    11b6:	18d3      	adds	r3, r2, r3
    11b8:	657b      	str	r3, [r7, #84]	; 0x54
        if (msectimeout == 0) {
    11ba:	6d7b      	ldr	r3, [r7, #84]	; 0x54
    11bc:	2b00      	cmp	r3, #0
    11be:	d102      	bne.n	11c6 <lwip_select+0x1fa>
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
    11c0:	f04f 0301 	mov.w	r3, #1
    11c4:	657b      	str	r3, [r7, #84]	; 0x54
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    11c6:	f107 0314 	add.w	r3, r7, #20
    11ca:	f103 0318 	add.w	r3, r3, #24
    11ce:	4618      	mov	r0, r3
    11d0:	6d79      	ldr	r1, [r7, #84]	; 0x54
    11d2:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			11d2: R_ARM_THM_CALL	sys_arch_sem_wait
    11d6:	65f8      	str	r0, [r7, #92]	; 0x5c
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
    11d8:	f04f 0300 	mov.w	r3, #0
    11dc:	653b      	str	r3, [r7, #80]	; 0x50
    11de:	e058      	b.n	1292 <lwip_select+0x2c6>
      if ((readset && FD_ISSET(i, readset)) ||
    11e0:	68bb      	ldr	r3, [r7, #8]
    11e2:	2b00      	cmp	r3, #0
    11e4:	d013      	beq.n	120e <lwip_select+0x242>
    11e6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    11e8:	2b00      	cmp	r3, #0
    11ea:	da01      	bge.n	11f0 <lwip_select+0x224>
    11ec:	f103 0307 	add.w	r3, r3, #7
    11f0:	ea4f 03e3 	mov.w	r3, r3, asr #3
    11f4:	68ba      	ldr	r2, [r7, #8]
    11f6:	5cd3      	ldrb	r3, [r2, r3]
    11f8:	461a      	mov	r2, r3
    11fa:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    11fc:	f003 0307 	and.w	r3, r3, #7
    1200:	fa42 f303 	asr.w	r3, r2, r3
    1204:	f003 0301 	and.w	r3, r3, #1
    1208:	b2db      	uxtb	r3, r3
    120a:	2b00      	cmp	r3, #0
    120c:	d12d      	bne.n	126a <lwip_select+0x29e>
    120e:	687b      	ldr	r3, [r7, #4]
    1210:	2b00      	cmp	r3, #0
    1212:	d013      	beq.n	123c <lwip_select+0x270>
          (writeset && FD_ISSET(i, writeset)) ||
    1214:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1216:	2b00      	cmp	r3, #0
    1218:	da01      	bge.n	121e <lwip_select+0x252>
    121a:	f103 0307 	add.w	r3, r3, #7
    121e:	ea4f 03e3 	mov.w	r3, r3, asr #3
    1222:	687a      	ldr	r2, [r7, #4]
    1224:	5cd3      	ldrb	r3, [r2, r3]
    1226:	461a      	mov	r2, r3
    1228:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    122a:	f003 0307 	and.w	r3, r3, #7
    122e:	fa42 f303 	asr.w	r3, r2, r3
    1232:	f003 0301 	and.w	r3, r3, #1
    1236:	b2db      	uxtb	r3, r3
    1238:	2b00      	cmp	r3, #0
    123a:	d116      	bne.n	126a <lwip_select+0x29e>
    123c:	683b      	ldr	r3, [r7, #0]
    123e:	2b00      	cmp	r3, #0
    1240:	d023      	beq.n	128a <lwip_select+0x2be>
          (exceptset && FD_ISSET(i, exceptset))) {
    1242:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1244:	2b00      	cmp	r3, #0
    1246:	da01      	bge.n	124c <lwip_select+0x280>
    1248:	f103 0307 	add.w	r3, r3, #7
    124c:	ea4f 03e3 	mov.w	r3, r3, asr #3
    1250:	683a      	ldr	r2, [r7, #0]
    1252:	5cd3      	ldrb	r3, [r2, r3]
    1254:	461a      	mov	r2, r3
    1256:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    1258:	f003 0307 	and.w	r3, r3, #7
    125c:	fa42 f303 	asr.w	r3, r2, r3
    1260:	f003 0301 	and.w	r3, r3, #1
    1264:	b2db      	uxtb	r3, r3
    1266:	2b00      	cmp	r3, #0
    1268:	d00f      	beq.n	128a <lwip_select+0x2be>
        struct lwip_sock *sock = tryget_socket(i);
    126a:	6d38      	ldr	r0, [r7, #80]	; 0x50
    126c:	f7fe fef6 	bl	5c <tryget_socket>
    1270:	6438      	str	r0, [r7, #64]	; 0x40
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
    1272:	f7ff fffe 	bl	0 <sys_arch_protect>
			1272: R_ARM_THM_CALL	sys_arch_protect
    1276:	64b8      	str	r0, [r7, #72]	; 0x48
        sock->select_waiting--;
    1278:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    127a:	695b      	ldr	r3, [r3, #20]
    127c:	f103 32ff 	add.w	r2, r3, #4294967295
    1280:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    1282:	615a      	str	r2, [r3, #20]
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
    1284:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    1286:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			1286: R_ARM_THM_CALL	sys_arch_unprotect
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
    128a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
    128c:	f103 0301 	add.w	r3, r3, #1
    1290:	653b      	str	r3, [r7, #80]	; 0x50
    1292:	6d3a      	ldr	r2, [r7, #80]	; 0x50
    1294:	68fb      	ldr	r3, [r7, #12]
    1296:	429a      	cmp	r2, r3
    1298:	dba2      	blt.n	11e0 <lwip_select+0x214>
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
    129a:	f7ff fffe 	bl	0 <sys_arch_protect>
			129a: R_ARM_THM_CALL	sys_arch_protect
    129e:	64b8      	str	r0, [r7, #72]	; 0x48
    if (select_cb.next != NULL) {
    12a0:	697b      	ldr	r3, [r7, #20]
    12a2:	2b00      	cmp	r3, #0
    12a4:	d002      	beq.n	12ac <lwip_select+0x2e0>
      select_cb.next->prev = select_cb.prev;
    12a6:	697b      	ldr	r3, [r7, #20]
    12a8:	69ba      	ldr	r2, [r7, #24]
    12aa:	605a      	str	r2, [r3, #4]
    }
    if (select_cb_list == &select_cb) {
    12ac:	4b04      	ldr	r3, [pc, #16]	; (12c0 <lwip_select+0x2f4>)
    12ae:	681a      	ldr	r2, [r3, #0]
    12b0:	f107 0314 	add.w	r3, r7, #20
    12b4:	429a      	cmp	r2, r3
    12b6:	d109      	bne.n	12cc <lwip_select+0x300>
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
      select_cb_list = select_cb.next;
    12b8:	697a      	ldr	r2, [r7, #20]
    12ba:	4b01      	ldr	r3, [pc, #4]	; (12c0 <lwip_select+0x2f4>)
    12bc:	601a      	str	r2, [r3, #0]
    12be:	e008      	b.n	12d2 <lwip_select+0x306>
    12c0:	000000c0 	.word	0x000000c0
			12c0: R_ARM_ABS32	.bss
    12c4:	000000c4 	.word	0x000000c4
			12c4: R_ARM_ABS32	.bss
    12c8:	10624dd3 	.word	0x10624dd3
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
      select_cb.prev->next = select_cb.next;
    12cc:	69bb      	ldr	r3, [r7, #24]
    12ce:	697a      	ldr	r2, [r7, #20]
    12d0:	601a      	str	r2, [r3, #0]
    }
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
    12d2:	4b21      	ldr	r3, [pc, #132]	; (1358 <lwip_select+0x38c>)
    12d4:	681b      	ldr	r3, [r3, #0]
    12d6:	f103 0201 	add.w	r2, r3, #1
    12da:	4b1f      	ldr	r3, [pc, #124]	; (1358 <lwip_select+0x38c>)
    12dc:	601a      	str	r2, [r3, #0]
    SYS_ARCH_UNPROTECT(lev);
    12de:	6cb8      	ldr	r0, [r7, #72]	; 0x48
    12e0:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			12e0: R_ARM_THM_CALL	sys_arch_unprotect

    sys_sem_free(&select_cb.sem);
    12e4:	f107 0314 	add.w	r3, r7, #20
    12e8:	f103 0318 	add.w	r3, r3, #24
    12ec:	4618      	mov	r0, r3
    12ee:	f7ff fffe 	bl	0 <sys_sem_free>
			12ee: R_ARM_THM_CALL	sys_sem_free
    if (waitres == SYS_ARCH_TIMEOUT)  {
    12f2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
    12f4:	f1b3 3fff 	cmp.w	r3, #4294967295
    12f8:	d012      	beq.n	1320 <lwip_select+0x354>
         or we would have returned earlier. */
      goto return_copy_fdsets;
    }

    /* See what's set */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
    12fa:	f107 033c 	add.w	r3, r7, #60	; 0x3c
    12fe:	9300      	str	r3, [sp, #0]
    1300:	f107 0338 	add.w	r3, r7, #56	; 0x38
    1304:	9301      	str	r3, [sp, #4]
    1306:	f107 0334 	add.w	r3, r7, #52	; 0x34
    130a:	9302      	str	r3, [sp, #8]
    130c:	68f8      	ldr	r0, [r7, #12]
    130e:	68b9      	ldr	r1, [r7, #8]
    1310:	687a      	ldr	r2, [r7, #4]
    1312:	683b      	ldr	r3, [r7, #0]
    1314:	f7ff fd3c 	bl	d90 <lwip_selscan>
    1318:	65b8      	str	r0, [r7, #88]	; 0x58
    131a:	e002      	b.n	1322 <lwip_select+0x356>
  if (!nready) {
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
    131c:	bf00      	nop
    131e:	e000      	b.n	1322 <lwip_select+0x356>
    if (waitres == SYS_ARCH_TIMEOUT)  {
      /* Timeout */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      /* This is OK as the local fdsets are empty and nready is zero,
         or we would have returned earlier. */
      goto return_copy_fdsets;
    1320:	bf00      	nop
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
return_copy_fdsets:
  set_errno(0);
  if (readset) {
    1322:	68bb      	ldr	r3, [r7, #8]
    1324:	2b00      	cmp	r3, #0
    1326:	d003      	beq.n	1330 <lwip_select+0x364>
    *readset = lreadset;
    1328:	68bb      	ldr	r3, [r7, #8]
    132a:	f897 203c 	ldrb.w	r2, [r7, #60]	; 0x3c
    132e:	701a      	strb	r2, [r3, #0]
  }
  if (writeset) {
    1330:	687b      	ldr	r3, [r7, #4]
    1332:	2b00      	cmp	r3, #0
    1334:	d003      	beq.n	133e <lwip_select+0x372>
    *writeset = lwriteset;
    1336:	687b      	ldr	r3, [r7, #4]
    1338:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
    133c:	701a      	strb	r2, [r3, #0]
  }
  if (exceptset) {
    133e:	683b      	ldr	r3, [r7, #0]
    1340:	2b00      	cmp	r3, #0
    1342:	d003      	beq.n	134c <lwip_select+0x380>
    *exceptset = lexceptset;
    1344:	683b      	ldr	r3, [r7, #0]
    1346:	f897 2034 	ldrb.w	r2, [r7, #52]	; 0x34
    134a:	701a      	strb	r2, [r3, #0]
  }


  return nready;
    134c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
}
    134e:	4618      	mov	r0, r3
    1350:	f107 0760 	add.w	r7, r7, #96	; 0x60
    1354:	46bd      	mov	sp, r7
    1356:	bd80      	pop	{r7, pc}
    1358:	000000c4 	.word	0x000000c4
			1358: R_ARM_ABS32	.bss

0000135c <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
    135c:	b580      	push	{r7, lr}
    135e:	b088      	sub	sp, #32
    1360:	af00      	add	r7, sp, #0
    1362:	6078      	str	r0, [r7, #4]
    1364:	4613      	mov	r3, r2
    1366:	460a      	mov	r2, r1
    1368:	70fa      	strb	r2, [r7, #3]
    136a:	803b      	strh	r3, [r7, #0]
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
    136c:	687b      	ldr	r3, [r7, #4]
    136e:	2b00      	cmp	r3, #0
    1370:	f000 80fe 	beq.w	1570 <event_callback+0x214>
    s = conn->socket;
    1374:	687b      	ldr	r3, [r7, #4]
    1376:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1378:	61fb      	str	r3, [r7, #28]
    if (s < 0) {
    137a:	69fb      	ldr	r3, [r7, #28]
    137c:	2b00      	cmp	r3, #0
    137e:	da19      	bge.n	13b4 <event_callback+0x58>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
    1380:	f7ff fffe 	bl	0 <sys_arch_protect>
			1380: R_ARM_THM_CALL	sys_arch_protect
    1384:	6178      	str	r0, [r7, #20]
      if (conn->socket < 0) {
    1386:	687b      	ldr	r3, [r7, #4]
    1388:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    138a:	2b00      	cmp	r3, #0
    138c:	da0c      	bge.n	13a8 <event_callback+0x4c>
        if (evt == NETCONN_EVT_RCVPLUS) {
    138e:	78fb      	ldrb	r3, [r7, #3]
    1390:	2b00      	cmp	r3, #0
    1392:	d105      	bne.n	13a0 <event_callback+0x44>
          conn->socket--;
    1394:	687b      	ldr	r3, [r7, #4]
    1396:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    1398:	f103 32ff 	add.w	r2, r3, #4294967295
    139c:	687b      	ldr	r3, [r7, #4]
    139e:	625a      	str	r2, [r3, #36]	; 0x24
        }
        SYS_ARCH_UNPROTECT(lev);
    13a0:	6978      	ldr	r0, [r7, #20]
    13a2:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			13a2: R_ARM_THM_CALL	sys_arch_unprotect
        return;
    13a6:	e0e6      	b.n	1576 <event_callback+0x21a>
      }
      s = conn->socket;
    13a8:	687b      	ldr	r3, [r7, #4]
    13aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    13ac:	61fb      	str	r3, [r7, #28]
      SYS_ARCH_UNPROTECT(lev);
    13ae:	6978      	ldr	r0, [r7, #20]
    13b0:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			13b0: R_ARM_THM_CALL	sys_arch_unprotect
    }

    sock = get_socket(s);
    13b4:	69f8      	ldr	r0, [r7, #28]
    13b6:	f7fe fe29 	bl	c <get_socket>
    13ba:	60f8      	str	r0, [r7, #12]
    if (!sock) {
    13bc:	68fb      	ldr	r3, [r7, #12]
    13be:	2b00      	cmp	r3, #0
    13c0:	f000 80d8 	beq.w	1574 <event_callback+0x218>
    }
  } else {
    return;
  }

  SYS_ARCH_PROTECT(lev);
    13c4:	f7ff fffe 	bl	0 <sys_arch_protect>
			13c4: R_ARM_THM_CALL	sys_arch_protect
    13c8:	6178      	str	r0, [r7, #20]
  /* Set event as required */
  switch (evt) {
    13ca:	78fb      	ldrb	r3, [r7, #3]
    13cc:	2b04      	cmp	r3, #4
    13ce:	d82c      	bhi.n	142a <event_callback+0xce>
    13d0:	a201      	add	r2, pc, #4	; (adr r2, 13d8 <event_callback+0x7c>)
    13d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    13d6:	bf00      	nop
    13d8:	000013ed 	.word	0x000013ed
			13d8: R_ARM_ABS32	.text
    13dc:	000013fd 	.word	0x000013fd
			13dc: R_ARM_ABS32	.text
    13e0:	0000140d 	.word	0x0000140d
			13e0: R_ARM_ABS32	.text
    13e4:	00001417 	.word	0x00001417
			13e4: R_ARM_ABS32	.text
    13e8:	00001421 	.word	0x00001421
			13e8: R_ARM_ABS32	.text
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
    13ec:	68fb      	ldr	r3, [r7, #12]
    13ee:	895b      	ldrh	r3, [r3, #10]
    13f0:	f103 0301 	add.w	r3, r3, #1
    13f4:	b29a      	uxth	r2, r3
    13f6:	68fb      	ldr	r3, [r7, #12]
    13f8:	815a      	strh	r2, [r3, #10]
      break;
    13fa:	e017      	b.n	142c <event_callback+0xd0>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
    13fc:	68fb      	ldr	r3, [r7, #12]
    13fe:	895b      	ldrh	r3, [r3, #10]
    1400:	f103 33ff 	add.w	r3, r3, #4294967295
    1404:	b29a      	uxth	r2, r3
    1406:	68fb      	ldr	r3, [r7, #12]
    1408:	815a      	strh	r2, [r3, #10]
      break;
    140a:	e00f      	b.n	142c <event_callback+0xd0>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
    140c:	68fb      	ldr	r3, [r7, #12]
    140e:	f04f 0201 	mov.w	r2, #1
    1412:	819a      	strh	r2, [r3, #12]
      break;
    1414:	e00a      	b.n	142c <event_callback+0xd0>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
    1416:	68fb      	ldr	r3, [r7, #12]
    1418:	f04f 0200 	mov.w	r2, #0
    141c:	819a      	strh	r2, [r3, #12]
      break;
    141e:	e005      	b.n	142c <event_callback+0xd0>
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
    1420:	68fb      	ldr	r3, [r7, #12]
    1422:	f04f 0201 	mov.w	r2, #1
    1426:	81da      	strh	r2, [r3, #14]
      break;
    1428:	e000      	b.n	142c <event_callback+0xd0>
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
    142a:	bf00      	nop
  }

  if (sock->select_waiting == 0) {
    142c:	68fb      	ldr	r3, [r7, #12]
    142e:	695b      	ldr	r3, [r3, #20]
    1430:	2b00      	cmp	r3, #0
    1432:	d104      	bne.n	143e <event_callback+0xe2>
    /* noone is waiting for this socket, no need to check select_cb_list */
    SYS_ARCH_UNPROTECT(lev);
    1434:	6978      	ldr	r0, [r7, #20]
    1436:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			1436: R_ARM_THM_CALL	sys_arch_unprotect
    return;
    143a:	e09c      	b.n	1576 <event_callback+0x21a>
    SYS_ARCH_UNPROTECT(lev);
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    143c:	bf00      	nop
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    143e:	4b50      	ldr	r3, [pc, #320]	; (1580 <event_callback+0x224>)
    1440:	681b      	ldr	r3, [r3, #0]
    1442:	61bb      	str	r3, [r7, #24]
    1444:	e08c      	b.n	1560 <event_callback+0x204>
    if (scb->sem_signalled == 0) {
    1446:	69bb      	ldr	r3, [r7, #24]
    1448:	695b      	ldr	r3, [r3, #20]
    144a:	2b00      	cmp	r3, #0
    144c:	d176      	bne.n	153c <event_callback+0x1e0>
      /* semaphore not signalled yet */
      int do_signal = 0;
    144e:	f04f 0300 	mov.w	r3, #0
    1452:	613b      	str	r3, [r7, #16]
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
    1454:	68fb      	ldr	r3, [r7, #12]
    1456:	895b      	ldrh	r3, [r3, #10]
    1458:	b21b      	sxth	r3, r3
    145a:	2b00      	cmp	r3, #0
    145c:	dd1b      	ble.n	1496 <event_callback+0x13a>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
    145e:	69bb      	ldr	r3, [r7, #24]
    1460:	689b      	ldr	r3, [r3, #8]
    1462:	2b00      	cmp	r3, #0
    1464:	d017      	beq.n	1496 <event_callback+0x13a>
    1466:	69bb      	ldr	r3, [r7, #24]
    1468:	689a      	ldr	r2, [r3, #8]
    146a:	69fb      	ldr	r3, [r7, #28]
    146c:	2b00      	cmp	r3, #0
    146e:	da01      	bge.n	1474 <event_callback+0x118>
    1470:	f103 0307 	add.w	r3, r3, #7
    1474:	ea4f 03e3 	mov.w	r3, r3, asr #3
    1478:	5cd3      	ldrb	r3, [r2, r3]
    147a:	461a      	mov	r2, r3
    147c:	69fb      	ldr	r3, [r7, #28]
    147e:	f003 0307 	and.w	r3, r3, #7
    1482:	fa42 f303 	asr.w	r3, r2, r3
    1486:	f003 0301 	and.w	r3, r3, #1
    148a:	b2db      	uxtb	r3, r3
    148c:	2b00      	cmp	r3, #0
    148e:	d002      	beq.n	1496 <event_callback+0x13a>
          do_signal = 1;
    1490:	f04f 0301 	mov.w	r3, #1
    1494:	613b      	str	r3, [r7, #16]
        }
      }
      if (sock->sendevent != 0) {
    1496:	68fb      	ldr	r3, [r7, #12]
    1498:	899b      	ldrh	r3, [r3, #12]
    149a:	2b00      	cmp	r3, #0
    149c:	d01e      	beq.n	14dc <event_callback+0x180>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
    149e:	693b      	ldr	r3, [r7, #16]
    14a0:	2b00      	cmp	r3, #0
    14a2:	d11b      	bne.n	14dc <event_callback+0x180>
    14a4:	69bb      	ldr	r3, [r7, #24]
    14a6:	68db      	ldr	r3, [r3, #12]
    14a8:	2b00      	cmp	r3, #0
    14aa:	d017      	beq.n	14dc <event_callback+0x180>
    14ac:	69bb      	ldr	r3, [r7, #24]
    14ae:	68da      	ldr	r2, [r3, #12]
    14b0:	69fb      	ldr	r3, [r7, #28]
    14b2:	2b00      	cmp	r3, #0
    14b4:	da01      	bge.n	14ba <event_callback+0x15e>
    14b6:	f103 0307 	add.w	r3, r3, #7
    14ba:	ea4f 03e3 	mov.w	r3, r3, asr #3
    14be:	5cd3      	ldrb	r3, [r2, r3]
    14c0:	461a      	mov	r2, r3
    14c2:	69fb      	ldr	r3, [r7, #28]
    14c4:	f003 0307 	and.w	r3, r3, #7
    14c8:	fa42 f303 	asr.w	r3, r2, r3
    14cc:	f003 0301 	and.w	r3, r3, #1
    14d0:	b2db      	uxtb	r3, r3
    14d2:	2b00      	cmp	r3, #0
    14d4:	d002      	beq.n	14dc <event_callback+0x180>
          do_signal = 1;
    14d6:	f04f 0301 	mov.w	r3, #1
    14da:	613b      	str	r3, [r7, #16]
        }
      }
      if (sock->errevent != 0) {
    14dc:	68fb      	ldr	r3, [r7, #12]
    14de:	89db      	ldrh	r3, [r3, #14]
    14e0:	2b00      	cmp	r3, #0
    14e2:	d01e      	beq.n	1522 <event_callback+0x1c6>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
    14e4:	693b      	ldr	r3, [r7, #16]
    14e6:	2b00      	cmp	r3, #0
    14e8:	d11b      	bne.n	1522 <event_callback+0x1c6>
    14ea:	69bb      	ldr	r3, [r7, #24]
    14ec:	691b      	ldr	r3, [r3, #16]
    14ee:	2b00      	cmp	r3, #0
    14f0:	d017      	beq.n	1522 <event_callback+0x1c6>
    14f2:	69bb      	ldr	r3, [r7, #24]
    14f4:	691a      	ldr	r2, [r3, #16]
    14f6:	69fb      	ldr	r3, [r7, #28]
    14f8:	2b00      	cmp	r3, #0
    14fa:	da01      	bge.n	1500 <event_callback+0x1a4>
    14fc:	f103 0307 	add.w	r3, r3, #7
    1500:	ea4f 03e3 	mov.w	r3, r3, asr #3
    1504:	5cd3      	ldrb	r3, [r2, r3]
    1506:	461a      	mov	r2, r3
    1508:	69fb      	ldr	r3, [r7, #28]
    150a:	f003 0307 	and.w	r3, r3, #7
    150e:	fa42 f303 	asr.w	r3, r2, r3
    1512:	f003 0301 	and.w	r3, r3, #1
    1516:	b2db      	uxtb	r3, r3
    1518:	2b00      	cmp	r3, #0
    151a:	d002      	beq.n	1522 <event_callback+0x1c6>
          do_signal = 1;
    151c:	f04f 0301 	mov.w	r3, #1
    1520:	613b      	str	r3, [r7, #16]
        }
      }
      if (do_signal) {
    1522:	693b      	ldr	r3, [r7, #16]
    1524:	2b00      	cmp	r3, #0
    1526:	d009      	beq.n	153c <event_callback+0x1e0>
        scb->sem_signalled = 1;
    1528:	69bb      	ldr	r3, [r7, #24]
    152a:	f04f 0201 	mov.w	r2, #1
    152e:	615a      	str	r2, [r3, #20]
        /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
           lead to the select thread taking itself off the list, invalidagin the semaphore. */
        sys_sem_signal(&scb->sem);
    1530:	69bb      	ldr	r3, [r7, #24]
    1532:	f103 0318 	add.w	r3, r3, #24
    1536:	4618      	mov	r0, r3
    1538:	f7ff fffe 	bl	0 <sys_sem_signal>
			1538: R_ARM_THM_CALL	sys_sem_signal
      }
    }
    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
    153c:	4b11      	ldr	r3, [pc, #68]	; (1584 <event_callback+0x228>)
    153e:	681b      	ldr	r3, [r3, #0]
    1540:	60bb      	str	r3, [r7, #8]
    SYS_ARCH_UNPROTECT(lev);
    1542:	6978      	ldr	r0, [r7, #20]
    1544:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			1544: R_ARM_THM_CALL	sys_arch_unprotect
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
    1548:	f7ff fffe 	bl	0 <sys_arch_protect>
			1548: R_ARM_THM_CALL	sys_arch_protect
    154c:	6178      	str	r0, [r7, #20]
    if (last_select_cb_ctr != select_cb_ctr) {
    154e:	4b0d      	ldr	r3, [pc, #52]	; (1584 <event_callback+0x228>)
    1550:	681b      	ldr	r3, [r3, #0]
    1552:	68ba      	ldr	r2, [r7, #8]
    1554:	429a      	cmp	r2, r3
    1556:	f47f af71 	bne.w	143c <event_callback+0xe0>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
    155a:	69bb      	ldr	r3, [r7, #24]
    155c:	681b      	ldr	r3, [r3, #0]
    155e:	61bb      	str	r3, [r7, #24]
    1560:	69bb      	ldr	r3, [r7, #24]
    1562:	2b00      	cmp	r3, #0
    1564:	f47f af6f 	bne.w	1446 <event_callback+0xea>
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
    1568:	6978      	ldr	r0, [r7, #20]
    156a:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			156a: R_ARM_THM_CALL	sys_arch_unprotect
    156e:	e002      	b.n	1576 <event_callback+0x21a>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
    1570:	bf00      	nop
    1572:	e000      	b.n	1576 <event_callback+0x21a>
      SYS_ARCH_UNPROTECT(lev);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
    1574:	bf00      	nop
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
}
    1576:	f107 0720 	add.w	r7, r7, #32
    157a:	46bd      	mov	sp, r7
    157c:	bd80      	pop	{r7, pc}
    157e:	bf00      	nop
    1580:	000000c0 	.word	0x000000c0
			1580: R_ARM_ABS32	.bss
    1584:	000000c4 	.word	0x000000c4
			1584: R_ARM_ABS32	.bss

00001588 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
    1588:	b580      	push	{r7, lr}
    158a:	b086      	sub	sp, #24
    158c:	af00      	add	r7, sp, #0
    158e:	6078      	str	r0, [r7, #4]
    1590:	6039      	str	r1, [r7, #0]
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
    1592:	f04f 0300 	mov.w	r3, #0
    1596:	75fb      	strb	r3, [r7, #23]
    1598:	f04f 0300 	mov.w	r3, #0
    159c:	75bb      	strb	r3, [r7, #22]

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
    159e:	6878      	ldr	r0, [r7, #4]
    15a0:	f7fe fd34 	bl	c <get_socket>
    15a4:	6138      	str	r0, [r7, #16]
  if (!sock) {
    15a6:	693b      	ldr	r3, [r7, #16]
    15a8:	2b00      	cmp	r3, #0
    15aa:	d102      	bne.n	15b2 <lwip_shutdown+0x2a>
    return -1;
    15ac:	f04f 33ff 	mov.w	r3, #4294967295
    15b0:	e05b      	b.n	166a <lwip_shutdown+0xe2>
  }

  if (sock->conn != NULL) {
    15b2:	693b      	ldr	r3, [r7, #16]
    15b4:	681b      	ldr	r3, [r3, #0]
    15b6:	2b00      	cmp	r3, #0
    15b8:	d00b      	beq.n	15d2 <lwip_shutdown+0x4a>
    if (netconn_type(sock->conn) != NETCONN_TCP) {
    15ba:	693b      	ldr	r3, [r7, #16]
    15bc:	681b      	ldr	r3, [r3, #0]
    15be:	781b      	ldrb	r3, [r3, #0]
    15c0:	2b10      	cmp	r3, #16
    15c2:	d00d      	beq.n	15e0 <lwip_shutdown+0x58>
      sock_set_errno(sock, EOPNOTSUPP);
    15c4:	693b      	ldr	r3, [r7, #16]
    15c6:	f04f 025f 	mov.w	r2, #95	; 0x5f
    15ca:	611a      	str	r2, [r3, #16]
      return EOPNOTSUPP;
    15cc:	f04f 035f 	mov.w	r3, #95	; 0x5f
    15d0:	e04b      	b.n	166a <lwip_shutdown+0xe2>
    }
  } else {
    sock_set_errno(sock, ENOTCONN);
    15d2:	693b      	ldr	r3, [r7, #16]
    15d4:	f04f 026b 	mov.w	r2, #107	; 0x6b
    15d8:	611a      	str	r2, [r3, #16]
    return ENOTCONN;
    15da:	f04f 036b 	mov.w	r3, #107	; 0x6b
    15de:	e044      	b.n	166a <lwip_shutdown+0xe2>
  }

  if (how == SHUT_RD) {
    15e0:	683b      	ldr	r3, [r7, #0]
    15e2:	2b00      	cmp	r3, #0
    15e4:	d103      	bne.n	15ee <lwip_shutdown+0x66>
    shut_rx = 1;
    15e6:	f04f 0301 	mov.w	r3, #1
    15ea:	75fb      	strb	r3, [r7, #23]
    15ec:	e017      	b.n	161e <lwip_shutdown+0x96>
  } else if (how == SHUT_WR) {
    15ee:	683b      	ldr	r3, [r7, #0]
    15f0:	2b01      	cmp	r3, #1
    15f2:	d103      	bne.n	15fc <lwip_shutdown+0x74>
    shut_tx = 1;
    15f4:	f04f 0301 	mov.w	r3, #1
    15f8:	75bb      	strb	r3, [r7, #22]
    15fa:	e010      	b.n	161e <lwip_shutdown+0x96>
  } else if(how == SHUT_RDWR) {
    15fc:	683b      	ldr	r3, [r7, #0]
    15fe:	2b02      	cmp	r3, #2
    1600:	d106      	bne.n	1610 <lwip_shutdown+0x88>
    shut_rx = 1;
    1602:	f04f 0301 	mov.w	r3, #1
    1606:	75fb      	strb	r3, [r7, #23]
    shut_tx = 1;
    1608:	f04f 0301 	mov.w	r3, #1
    160c:	75bb      	strb	r3, [r7, #22]
    160e:	e006      	b.n	161e <lwip_shutdown+0x96>
  } else {
    sock_set_errno(sock, EINVAL);
    1610:	693b      	ldr	r3, [r7, #16]
    1612:	f04f 0216 	mov.w	r2, #22
    1616:	611a      	str	r2, [r3, #16]
    return EINVAL;
    1618:	f04f 0316 	mov.w	r3, #22
    161c:	e025      	b.n	166a <lwip_shutdown+0xe2>
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
    161e:	693b      	ldr	r3, [r7, #16]
    1620:	6819      	ldr	r1, [r3, #0]
    1622:	7dfa      	ldrb	r2, [r7, #23]
    1624:	7dbb      	ldrb	r3, [r7, #22]
    1626:	4608      	mov	r0, r1
    1628:	4611      	mov	r1, r2
    162a:	461a      	mov	r2, r3
    162c:	f7ff fffe 	bl	0 <netconn_shutdown>
			162c: R_ARM_THM_CALL	netconn_shutdown
    1630:	4603      	mov	r3, r0
    1632:	73fb      	strb	r3, [r7, #15]

  sock_set_errno(sock, err_to_errno(err));
    1634:	f997 300f 	ldrsb.w	r3, [r7, #15]
    1638:	f1c3 0300 	rsb	r3, r3, #0
    163c:	2b0f      	cmp	r3, #15
    163e:	d807      	bhi.n	1650 <lwip_shutdown+0xc8>
    1640:	f997 300f 	ldrsb.w	r3, [r7, #15]
    1644:	f1c3 0200 	rsb	r2, r3, #0
    1648:	4b0a      	ldr	r3, [pc, #40]	; (1674 <lwip_shutdown+0xec>)
    164a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    164e:	e001      	b.n	1654 <lwip_shutdown+0xcc>
    1650:	f04f 0305 	mov.w	r3, #5
    1654:	693a      	ldr	r2, [r7, #16]
    1656:	6113      	str	r3, [r2, #16]
  return (err == ERR_OK ? 0 : -1);
    1658:	f997 300f 	ldrsb.w	r3, [r7, #15]
    165c:	2b00      	cmp	r3, #0
    165e:	d102      	bne.n	1666 <lwip_shutdown+0xde>
    1660:	f04f 0300 	mov.w	r3, #0
    1664:	e001      	b.n	166a <lwip_shutdown+0xe2>
    1666:	f04f 33ff 	mov.w	r3, #4294967295
}
    166a:	4618      	mov	r0, r3
    166c:	f107 0718 	add.w	r7, r7, #24
    1670:	46bd      	mov	sp, r7
    1672:	bd80      	pop	{r7, pc}
    1674:	00000000 	.word	0x00000000
			1674: R_ARM_ABS32	.rodata

00001678 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
    1678:	b580      	push	{r7, lr}
    167a:	b08a      	sub	sp, #40	; 0x28
    167c:	af00      	add	r7, sp, #0
    167e:	60f8      	str	r0, [r7, #12]
    1680:	60b9      	str	r1, [r7, #8]
    1682:	607a      	str	r2, [r7, #4]
    1684:	70fb      	strb	r3, [r7, #3]
  struct lwip_sock *sock;
  struct sockaddr_in sin;
  ip_addr_t naddr;

  sock = get_socket(s);
    1686:	68f8      	ldr	r0, [r7, #12]
    1688:	f7fe fcc0 	bl	c <get_socket>
    168c:	6278      	str	r0, [r7, #36]	; 0x24
  if (!sock) {
    168e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1690:	2b00      	cmp	r3, #0
    1692:	d102      	bne.n	169a <lwip_getaddrname+0x22>
    return -1;
    1694:	f04f 33ff 	mov.w	r3, #4294967295
    1698:	e038      	b.n	170c <lwip_getaddrname+0x94>
  }

  memset(&sin, 0, sizeof(sin));
    169a:	f107 0314 	add.w	r3, r7, #20
    169e:	4618      	mov	r0, r3
    16a0:	f04f 0100 	mov.w	r1, #0
    16a4:	f04f 0210 	mov.w	r2, #16
    16a8:	f7ff fffe 	bl	0 <memset>
			16a8: R_ARM_THM_CALL	memset
  sin.sin_len = sizeof(sin);
    16ac:	f04f 0310 	mov.w	r3, #16
    16b0:	753b      	strb	r3, [r7, #20]
  sin.sin_family = AF_INET;
    16b2:	f04f 0302 	mov.w	r3, #2
    16b6:	757b      	strb	r3, [r7, #21]

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
    16b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    16ba:	6818      	ldr	r0, [r3, #0]
    16bc:	f107 0110 	add.w	r1, r7, #16
    16c0:	f107 0314 	add.w	r3, r7, #20
    16c4:	f103 0202 	add.w	r2, r3, #2
    16c8:	78fb      	ldrb	r3, [r7, #3]
    16ca:	f7ff fffe 	bl	0 <netconn_getaddr>
			16ca: R_ARM_THM_CALL	netconn_getaddr

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
    16ce:	8afb      	ldrh	r3, [r7, #22]
    16d0:	4618      	mov	r0, r3
    16d2:	f7ff fffe 	bl	0 <lwip_htons>
			16d2: R_ARM_THM_CALL	lwip_htons
    16d6:	4603      	mov	r3, r0
    16d8:	82fb      	strh	r3, [r7, #22]
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
    16da:	693b      	ldr	r3, [r7, #16]
    16dc:	61bb      	str	r3, [r7, #24]

  if (*namelen > sizeof(sin)) {
    16de:	687b      	ldr	r3, [r7, #4]
    16e0:	681b      	ldr	r3, [r3, #0]
    16e2:	2b10      	cmp	r3, #16
    16e4:	d903      	bls.n	16ee <lwip_getaddrname+0x76>
    *namelen = sizeof(sin);
    16e6:	687b      	ldr	r3, [r7, #4]
    16e8:	f04f 0210 	mov.w	r2, #16
    16ec:	601a      	str	r2, [r3, #0]
  }

  MEMCPY(name, &sin, *namelen);
    16ee:	687b      	ldr	r3, [r7, #4]
    16f0:	681b      	ldr	r3, [r3, #0]
    16f2:	f107 0214 	add.w	r2, r7, #20
    16f6:	68b8      	ldr	r0, [r7, #8]
    16f8:	4611      	mov	r1, r2
    16fa:	461a      	mov	r2, r3
    16fc:	f7ff fffe 	bl	0 <memcpy>
			16fc: R_ARM_THM_CALL	memcpy
  sock_set_errno(sock, 0);
    1700:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1702:	f04f 0200 	mov.w	r2, #0
    1706:	611a      	str	r2, [r3, #16]
  return 0;
    1708:	f04f 0300 	mov.w	r3, #0
}
    170c:	4618      	mov	r0, r3
    170e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    1712:	46bd      	mov	sp, r7
    1714:	bd80      	pop	{r7, pc}
    1716:	bf00      	nop

00001718 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
    1718:	b580      	push	{r7, lr}
    171a:	b084      	sub	sp, #16
    171c:	af00      	add	r7, sp, #0
    171e:	60f8      	str	r0, [r7, #12]
    1720:	60b9      	str	r1, [r7, #8]
    1722:	607a      	str	r2, [r7, #4]
  return lwip_getaddrname(s, name, namelen, 0);
    1724:	68f8      	ldr	r0, [r7, #12]
    1726:	68b9      	ldr	r1, [r7, #8]
    1728:	687a      	ldr	r2, [r7, #4]
    172a:	f04f 0300 	mov.w	r3, #0
    172e:	f7ff ffa3 	bl	1678 <lwip_getaddrname>
    1732:	4603      	mov	r3, r0
}
    1734:	4618      	mov	r0, r3
    1736:	f107 0710 	add.w	r7, r7, #16
    173a:	46bd      	mov	sp, r7
    173c:	bd80      	pop	{r7, pc}
    173e:	bf00      	nop

00001740 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
    1740:	b580      	push	{r7, lr}
    1742:	b084      	sub	sp, #16
    1744:	af00      	add	r7, sp, #0
    1746:	60f8      	str	r0, [r7, #12]
    1748:	60b9      	str	r1, [r7, #8]
    174a:	607a      	str	r2, [r7, #4]
  return lwip_getaddrname(s, name, namelen, 1);
    174c:	68f8      	ldr	r0, [r7, #12]
    174e:	68b9      	ldr	r1, [r7, #8]
    1750:	687a      	ldr	r2, [r7, #4]
    1752:	f04f 0301 	mov.w	r3, #1
    1756:	f7ff ff8f 	bl	1678 <lwip_getaddrname>
    175a:	4603      	mov	r3, r0
}
    175c:	4618      	mov	r0, r3
    175e:	f107 0710 	add.w	r7, r7, #16
    1762:	46bd      	mov	sp, r7
    1764:	bd80      	pop	{r7, pc}
    1766:	bf00      	nop

00001768 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
    1768:	b580      	push	{r7, lr}
    176a:	b08c      	sub	sp, #48	; 0x30
    176c:	af00      	add	r7, sp, #0
    176e:	60f8      	str	r0, [r7, #12]
    1770:	60b9      	str	r1, [r7, #8]
    1772:	607a      	str	r2, [r7, #4]
    1774:	603b      	str	r3, [r7, #0]
  err_t err = ERR_OK;
    1776:	f04f 0300 	mov.w	r3, #0
    177a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  struct lwip_sock *sock = get_socket(s);
    177e:	68f8      	ldr	r0, [r7, #12]
    1780:	f7fe fc44 	bl	c <get_socket>
    1784:	62b8      	str	r0, [r7, #40]	; 0x28
  struct lwip_setgetsockopt_data data;

  if (!sock) {
    1786:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1788:	2b00      	cmp	r3, #0
    178a:	d102      	bne.n	1792 <lwip_getsockopt+0x2a>
    return -1;
    178c:	f04f 33ff 	mov.w	r3, #4294967295
    1790:	e105      	b.n	199e <lwip_getsockopt+0x236>
  }

  if ((NULL == optval) || (NULL == optlen)) {
    1792:	683b      	ldr	r3, [r7, #0]
    1794:	2b00      	cmp	r3, #0
    1796:	d002      	beq.n	179e <lwip_getsockopt+0x36>
    1798:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    179a:	2b00      	cmp	r3, #0
    179c:	d106      	bne.n	17ac <lwip_getsockopt+0x44>
    sock_set_errno(sock, EFAULT);
    179e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    17a0:	f04f 020e 	mov.w	r2, #14
    17a4:	611a      	str	r2, [r3, #16]
    return -1;
    17a6:	f04f 33ff 	mov.w	r3, #4294967295
    17aa:	e0f8      	b.n	199e <lwip_getsockopt+0x236>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
    17ac:	68bb      	ldr	r3, [r7, #8]
    17ae:	2b06      	cmp	r3, #6
    17b0:	f000 8099 	beq.w	18e6 <lwip_getsockopt+0x17e>
    17b4:	f640 72ff 	movw	r2, #4095	; 0xfff
    17b8:	4293      	cmp	r3, r2
    17ba:	d002      	beq.n	17c2 <lwip_getsockopt+0x5a>
    17bc:	2b00      	cmp	r3, #0
    17be:	d046      	beq.n	184e <lwip_getsockopt+0xe6>
    17c0:	e0ae      	b.n	1920 <lwip_getsockopt+0x1b8>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
    17c2:	687b      	ldr	r3, [r7, #4]
    17c4:	f241 0202 	movw	r2, #4098	; 0x1002
    17c8:	4293      	cmp	r3, r2
    17ca:	d017      	beq.n	17fc <lwip_getsockopt+0x94>
    17cc:	f241 0202 	movw	r2, #4098	; 0x1002
    17d0:	4293      	cmp	r3, r2
    17d2:	dc06      	bgt.n	17e2 <lwip_getsockopt+0x7a>
    17d4:	2b08      	cmp	r3, #8
    17d6:	d011      	beq.n	17fc <lwip_getsockopt+0x94>
    17d8:	2b20      	cmp	r3, #32
    17da:	d00f      	beq.n	17fc <lwip_getsockopt+0x94>
    17dc:	2b02      	cmp	r3, #2
    17de:	d00d      	beq.n	17fc <lwip_getsockopt+0x94>
    17e0:	e02f      	b.n	1842 <lwip_getsockopt+0xda>
    17e2:	f241 0207 	movw	r2, #4103	; 0x1007
    17e6:	4293      	cmp	r3, r2
    17e8:	db2b      	blt.n	1842 <lwip_getsockopt+0xda>
    17ea:	f241 0208 	movw	r2, #4104	; 0x1008
    17ee:	4293      	cmp	r3, r2
    17f0:	dd04      	ble.n	17fc <lwip_getsockopt+0x94>
    17f2:	f241 020a 	movw	r2, #4106	; 0x100a
    17f6:	4293      	cmp	r3, r2
    17f8:	d009      	beq.n	180e <lwip_getsockopt+0xa6>
    17fa:	e022      	b.n	1842 <lwip_getsockopt+0xda>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
    17fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    17fe:	681b      	ldr	r3, [r3, #0]
    1800:	2b03      	cmp	r3, #3
    1802:	d803      	bhi.n	180c <lwip_getsockopt+0xa4>
        err = EINVAL;
    1804:	f04f 0316 	mov.w	r3, #22
    1808:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    180c:	e01e      	b.n	184c <lwip_getsockopt+0xe4>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
    180e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1810:	681b      	ldr	r3, [r3, #0]
    1812:	2b03      	cmp	r3, #3
    1814:	d803      	bhi.n	181e <lwip_getsockopt+0xb6>
        err = EINVAL;
    1816:	f04f 0316 	mov.w	r3, #22
    181a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
    181e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1820:	681b      	ldr	r3, [r3, #0]
    1822:	781b      	ldrb	r3, [r3, #0]
    1824:	2b20      	cmp	r3, #32
    1826:	d107      	bne.n	1838 <lwip_getsockopt+0xd0>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    1828:	6abb      	ldr	r3, [r7, #40]	; 0x28
    182a:	681b      	ldr	r3, [r3, #0]
    182c:	685b      	ldr	r3, [r3, #4]
    182e:	7c1b      	ldrb	r3, [r3, #16]
    1830:	f003 0302 	and.w	r3, r3, #2
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
    1834:	2b00      	cmp	r3, #0
    1836:	d003      	beq.n	1840 <lwip_getsockopt+0xd8>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
    1838:	f04f 0361 	mov.w	r3, #97	; 0x61
    183c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
#endif /* LWIP_UDP */
      break;
    1840:	e004      	b.n	184c <lwip_getsockopt+0xe4>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    1842:	f04f 035c 	mov.w	r3, #92	; 0x5c
    1846:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }  /* switch (optname) */
    break;
    184a:	e06d      	b.n	1928 <lwip_getsockopt+0x1c0>
    184c:	e06c      	b.n	1928 <lwip_getsockopt+0x1c0>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    184e:	687b      	ldr	r3, [r7, #4]
    1850:	f103 33ff 	add.w	r3, r3, #4294967295
    1854:	2b06      	cmp	r3, #6
    1856:	d840      	bhi.n	18da <lwip_getsockopt+0x172>
    1858:	a201      	add	r2, pc, #4	; (adr r2, 1860 <lwip_getsockopt+0xf8>)
    185a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    185e:	bf00      	nop
    1860:	0000187d 	.word	0x0000187d
			1860: R_ARM_ABS32	.text
    1864:	0000187d 	.word	0x0000187d
			1864: R_ARM_ABS32	.text
    1868:	000018db 	.word	0x000018db
			1868: R_ARM_ABS32	.text
    186c:	000018db 	.word	0x000018db
			186c: R_ARM_ABS32	.text
    1870:	0000188f 	.word	0x0000188f
			1870: R_ARM_ABS32	.text
    1874:	000018a1 	.word	0x000018a1
			1874: R_ARM_ABS32	.text
    1878:	000018b3 	.word	0x000018b3
			1878: R_ARM_ABS32	.text
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
    187c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    187e:	681b      	ldr	r3, [r3, #0]
    1880:	2b03      	cmp	r3, #3
    1882:	d803      	bhi.n	188c <lwip_getsockopt+0x124>
        err = EINVAL;
    1884:	f04f 0316 	mov.w	r3, #22
    1888:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    188c:	e02a      	b.n	18e4 <lwip_getsockopt+0x17c>
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      if (*optlen < sizeof(u8_t)) {
    188e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1890:	681b      	ldr	r3, [r3, #0]
    1892:	2b00      	cmp	r3, #0
    1894:	d103      	bne.n	189e <lwip_getsockopt+0x136>
        err = EINVAL;
    1896:	f04f 0316 	mov.w	r3, #22
    189a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    189e:	e021      	b.n	18e4 <lwip_getsockopt+0x17c>
    case IP_MULTICAST_IF:
      if (*optlen < sizeof(struct in_addr)) {
    18a0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    18a2:	681b      	ldr	r3, [r3, #0]
    18a4:	2b03      	cmp	r3, #3
    18a6:	d803      	bhi.n	18b0 <lwip_getsockopt+0x148>
        err = EINVAL;
    18a8:	f04f 0316 	mov.w	r3, #22
    18ac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    18b0:	e018      	b.n	18e4 <lwip_getsockopt+0x17c>
    case IP_MULTICAST_LOOP:
      if (*optlen < sizeof(u8_t)) {
    18b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    18b4:	681b      	ldr	r3, [r3, #0]
    18b6:	2b00      	cmp	r3, #0
    18b8:	d103      	bne.n	18c2 <lwip_getsockopt+0x15a>
        err = EINVAL;
    18ba:	f04f 0316 	mov.w	r3, #22
    18be:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
    18c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
    18c4:	681b      	ldr	r3, [r3, #0]
    18c6:	781b      	ldrb	r3, [r3, #0]
    18c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    18cc:	2b20      	cmp	r3, #32
    18ce:	d003      	beq.n	18d8 <lwip_getsockopt+0x170>
        err = EAFNOSUPPORT;
    18d0:	f04f 0361 	mov.w	r3, #97	; 0x61
    18d4:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    18d8:	e004      	b.n	18e4 <lwip_getsockopt+0x17c>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    18da:	f04f 035c 	mov.w	r3, #92	; 0x5c
    18de:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }  /* switch (optname) */
    break;
    18e2:	e021      	b.n	1928 <lwip_getsockopt+0x1c0>
    18e4:	e020      	b.n	1928 <lwip_getsockopt+0x1c0>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
    18e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    18e8:	681b      	ldr	r3, [r3, #0]
    18ea:	2b03      	cmp	r3, #3
    18ec:	d804      	bhi.n	18f8 <lwip_getsockopt+0x190>
      err = EINVAL;
    18ee:	f04f 0316 	mov.w	r3, #22
    18f2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      break;
    18f6:	e017      	b.n	1928 <lwip_getsockopt+0x1c0>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
    18f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
    18fa:	681b      	ldr	r3, [r3, #0]
    18fc:	781b      	ldrb	r3, [r3, #0]
    18fe:	2b10      	cmp	r3, #16
    1900:	d002      	beq.n	1908 <lwip_getsockopt+0x1a0>
      return 0;
    1902:	f04f 0300 	mov.w	r3, #0
    1906:	e04a      	b.n	199e <lwip_getsockopt+0x236>

    switch (optname) {
    1908:	687b      	ldr	r3, [r7, #4]
    190a:	f103 33ff 	add.w	r3, r3, #4294967295
    190e:	2b01      	cmp	r3, #1
    1910:	d801      	bhi.n	1916 <lwip_getsockopt+0x1ae>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
    1912:	bf00      	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
    1914:	e008      	b.n	1928 <lwip_getsockopt+0x1c0>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    1916:	f04f 035c 	mov.w	r3, #92	; 0x5c
    191a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }  /* switch (optname) */
    break;
    191e:	e003      	b.n	1928 <lwip_getsockopt+0x1c0>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
    1920:	f04f 035c 	mov.w	r3, #92	; 0x5c
    1924:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  }  /* switch */

   
  if (err != ERR_OK) {
    1928:	f997 302f 	ldrsb.w	r3, [r7, #47]	; 0x2f
    192c:	2b00      	cmp	r3, #0
    192e:	d006      	beq.n	193e <lwip_getsockopt+0x1d6>
    sock_set_errno(sock, err);
    1930:	f997 202f 	ldrsb.w	r2, [r7, #47]	; 0x2f
    1934:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1936:	611a      	str	r2, [r3, #16]
    return -1;
    1938:	f04f 33ff 	mov.w	r3, #4294967295
    193c:	e02f      	b.n	199e <lwip_getsockopt+0x236>
  }

  /* Now do the actual option processing */
  data.sock = sock;
    193e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1940:	613b      	str	r3, [r7, #16]
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
    1942:	68bb      	ldr	r3, [r7, #8]
    1944:	617b      	str	r3, [r7, #20]
  data.optname = optname;
    1946:	687b      	ldr	r3, [r7, #4]
    1948:	61bb      	str	r3, [r7, #24]
  data.optval = optval;
    194a:	683b      	ldr	r3, [r7, #0]
    194c:	61fb      	str	r3, [r7, #28]
  data.optlen = optlen;
    194e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1950:	623b      	str	r3, [r7, #32]
  data.err = err;
    1952:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    1956:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  tcpip_callback(lwip_getsockopt_internal, &data);
    195a:	f107 0310 	add.w	r3, r7, #16
    195e:	4812      	ldr	r0, [pc, #72]	; (19a8 <lwip_getsockopt+0x240>)
    1960:	4619      	mov	r1, r3
    1962:	f04f 0201 	mov.w	r2, #1
    1966:	f7ff fffe 	bl	0 <tcpip_callback_with_block>
			1966: R_ARM_THM_CALL	tcpip_callback_with_block
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
    196a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    196c:	681b      	ldr	r3, [r3, #0]
    196e:	f103 030c 	add.w	r3, r3, #12
    1972:	4618      	mov	r0, r3
    1974:	f04f 0100 	mov.w	r1, #0
    1978:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			1978: R_ARM_THM_CALL	sys_arch_sem_wait
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
    197c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    1980:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  sock_set_errno(sock, err);
    1984:	f997 202f 	ldrsb.w	r2, [r7, #47]	; 0x2f
    1988:	6abb      	ldr	r3, [r7, #40]	; 0x28
    198a:	611a      	str	r2, [r3, #16]
  return err ? -1 : 0;
    198c:	f997 302f 	ldrsb.w	r3, [r7, #47]	; 0x2f
    1990:	2b00      	cmp	r3, #0
    1992:	d002      	beq.n	199a <lwip_getsockopt+0x232>
    1994:	f04f 33ff 	mov.w	r3, #4294967295
    1998:	e001      	b.n	199e <lwip_getsockopt+0x236>
    199a:	f04f 0300 	mov.w	r3, #0
}
    199e:	4618      	mov	r0, r3
    19a0:	f107 0730 	add.w	r7, r7, #48	; 0x30
    19a4:	46bd      	mov	sp, r7
    19a6:	bd80      	pop	{r7, pc}
    19a8:	00000000 	.word	0x00000000
			19a8: R_ARM_ABS32	lwip_getsockopt_internal

000019ac <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
    19ac:	b580      	push	{r7, lr}
    19ae:	b088      	sub	sp, #32
    19b0:	af00      	add	r7, sp, #0
    19b2:	6078      	str	r0, [r7, #4]
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
    19b4:	687b      	ldr	r3, [r7, #4]
    19b6:	61fb      	str	r3, [r7, #28]
  sock = data->sock;
    19b8:	69fb      	ldr	r3, [r7, #28]
    19ba:	681b      	ldr	r3, [r3, #0]
    19bc:	61bb      	str	r3, [r7, #24]
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
    19be:	69fb      	ldr	r3, [r7, #28]
    19c0:	685b      	ldr	r3, [r3, #4]
    19c2:	617b      	str	r3, [r7, #20]
  optname = data->optname;
    19c4:	69fb      	ldr	r3, [r7, #28]
    19c6:	689b      	ldr	r3, [r3, #8]
    19c8:	613b      	str	r3, [r7, #16]
  optval = data->optval;
    19ca:	69fb      	ldr	r3, [r7, #28]
    19cc:	68db      	ldr	r3, [r3, #12]
    19ce:	60fb      	str	r3, [r7, #12]

  switch (level) {
    19d0:	697b      	ldr	r3, [r7, #20]
    19d2:	2b06      	cmp	r3, #6
    19d4:	f000 80d0 	beq.w	1b78 <lwip_getsockopt_internal+0x1cc>
    19d8:	f640 72ff 	movw	r2, #4095	; 0xfff
    19dc:	4293      	cmp	r3, r2
    19de:	d003      	beq.n	19e8 <lwip_getsockopt_internal+0x3c>
    19e0:	2b00      	cmp	r3, #0
    19e2:	f000 8082 	beq.w	1aea <lwip_getsockopt_internal+0x13e>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
    19e6:	e0e3      	b.n	1bb0 <lwip_getsockopt_internal+0x204>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
    19e8:	693b      	ldr	r3, [r7, #16]
    19ea:	f241 0202 	movw	r2, #4098	; 0x1002
    19ee:	4293      	cmp	r3, r2
    19f0:	d06a      	beq.n	1ac8 <lwip_getsockopt_internal+0x11c>
    19f2:	f241 0202 	movw	r2, #4098	; 0x1002
    19f6:	4293      	cmp	r3, r2
    19f8:	dc06      	bgt.n	1a08 <lwip_getsockopt_internal+0x5c>
    19fa:	2b08      	cmp	r3, #8
    19fc:	d011      	beq.n	1a22 <lwip_getsockopt_internal+0x76>
    19fe:	2b20      	cmp	r3, #32
    1a00:	d00f      	beq.n	1a22 <lwip_getsockopt_internal+0x76>
    1a02:	2b02      	cmp	r3, #2
    1a04:	d00d      	beq.n	1a22 <lwip_getsockopt_internal+0x76>
    1a06:	e06e      	b.n	1ae6 <lwip_getsockopt_internal+0x13a>
    1a08:	f241 0208 	movw	r2, #4104	; 0x1008
    1a0c:	4293      	cmp	r3, r2
    1a0e:	d013      	beq.n	1a38 <lwip_getsockopt_internal+0x8c>
    1a10:	f241 020a 	movw	r2, #4106	; 0x100a
    1a14:	4293      	cmp	r3, r2
    1a16:	d05d      	beq.n	1ad4 <lwip_getsockopt_internal+0x128>
    1a18:	f241 0207 	movw	r2, #4103	; 0x1007
    1a1c:	4293      	cmp	r3, r2
    1a1e:	d02c      	beq.n	1a7a <lwip_getsockopt_internal+0xce>
    1a20:	e061      	b.n	1ae6 <lwip_getsockopt_internal+0x13a>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
    1a22:	68fb      	ldr	r3, [r7, #12]
    1a24:	69ba      	ldr	r2, [r7, #24]
    1a26:	6812      	ldr	r2, [r2, #0]
    1a28:	6852      	ldr	r2, [r2, #4]
    1a2a:	7a12      	ldrb	r2, [r2, #8]
    1a2c:	4611      	mov	r1, r2
    1a2e:	693a      	ldr	r2, [r7, #16]
    1a30:	ea01 0202 	and.w	r2, r1, r2
    1a34:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
    1a36:	e057      	b.n	1ae8 <lwip_getsockopt_internal+0x13c>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
    1a38:	69bb      	ldr	r3, [r7, #24]
    1a3a:	681b      	ldr	r3, [r3, #0]
    1a3c:	781b      	ldrb	r3, [r3, #0]
    1a3e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1a42:	2b20      	cmp	r3, #32
    1a44:	d00e      	beq.n	1a64 <lwip_getsockopt_internal+0xb8>
    1a46:	2b40      	cmp	r3, #64	; 0x40
    1a48:	d002      	beq.n	1a50 <lwip_getsockopt_internal+0xa4>
    1a4a:	2b10      	cmp	r3, #16
    1a4c:	d005      	beq.n	1a5a <lwip_getsockopt_internal+0xae>
    1a4e:	e00e      	b.n	1a6e <lwip_getsockopt_internal+0xc2>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
    1a50:	68fb      	ldr	r3, [r7, #12]
    1a52:	f04f 0203 	mov.w	r2, #3
    1a56:	601a      	str	r2, [r3, #0]
        break;
    1a58:	e00e      	b.n	1a78 <lwip_getsockopt_internal+0xcc>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
    1a5a:	68fb      	ldr	r3, [r7, #12]
    1a5c:	f04f 0201 	mov.w	r2, #1
    1a60:	601a      	str	r2, [r3, #0]
        break;
    1a62:	e009      	b.n	1a78 <lwip_getsockopt_internal+0xcc>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
    1a64:	68fb      	ldr	r3, [r7, #12]
    1a66:	f04f 0202 	mov.w	r2, #2
    1a6a:	601a      	str	r2, [r3, #0]
        break;
    1a6c:	e004      	b.n	1a78 <lwip_getsockopt_internal+0xcc>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
    1a6e:	68fb      	ldr	r3, [r7, #12]
    1a70:	69ba      	ldr	r2, [r7, #24]
    1a72:	6812      	ldr	r2, [r2, #0]
    1a74:	7812      	ldrb	r2, [r2, #0]
    1a76:	601a      	str	r2, [r3, #0]
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
    1a78:	e036      	b.n	1ae8 <lwip_getsockopt_internal+0x13c>

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
    1a7a:	69bb      	ldr	r3, [r7, #24]
    1a7c:	691b      	ldr	r3, [r3, #16]
    1a7e:	2b00      	cmp	r3, #0
    1a80:	d003      	beq.n	1a8a <lwip_getsockopt_internal+0xde>
    1a82:	69bb      	ldr	r3, [r7, #24]
    1a84:	691b      	ldr	r3, [r3, #16]
    1a86:	2b73      	cmp	r3, #115	; 0x73
    1a88:	d115      	bne.n	1ab6 <lwip_getsockopt_internal+0x10a>
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
    1a8a:	69bb      	ldr	r3, [r7, #24]
    1a8c:	681b      	ldr	r3, [r3, #0]
    1a8e:	7a1b      	ldrb	r3, [r3, #8]
    1a90:	b25b      	sxtb	r3, r3
    1a92:	f1c3 0300 	rsb	r3, r3, #0
    1a96:	2b0f      	cmp	r3, #15
    1a98:	d809      	bhi.n	1aae <lwip_getsockopt_internal+0x102>
    1a9a:	69bb      	ldr	r3, [r7, #24]
    1a9c:	681b      	ldr	r3, [r3, #0]
    1a9e:	7a1b      	ldrb	r3, [r3, #8]
    1aa0:	b25b      	sxtb	r3, r3
    1aa2:	f1c3 0200 	rsb	r2, r3, #0
    1aa6:	4b48      	ldr	r3, [pc, #288]	; (1bc8 <lwip_getsockopt_internal+0x21c>)
    1aa8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    1aac:	e001      	b.n	1ab2 <lwip_getsockopt_internal+0x106>
    1aae:	f04f 0305 	mov.w	r3, #5
    1ab2:	69ba      	ldr	r2, [r7, #24]
    1ab4:	6113      	str	r3, [r2, #16]
      } 
      *(int *)optval = sock->err;
    1ab6:	68fb      	ldr	r3, [r7, #12]
    1ab8:	69ba      	ldr	r2, [r7, #24]
    1aba:	6912      	ldr	r2, [r2, #16]
    1abc:	601a      	str	r2, [r3, #0]
      sock->err = 0;
    1abe:	69bb      	ldr	r3, [r7, #24]
    1ac0:	f04f 0200 	mov.w	r2, #0
    1ac4:	611a      	str	r2, [r3, #16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
    1ac6:	e00f      	b.n	1ae8 <lwip_getsockopt_internal+0x13c>
      *(int *)optval = netconn_get_recvtimeout(sock->conn);
      break;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
      *(int *)optval = netconn_get_recvbufsize(sock->conn);
    1ac8:	68fb      	ldr	r3, [r7, #12]
    1aca:	69ba      	ldr	r2, [r7, #24]
    1acc:	6812      	ldr	r2, [r2, #0]
    1ace:	6a92      	ldr	r2, [r2, #40]	; 0x28
    1ad0:	601a      	str	r2, [r3, #0]
      break;
    1ad2:	e009      	b.n	1ae8 <lwip_getsockopt_internal+0x13c>
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
    1ad4:	68fb      	ldr	r3, [r7, #12]
    1ad6:	69ba      	ldr	r2, [r7, #24]
    1ad8:	6812      	ldr	r2, [r2, #0]
    1ada:	6852      	ldr	r2, [r2, #4]
    1adc:	7c12      	ldrb	r2, [r2, #16]
    1ade:	f002 0201 	and.w	r2, r2, #1
    1ae2:	601a      	str	r2, [r3, #0]
      break;
    1ae4:	e000      	b.n	1ae8 <lwip_getsockopt_internal+0x13c>
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    1ae6:	bf00      	nop
    }  /* switch (optname) */
    break;
    1ae8:	e062      	b.n	1bb0 <lwip_getsockopt_internal+0x204>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    1aea:	693b      	ldr	r3, [r7, #16]
    1aec:	f103 33ff 	add.w	r3, r3, #4294967295
    1af0:	2b06      	cmp	r3, #6
    1af2:	d83f      	bhi.n	1b74 <lwip_getsockopt_internal+0x1c8>
    1af4:	a201      	add	r2, pc, #4	; (adr r2, 1afc <lwip_getsockopt_internal+0x150>)
    1af6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1afa:	bf00      	nop
    1afc:	00001b27 	.word	0x00001b27
			1afc: R_ARM_ABS32	.text
    1b00:	00001b19 	.word	0x00001b19
			1b00: R_ARM_ABS32	.text
    1b04:	00001b75 	.word	0x00001b75
			1b04: R_ARM_ABS32	.text
    1b08:	00001b75 	.word	0x00001b75
			1b08: R_ARM_ABS32	.text
    1b0c:	00001b35 	.word	0x00001b35
			1b0c: R_ARM_ABS32	.text
    1b10:	00001b43 	.word	0x00001b43
			1b10: R_ARM_ABS32	.text
    1b14:	00001b51 	.word	0x00001b51
			1b14: R_ARM_ABS32	.text
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
    1b18:	68fb      	ldr	r3, [r7, #12]
    1b1a:	69ba      	ldr	r2, [r7, #24]
    1b1c:	6812      	ldr	r2, [r2, #0]
    1b1e:	6852      	ldr	r2, [r2, #4]
    1b20:	7a92      	ldrb	r2, [r2, #10]
    1b22:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    1b24:	e027      	b.n	1b76 <lwip_getsockopt_internal+0x1ca>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
    1b26:	68fb      	ldr	r3, [r7, #12]
    1b28:	69ba      	ldr	r2, [r7, #24]
    1b2a:	6812      	ldr	r2, [r2, #0]
    1b2c:	6852      	ldr	r2, [r2, #4]
    1b2e:	7a52      	ldrb	r2, [r2, #9]
    1b30:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
    1b32:	e020      	b.n	1b76 <lwip_getsockopt_internal+0x1ca>
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      *(u8_t*)optval = sock->conn->pcb.ip->ttl;
    1b34:	68fb      	ldr	r3, [r7, #12]
    1b36:	69ba      	ldr	r2, [r7, #24]
    1b38:	6812      	ldr	r2, [r2, #0]
    1b3a:	6852      	ldr	r2, [r2, #4]
    1b3c:	7a92      	ldrb	r2, [r2, #10]
    1b3e:	701a      	strb	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    1b40:	e019      	b.n	1b76 <lwip_getsockopt_internal+0x1ca>
    case IP_MULTICAST_IF:
      inet_addr_from_ipaddr((struct in_addr*)optval, &sock->conn->pcb.udp->multicast_ip);
    1b42:	68fb      	ldr	r3, [r7, #12]
    1b44:	69ba      	ldr	r2, [r7, #24]
    1b46:	6812      	ldr	r2, [r2, #0]
    1b48:	6852      	ldr	r2, [r2, #4]
    1b4a:	6992      	ldr	r2, [r2, #24]
    1b4c:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%"X32_F"\n",
                  s, *(u32_t *)optval));
      break;
    1b4e:	e012      	b.n	1b76 <lwip_getsockopt_internal+0x1ca>
    case IP_MULTICAST_LOOP:
      if ((sock->conn->pcb.udp->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) {
    1b50:	69bb      	ldr	r3, [r7, #24]
    1b52:	681b      	ldr	r3, [r3, #0]
    1b54:	685b      	ldr	r3, [r3, #4]
    1b56:	7c1b      	ldrb	r3, [r3, #16]
    1b58:	f003 0308 	and.w	r3, r3, #8
    1b5c:	2b00      	cmp	r3, #0
    1b5e:	d004      	beq.n	1b6a <lwip_getsockopt_internal+0x1be>
        *(u8_t*)optval = 1;
    1b60:	68fb      	ldr	r3, [r7, #12]
    1b62:	f04f 0201 	mov.w	r2, #1
    1b66:	701a      	strb	r2, [r3, #0]
    1b68:	e003      	b.n	1b72 <lwip_getsockopt_internal+0x1c6>
      } else {
        *(u8_t*)optval = 0;
    1b6a:	68fb      	ldr	r3, [r7, #12]
    1b6c:	f04f 0200 	mov.w	r2, #0
    1b70:	701a      	strb	r2, [r3, #0]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
                  s, *(int *)optval));
      break;
    1b72:	e000      	b.n	1b76 <lwip_getsockopt_internal+0x1ca>
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    1b74:	bf00      	nop
    }  /* switch (optname) */
    break;
    1b76:	e01b      	b.n	1bb0 <lwip_getsockopt_internal+0x204>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    1b78:	693b      	ldr	r3, [r7, #16]
    1b7a:	2b01      	cmp	r3, #1
    1b7c:	d002      	beq.n	1b84 <lwip_getsockopt_internal+0x1d8>
    1b7e:	2b02      	cmp	r3, #2
    1b80:	d00d      	beq.n	1b9e <lwip_getsockopt_internal+0x1f2>
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    1b82:	e014      	b.n	1bae <lwip_getsockopt_internal+0x202>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
    1b84:	68fb      	ldr	r3, [r7, #12]
    1b86:	69ba      	ldr	r2, [r7, #24]
    1b88:	6812      	ldr	r2, [r2, #0]
    1b8a:	6852      	ldr	r2, [r2, #4]
    1b8c:	7f92      	ldrb	r2, [r2, #30]
    1b8e:	f002 0240 	and.w	r2, r2, #64	; 0x40
    1b92:	2a00      	cmp	r2, #0
    1b94:	bf0c      	ite	eq
    1b96:	2200      	moveq	r2, #0
    1b98:	2201      	movne	r2, #1
    1b9a:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
    1b9c:	e007      	b.n	1bae <lwip_getsockopt_internal+0x202>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
    1b9e:	68fb      	ldr	r3, [r7, #12]
    1ba0:	69ba      	ldr	r2, [r7, #24]
    1ba2:	6812      	ldr	r2, [r2, #0]
    1ba4:	6852      	ldr	r2, [r2, #4]
    1ba6:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
    1baa:	601a      	str	r2, [r3, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
    1bac:	bf00      	nop
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
    1bae:	bf00      	nop
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  } /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
    1bb0:	69bb      	ldr	r3, [r7, #24]
    1bb2:	681b      	ldr	r3, [r3, #0]
    1bb4:	f103 030c 	add.w	r3, r3, #12
    1bb8:	4618      	mov	r0, r3
    1bba:	f7ff fffe 	bl	0 <sys_sem_signal>
			1bba: R_ARM_THM_CALL	sys_sem_signal
}
    1bbe:	f107 0720 	add.w	r7, r7, #32
    1bc2:	46bd      	mov	sp, r7
    1bc4:	bd80      	pop	{r7, pc}
    1bc6:	bf00      	nop
    1bc8:	00000000 	.word	0x00000000
			1bc8: R_ARM_ABS32	.rodata

00001bcc <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
    1bcc:	b580      	push	{r7, lr}
    1bce:	b08c      	sub	sp, #48	; 0x30
    1bd0:	af00      	add	r7, sp, #0
    1bd2:	60f8      	str	r0, [r7, #12]
    1bd4:	60b9      	str	r1, [r7, #8]
    1bd6:	607a      	str	r2, [r7, #4]
    1bd8:	603b      	str	r3, [r7, #0]
  struct lwip_sock *sock = get_socket(s);
    1bda:	68f8      	ldr	r0, [r7, #12]
    1bdc:	f7fe fa16 	bl	c <get_socket>
    1be0:	62b8      	str	r0, [r7, #40]	; 0x28
  err_t err = ERR_OK;
    1be2:	f04f 0300 	mov.w	r3, #0
    1be6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  struct lwip_setgetsockopt_data data;

  if (!sock) {
    1bea:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1bec:	2b00      	cmp	r3, #0
    1bee:	d102      	bne.n	1bf6 <lwip_setsockopt+0x2a>
    return -1;
    1bf0:	f04f 33ff 	mov.w	r3, #4294967295
    1bf4:	e118      	b.n	1e28 <lwip_setsockopt+0x25c>
  }

  if (NULL == optval) {
    1bf6:	683b      	ldr	r3, [r7, #0]
    1bf8:	2b00      	cmp	r3, #0
    1bfa:	d106      	bne.n	1c0a <lwip_setsockopt+0x3e>
    sock_set_errno(sock, EFAULT);
    1bfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1bfe:	f04f 020e 	mov.w	r2, #14
    1c02:	611a      	str	r2, [r3, #16]
    return -1;
    1c04:	f04f 33ff 	mov.w	r3, #4294967295
    1c08:	e10e      	b.n	1e28 <lwip_setsockopt+0x25c>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
    1c0a:	68bb      	ldr	r3, [r7, #8]
    1c0c:	2b06      	cmp	r3, #6
    1c0e:	f000 80af 	beq.w	1d70 <lwip_setsockopt+0x1a4>
    1c12:	f640 72ff 	movw	r2, #4095	; 0xfff
    1c16:	4293      	cmp	r3, r2
    1c18:	d002      	beq.n	1c20 <lwip_setsockopt+0x54>
    1c1a:	2b00      	cmp	r3, #0
    1c1c:	d038      	beq.n	1c90 <lwip_setsockopt+0xc4>
    1c1e:	e0c3      	b.n	1da8 <lwip_setsockopt+0x1dc>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
    1c20:	687b      	ldr	r3, [r7, #4]
    1c22:	2b20      	cmp	r3, #32
    1c24:	d00d      	beq.n	1c42 <lwip_setsockopt+0x76>
    1c26:	2b20      	cmp	r3, #32
    1c28:	dc02      	bgt.n	1c30 <lwip_setsockopt+0x64>
    1c2a:	2b08      	cmp	r3, #8
    1c2c:	d009      	beq.n	1c42 <lwip_setsockopt+0x76>
    1c2e:	e029      	b.n	1c84 <lwip_setsockopt+0xb8>
    1c30:	f241 0202 	movw	r2, #4098	; 0x1002
    1c34:	4293      	cmp	r3, r2
    1c36:	d004      	beq.n	1c42 <lwip_setsockopt+0x76>
    1c38:	f241 020a 	movw	r2, #4106	; 0x100a
    1c3c:	4293      	cmp	r3, r2
    1c3e:	d008      	beq.n	1c52 <lwip_setsockopt+0x86>
    1c40:	e020      	b.n	1c84 <lwip_setsockopt+0xb8>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
    1c42:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1c44:	2b03      	cmp	r3, #3
    1c46:	d803      	bhi.n	1c50 <lwip_setsockopt+0x84>
        err = EINVAL;
    1c48:	f04f 0316 	mov.w	r3, #22
    1c4c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    1c50:	e01d      	b.n	1c8e <lwip_setsockopt+0xc2>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
    1c52:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1c54:	2b03      	cmp	r3, #3
    1c56:	d803      	bhi.n	1c60 <lwip_setsockopt+0x94>
        err = EINVAL;
    1c58:	f04f 0316 	mov.w	r3, #22
    1c5c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
    1c60:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1c62:	681b      	ldr	r3, [r3, #0]
    1c64:	781b      	ldrb	r3, [r3, #0]
    1c66:	2b20      	cmp	r3, #32
    1c68:	d107      	bne.n	1c7a <lwip_setsockopt+0xae>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
    1c6a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1c6c:	681b      	ldr	r3, [r3, #0]
    1c6e:	685b      	ldr	r3, [r3, #4]
    1c70:	7c1b      	ldrb	r3, [r3, #16]
    1c72:	f003 0302 	and.w	r3, r3, #2
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
    1c76:	2b00      	cmp	r3, #0
    1c78:	d003      	beq.n	1c82 <lwip_setsockopt+0xb6>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
    1c7a:	f04f 0361 	mov.w	r3, #97	; 0x61
    1c7e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
#endif /* LWIP_UDP */
      break;
    1c82:	e004      	b.n	1c8e <lwip_setsockopt+0xc2>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    1c84:	f04f 035c 	mov.w	r3, #92	; 0x5c
    1c88:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }  /* switch (optname) */
    break;
    1c8c:	e090      	b.n	1db0 <lwip_setsockopt+0x1e4>
    1c8e:	e08f      	b.n	1db0 <lwip_setsockopt+0x1e4>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    1c90:	687b      	ldr	r3, [r7, #4]
    1c92:	f103 33ff 	add.w	r3, r3, #4294967295
    1c96:	2b06      	cmp	r3, #6
    1c98:	d864      	bhi.n	1d64 <lwip_setsockopt+0x198>
    1c9a:	a201      	add	r2, pc, #4	; (adr r2, 1ca0 <lwip_setsockopt+0xd4>)
    1c9c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1ca0:	00001cbd 	.word	0x00001cbd
			1ca0: R_ARM_ABS32	.text
    1ca4:	00001cbd 	.word	0x00001cbd
			1ca4: R_ARM_ABS32	.text
    1ca8:	00001d3f 	.word	0x00001d3f
			1ca8: R_ARM_ABS32	.text
    1cac:	00001d3f 	.word	0x00001d3f
			1cac: R_ARM_ABS32	.text
    1cb0:	00001ccd 	.word	0x00001ccd
			1cb0: R_ARM_ABS32	.text
    1cb4:	00001cf3 	.word	0x00001cf3
			1cb4: R_ARM_ABS32	.text
    1cb8:	00001d19 	.word	0x00001d19
			1cb8: R_ARM_ABS32	.text
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
    1cbc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1cbe:	2b03      	cmp	r3, #3
    1cc0:	d803      	bhi.n	1cca <lwip_setsockopt+0xfe>
        err = EINVAL;
    1cc2:	f04f 0316 	mov.w	r3, #22
    1cc6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    1cca:	e050      	b.n	1d6e <lwip_setsockopt+0x1a2>
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      if (optlen < sizeof(u8_t)) {
    1ccc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1cce:	2b00      	cmp	r3, #0
    1cd0:	d103      	bne.n	1cda <lwip_setsockopt+0x10e>
        err = EINVAL;
    1cd2:	f04f 0316 	mov.w	r3, #22
    1cd6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
    1cda:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1cdc:	681b      	ldr	r3, [r3, #0]
    1cde:	781b      	ldrb	r3, [r3, #0]
    1ce0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1ce4:	2b20      	cmp	r3, #32
    1ce6:	d003      	beq.n	1cf0 <lwip_setsockopt+0x124>
        err = EAFNOSUPPORT;
    1ce8:	f04f 0361 	mov.w	r3, #97	; 0x61
    1cec:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    1cf0:	e03d      	b.n	1d6e <lwip_setsockopt+0x1a2>
    case IP_MULTICAST_IF:
      if (optlen < sizeof(struct in_addr)) {
    1cf2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1cf4:	2b03      	cmp	r3, #3
    1cf6:	d803      	bhi.n	1d00 <lwip_setsockopt+0x134>
        err = EINVAL;
    1cf8:	f04f 0316 	mov.w	r3, #22
    1cfc:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
    1d00:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d02:	681b      	ldr	r3, [r3, #0]
    1d04:	781b      	ldrb	r3, [r3, #0]
    1d06:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1d0a:	2b20      	cmp	r3, #32
    1d0c:	d003      	beq.n	1d16 <lwip_setsockopt+0x14a>
        err = EAFNOSUPPORT;
    1d0e:	f04f 0361 	mov.w	r3, #97	; 0x61
    1d12:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    1d16:	e02a      	b.n	1d6e <lwip_setsockopt+0x1a2>
    case IP_MULTICAST_LOOP:
      if (optlen < sizeof(u8_t)) {
    1d18:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1d1a:	2b00      	cmp	r3, #0
    1d1c:	d103      	bne.n	1d26 <lwip_setsockopt+0x15a>
        err = EINVAL;
    1d1e:	f04f 0316 	mov.w	r3, #22
    1d22:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
    1d26:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d28:	681b      	ldr	r3, [r3, #0]
    1d2a:	781b      	ldrb	r3, [r3, #0]
    1d2c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1d30:	2b20      	cmp	r3, #32
    1d32:	d003      	beq.n	1d3c <lwip_setsockopt+0x170>
        err = EAFNOSUPPORT;
    1d34:	f04f 0361 	mov.w	r3, #97	; 0x61
    1d38:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    1d3c:	e017      	b.n	1d6e <lwip_setsockopt+0x1a2>
    case IP_ADD_MEMBERSHIP:
    case IP_DROP_MEMBERSHIP:
      if (optlen < sizeof(struct ip_mreq)) {
    1d3e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1d40:	2b07      	cmp	r3, #7
    1d42:	d803      	bhi.n	1d4c <lwip_setsockopt+0x180>
        err = EINVAL;
    1d44:	f04f 0316 	mov.w	r3, #22
    1d48:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      if (NETCONNTYPE_GROUP(sock->conn->type) != NETCONN_UDP) {
    1d4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d4e:	681b      	ldr	r3, [r3, #0]
    1d50:	781b      	ldrb	r3, [r3, #0]
    1d52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    1d56:	2b20      	cmp	r3, #32
    1d58:	d003      	beq.n	1d62 <lwip_setsockopt+0x196>
        err = EAFNOSUPPORT;
    1d5a:	f04f 0361 	mov.w	r3, #97	; 0x61
    1d5e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }
      break;
    1d62:	e004      	b.n	1d6e <lwip_setsockopt+0x1a2>
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    1d64:	f04f 035c 	mov.w	r3, #92	; 0x5c
    1d68:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }  /* switch (optname) */
    break;
    1d6c:	e020      	b.n	1db0 <lwip_setsockopt+0x1e4>
    1d6e:	e01f      	b.n	1db0 <lwip_setsockopt+0x1e4>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
    1d70:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    1d72:	2b03      	cmp	r3, #3
    1d74:	d804      	bhi.n	1d80 <lwip_setsockopt+0x1b4>
      err = EINVAL;
    1d76:	f04f 0316 	mov.w	r3, #22
    1d7a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      break;
    1d7e:	e017      	b.n	1db0 <lwip_setsockopt+0x1e4>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
    1d80:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1d82:	681b      	ldr	r3, [r3, #0]
    1d84:	781b      	ldrb	r3, [r3, #0]
    1d86:	2b10      	cmp	r3, #16
    1d88:	d002      	beq.n	1d90 <lwip_setsockopt+0x1c4>
      return 0;
    1d8a:	f04f 0300 	mov.w	r3, #0
    1d8e:	e04b      	b.n	1e28 <lwip_setsockopt+0x25c>

    switch (optname) {
    1d90:	687b      	ldr	r3, [r7, #4]
    1d92:	f103 33ff 	add.w	r3, r3, #4294967295
    1d96:	2b01      	cmp	r3, #1
    1d98:	d801      	bhi.n	1d9e <lwip_setsockopt+0x1d2>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
    1d9a:	bf00      	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
    1d9c:	e008      	b.n	1db0 <lwip_setsockopt+0x1e4>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    1d9e:	f04f 035c 	mov.w	r3, #92	; 0x5c
    1da2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }  /* switch (optname) */
    break;
    1da6:	e003      	b.n	1db0 <lwip_setsockopt+0x1e4>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
    1da8:	f04f 035c 	mov.w	r3, #92	; 0x5c
    1dac:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  }  /* switch (level) */


  if (err != ERR_OK) {
    1db0:	f997 302f 	ldrsb.w	r3, [r7, #47]	; 0x2f
    1db4:	2b00      	cmp	r3, #0
    1db6:	d006      	beq.n	1dc6 <lwip_setsockopt+0x1fa>
    sock_set_errno(sock, err);
    1db8:	f997 202f 	ldrsb.w	r2, [r7, #47]	; 0x2f
    1dbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dbe:	611a      	str	r2, [r3, #16]
    return -1;
    1dc0:	f04f 33ff 	mov.w	r3, #4294967295
    1dc4:	e030      	b.n	1e28 <lwip_setsockopt+0x25c>
  }


  /* Now do the actual option processing */
  data.sock = sock;
    1dc6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1dc8:	613b      	str	r3, [r7, #16]
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
    1dca:	68bb      	ldr	r3, [r7, #8]
    1dcc:	617b      	str	r3, [r7, #20]
  data.optname = optname;
    1dce:	687b      	ldr	r3, [r7, #4]
    1dd0:	61bb      	str	r3, [r7, #24]
  data.optval = (void*)optval;
    1dd2:	683b      	ldr	r3, [r7, #0]
    1dd4:	61fb      	str	r3, [r7, #28]
  data.optlen = &optlen;
    1dd6:	f107 0338 	add.w	r3, r7, #56	; 0x38
    1dda:	623b      	str	r3, [r7, #32]
  data.err = err;
    1ddc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
    1de0:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  tcpip_callback(lwip_setsockopt_internal, &data);
    1de4:	f107 0310 	add.w	r3, r7, #16
    1de8:	4812      	ldr	r0, [pc, #72]	; (1e34 <lwip_setsockopt+0x268>)
    1dea:	4619      	mov	r1, r3
    1dec:	f04f 0201 	mov.w	r2, #1
    1df0:	f7ff fffe 	bl	0 <tcpip_callback_with_block>
			1df0: R_ARM_THM_CALL	tcpip_callback_with_block
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
    1df4:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1df6:	681b      	ldr	r3, [r3, #0]
    1df8:	f103 030c 	add.w	r3, r3, #12
    1dfc:	4618      	mov	r0, r3
    1dfe:	f04f 0100 	mov.w	r1, #0
    1e02:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			1e02: R_ARM_THM_CALL	sys_arch_sem_wait
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
    1e06:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
    1e0a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  sock_set_errno(sock, err);
    1e0e:	f997 202f 	ldrsb.w	r2, [r7, #47]	; 0x2f
    1e12:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1e14:	611a      	str	r2, [r3, #16]
  return err ? -1 : 0;
    1e16:	f997 302f 	ldrsb.w	r3, [r7, #47]	; 0x2f
    1e1a:	2b00      	cmp	r3, #0
    1e1c:	d002      	beq.n	1e24 <lwip_setsockopt+0x258>
    1e1e:	f04f 33ff 	mov.w	r3, #4294967295
    1e22:	e001      	b.n	1e28 <lwip_setsockopt+0x25c>
    1e24:	f04f 0300 	mov.w	r3, #0
}
    1e28:	4618      	mov	r0, r3
    1e2a:	f107 0730 	add.w	r7, r7, #48	; 0x30
    1e2e:	46bd      	mov	sp, r7
    1e30:	bd80      	pop	{r7, pc}
    1e32:	bf00      	nop
    1e34:	00000000 	.word	0x00000000
			1e34: R_ARM_ABS32	lwip_setsockopt_internal

00001e38 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
    1e38:	b580      	push	{r7, lr}
    1e3a:	b08a      	sub	sp, #40	; 0x28
    1e3c:	af00      	add	r7, sp, #0
    1e3e:	6078      	str	r0, [r7, #4]
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
    1e40:	687b      	ldr	r3, [r7, #4]
    1e42:	627b      	str	r3, [r7, #36]	; 0x24
  sock = data->sock;
    1e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e46:	681b      	ldr	r3, [r3, #0]
    1e48:	623b      	str	r3, [r7, #32]
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
    1e4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e4c:	685b      	ldr	r3, [r3, #4]
    1e4e:	61fb      	str	r3, [r7, #28]
  optname = data->optname;
    1e50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e52:	689b      	ldr	r3, [r3, #8]
    1e54:	61bb      	str	r3, [r7, #24]
  optval = data->optval;
    1e56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e58:	68db      	ldr	r3, [r3, #12]
    1e5a:	617b      	str	r3, [r7, #20]

  switch (level) {
    1e5c:	69fb      	ldr	r3, [r7, #28]
    1e5e:	2b06      	cmp	r3, #6
    1e60:	f000 80e3 	beq.w	202a <lwip_setsockopt_internal+0x1f2>
    1e64:	f640 72ff 	movw	r2, #4095	; 0xfff
    1e68:	4293      	cmp	r3, r2
    1e6a:	d002      	beq.n	1e72 <lwip_setsockopt_internal+0x3a>
    1e6c:	2b00      	cmp	r3, #0
    1e6e:	d05c      	beq.n	1f2a <lwip_setsockopt_internal+0xf2>
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
    1e70:	e106      	b.n	2080 <lwip_setsockopt_internal+0x248>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
    1e72:	69bb      	ldr	r3, [r7, #24]
    1e74:	2b20      	cmp	r3, #32
    1e76:	d00d      	beq.n	1e94 <lwip_setsockopt_internal+0x5c>
    1e78:	2b20      	cmp	r3, #32
    1e7a:	dc02      	bgt.n	1e82 <lwip_setsockopt_internal+0x4a>
    1e7c:	2b08      	cmp	r3, #8
    1e7e:	d009      	beq.n	1e94 <lwip_setsockopt_internal+0x5c>
    1e80:	e051      	b.n	1f26 <lwip_setsockopt_internal+0xee>
    1e82:	f241 0202 	movw	r2, #4098	; 0x1002
    1e86:	4293      	cmp	r3, r2
    1e88:	d02b      	beq.n	1ee2 <lwip_setsockopt_internal+0xaa>
    1e8a:	f241 020a 	movw	r2, #4106	; 0x100a
    1e8e:	4293      	cmp	r3, r2
    1e90:	d02d      	beq.n	1eee <lwip_setsockopt_internal+0xb6>
    1e92:	e048      	b.n	1f26 <lwip_setsockopt_internal+0xee>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
    1e94:	697b      	ldr	r3, [r7, #20]
    1e96:	681b      	ldr	r3, [r3, #0]
    1e98:	2b00      	cmp	r3, #0
    1e9a:	d00f      	beq.n	1ebc <lwip_setsockopt_internal+0x84>
        ip_set_option(sock->conn->pcb.ip, optname);
    1e9c:	6a3b      	ldr	r3, [r7, #32]
    1e9e:	681b      	ldr	r3, [r3, #0]
    1ea0:	685b      	ldr	r3, [r3, #4]
    1ea2:	6a3a      	ldr	r2, [r7, #32]
    1ea4:	6812      	ldr	r2, [r2, #0]
    1ea6:	6852      	ldr	r2, [r2, #4]
    1ea8:	7a12      	ldrb	r2, [r2, #8]
    1eaa:	b2d1      	uxtb	r1, r2
    1eac:	69ba      	ldr	r2, [r7, #24]
    1eae:	b2d2      	uxtb	r2, r2
    1eb0:	ea41 0202 	orr.w	r2, r1, r2
    1eb4:	b2d2      	uxtb	r2, r2
    1eb6:	b2d2      	uxtb	r2, r2
    1eb8:	721a      	strb	r2, [r3, #8]
    1eba:	e011      	b.n	1ee0 <lwip_setsockopt_internal+0xa8>
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
    1ebc:	6a3b      	ldr	r3, [r7, #32]
    1ebe:	681b      	ldr	r3, [r3, #0]
    1ec0:	685b      	ldr	r3, [r3, #4]
    1ec2:	6a3a      	ldr	r2, [r7, #32]
    1ec4:	6812      	ldr	r2, [r2, #0]
    1ec6:	6852      	ldr	r2, [r2, #4]
    1ec8:	7a12      	ldrb	r2, [r2, #8]
    1eca:	b2d1      	uxtb	r1, r2
    1ecc:	69ba      	ldr	r2, [r7, #24]
    1ece:	b2d2      	uxtb	r2, r2
    1ed0:	ea6f 0202 	mvn.w	r2, r2
    1ed4:	b2d2      	uxtb	r2, r2
    1ed6:	ea01 0202 	and.w	r2, r1, r2
    1eda:	b2d2      	uxtb	r2, r2
    1edc:	b2d2      	uxtb	r2, r2
    1ede:	721a      	strb	r2, [r3, #8]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
    1ee0:	e022      	b.n	1f28 <lwip_setsockopt_internal+0xf0>
      netconn_set_recvtimeout(sock->conn, *(int*)optval);
      break;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
    case SO_RCVBUF:
      netconn_set_recvbufsize(sock->conn, *(int*)optval);
    1ee2:	6a3b      	ldr	r3, [r7, #32]
    1ee4:	681b      	ldr	r3, [r3, #0]
    1ee6:	697a      	ldr	r2, [r7, #20]
    1ee8:	6812      	ldr	r2, [r2, #0]
    1eea:	629a      	str	r2, [r3, #40]	; 0x28
      break;
    1eec:	e01c      	b.n	1f28 <lwip_setsockopt_internal+0xf0>
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
    1eee:	697b      	ldr	r3, [r7, #20]
    1ef0:	681b      	ldr	r3, [r3, #0]
    1ef2:	2b00      	cmp	r3, #0
    1ef4:	d00b      	beq.n	1f0e <lwip_setsockopt_internal+0xd6>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
    1ef6:	6a3b      	ldr	r3, [r7, #32]
    1ef8:	681b      	ldr	r3, [r3, #0]
    1efa:	685b      	ldr	r3, [r3, #4]
    1efc:	6a3a      	ldr	r2, [r7, #32]
    1efe:	6812      	ldr	r2, [r2, #0]
    1f00:	6852      	ldr	r2, [r2, #4]
    1f02:	7c12      	ldrb	r2, [r2, #16]
    1f04:	f042 0201 	orr.w	r2, r2, #1
    1f08:	b2d2      	uxtb	r2, r2
    1f0a:	741a      	strb	r2, [r3, #16]
    1f0c:	e00a      	b.n	1f24 <lwip_setsockopt_internal+0xec>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
    1f0e:	6a3b      	ldr	r3, [r7, #32]
    1f10:	681b      	ldr	r3, [r3, #0]
    1f12:	685b      	ldr	r3, [r3, #4]
    1f14:	6a3a      	ldr	r2, [r7, #32]
    1f16:	6812      	ldr	r2, [r2, #0]
    1f18:	6852      	ldr	r2, [r2, #4]
    1f1a:	7c12      	ldrb	r2, [r2, #16]
    1f1c:	f022 0201 	bic.w	r2, r2, #1
    1f20:	b2d2      	uxtb	r2, r2
    1f22:	741a      	strb	r2, [r3, #16]
      }
      break;
    1f24:	e000      	b.n	1f28 <lwip_setsockopt_internal+0xf0>
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    1f26:	bf00      	nop
    }  /* switch (optname) */
    break;
    1f28:	e0aa      	b.n	2080 <lwip_setsockopt_internal+0x248>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
    1f2a:	69bb      	ldr	r3, [r7, #24]
    1f2c:	f103 33ff 	add.w	r3, r3, #4294967295
    1f30:	2b06      	cmp	r3, #6
    1f32:	d878      	bhi.n	2026 <lwip_setsockopt_internal+0x1ee>
    1f34:	a201      	add	r2, pc, #4	; (adr r2, 1f3c <lwip_setsockopt_internal+0x104>)
    1f36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1f3a:	bf00      	nop
    1f3c:	00001f69 	.word	0x00001f69
			1f3c: R_ARM_ABS32	.text
    1f40:	00001f59 	.word	0x00001f59
			1f40: R_ARM_ABS32	.text
    1f44:	00001fcd 	.word	0x00001fcd
			1f44: R_ARM_ABS32	.text
    1f48:	00001fcd 	.word	0x00001fcd
			1f48: R_ARM_ABS32	.text
    1f4c:	00001f79 	.word	0x00001f79
			1f4c: R_ARM_ABS32	.text
    1f50:	00001f87 	.word	0x00001f87
			1f50: R_ARM_ABS32	.text
    1f54:	00001f95 	.word	0x00001f95
			1f54: R_ARM_ABS32	.text
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
    1f58:	6a3b      	ldr	r3, [r7, #32]
    1f5a:	681b      	ldr	r3, [r3, #0]
    1f5c:	685b      	ldr	r3, [r3, #4]
    1f5e:	697a      	ldr	r2, [r7, #20]
    1f60:	6812      	ldr	r2, [r2, #0]
    1f62:	b2d2      	uxtb	r2, r2
    1f64:	729a      	strb	r2, [r3, #10]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
    1f66:	e05f      	b.n	2028 <lwip_setsockopt_internal+0x1f0>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
    1f68:	6a3b      	ldr	r3, [r7, #32]
    1f6a:	681b      	ldr	r3, [r3, #0]
    1f6c:	685b      	ldr	r3, [r3, #4]
    1f6e:	697a      	ldr	r2, [r7, #20]
    1f70:	6812      	ldr	r2, [r2, #0]
    1f72:	b2d2      	uxtb	r2, r2
    1f74:	725a      	strb	r2, [r3, #9]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                  s, sock->conn->pcb.ip->tos));
      break;
    1f76:	e057      	b.n	2028 <lwip_setsockopt_internal+0x1f0>
#if LWIP_IGMP
    case IP_MULTICAST_TTL:
      sock->conn->pcb.udp->ttl = (u8_t)(*(u8_t*)optval);
    1f78:	6a3b      	ldr	r3, [r7, #32]
    1f7a:	681b      	ldr	r3, [r3, #0]
    1f7c:	685b      	ldr	r3, [r3, #4]
    1f7e:	697a      	ldr	r2, [r7, #20]
    1f80:	7812      	ldrb	r2, [r2, #0]
    1f82:	729a      	strb	r2, [r3, #10]
      break;
    1f84:	e050      	b.n	2028 <lwip_setsockopt_internal+0x1f0>
    case IP_MULTICAST_IF:
      inet_addr_to_ipaddr(&sock->conn->pcb.udp->multicast_ip, (struct in_addr*)optval);
    1f86:	6a3b      	ldr	r3, [r7, #32]
    1f88:	681b      	ldr	r3, [r3, #0]
    1f8a:	685b      	ldr	r3, [r3, #4]
    1f8c:	697a      	ldr	r2, [r7, #20]
    1f8e:	6812      	ldr	r2, [r2, #0]
    1f90:	619a      	str	r2, [r3, #24]
      break;
    1f92:	e049      	b.n	2028 <lwip_setsockopt_internal+0x1f0>
    case IP_MULTICAST_LOOP:
      if (*(u8_t*)optval) {
    1f94:	697b      	ldr	r3, [r7, #20]
    1f96:	781b      	ldrb	r3, [r3, #0]
    1f98:	2b00      	cmp	r3, #0
    1f9a:	d00b      	beq.n	1fb4 <lwip_setsockopt_internal+0x17c>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_MULTICAST_LOOP);
    1f9c:	6a3b      	ldr	r3, [r7, #32]
    1f9e:	681b      	ldr	r3, [r3, #0]
    1fa0:	685b      	ldr	r3, [r3, #4]
    1fa2:	6a3a      	ldr	r2, [r7, #32]
    1fa4:	6812      	ldr	r2, [r2, #0]
    1fa6:	6852      	ldr	r2, [r2, #4]
    1fa8:	7c12      	ldrb	r2, [r2, #16]
    1faa:	f042 0208 	orr.w	r2, r2, #8
    1fae:	b2d2      	uxtb	r2, r2
    1fb0:	741a      	strb	r2, [r3, #16]
    1fb2:	e00a      	b.n	1fca <lwip_setsockopt_internal+0x192>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_MULTICAST_LOOP);
    1fb4:	6a3b      	ldr	r3, [r7, #32]
    1fb6:	681b      	ldr	r3, [r3, #0]
    1fb8:	685b      	ldr	r3, [r3, #4]
    1fba:	6a3a      	ldr	r2, [r7, #32]
    1fbc:	6812      	ldr	r2, [r2, #0]
    1fbe:	6852      	ldr	r2, [r2, #4]
    1fc0:	7c12      	ldrb	r2, [r2, #16]
    1fc2:	f022 0208 	bic.w	r2, r2, #8
    1fc6:	b2d2      	uxtb	r2, r2
    1fc8:	741a      	strb	r2, [r3, #16]
      }
      break;
    1fca:	e02d      	b.n	2028 <lwip_setsockopt_internal+0x1f0>
    case IP_ADD_MEMBERSHIP:
    case IP_DROP_MEMBERSHIP:
      {
        /* If this is a TCP or a RAW socket, ignore these options. */
        struct ip_mreq *imr = (struct ip_mreq *)optval;
    1fcc:	697b      	ldr	r3, [r7, #20]
    1fce:	613b      	str	r3, [r7, #16]
        ip_addr_t if_addr;
        ip_addr_t multi_addr;
        inet_addr_to_ipaddr(&if_addr, &imr->imr_interface);
    1fd0:	693b      	ldr	r3, [r7, #16]
    1fd2:	685b      	ldr	r3, [r3, #4]
    1fd4:	60fb      	str	r3, [r7, #12]
        inet_addr_to_ipaddr(&multi_addr, &imr->imr_multiaddr);
    1fd6:	693b      	ldr	r3, [r7, #16]
    1fd8:	681b      	ldr	r3, [r3, #0]
    1fda:	60bb      	str	r3, [r7, #8]
        if(optname == IP_ADD_MEMBERSHIP){
    1fdc:	69bb      	ldr	r3, [r7, #24]
    1fde:	2b03      	cmp	r3, #3
    1fe0:	d10c      	bne.n	1ffc <lwip_setsockopt_internal+0x1c4>
          data->err = igmp_joingroup(&if_addr, &multi_addr);
    1fe2:	f107 020c 	add.w	r2, r7, #12
    1fe6:	f107 0308 	add.w	r3, r7, #8
    1fea:	4610      	mov	r0, r2
    1fec:	4619      	mov	r1, r3
    1fee:	f7ff fffe 	bl	0 <igmp_joingroup>
			1fee: R_ARM_THM_CALL	igmp_joingroup
    1ff2:	4603      	mov	r3, r0
    1ff4:	461a      	mov	r2, r3
    1ff6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1ff8:	751a      	strb	r2, [r3, #20]
    1ffa:	e00b      	b.n	2014 <lwip_setsockopt_internal+0x1dc>
        } else {
          data->err = igmp_leavegroup(&if_addr, &multi_addr);
    1ffc:	f107 020c 	add.w	r2, r7, #12
    2000:	f107 0308 	add.w	r3, r7, #8
    2004:	4610      	mov	r0, r2
    2006:	4619      	mov	r1, r3
    2008:	f7ff fffe 	bl	0 <igmp_leavegroup>
			2008: R_ARM_THM_CALL	igmp_leavegroup
    200c:	4603      	mov	r3, r0
    200e:	461a      	mov	r2, r3
    2010:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2012:	751a      	strb	r2, [r3, #20]
        }
        if(data->err != ERR_OK) {
    2014:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    2016:	7d1b      	ldrb	r3, [r3, #20]
    2018:	2b00      	cmp	r3, #0
    201a:	d003      	beq.n	2024 <lwip_setsockopt_internal+0x1ec>
          data->err = EADDRNOTAVAIL;
    201c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    201e:	f04f 0263 	mov.w	r2, #99	; 0x63
    2022:	751a      	strb	r2, [r3, #20]
        }
      }
      break;
    2024:	e000      	b.n	2028 <lwip_setsockopt_internal+0x1f0>
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    2026:	bf00      	nop
    }  /* switch (optname) */
    break;
    2028:	e02a      	b.n	2080 <lwip_setsockopt_internal+0x248>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    202a:	69bb      	ldr	r3, [r7, #24]
    202c:	2b01      	cmp	r3, #1
    202e:	d002      	beq.n	2036 <lwip_setsockopt_internal+0x1fe>
    2030:	2b02      	cmp	r3, #2
    2032:	d01c      	beq.n	206e <lwip_setsockopt_internal+0x236>
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    2034:	e023      	b.n	207e <lwip_setsockopt_internal+0x246>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
    2036:	697b      	ldr	r3, [r7, #20]
    2038:	681b      	ldr	r3, [r3, #0]
    203a:	2b00      	cmp	r3, #0
    203c:	d00b      	beq.n	2056 <lwip_setsockopt_internal+0x21e>
        tcp_nagle_disable(sock->conn->pcb.tcp);
    203e:	6a3b      	ldr	r3, [r7, #32]
    2040:	681b      	ldr	r3, [r3, #0]
    2042:	685b      	ldr	r3, [r3, #4]
    2044:	6a3a      	ldr	r2, [r7, #32]
    2046:	6812      	ldr	r2, [r2, #0]
    2048:	6852      	ldr	r2, [r2, #4]
    204a:	7f92      	ldrb	r2, [r2, #30]
    204c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2050:	b2d2      	uxtb	r2, r2
    2052:	779a      	strb	r2, [r3, #30]
    2054:	e00a      	b.n	206c <lwip_setsockopt_internal+0x234>
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
    2056:	6a3b      	ldr	r3, [r7, #32]
    2058:	681b      	ldr	r3, [r3, #0]
    205a:	685b      	ldr	r3, [r3, #4]
    205c:	6a3a      	ldr	r2, [r7, #32]
    205e:	6812      	ldr	r2, [r2, #0]
    2060:	6852      	ldr	r2, [r2, #4]
    2062:	7f92      	ldrb	r2, [r2, #30]
    2064:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    2068:	b2d2      	uxtb	r2, r2
    206a:	779a      	strb	r2, [r3, #30]
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    206c:	e007      	b.n	207e <lwip_setsockopt_internal+0x246>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
    206e:	6a3b      	ldr	r3, [r7, #32]
    2070:	681b      	ldr	r3, [r3, #0]
    2072:	685b      	ldr	r3, [r3, #4]
    2074:	697a      	ldr	r2, [r7, #20]
    2076:	6812      	ldr	r2, [r2, #0]
    2078:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
    207c:	bf00      	nop
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
      break;
    }  /* switch (optname) */
    break;
    207e:	bf00      	nop
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  }  /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
    2080:	6a3b      	ldr	r3, [r7, #32]
    2082:	681b      	ldr	r3, [r3, #0]
    2084:	f103 030c 	add.w	r3, r3, #12
    2088:	4618      	mov	r0, r3
    208a:	f7ff fffe 	bl	0 <sys_sem_signal>
			208a: R_ARM_THM_CALL	sys_sem_signal
}
    208e:	f107 0728 	add.w	r7, r7, #40	; 0x28
    2092:	46bd      	mov	sp, r7
    2094:	bd80      	pop	{r7, pc}
    2096:	bf00      	nop

00002098 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
    2098:	b580      	push	{r7, lr}
    209a:	b08a      	sub	sp, #40	; 0x28
    209c:	af00      	add	r7, sp, #0
    209e:	60f8      	str	r0, [r7, #12]
    20a0:	60b9      	str	r1, [r7, #8]
    20a2:	607a      	str	r2, [r7, #4]
  struct lwip_sock *sock = get_socket(s);
    20a4:	68f8      	ldr	r0, [r7, #12]
    20a6:	f7fd ffb1 	bl	c <get_socket>
    20aa:	61f8      	str	r0, [r7, #28]
  u8_t val;
#if LWIP_SO_RCVBUF
  u16_t buflen = 0;
    20ac:	f04f 0300 	mov.w	r3, #0
    20b0:	837b      	strh	r3, [r7, #26]
  s16_t recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
    20b2:	69fb      	ldr	r3, [r7, #28]
    20b4:	2b00      	cmp	r3, #0
    20b6:	d102      	bne.n	20be <lwip_ioctl+0x26>
    return -1;
    20b8:	f04f 33ff 	mov.w	r3, #4294967295
    20bc:	e080      	b.n	21c0 <lwip_ioctl+0x128>
  }

  switch (cmd) {
    20be:	68bb      	ldr	r3, [r7, #8]
    20c0:	4a42      	ldr	r2, [pc, #264]	; (21cc <lwip_ioctl+0x134>)
    20c2:	4293      	cmp	r3, r2
    20c4:	d045      	beq.n	2152 <lwip_ioctl+0xba>
    20c6:	4a42      	ldr	r2, [pc, #264]	; (21d0 <lwip_ioctl+0x138>)
    20c8:	4293      	cmp	r3, r2
    20ca:	d173      	bne.n	21b4 <lwip_ioctl+0x11c>
#if LWIP_SO_RCVBUF
  case FIONREAD:
    if (!argp) {
    20cc:	687b      	ldr	r3, [r7, #4]
    20ce:	2b00      	cmp	r3, #0
    20d0:	d106      	bne.n	20e0 <lwip_ioctl+0x48>
      sock_set_errno(sock, EINVAL);
    20d2:	69fb      	ldr	r3, [r7, #28]
    20d4:	f04f 0216 	mov.w	r2, #22
    20d8:	611a      	str	r2, [r3, #16]
      return -1;
    20da:	f04f 33ff 	mov.w	r3, #4294967295
    20de:	e06f      	b.n	e2 <sys_arch_protect+0xe2>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, recv_avail);
    20e0:	f7ff fffe 	bl	0 <sys_arch_protect>
			20e0: R_ARM_THM_CALL	sys_arch_protect
    20e4:	6178      	str	r0, [r7, #20]
    20e6:	69fb      	ldr	r3, [r7, #28]
    20e8:	681b      	ldr	r3, [r3, #0]
    20ea:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
    20ec:	84bb      	strh	r3, [r7, #36]	; 0x24
    20ee:	6978      	ldr	r0, [r7, #20]
    20f0:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			20f0: R_ARM_THM_CALL	sys_arch_unprotect
    if (recv_avail < 0) {
    20f4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
    20f8:	2b00      	cmp	r3, #0
    20fa:	da02      	bge.n	2102 <lwip_ioctl+0x6a>
      recv_avail = 0;
    20fc:	f04f 0300 	mov.w	r3, #0
    2100:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    *((u16_t*)argp) = (u16_t)recv_avail;
    2102:	687b      	ldr	r3, [r7, #4]
    2104:	8cba      	ldrh	r2, [r7, #36]	; 0x24
    2106:	801a      	strh	r2, [r3, #0]

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
    2108:	69fb      	ldr	r3, [r7, #28]
    210a:	685b      	ldr	r3, [r3, #4]
    210c:	2b00      	cmp	r3, #0
    210e:	d019      	beq.n	2144 <lwip_ioctl+0xac>
      struct pbuf *p = (struct pbuf *)sock->lastdata;
    2110:	69fb      	ldr	r3, [r7, #28]
    2112:	685b      	ldr	r3, [r3, #4]
    2114:	623b      	str	r3, [r7, #32]
      if (netconn_type(sock->conn) != NETCONN_TCP) {
    2116:	69fb      	ldr	r3, [r7, #28]
    2118:	681b      	ldr	r3, [r3, #0]
    211a:	781b      	ldrb	r3, [r3, #0]
    211c:	2b10      	cmp	r3, #16
    211e:	d002      	beq.n	2126 <lwip_ioctl+0x8e>
        p = ((struct netbuf *)p)->p;
    2120:	6a3b      	ldr	r3, [r7, #32]
    2122:	681b      	ldr	r3, [r3, #0]
    2124:	623b      	str	r3, [r7, #32]
      }
      buflen = p->tot_len;
    2126:	6a3b      	ldr	r3, [r7, #32]
    2128:	891b      	ldrh	r3, [r3, #8]
    212a:	837b      	strh	r3, [r7, #26]
      buflen -= sock->lastoffset;
    212c:	69fb      	ldr	r3, [r7, #28]
    212e:	891b      	ldrh	r3, [r3, #8]
    2130:	8b7a      	ldrh	r2, [r7, #26]
    2132:	1ad3      	subs	r3, r2, r3
    2134:	837b      	strh	r3, [r7, #26]

      *((u16_t*)argp) += buflen;
    2136:	687b      	ldr	r3, [r7, #4]
    2138:	687a      	ldr	r2, [r7, #4]
    213a:	8811      	ldrh	r1, [r2, #0]
    213c:	8b7a      	ldrh	r2, [r7, #26]
    213e:	188a      	adds	r2, r1, r2
    2140:	b292      	uxth	r2, r2
    2142:	801a      	strh	r2, [r3, #0]
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %"U16_F"\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    2144:	69fb      	ldr	r3, [r7, #28]
    2146:	f04f 0200 	mov.w	r2, #0
    214a:	611a      	str	r2, [r3, #16]
    return 0;
    214c:	f04f 0300 	mov.w	r3, #0
    2150:	e036      	b.n	21c0 <lwip_ioctl+0x128>
#endif /* LWIP_SO_RCVBUF */

  case FIONBIO:
    val = 0;
    2152:	f04f 0300 	mov.w	r3, #0
    2156:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if (argp && *(u32_t*)argp) {
    215a:	687b      	ldr	r3, [r7, #4]
    215c:	2b00      	cmp	r3, #0
    215e:	d007      	beq.n	2170 <lwip_ioctl+0xd8>
    2160:	687b      	ldr	r3, [r7, #4]
    2162:	681b      	ldr	r3, [r3, #0]
    2164:	2b00      	cmp	r3, #0
    2166:	d003      	beq.n	2170 <lwip_ioctl+0xd8>
      val = 1;
    2168:	f04f 0301 	mov.w	r3, #1
    216c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    }
    netconn_set_nonblocking(sock->conn, val);
    2170:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
    2174:	2b00      	cmp	r3, #0
    2176:	d00b      	beq.n	2190 <lwip_ioctl+0xf8>
    2178:	69fb      	ldr	r3, [r7, #28]
    217a:	681b      	ldr	r3, [r3, #0]
    217c:	69fa      	ldr	r2, [r7, #28]
    217e:	6812      	ldr	r2, [r2, #0]
    2180:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
    2184:	f042 0202 	orr.w	r2, r2, #2
    2188:	b2d2      	uxtb	r2, r2
    218a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    218e:	e00a      	b.n	21a6 <lwip_ioctl+0x10e>
    2190:	69fb      	ldr	r3, [r7, #28]
    2192:	681b      	ldr	r3, [r3, #0]
    2194:	69fa      	ldr	r2, [r7, #28]
    2196:	6812      	ldr	r2, [r2, #0]
    2198:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
    219c:	f022 0202 	bic.w	r2, r2, #2
    21a0:	b2d2      	uxtb	r2, r2
    21a2:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
    sock_set_errno(sock, 0);
    21a6:	69fb      	ldr	r3, [r7, #28]
    21a8:	f04f 0200 	mov.w	r2, #0
    21ac:	611a      	str	r2, [r3, #16]
    return 0;
    21ae:	f04f 0300 	mov.w	r3, #0
    21b2:	e005      	b.n	21c0 <lwip_ioctl+0x128>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    21b4:	69fb      	ldr	r3, [r7, #28]
    21b6:	f04f 0226 	mov.w	r2, #38	; 0x26
    21ba:	611a      	str	r2, [r3, #16]
    return -1;
    21bc:	f04f 33ff 	mov.w	r3, #4294967295
  } /* switch (cmd) */
}
    21c0:	4618      	mov	r0, r3
    21c2:	f107 0728 	add.w	r7, r7, #40	; 0x28
    21c6:	46bd      	mov	sp, r7
    21c8:	bd80      	pop	{r7, pc}
    21ca:	bf00      	nop
    21cc:	8004667e 	.word	0x8004667e
    21d0:	4004667f 	.word	0x4004667f

000021d4 <lwip_fcntl>:
 * Currently only the commands F_GETFL and F_SETFL are implemented.
 * Only the flag O_NONBLOCK is implemented.
 */
int
lwip_fcntl(int s, int cmd, int val)
{
    21d4:	b580      	push	{r7, lr}
    21d6:	b086      	sub	sp, #24
    21d8:	af00      	add	r7, sp, #0
    21da:	60f8      	str	r0, [r7, #12]
    21dc:	60b9      	str	r1, [r7, #8]
    21de:	607a      	str	r2, [r7, #4]
  struct lwip_sock *sock = get_socket(s);
    21e0:	68f8      	ldr	r0, [r7, #12]
    21e2:	f7fd ff13 	bl	c <get_socket>
    21e6:	6138      	str	r0, [r7, #16]
  int ret = -1;
    21e8:	f04f 33ff 	mov.w	r3, #4294967295
    21ec:	617b      	str	r3, [r7, #20]

  if (!sock || !sock->conn) {
    21ee:	693b      	ldr	r3, [r7, #16]
    21f0:	2b00      	cmp	r3, #0
    21f2:	d003      	beq.n	21fc <lwip_fcntl+0x28>
    21f4:	693b      	ldr	r3, [r7, #16]
    21f6:	681b      	ldr	r3, [r3, #0]
    21f8:	2b00      	cmp	r3, #0
    21fa:	d102      	bne.n	2202 <lwip_fcntl+0x2e>
    return -1;
    21fc:	f04f 33ff 	mov.w	r3, #4294967295
    2200:	e039      	b.n	2276 <lwip_fcntl+0xa2>
  }

  switch (cmd) {
    2202:	68bb      	ldr	r3, [r7, #8]
    2204:	2b03      	cmp	r3, #3
    2206:	d002      	beq.n	220e <lwip_fcntl+0x3a>
    2208:	2b04      	cmp	r3, #4
    220a:	d00c      	beq.n	2226 <lwip_fcntl+0x52>
      ret = 0;
    }
    break;
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
    220c:	e032      	b.n	2274 <lwip_fcntl+0xa0>
    return -1;
  }

  switch (cmd) {
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
    220e:	693b      	ldr	r3, [r7, #16]
    2210:	681b      	ldr	r3, [r3, #0]
    2212:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
    2216:	f003 0302 	and.w	r3, r3, #2
    221a:	2b00      	cmp	r3, #0
    221c:	bf0c      	ite	eq
    221e:	2300      	moveq	r3, #0
    2220:	2301      	movne	r3, #1
    2222:	617b      	str	r3, [r7, #20]
    break;
    2224:	e026      	b.n	2274 <lwip_fcntl+0xa0>
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
    2226:	687b      	ldr	r3, [r7, #4]
    2228:	f023 0301 	bic.w	r3, r3, #1
    222c:	2b00      	cmp	r3, #0
    222e:	d120      	bne.n	2272 <lwip_fcntl+0x9e>
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
    2230:	687b      	ldr	r3, [r7, #4]
    2232:	f003 0301 	and.w	r3, r3, #1
    2236:	b2db      	uxtb	r3, r3
    2238:	2b00      	cmp	r3, #0
    223a:	d00b      	beq.n	2254 <lwip_fcntl+0x80>
    223c:	693b      	ldr	r3, [r7, #16]
    223e:	681b      	ldr	r3, [r3, #0]
    2240:	693a      	ldr	r2, [r7, #16]
    2242:	6812      	ldr	r2, [r2, #0]
    2244:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
    2248:	f042 0202 	orr.w	r2, r2, #2
    224c:	b2d2      	uxtb	r2, r2
    224e:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    2252:	e00a      	b.n	226a <lwip_fcntl+0x96>
    2254:	693b      	ldr	r3, [r7, #16]
    2256:	681b      	ldr	r3, [r3, #0]
    2258:	693a      	ldr	r2, [r7, #16]
    225a:	6812      	ldr	r2, [r2, #0]
    225c:	f892 202e 	ldrb.w	r2, [r2, #46]	; 0x2e
    2260:	f022 0202 	bic.w	r2, r2, #2
    2264:	b2d2      	uxtb	r2, r2
    2266:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
      ret = 0;
    226a:	f04f 0300 	mov.w	r3, #0
    226e:	617b      	str	r3, [r7, #20]
    }
    break;
    2270:	e000      	b.n	2274 <lwip_fcntl+0xa0>
    2272:	bf00      	nop
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
  }
  return ret;
    2274:	697b      	ldr	r3, [r7, #20]
}
    2276:	4618      	mov	r0, r3
    2278:	f107 0718 	add.w	r7, r7, #24
    227c:	46bd      	mov	sp, r7
    227e:	bd80      	pop	{r7, pc}

tcpip.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  59896 Jul 30 19:07 2021 tcpip.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004a4  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000004d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00000000  00000000  000004d8  2**2
                  ALLOC
  3 .debug_abbrev 000001e4  00000000  00000000  000004d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000d73  00000000  00000000  000006bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000005b4  00000000  00000000  0000142f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000aa52  00000000  00000000  000019e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000010  00000000  00000000  0000c438  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    000002d8  00000000  00000000  0000c448  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 00000100  00000000  00000000  0000c720  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 0000023d  00000000  00000000  0000c820  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  0000ca5d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    000007d7  00000000  00000000  0000ca7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0000d254  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000d27f  2**0
                  CONTENTS, READONLY
 15 .debug_frame  000001b0  00000000  00000000  0000d2b0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 tcpip.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 tcpip_init_done
00000004 l       .bss	00000000 tcpip_init_done_arg
00000008 l       .bss	00000000 mbox
00000000 l     F .text	00000120 tcpip_thread
00000000 l    d  .rodata	00000000 .rodata
00000440 l     F .text	0000001a pbuf_free_int
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000         *UND*	00000000 sys_timeouts_mbox_fetch
00000000         *UND*	00000000 ethernet_input
00000000         *UND*	00000000 ip_input
00000000         *UND*	00000000 memp_free
00000000         *UND*	00000000 sys_timeout
00000000         *UND*	00000000 sys_untimeout
00000120 g     F .text	0000007c tcpip_input
00000000         *UND*	00000000 sys_mbox_valid
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 sys_mbox_trypost
0000019c g     F .text	00000090 tcpip_callback_with_block
00000000         *UND*	00000000 sys_mbox_post
0000022c g     F .text	0000006c tcpip_timeout
00000298 g     F .text	00000064 tcpip_untimeout
000002fc g     F .text	00000058 tcpip_apimsg
00000000         *UND*	00000000 sys_arch_sem_wait
00000354 g     F .text	00000042 tcpip_callbackmsg_new
00000398 g     F .text	0000001a tcpip_callbackmsg_delete
000003b4 g     F .text	00000034 tcpip_trycallback
000003e8 g     F .text	00000058 tcpip_init
00000000         *UND*	00000000 lwip_init
00000000         *UND*	00000000 sys_mbox_new
00000000         *UND*	00000000 sys_thread_new
00000000         *UND*	00000000 pbuf_free
0000045c g     F .text	00000024 pbuf_free_callback
00000480 g     F .text	00000024 mem_free_callback
00000000         *UND*	00000000 mem_free



Disassembly of section .text:

00000000 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
   8:	4b42      	ldr	r3, [pc, #264]	; (114 <tcpip_thread+0x114>)
   a:	681b      	ldr	r3, [r3, #0]
   c:	2b00      	cmp	r3, #0
   e:	d005      	beq.n	1c <tcpip_thread+0x1c>
    tcpip_init_done(tcpip_init_done_arg);
  10:	4b40      	ldr	r3, [pc, #256]	; (114 <tcpip_thread+0x114>)
  12:	681b      	ldr	r3, [r3, #0]
  14:	4a40      	ldr	r2, [pc, #256]	; (118 <tcpip_thread+0x118>)
  16:	6812      	ldr	r2, [r2, #0]
  18:	4610      	mov	r0, r2
  1a:	4798      	blx	r3
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
  1c:	f107 030c 	add.w	r3, r7, #12
  20:	483e      	ldr	r0, [pc, #248]	; (11c <tcpip_thread+0x11c>)
  22:	4619      	mov	r1, r3
  24:	f7ff fffe 	bl	0 <sys_timeouts_mbox_fetch>
			24: R_ARM_THM_CALL	sys_timeouts_mbox_fetch
    LOCK_TCPIP_CORE();
    switch (msg->type) {
  28:	68fb      	ldr	r3, [r7, #12]
  2a:	781b      	ldrb	r3, [r3, #0]
  2c:	2b05      	cmp	r3, #5
  2e:	d86e      	bhi.n	10e <tcpip_thread+0x10e>
  30:	a201      	add	r2, pc, #4	; (adr r2, 38 <tcpip_thread+0x38>)
  32:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  36:	bf00      	nop
  38:	00000051 	.word	0x00000051
			38: R_ARM_ABS32	.text
  3c:	00000065 	.word	0x00000065
			3c: R_ARM_ABS32	.text
  40:	000000a5 	.word	0x000000a5
			40: R_ARM_ABS32	.text
  44:	000000c9 	.word	0x000000c9
			44: R_ARM_ABS32	.text
  48:	000000e7 	.word	0x000000e7
			48: R_ARM_ABS32	.text
  4c:	00000101 	.word	0x00000101
			4c: R_ARM_ABS32	.text
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  50:	68fb      	ldr	r3, [r7, #12]
  52:	689b      	ldr	r3, [r3, #8]
  54:	681b      	ldr	r3, [r3, #0]
  56:	68fa      	ldr	r2, [r7, #12]
  58:	6892      	ldr	r2, [r2, #8]
  5a:	f102 0204 	add.w	r2, r2, #4
  5e:	4610      	mov	r0, r2
  60:	4798      	blx	r3
      break;
  62:	e055      	b.n	110 <tcpip_thread+0x110>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
  64:	68fb      	ldr	r3, [r7, #12]
  66:	68db      	ldr	r3, [r3, #12]
  68:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  6c:	f003 0360 	and.w	r3, r3, #96	; 0x60
  70:	2b00      	cmp	r3, #0
  72:	d008      	beq.n	86 <tcpip_thread+0x86>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  74:	68fb      	ldr	r3, [r7, #12]
  76:	689a      	ldr	r2, [r3, #8]
  78:	68fb      	ldr	r3, [r7, #12]
  7a:	68db      	ldr	r3, [r3, #12]
  7c:	4610      	mov	r0, r2
  7e:	4619      	mov	r1, r3
  80:	f7ff fffe 	bl	0 <ethernet_input>
			80: R_ARM_THM_CALL	ethernet_input
  84:	e007      	b.n	96 <tcpip_thread+0x96>
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  86:	68fb      	ldr	r3, [r7, #12]
  88:	689a      	ldr	r2, [r3, #8]
  8a:	68fb      	ldr	r3, [r7, #12]
  8c:	68db      	ldr	r3, [r3, #12]
  8e:	4610      	mov	r0, r2
  90:	4619      	mov	r1, r3
  92:	f7ff fffe 	bl	0 <ip_input>
			92: R_ARM_THM_CALL	ip_input
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  96:	68fb      	ldr	r3, [r7, #12]
  98:	f04f 0009 	mov.w	r0, #9
  9c:	4619      	mov	r1, r3
  9e:	f7ff fffe 	bl	0 <memp_free>
			9e: R_ARM_THM_CALL	memp_free
      break;
  a2:	e035      	b.n	110 <tcpip_thread+0x110>
#endif /* LWIP_NETIF_API */

#if LWIP_TCPIP_TIMEOUT
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  a4:	68fb      	ldr	r3, [r7, #12]
  a6:	6899      	ldr	r1, [r3, #8]
  a8:	68fb      	ldr	r3, [r7, #12]
  aa:	68da      	ldr	r2, [r3, #12]
  ac:	68fb      	ldr	r3, [r7, #12]
  ae:	691b      	ldr	r3, [r3, #16]
  b0:	4608      	mov	r0, r1
  b2:	4611      	mov	r1, r2
  b4:	461a      	mov	r2, r3
  b6:	f7ff fffe 	bl	0 <sys_timeout>
			b6: R_ARM_THM_CALL	sys_timeout
      memp_free(MEMP_TCPIP_MSG_API, msg);
  ba:	68fb      	ldr	r3, [r7, #12]
  bc:	f04f 0008 	mov.w	r0, #8
  c0:	4619      	mov	r1, r3
  c2:	f7ff fffe 	bl	0 <memp_free>
			c2: R_ARM_THM_CALL	memp_free
      break;
  c6:	e023      	b.n	110 <tcpip_thread+0x110>
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
  c8:	68fb      	ldr	r3, [r7, #12]
  ca:	68da      	ldr	r2, [r3, #12]
  cc:	68fb      	ldr	r3, [r7, #12]
  ce:	691b      	ldr	r3, [r3, #16]
  d0:	4610      	mov	r0, r2
  d2:	4619      	mov	r1, r3
  d4:	f7ff fffe 	bl	0 <sys_untimeout>
			d4: R_ARM_THM_CALL	sys_untimeout
      memp_free(MEMP_TCPIP_MSG_API, msg);
  d8:	68fb      	ldr	r3, [r7, #12]
  da:	f04f 0008 	mov.w	r0, #8
  de:	4619      	mov	r1, r3
  e0:	f7ff fffe 	bl	0 <memp_free>
			e0: R_ARM_THM_CALL	memp_free
      break;
  e4:	e014      	b.n	110 <tcpip_thread+0x110>
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
  e6:	68fb      	ldr	r3, [r7, #12]
  e8:	689b      	ldr	r3, [r3, #8]
  ea:	68fa      	ldr	r2, [r7, #12]
  ec:	68d2      	ldr	r2, [r2, #12]
  ee:	4610      	mov	r0, r2
  f0:	4798      	blx	r3
      memp_free(MEMP_TCPIP_MSG_API, msg);
  f2:	68fb      	ldr	r3, [r7, #12]
  f4:	f04f 0008 	mov.w	r0, #8
  f8:	4619      	mov	r1, r3
  fa:	f7ff fffe 	bl	0 <memp_free>
			fa: R_ARM_THM_CALL	memp_free
      break;
  fe:	e007      	b.n	110 <tcpip_thread+0x110>

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 100:	68fb      	ldr	r3, [r7, #12]
 102:	689b      	ldr	r3, [r3, #8]
 104:	68fa      	ldr	r2, [r7, #12]
 106:	68d2      	ldr	r2, [r2, #12]
 108:	4610      	mov	r0, r2
 10a:	4798      	blx	r3
      break;
 10c:	e000      	b.n	110 <tcpip_thread+0x110>

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
      break;
 10e:	bf00      	nop
    }
  }
 110:	e784      	b.n	1c <tcpip_thread+0x1c>
 112:	bf00      	nop
 114:	00000000 	.word	0x00000000
			114: R_ARM_ABS32	.bss
 118:	00000004 	.word	0x00000004
			118: R_ARM_ABS32	.bss
 11c:	00000008 	.word	0x00000008
			11c: R_ARM_ABS32	.bss

00000120 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 120:	b580      	push	{r7, lr}
 122:	b084      	sub	sp, #16
 124:	af00      	add	r7, sp, #0
 126:	6078      	str	r0, [r7, #4]
 128:	6039      	str	r1, [r7, #0]
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 12a:	481b      	ldr	r0, [pc, #108]	; (198 <tcpip_input+0x78>)
 12c:	f7ff fffe 	bl	0 <sys_mbox_valid>
			12c: R_ARM_THM_CALL	sys_mbox_valid
 130:	4603      	mov	r3, r0
 132:	2b00      	cmp	r3, #0
 134:	d102      	bne.n	13c <tcpip_input+0x1c>
    return ERR_VAL;
 136:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 13a:	e026      	b.n	18a <tcpip_input+0x6a>
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 13c:	f04f 0009 	mov.w	r0, #9
 140:	f7ff fffe 	bl	0 <memp_malloc>
			140: R_ARM_THM_CALL	memp_malloc
 144:	4603      	mov	r3, r0
 146:	60fb      	str	r3, [r7, #12]
  if (msg == NULL) {
 148:	68fb      	ldr	r3, [r7, #12]
 14a:	2b00      	cmp	r3, #0
 14c:	d102      	bne.n	154 <tcpip_input+0x34>
    return ERR_MEM;
 14e:	f04f 03ff 	mov.w	r3, #255	; 0xff
 152:	e01a      	b.n	18a <tcpip_input+0x6a>
  }

  msg->type = TCPIP_MSG_INPKT;
 154:	68fb      	ldr	r3, [r7, #12]
 156:	f04f 0201 	mov.w	r2, #1
 15a:	701a      	strb	r2, [r3, #0]
  msg->msg.inp.p = p;
 15c:	68fb      	ldr	r3, [r7, #12]
 15e:	687a      	ldr	r2, [r7, #4]
 160:	609a      	str	r2, [r3, #8]
  msg->msg.inp.netif = inp;
 162:	68fb      	ldr	r3, [r7, #12]
 164:	683a      	ldr	r2, [r7, #0]
 166:	60da      	str	r2, [r3, #12]
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 168:	480b      	ldr	r0, [pc, #44]	; (198 <tcpip_input+0x78>)
 16a:	68f9      	ldr	r1, [r7, #12]
 16c:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			16c: R_ARM_THM_CALL	sys_mbox_trypost
 170:	4603      	mov	r3, r0
 172:	2b00      	cmp	r3, #0
 174:	d007      	beq.n	186 <tcpip_input+0x66>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 176:	f04f 0009 	mov.w	r0, #9
 17a:	68f9      	ldr	r1, [r7, #12]
 17c:	f7ff fffe 	bl	0 <memp_free>
			17c: R_ARM_THM_CALL	memp_free
    return ERR_MEM;
 180:	f04f 03ff 	mov.w	r3, #255	; 0xff
 184:	e001      	b.n	18a <tcpip_input+0x6a>
  }
  return ERR_OK;
 186:	f04f 0300 	mov.w	r3, #0
 18a:	b25b      	sxtb	r3, r3
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 18c:	4618      	mov	r0, r3
 18e:	f107 0710 	add.w	r7, r7, #16
 192:	46bd      	mov	sp, r7
 194:	bd80      	pop	{r7, pc}
 196:	bf00      	nop
 198:	00000008 	.word	0x00000008
			198: R_ARM_ABS32	.bss

0000019c <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 19c:	b580      	push	{r7, lr}
 19e:	b086      	sub	sp, #24
 1a0:	af00      	add	r7, sp, #0
 1a2:	60f8      	str	r0, [r7, #12]
 1a4:	60b9      	str	r1, [r7, #8]
 1a6:	4613      	mov	r3, r2
 1a8:	71fb      	strb	r3, [r7, #7]
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 1aa:	481f      	ldr	r0, [pc, #124]	; (228 <tcpip_callback_with_block+0x8c>)
 1ac:	f7ff fffe 	bl	0 <sys_mbox_valid>
			1ac: R_ARM_THM_CALL	sys_mbox_valid
 1b0:	4603      	mov	r3, r0
 1b2:	2b00      	cmp	r3, #0
 1b4:	d02f      	beq.n	216 <tcpip_callback_with_block+0x7a>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 1b6:	f04f 0008 	mov.w	r0, #8
 1ba:	f7ff fffe 	bl	0 <memp_malloc>
			1ba: R_ARM_THM_CALL	memp_malloc
 1be:	4603      	mov	r3, r0
 1c0:	617b      	str	r3, [r7, #20]
    if (msg == NULL) {
 1c2:	697b      	ldr	r3, [r7, #20]
 1c4:	2b00      	cmp	r3, #0
 1c6:	d102      	bne.n	1ce <tcpip_callback_with_block+0x32>
      return ERR_MEM;
 1c8:	f04f 03ff 	mov.w	r3, #255	; 0xff
 1cc:	e025      	b.n	21a <tcpip_callback_with_block+0x7e>
    }

    msg->type = TCPIP_MSG_CALLBACK;
 1ce:	697b      	ldr	r3, [r7, #20]
 1d0:	f04f 0204 	mov.w	r2, #4
 1d4:	701a      	strb	r2, [r3, #0]
    msg->msg.cb.function = function;
 1d6:	697b      	ldr	r3, [r7, #20]
 1d8:	68fa      	ldr	r2, [r7, #12]
 1da:	609a      	str	r2, [r3, #8]
    msg->msg.cb.ctx = ctx;
 1dc:	697b      	ldr	r3, [r7, #20]
 1de:	68ba      	ldr	r2, [r7, #8]
 1e0:	60da      	str	r2, [r3, #12]
    if (block) {
 1e2:	79fb      	ldrb	r3, [r7, #7]
 1e4:	2b00      	cmp	r3, #0
 1e6:	d004      	beq.n	1f2 <tcpip_callback_with_block+0x56>
      sys_mbox_post(&mbox, msg);
 1e8:	480f      	ldr	r0, [pc, #60]	; (228 <tcpip_callback_with_block+0x8c>)
 1ea:	6979      	ldr	r1, [r7, #20]
 1ec:	f7ff fffe 	bl	0 <sys_mbox_post>
			1ec: R_ARM_THM_CALL	sys_mbox_post
 1f0:	e00e      	b.n	210 <tcpip_callback_with_block+0x74>
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 1f2:	480d      	ldr	r0, [pc, #52]	; (228 <tcpip_callback_with_block+0x8c>)
 1f4:	6979      	ldr	r1, [r7, #20]
 1f6:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			1f6: R_ARM_THM_CALL	sys_mbox_trypost
 1fa:	4603      	mov	r3, r0
 1fc:	2b00      	cmp	r3, #0
 1fe:	d007      	beq.n	210 <tcpip_callback_with_block+0x74>
        memp_free(MEMP_TCPIP_MSG_API, msg);
 200:	f04f 0008 	mov.w	r0, #8
 204:	6979      	ldr	r1, [r7, #20]
 206:	f7ff fffe 	bl	0 <memp_free>
			206: R_ARM_THM_CALL	memp_free
        return ERR_MEM;
 20a:	f04f 03ff 	mov.w	r3, #255	; 0xff
 20e:	e004      	b.n	21a <tcpip_callback_with_block+0x7e>
      }
    }
    return ERR_OK;
 210:	f04f 0300 	mov.w	r3, #0
 214:	e001      	b.n	21a <tcpip_callback_with_block+0x7e>
  }
  return ERR_VAL;
 216:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 21a:	b25b      	sxtb	r3, r3
}
 21c:	4618      	mov	r0, r3
 21e:	f107 0718 	add.w	r7, r7, #24
 222:	46bd      	mov	sp, r7
 224:	bd80      	pop	{r7, pc}
 226:	bf00      	nop
 228:	00000008 	.word	0x00000008
			228: R_ARM_ABS32	.bss

0000022c <tcpip_timeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
 22c:	b580      	push	{r7, lr}
 22e:	b086      	sub	sp, #24
 230:	af00      	add	r7, sp, #0
 232:	60f8      	str	r0, [r7, #12]
 234:	60b9      	str	r1, [r7, #8]
 236:	607a      	str	r2, [r7, #4]
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 238:	4816      	ldr	r0, [pc, #88]	; (294 <tcpip_timeout+0x68>)
 23a:	f7ff fffe 	bl	0 <sys_mbox_valid>
			23a: R_ARM_THM_CALL	sys_mbox_valid
 23e:	4603      	mov	r3, r0
 240:	2b00      	cmp	r3, #0
 242:	d01f      	beq.n	284 <tcpip_timeout+0x58>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 244:	f04f 0008 	mov.w	r0, #8
 248:	f7ff fffe 	bl	0 <memp_malloc>
			248: R_ARM_THM_CALL	memp_malloc
 24c:	4603      	mov	r3, r0
 24e:	617b      	str	r3, [r7, #20]
    if (msg == NULL) {
 250:	697b      	ldr	r3, [r7, #20]
 252:	2b00      	cmp	r3, #0
 254:	d102      	bne.n	25c <tcpip_timeout+0x30>
      return ERR_MEM;
 256:	f04f 03ff 	mov.w	r3, #255	; 0xff
 25a:	e015      	b.n	288 <tcpip_timeout+0x5c>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
 25c:	697b      	ldr	r3, [r7, #20]
 25e:	f04f 0202 	mov.w	r2, #2
 262:	701a      	strb	r2, [r3, #0]
    msg->msg.tmo.msecs = msecs;
 264:	697b      	ldr	r3, [r7, #20]
 266:	68fa      	ldr	r2, [r7, #12]
 268:	609a      	str	r2, [r3, #8]
    msg->msg.tmo.h = h;
 26a:	697b      	ldr	r3, [r7, #20]
 26c:	68ba      	ldr	r2, [r7, #8]
 26e:	60da      	str	r2, [r3, #12]
    msg->msg.tmo.arg = arg;
 270:	697b      	ldr	r3, [r7, #20]
 272:	687a      	ldr	r2, [r7, #4]
 274:	611a      	str	r2, [r3, #16]
    sys_mbox_post(&mbox, msg);
 276:	4807      	ldr	r0, [pc, #28]	; (294 <tcpip_timeout+0x68>)
 278:	6979      	ldr	r1, [r7, #20]
 27a:	f7ff fffe 	bl	0 <sys_mbox_post>
			27a: R_ARM_THM_CALL	sys_mbox_post
    return ERR_OK;
 27e:	f04f 0300 	mov.w	r3, #0
 282:	e001      	b.n	288 <tcpip_timeout+0x5c>
  }
  return ERR_VAL;
 284:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 288:	b25b      	sxtb	r3, r3
}
 28a:	4618      	mov	r0, r3
 28c:	f107 0718 	add.w	r7, r7, #24
 290:	46bd      	mov	sp, r7
 292:	bd80      	pop	{r7, pc}
 294:	00000008 	.word	0x00000008
			294: R_ARM_ABS32	.bss

00000298 <tcpip_untimeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
 298:	b580      	push	{r7, lr}
 29a:	b084      	sub	sp, #16
 29c:	af00      	add	r7, sp, #0
 29e:	6078      	str	r0, [r7, #4]
 2a0:	6039      	str	r1, [r7, #0]
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 2a2:	4815      	ldr	r0, [pc, #84]	; (2f8 <tcpip_untimeout+0x60>)
 2a4:	f7ff fffe 	bl	0 <sys_mbox_valid>
			2a4: R_ARM_THM_CALL	sys_mbox_valid
 2a8:	4603      	mov	r3, r0
 2aa:	2b00      	cmp	r3, #0
 2ac:	d01c      	beq.n	2e8 <tcpip_untimeout+0x50>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 2ae:	f04f 0008 	mov.w	r0, #8
 2b2:	f7ff fffe 	bl	0 <memp_malloc>
			2b2: R_ARM_THM_CALL	memp_malloc
 2b6:	4603      	mov	r3, r0
 2b8:	60fb      	str	r3, [r7, #12]
    if (msg == NULL) {
 2ba:	68fb      	ldr	r3, [r7, #12]
 2bc:	2b00      	cmp	r3, #0
 2be:	d102      	bne.n	2c6 <tcpip_untimeout+0x2e>
      return ERR_MEM;
 2c0:	f04f 03ff 	mov.w	r3, #255	; 0xff
 2c4:	e012      	b.n	2ec <tcpip_untimeout+0x54>
    }

    msg->type = TCPIP_MSG_UNTIMEOUT;
 2c6:	68fb      	ldr	r3, [r7, #12]
 2c8:	f04f 0203 	mov.w	r2, #3
 2cc:	701a      	strb	r2, [r3, #0]
    msg->msg.tmo.h = h;
 2ce:	68fb      	ldr	r3, [r7, #12]
 2d0:	687a      	ldr	r2, [r7, #4]
 2d2:	60da      	str	r2, [r3, #12]
    msg->msg.tmo.arg = arg;
 2d4:	68fb      	ldr	r3, [r7, #12]
 2d6:	683a      	ldr	r2, [r7, #0]
 2d8:	611a      	str	r2, [r3, #16]
    sys_mbox_post(&mbox, msg);
 2da:	4807      	ldr	r0, [pc, #28]	; (2f8 <tcpip_untimeout+0x60>)
 2dc:	68f9      	ldr	r1, [r7, #12]
 2de:	f7ff fffe 	bl	0 <sys_mbox_post>
			2de: R_ARM_THM_CALL	sys_mbox_post
    return ERR_OK;
 2e2:	f04f 0300 	mov.w	r3, #0
 2e6:	e001      	b.n	2ec <tcpip_untimeout+0x54>
  }
  return ERR_VAL;
 2e8:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 2ec:	b25b      	sxtb	r3, r3
}
 2ee:	4618      	mov	r0, r3
 2f0:	f107 0710 	add.w	r7, r7, #16
 2f4:	46bd      	mov	sp, r7
 2f6:	bd80      	pop	{r7, pc}
 2f8:	00000008 	.word	0x00000008
			2f8: R_ARM_ABS32	.bss

000002fc <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
 2fc:	b580      	push	{r7, lr}
 2fe:	b088      	sub	sp, #32
 300:	af00      	add	r7, sp, #0
 302:	6078      	str	r0, [r7, #4]
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
 304:	4812      	ldr	r0, [pc, #72]	; (350 <tcpip_apimsg+0x54>)
 306:	f7ff fffe 	bl	0 <sys_mbox_valid>
			306: R_ARM_THM_CALL	sys_mbox_valid
 30a:	4603      	mov	r3, r0
 30c:	2b00      	cmp	r3, #0
 30e:	d016      	beq.n	33e <tcpip_apimsg+0x42>
    msg.type = TCPIP_MSG_API;
 310:	f04f 0300 	mov.w	r3, #0
 314:	733b      	strb	r3, [r7, #12]
    msg.msg.apimsg = apimsg;
 316:	687b      	ldr	r3, [r7, #4]
 318:	617b      	str	r3, [r7, #20]
    sys_mbox_post(&mbox, &msg);
 31a:	f107 030c 	add.w	r3, r7, #12
 31e:	480c      	ldr	r0, [pc, #48]	; (350 <tcpip_apimsg+0x54>)
 320:	4619      	mov	r1, r3
 322:	f7ff fffe 	bl	0 <sys_mbox_post>
			322: R_ARM_THM_CALL	sys_mbox_post
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
 326:	687b      	ldr	r3, [r7, #4]
 328:	685b      	ldr	r3, [r3, #4]
 32a:	f103 030c 	add.w	r3, r3, #12
 32e:	4618      	mov	r0, r3
 330:	f04f 0100 	mov.w	r1, #0
 334:	f7ff fffe 	bl	0 <sys_arch_sem_wait>
			334: R_ARM_THM_CALL	sys_arch_sem_wait
    return apimsg->msg.err;
 338:	687b      	ldr	r3, [r7, #4]
 33a:	7a1b      	ldrb	r3, [r3, #8]
 33c:	e001      	b.n	342 <tcpip_apimsg+0x46>
  }
  return ERR_VAL;
 33e:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 342:	b25b      	sxtb	r3, r3
}
 344:	4618      	mov	r0, r3
 346:	f107 0720 	add.w	r7, r7, #32
 34a:	46bd      	mov	sp, r7
 34c:	bd80      	pop	{r7, pc}
 34e:	bf00      	nop
 350:	00000008 	.word	0x00000008
			350: R_ARM_ABS32	.bss

00000354 <tcpip_callbackmsg_new>:
 * @param function the function to call
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
 354:	b580      	push	{r7, lr}
 356:	b084      	sub	sp, #16
 358:	af00      	add	r7, sp, #0
 35a:	6078      	str	r0, [r7, #4]
 35c:	6039      	str	r1, [r7, #0]
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 35e:	f04f 0008 	mov.w	r0, #8
 362:	f7ff fffe 	bl	0 <memp_malloc>
			362: R_ARM_THM_CALL	memp_malloc
 366:	4603      	mov	r3, r0
 368:	60fb      	str	r3, [r7, #12]
  if (msg == NULL) {
 36a:	68fb      	ldr	r3, [r7, #12]
 36c:	2b00      	cmp	r3, #0
 36e:	d102      	bne.n	376 <tcpip_callbackmsg_new+0x22>
    return NULL;
 370:	f04f 0300 	mov.w	r3, #0
 374:	e00a      	b.n	38c <tcpip_callbackmsg_new+0x38>
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
 376:	68fb      	ldr	r3, [r7, #12]
 378:	f04f 0205 	mov.w	r2, #5
 37c:	701a      	strb	r2, [r3, #0]
  msg->msg.cb.function = function;
 37e:	68fb      	ldr	r3, [r7, #12]
 380:	687a      	ldr	r2, [r7, #4]
 382:	609a      	str	r2, [r3, #8]
  msg->msg.cb.ctx = ctx;
 384:	68fb      	ldr	r3, [r7, #12]
 386:	683a      	ldr	r2, [r7, #0]
 388:	60da      	str	r2, [r3, #12]
  return (struct tcpip_callback_msg*)msg;
 38a:	68fb      	ldr	r3, [r7, #12]
}
 38c:	4618      	mov	r0, r3
 38e:	f107 0710 	add.w	r7, r7, #16
 392:	46bd      	mov	sp, r7
 394:	bd80      	pop	{r7, pc}
 396:	bf00      	nop

00000398 <tcpip_callbackmsg_delete>:
 * Free a callback message allocated by tcpip_callbackmsg_new().
 *
 * @param msg the message to free
 */
void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
{
 398:	b580      	push	{r7, lr}
 39a:	b082      	sub	sp, #8
 39c:	af00      	add	r7, sp, #0
 39e:	6078      	str	r0, [r7, #4]
  memp_free(MEMP_TCPIP_MSG_API, msg);
 3a0:	f04f 0008 	mov.w	r0, #8
 3a4:	6879      	ldr	r1, [r7, #4]
 3a6:	f7ff fffe 	bl	0 <memp_free>
			3a6: R_ARM_THM_CALL	memp_free
}
 3aa:	f107 0708 	add.w	r7, r7, #8
 3ae:	46bd      	mov	sp, r7
 3b0:	bd80      	pop	{r7, pc}
 3b2:	bf00      	nop

000003b4 <tcpip_trycallback>:
 * @param msg pointer to the message to post
 * @return sys_mbox_trypost() return code
 */
err_t
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
 3b4:	b580      	push	{r7, lr}
 3b6:	b082      	sub	sp, #8
 3b8:	af00      	add	r7, sp, #0
 3ba:	6078      	str	r0, [r7, #4]
  if (!sys_mbox_valid(&mbox)) {
 3bc:	4809      	ldr	r0, [pc, #36]	; (3e4 <tcpip_trycallback+0x30>)
 3be:	f7ff fffe 	bl	0 <sys_mbox_valid>
			3be: R_ARM_THM_CALL	sys_mbox_valid
 3c2:	4603      	mov	r3, r0
 3c4:	2b00      	cmp	r3, #0
 3c6:	d102      	bne.n	3ce <tcpip_trycallback+0x1a>
    return ERR_VAL;
 3c8:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 3cc:	e004      	b.n	3d8 <tcpip_trycallback+0x24>
  }
  return sys_mbox_trypost(&mbox, msg);
 3ce:	4805      	ldr	r0, [pc, #20]	; (3e4 <tcpip_trycallback+0x30>)
 3d0:	6879      	ldr	r1, [r7, #4]
 3d2:	f7ff fffe 	bl	0 <sys_mbox_trypost>
			3d2: R_ARM_THM_CALL	sys_mbox_trypost
 3d6:	4603      	mov	r3, r0
 3d8:	b25b      	sxtb	r3, r3
}
 3da:	4618      	mov	r0, r3
 3dc:	f107 0708 	add.w	r7, r7, #8
 3e0:	46bd      	mov	sp, r7
 3e2:	bd80      	pop	{r7, pc}
 3e4:	00000008 	.word	0x00000008
			3e4: R_ARM_ABS32	.bss

000003e8 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 3e8:	b580      	push	{r7, lr}
 3ea:	b084      	sub	sp, #16
 3ec:	af02      	add	r7, sp, #8
 3ee:	6078      	str	r0, [r7, #4]
 3f0:	6039      	str	r1, [r7, #0]
  lwip_init();
 3f2:	f7ff fffe 	bl	0 <lwip_init>
			3f2: R_ARM_THM_CALL	lwip_init

  tcpip_init_done = initfunc;
 3f6:	4b0d      	ldr	r3, [pc, #52]	; (42c <tcpip_init+0x44>)
 3f8:	687a      	ldr	r2, [r7, #4]
 3fa:	601a      	str	r2, [r3, #0]
  tcpip_init_done_arg = arg;
 3fc:	4b0c      	ldr	r3, [pc, #48]	; (430 <tcpip_init+0x48>)
 3fe:	683a      	ldr	r2, [r7, #0]
 400:	601a      	str	r2, [r3, #0]

  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 402:	480c      	ldr	r0, [pc, #48]	; (434 <tcpip_init+0x4c>)
 404:	f04f 010a 	mov.w	r1, #10
 408:	f7ff fffe 	bl	0 <sys_mbox_new>
			408: R_ARM_THM_CALL	sys_mbox_new
  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 40c:	f04f 0301 	mov.w	r3, #1
 410:	9300      	str	r3, [sp, #0]
 412:	4809      	ldr	r0, [pc, #36]	; (438 <tcpip_init+0x50>)
 414:	4909      	ldr	r1, [pc, #36]	; (43c <tcpip_init+0x54>)
 416:	f04f 0200 	mov.w	r2, #0
 41a:	f44f 7380 	mov.w	r3, #256	; 0x100
 41e:	f7ff fffe 	bl	0 <sys_thread_new>
			41e: R_ARM_THM_CALL	sys_thread_new
}
 422:	f107 0708 	add.w	r7, r7, #8
 426:	46bd      	mov	sp, r7
 428:	bd80      	pop	{r7, pc}
 42a:	bf00      	nop
 42c:	00000000 	.word	0x00000000
			42c: R_ARM_ABS32	.bss
 430:	00000004 	.word	0x00000004
			430: R_ARM_ABS32	.bss
 434:	00000008 	.word	0x00000008
			434: R_ARM_ABS32	.bss
	...
			438: R_ARM_ABS32	.rodata
			43c: R_ARM_ABS32	tcpip_thread

00000440 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
 440:	b580      	push	{r7, lr}
 442:	b084      	sub	sp, #16
 444:	af00      	add	r7, sp, #0
 446:	6078      	str	r0, [r7, #4]
  struct pbuf *q = (struct pbuf *)p;
 448:	687b      	ldr	r3, [r7, #4]
 44a:	60fb      	str	r3, [r7, #12]
  pbuf_free(q);
 44c:	68f8      	ldr	r0, [r7, #12]
 44e:	f7ff fffe 	bl	0 <pbuf_free>
			44e: R_ARM_THM_CALL	pbuf_free
}
 452:	f107 0710 	add.w	r7, r7, #16
 456:	46bd      	mov	sp, r7
 458:	bd80      	pop	{r7, pc}
 45a:	bf00      	nop

0000045c <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
 45c:	b580      	push	{r7, lr}
 45e:	b082      	sub	sp, #8
 460:	af00      	add	r7, sp, #0
 462:	6078      	str	r0, [r7, #4]
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
 464:	4805      	ldr	r0, [pc, #20]	; (47c <pbuf_free_callback+0x20>)
 466:	6879      	ldr	r1, [r7, #4]
 468:	f04f 0200 	mov.w	r2, #0
 46c:	f7ff fffe 	bl	19c <tcpip_callback_with_block>
			46c: R_ARM_THM_CALL	tcpip_callback_with_block
 470:	4603      	mov	r3, r0
}
 472:	4618      	mov	r0, r3
 474:	f107 0708 	add.w	r7, r7, #8
 478:	46bd      	mov	sp, r7
 47a:	bd80      	pop	{r7, pc}
 47c:	00000000 	.word	0x00000000
			47c: R_ARM_ABS32	pbuf_free_int

00000480 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
 480:	b580      	push	{r7, lr}
 482:	b082      	sub	sp, #8
 484:	af00      	add	r7, sp, #0
 486:	6078      	str	r0, [r7, #4]
   return tcpip_callback_with_block(mem_free, m, 0);
 488:	4805      	ldr	r0, [pc, #20]	; (4a0 <mem_free_callback+0x20>)
 48a:	6879      	ldr	r1, [r7, #4]
 48c:	f04f 0200 	mov.w	r2, #0
 490:	f7ff fffe 	bl	19c <tcpip_callback_with_block>
			490: R_ARM_THM_CALL	tcpip_callback_with_block
 494:	4603      	mov	r3, r0
}
 496:	4618      	mov	r0, r3
 498:	f107 0708 	add.w	r7, r7, #8
 49c:	46bd      	mov	sp, r7
 49e:	bd80      	pop	{r7, pc}
 4a0:	00000000 	.word	0x00000000
			4a0: R_ARM_ABS32	mem_free
