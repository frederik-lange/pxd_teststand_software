In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libxme_lwip_core_ipv4.a:

autoip.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  19996 Jul 30 19:07 2021 autoip.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 0000002a  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000057  00000000  00000000  0000005e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000193  00000000  00000000  000000b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0000461b  00000000  00000000  00000248  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubtypes 00000012  00000000  00000000  00004863  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000ba  00000000  00000000  00004875  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002b  00000000  00000000  0000492f  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  0000495a  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 autoip.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes



icmp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  48196 Jul 30 19:07 2021 icmp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000033c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000370  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000370  2**0
                  ALLOC
  3 .debug_abbrev 000001b6  00000000  00000000  00000370  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000006e3  00000000  00000000  00000526  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000539  00000000  00000000  00000c09  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000959a  00000000  00000000  00001142  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000000e0  00000000  00000000  0000a6dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000004e  00000000  00000000  0000a7bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000155  00000000  00000000  0000a80a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000a95f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_ranges 00000018  00000000  00000000  0000a97f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000412  00000000  00000000  0000a997  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0000ada9  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000add4  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00000090  00000000  00000000  0000ae08  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 icmp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
0000026c l     F .text	000000ce icmp_send_response
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000224 icmp_input
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 ip4_addr_isbroadcast
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 inet_chksum_pbuf
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 pbuf_copy
00000000         *UND*	00000000 ip_output_if
00000000         *UND*	00000000 current_iphdr_dest
00000000         *UND*	00000000 current_iphdr_src
00000224 g     F .text	00000022 icmp_dest_unreach
00000248 g     F .text	00000022 icmp_time_exceeded
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 inet_chksum
00000000         *UND*	00000000 ip_output



Disassembly of section .text:

00000000 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
   0:	b580      	push	{r7, lr}
   2:	b08c      	sub	sp, #48	; 0x30
   4:	af04      	add	r7, sp, #16
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
   a:	687b      	ldr	r3, [r7, #4]
   c:	685b      	ldr	r3, [r3, #4]
   e:	61fb      	str	r3, [r7, #28]
  hlen = IPH_HL(iphdr) * 4;
  10:	69fb      	ldr	r3, [r7, #28]
  12:	781b      	ldrb	r3, [r3, #0]
  14:	f003 030f 	and.w	r3, r3, #15
  18:	b29b      	uxth	r3, r3
  1a:	ea4f 0383 	mov.w	r3, r3, lsl #2
  1e:	b29b      	uxth	r3, r3
  20:	82fb      	strh	r3, [r7, #22]
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  22:	8afb      	ldrh	r3, [r7, #22]
  24:	f1c3 0300 	rsb	r3, r3, #0
  28:	b29b      	uxth	r3, r3
  2a:	b29b      	uxth	r3, r3
  2c:	b21b      	sxth	r3, r3
  2e:	6878      	ldr	r0, [r7, #4]
  30:	4619      	mov	r1, r3
  32:	f7ff fffe 	bl	0 <pbuf_header>
			32: R_ARM_THM_CALL	pbuf_header
  36:	4603      	mov	r3, r0
  38:	2b00      	cmp	r3, #0
  3a:	f040 80d9 	bne.w	1f0 <icmp_input+0x1f0>
  3e:	687b      	ldr	r3, [r7, #4]
  40:	891b      	ldrh	r3, [r3, #8]
  42:	2b03      	cmp	r3, #3
  44:	f240 80d4 	bls.w	1f0 <icmp_input+0x1f0>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  48:	687b      	ldr	r3, [r7, #4]
  4a:	685b      	ldr	r3, [r3, #4]
  4c:	781b      	ldrb	r3, [r3, #0]
  4e:	757b      	strb	r3, [r7, #21]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  50:	7d7b      	ldrb	r3, [r7, #21]
  52:	2b00      	cmp	r3, #0
  54:	f000 80c4 	beq.w	1e0 <icmp_input+0x1e0>
  58:	2b08      	cmp	r3, #8
  5a:	f040 80c4 	bne.w	1e6 <icmp_input+0x1e6>
       (as obviously, an echo request has been sent, too). */
    break; 
  case ICMP_ECHO:
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
  5e:	f04f 0301 	mov.w	r3, #1
  62:	61bb      	str	r3, [r7, #24]
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
  64:	4b6d      	ldr	r3, [pc, #436]	; (21c <icmp_input+0x21c>)
  66:	681b      	ldr	r3, [r3, #0]
  68:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  6c:	2be0      	cmp	r3, #224	; 0xe0
  6e:	d102      	bne.n	76 <icmp_input+0x76>
        accepted = 0;
  70:	f04f 0300 	mov.w	r3, #0
  74:	61bb      	str	r3, [r7, #24]
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
  76:	4b69      	ldr	r3, [pc, #420]	; (21c <icmp_input+0x21c>)
  78:	681b      	ldr	r3, [r3, #0]
  7a:	4618      	mov	r0, r3
  7c:	6839      	ldr	r1, [r7, #0]
  7e:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			7e: R_ARM_THM_CALL	ip4_addr_isbroadcast
  82:	4603      	mov	r3, r0
  84:	2b00      	cmp	r3, #0
  86:	d002      	beq.n	8e <icmp_input+0x8e>
        accepted = 0;
  88:	f04f 0300 	mov.w	r3, #0
  8c:	61bb      	str	r3, [r7, #24]
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
  8e:	69bb      	ldr	r3, [r7, #24]
  90:	2b00      	cmp	r3, #0
  92:	d103      	bne.n	9c <icmp_input+0x9c>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
        ICMP_STATS_INC(icmp.err);
        pbuf_free(p);
  94:	6878      	ldr	r0, [r7, #4]
  96:	f7ff fffe 	bl	0 <pbuf_free>
			96: R_ARM_THM_CALL	pbuf_free
        return;
  9a:	e0ba      	b.n	212 <icmp_input+0x212>
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  9c:	687b      	ldr	r3, [r7, #4]
  9e:	891b      	ldrh	r3, [r3, #8]
  a0:	2b07      	cmp	r3, #7
  a2:	f240 80a4 	bls.w	1ee <icmp_input+0x1ee>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  a6:	6878      	ldr	r0, [r7, #4]
  a8:	f7ff fffe 	bl	0 <inet_chksum_pbuf>
			a8: R_ARM_THM_CALL	inet_chksum_pbuf
  ac:	4603      	mov	r3, r0
  ae:	2b00      	cmp	r3, #0
  b0:	d003      	beq.n	ba <icmp_input+0xba>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  b2:	6878      	ldr	r0, [r7, #4]
  b4:	f7ff fffe 	bl	0 <pbuf_free>
			b4: R_ARM_THM_CALL	pbuf_free
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  b8:	e0ab      	b.n	212 <icmp_input+0x212>
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  ba:	6878      	ldr	r0, [r7, #4]
  bc:	f04f 0122 	mov.w	r1, #34	; 0x22
  c0:	f7ff fffe 	bl	0 <pbuf_header>
			c0: R_ARM_THM_CALL	pbuf_header
  c4:	4603      	mov	r3, r0
  c6:	2b00      	cmp	r3, #0
  c8:	d034      	beq.n	134 <icmp_input+0x134>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  ca:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
  ce:	6878      	ldr	r0, [r7, #4]
  d0:	4619      	mov	r1, r3
  d2:	f7ff fffe 	bl	0 <pbuf_header>
			d2: R_ARM_THM_CALL	pbuf_header
  d6:	4603      	mov	r3, r0
  d8:	2b00      	cmp	r3, #0
  da:	f040 808d 	bne.w	1f8 <icmp_input+0x1f8>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  de:	687b      	ldr	r3, [r7, #4]
  e0:	891b      	ldrh	r3, [r3, #8]
  e2:	f04f 0002 	mov.w	r0, #2
  e6:	4619      	mov	r1, r3
  e8:	f04f 0200 	mov.w	r2, #0
  ec:	f7ff fffe 	bl	0 <pbuf_alloc>
			ec: R_ARM_THM_CALL	pbuf_alloc
  f0:	6138      	str	r0, [r7, #16]
      if (r == NULL) {
  f2:	693b      	ldr	r3, [r7, #16]
  f4:	2b00      	cmp	r3, #0
  f6:	f000 8081 	beq.w	1fc <icmp_input+0x1fc>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  fa:	6938      	ldr	r0, [r7, #16]
  fc:	6879      	ldr	r1, [r7, #4]
  fe:	f7ff fffe 	bl	0 <pbuf_copy>
			fe: R_ARM_THM_CALL	pbuf_copy
 102:	4603      	mov	r3, r0
 104:	2b00      	cmp	r3, #0
 106:	d17b      	bne.n	200 <icmp_input+0x200>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
 108:	693b      	ldr	r3, [r7, #16]
 10a:	685b      	ldr	r3, [r3, #4]
 10c:	61fb      	str	r3, [r7, #28]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 10e:	8afb      	ldrh	r3, [r7, #22]
 110:	f1c3 0300 	rsb	r3, r3, #0
 114:	b29b      	uxth	r3, r3
 116:	b29b      	uxth	r3, r3
 118:	b21b      	sxth	r3, r3
 11a:	6938      	ldr	r0, [r7, #16]
 11c:	4619      	mov	r1, r3
 11e:	f7ff fffe 	bl	0 <pbuf_header>
			11e: R_ARM_THM_CALL	pbuf_header
 122:	4603      	mov	r3, r0
 124:	2b00      	cmp	r3, #0
 126:	d16d      	bne.n	204 <icmp_input+0x204>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 128:	6878      	ldr	r0, [r7, #4]
 12a:	f7ff fffe 	bl	0 <pbuf_free>
			12a: R_ARM_THM_CALL	pbuf_free
      /* we now have an identical copy of p that has room for link headers */
      p = r;
 12e:	693b      	ldr	r3, [r7, #16]
 130:	607b      	str	r3, [r7, #4]
 132:	e007      	b.n	144 <icmp_input+0x144>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 134:	6878      	ldr	r0, [r7, #4]
 136:	f06f 0121 	mvn.w	r1, #33	; 0x21
 13a:	f7ff fffe 	bl	0 <pbuf_header>
			13a: R_ARM_THM_CALL	pbuf_header
 13e:	4603      	mov	r3, r0
 140:	2b00      	cmp	r3, #0
 142:	d161      	bne.n	208 <icmp_input+0x208>
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
 144:	687b      	ldr	r3, [r7, #4]
 146:	685b      	ldr	r3, [r3, #4]
 148:	60fb      	str	r3, [r7, #12]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 14a:	4b34      	ldr	r3, [pc, #208]	; (21c <icmp_input+0x21c>)
 14c:	681a      	ldr	r2, [r3, #0]
 14e:	69fb      	ldr	r3, [r7, #28]
 150:	60da      	str	r2, [r3, #12]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 152:	4b33      	ldr	r3, [pc, #204]	; (220 <icmp_input+0x220>)
 154:	681a      	ldr	r2, [r3, #0]
 156:	69fb      	ldr	r3, [r7, #28]
 158:	611a      	str	r2, [r3, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 15a:	68fb      	ldr	r3, [r7, #12]
 15c:	f04f 0200 	mov.w	r2, #0
 160:	701a      	strb	r2, [r3, #0]
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 162:	68fb      	ldr	r3, [r7, #12]
 164:	885b      	ldrh	r3, [r3, #2]
 166:	b29a      	uxth	r2, r3
 168:	f64f 73f6 	movw	r3, #65526	; 0xfff6
 16c:	429a      	cmp	r2, r3
 16e:	d908      	bls.n	182 <icmp_input+0x182>
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 170:	68fb      	ldr	r3, [r7, #12]
 172:	885b      	ldrh	r3, [r3, #2]
 174:	b29b      	uxth	r3, r3
 176:	f103 0309 	add.w	r3, r3, #9
 17a:	b29a      	uxth	r2, r3
 17c:	68fb      	ldr	r3, [r7, #12]
 17e:	805a      	strh	r2, [r3, #2]
 180:	e007      	b.n	192 <icmp_input+0x192>
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 182:	68fb      	ldr	r3, [r7, #12]
 184:	885b      	ldrh	r3, [r3, #2]
 186:	b29b      	uxth	r3, r3
 188:	f103 0308 	add.w	r3, r3, #8
 18c:	b29a      	uxth	r2, r3
 18e:	68fb      	ldr	r3, [r7, #12]
 190:	805a      	strh	r2, [r3, #2]
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 192:	69fb      	ldr	r3, [r7, #28]
 194:	f04f 02ff 	mov.w	r2, #255	; 0xff
 198:	721a      	strb	r2, [r3, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 19a:	69fb      	ldr	r3, [r7, #28]
 19c:	f04f 0200 	mov.w	r2, #0
 1a0:	729a      	strb	r2, [r3, #10]
 1a2:	f04f 0200 	mov.w	r2, #0
 1a6:	72da      	strb	r2, [r3, #11]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 1a8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 1ac:	6878      	ldr	r0, [r7, #4]
 1ae:	4619      	mov	r1, r3
 1b0:	f7ff fffe 	bl	0 <pbuf_header>
			1b0: R_ARM_THM_CALL	pbuf_header
 1b4:	4603      	mov	r3, r0
 1b6:	2b00      	cmp	r3, #0
 1b8:	d114      	bne.n	1e4 <icmp_input+0x1e4>
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 1ba:	f04f 0300 	mov.w	r3, #0
 1be:	9300      	str	r3, [sp, #0]
 1c0:	f04f 0301 	mov.w	r3, #1
 1c4:	9301      	str	r3, [sp, #4]
 1c6:	683b      	ldr	r3, [r7, #0]
 1c8:	9302      	str	r3, [sp, #8]
 1ca:	6878      	ldr	r0, [r7, #4]
 1cc:	4913      	ldr	r1, [pc, #76]	; (21c <icmp_input+0x21c>)
 1ce:	f04f 0200 	mov.w	r2, #0
 1d2:	f04f 03ff 	mov.w	r3, #255	; 0xff
 1d6:	f7ff fffe 	bl	0 <ip_output_if>
			1d6: R_ARM_THM_CALL	ip_output_if
 1da:	4603      	mov	r3, r0
 1dc:	72fb      	strb	r3, [r7, #11]
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 1de:	e002      	b.n	1e6 <icmp_input+0x1e6>
#endif /* LWIP_DEBUG */
  switch (type) {
  case ICMP_ER:
    /* This is OK, echo reply might have been parsed by a raw PCB
       (as obviously, an echo request has been sent, too). */
    break; 
 1e0:	bf00      	nop
 1e2:	e000      	b.n	1e6 <icmp_input+0x1e6>
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
 1e4:	bf00      	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
 1e6:	6878      	ldr	r0, [r7, #4]
 1e8:	f7ff fffe 	bl	0 <pbuf_free>
			1e8: R_ARM_THM_CALL	pbuf_free
  return;
 1ec:	e011      	b.n	212 <icmp_input+0x212>
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
 1ee:	bf00      	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
 1f0:	6878      	ldr	r0, [r7, #4]
 1f2:	f7ff fffe 	bl	0 <pbuf_free>
			1f2: R_ARM_THM_CALL	pbuf_free
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
 1f6:	e00c      	b.n	212 <icmp_input+0x212>
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
        goto memerr;
 1f8:	bf00      	nop
 1fa:	e006      	b.n	20a <icmp_input+0x20a>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
 1fc:	bf00      	nop
 1fe:	e004      	b.n	20a <icmp_input+0x20a>
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
 200:	bf00      	nop
 202:	e002      	b.n	20a <icmp_input+0x20a>
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 204:	bf00      	nop
 206:	e000      	b.n	20a <icmp_input+0x20a>
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
 208:	bf00      	nop
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 20a:	6878      	ldr	r0, [r7, #4]
 20c:	f7ff fffe 	bl	0 <pbuf_free>
			20c: R_ARM_THM_CALL	pbuf_free
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
 210:	bf00      	nop
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 212:	f107 0720 	add.w	r7, r7, #32
 216:	46bd      	mov	sp, r7
 218:	bd80      	pop	{r7, pc}
 21a:	bf00      	nop
	...
			21c: R_ARM_ABS32	current_iphdr_dest
			220: R_ARM_ABS32	current_iphdr_src

00000224 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
 224:	b580      	push	{r7, lr}
 226:	b082      	sub	sp, #8
 228:	af00      	add	r7, sp, #0
 22a:	6078      	str	r0, [r7, #4]
 22c:	460b      	mov	r3, r1
 22e:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_DUR, t);
 230:	78fb      	ldrb	r3, [r7, #3]
 232:	6878      	ldr	r0, [r7, #4]
 234:	f04f 0103 	mov.w	r1, #3
 238:	461a      	mov	r2, r3
 23a:	f000 f817 	bl	26c <icmp_send_response>
}
 23e:	f107 0708 	add.w	r7, r7, #8
 242:	46bd      	mov	sp, r7
 244:	bd80      	pop	{r7, pc}
 246:	bf00      	nop

00000248 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
 248:	b580      	push	{r7, lr}
 24a:	b082      	sub	sp, #8
 24c:	af00      	add	r7, sp, #0
 24e:	6078      	str	r0, [r7, #4]
 250:	460b      	mov	r3, r1
 252:	70fb      	strb	r3, [r7, #3]
  icmp_send_response(p, ICMP_TE, t);
 254:	78fb      	ldrb	r3, [r7, #3]
 256:	6878      	ldr	r0, [r7, #4]
 258:	f04f 010b 	mov.w	r1, #11
 25c:	461a      	mov	r2, r3
 25e:	f000 f805 	bl	26c <icmp_send_response>
}
 262:	f107 0708 	add.w	r7, r7, #8
 266:	46bd      	mov	sp, r7
 268:	bd80      	pop	{r7, pc}
 26a:	bf00      	nop

0000026c <icmp_send_response>:
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
{
 26c:	b580      	push	{r7, lr}
 26e:	b088      	sub	sp, #32
 270:	af02      	add	r7, sp, #8
 272:	6078      	str	r0, [r7, #4]
 274:	4613      	mov	r3, r2
 276:	460a      	mov	r2, r1
 278:	70fa      	strb	r2, [r7, #3]
 27a:	70bb      	strb	r3, [r7, #2]
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 27c:	f04f 0001 	mov.w	r0, #1
 280:	f04f 0124 	mov.w	r1, #36	; 0x24
 284:	f04f 0200 	mov.w	r2, #0
 288:	f7ff fffe 	bl	0 <pbuf_alloc>
			288: R_ARM_THM_CALL	pbuf_alloc
 28c:	6178      	str	r0, [r7, #20]
                 PBUF_RAM);
  if (q == NULL) {
 28e:	697b      	ldr	r3, [r7, #20]
 290:	2b00      	cmp	r3, #0
 292:	d04d      	beq.n	330 <icmp_send_response+0xc4>
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 294:	687b      	ldr	r3, [r7, #4]
 296:	685b      	ldr	r3, [r3, #4]
 298:	613b      	str	r3, [r7, #16]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 29a:	697b      	ldr	r3, [r7, #20]
 29c:	685b      	ldr	r3, [r3, #4]
 29e:	60fb      	str	r3, [r7, #12]
  icmphdr->type = type;
 2a0:	68fb      	ldr	r3, [r7, #12]
 2a2:	78fa      	ldrb	r2, [r7, #3]
 2a4:	701a      	strb	r2, [r3, #0]
  icmphdr->code = code;
 2a6:	68fb      	ldr	r3, [r7, #12]
 2a8:	78ba      	ldrb	r2, [r7, #2]
 2aa:	705a      	strb	r2, [r3, #1]
  icmphdr->id = 0;
 2ac:	68fb      	ldr	r3, [r7, #12]
 2ae:	f04f 0200 	mov.w	r2, #0
 2b2:	711a      	strb	r2, [r3, #4]
 2b4:	f04f 0200 	mov.w	r2, #0
 2b8:	715a      	strb	r2, [r3, #5]
  icmphdr->seqno = 0;
 2ba:	68fb      	ldr	r3, [r7, #12]
 2bc:	f04f 0200 	mov.w	r2, #0
 2c0:	719a      	strb	r2, [r3, #6]
 2c2:	f04f 0200 	mov.w	r2, #0
 2c6:	71da      	strb	r2, [r3, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 2c8:	697b      	ldr	r3, [r7, #20]
 2ca:	685b      	ldr	r3, [r3, #4]
 2cc:	f103 0208 	add.w	r2, r3, #8
 2d0:	687b      	ldr	r3, [r7, #4]
 2d2:	685b      	ldr	r3, [r3, #4]
 2d4:	4610      	mov	r0, r2
 2d6:	4619      	mov	r1, r3
 2d8:	f04f 021c 	mov.w	r2, #28
 2dc:	f7ff fffe 	bl	0 <memcpy>
			2dc: R_ARM_THM_CALL	memcpy
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 2e0:	68fb      	ldr	r3, [r7, #12]
 2e2:	f04f 0200 	mov.w	r2, #0
 2e6:	709a      	strb	r2, [r3, #2]
 2e8:	f04f 0200 	mov.w	r2, #0
 2ec:	70da      	strb	r2, [r3, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 2ee:	697b      	ldr	r3, [r7, #20]
 2f0:	895b      	ldrh	r3, [r3, #10]
 2f2:	68f8      	ldr	r0, [r7, #12]
 2f4:	4619      	mov	r1, r3
 2f6:	f7ff fffe 	bl	0 <inet_chksum>
			2f6: R_ARM_THM_CALL	inet_chksum
 2fa:	4603      	mov	r3, r0
 2fc:	461a      	mov	r2, r3
 2fe:	68fb      	ldr	r3, [r7, #12]
 300:	805a      	strh	r2, [r3, #2]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 302:	693b      	ldr	r3, [r7, #16]
 304:	68db      	ldr	r3, [r3, #12]
 306:	60bb      	str	r3, [r7, #8]
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 308:	f107 0308 	add.w	r3, r7, #8
 30c:	f04f 0200 	mov.w	r2, #0
 310:	9200      	str	r2, [sp, #0]
 312:	f04f 0201 	mov.w	r2, #1
 316:	9201      	str	r2, [sp, #4]
 318:	6978      	ldr	r0, [r7, #20]
 31a:	f04f 0100 	mov.w	r1, #0
 31e:	461a      	mov	r2, r3
 320:	f04f 03ff 	mov.w	r3, #255	; 0xff
 324:	f7ff fffe 	bl	0 <ip_output>
			324: R_ARM_THM_CALL	ip_output
  pbuf_free(q);
 328:	6978      	ldr	r0, [r7, #20]
 32a:	f7ff fffe 	bl	0 <pbuf_free>
			32a: R_ARM_THM_CALL	pbuf_free
 32e:	e000      	b.n	332 <icmp_send_response+0xc6>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
 330:	bf00      	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
 332:	f107 0718 	add.w	r7, r7, #24
 336:	46bd      	mov	sp, r7
 338:	bd80      	pop	{r7, pc}
 33a:	bf00      	nop

igmp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  64844 Jul 30 19:07 2021 igmp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000830  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000864  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000c  00000000  00000000  00000864  2**2
                  ALLOC
  3 .debug_abbrev 000001c5  00000000  00000000  00000864  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000ad7  00000000  00000000  00000a29  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000085b  00000000  00000000  00001500  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000be23  00000000  00000000  00001d5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000374  00000000  00000000  0000db7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000ae  00000000  00000000  0000def2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000013c  00000000  00000000  0000dfa0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000e0dc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000005b3  00000000  00000000  0000e0fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000e6af  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000e6da  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000204  00000000  00000000  0000e70c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 igmp_group_list
00000004 l       .bss	00000000 allsystems
00000008 l       .bss	00000000 allrouters
0000019c l     F .text	00000090 igmp_lookup_group
000006b4 l     F .text	0000004a igmp_delaying_member
0000022c l     F .text	00000074 igmp_remove_group
00000750 l     F .text	000000e0 igmp_send
00000670 l     F .text	00000042 igmp_start_timer
0000064c l     F .text	00000022 igmp_timeout
00000700 l     F .text	00000050 igmp_ip_output_if
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000028 igmp_init
00000028 g     F .text	00000060 igmp_start
00000088 g     F .text	0000008c igmp_stop
00000000         *UND*	00000000 memp_free
00000114 g     F .text	0000003c igmp_report_groups
00000150 g     F .text	0000004c igmp_lookfor_group
00000000         *UND*	00000000 memp_malloc
000002a0 g     F .text	00000188 igmp_input
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 inet_chksum
00000428 g     F .text	000000f4 igmp_joingroup
00000000         *UND*	00000000 netif_list
0000051c g     F .text	000000e4 igmp_leavegroup
00000600 g     F .text	0000004c igmp_tmr
00000000         *UND*	00000000 lwip_rand_arch
00000000         *UND*	00000000 ip_output_if_opt
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 ip_addr_any



Disassembly of section .text:

00000000 <igmp_init>:
/**
 * Initialize the IGMP module
 */
void
igmp_init(void)
{
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_init: initializing\n"));

  IP4_ADDR(&allsystems, 224, 0, 0, 1);
   4:	4b04      	ldr	r3, [pc, #16]	; (18 <igmp_init+0x18>)
   6:	4a05      	ldr	r2, [pc, #20]	; (1c <igmp_init+0x1c>)
   8:	601a      	str	r2, [r3, #0]
  IP4_ADDR(&allrouters, 224, 0, 0, 2);
   a:	4b05      	ldr	r3, [pc, #20]	; (20 <igmp_init+0x20>)
   c:	4a05      	ldr	r2, [pc, #20]	; (24 <igmp_init+0x24>)
   e:	601a      	str	r2, [r3, #0]
}
  10:	46bd      	mov	sp, r7
  12:	bc80      	pop	{r7}
  14:	4770      	bx	lr
  16:	bf00      	nop
  18:	00000004 	.word	0x00000004
			18: R_ARM_ABS32	.bss
  1c:	010000e0 	.word	0x010000e0
  20:	00000008 	.word	0x00000008
			20: R_ARM_ABS32	.bss
  24:	020000e0 	.word	0x020000e0

00000028 <igmp_start>:
 *
 * @param netif network interface on which start IGMP processing
 */
err_t
igmp_start(struct netif *netif)
{
  28:	b580      	push	{r7, lr}
  2a:	b084      	sub	sp, #16
  2c:	af00      	add	r7, sp, #0
  2e:	6078      	str	r0, [r7, #4]
  struct igmp_group* group;

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: starting IGMP processing on if %p\n", netif));

  group = igmp_lookup_group(netif, &allsystems);
  30:	6878      	ldr	r0, [r7, #4]
  32:	4914      	ldr	r1, [pc, #80]	; (84 <igmp_start+0x5c>)
  34:	f000 f8b2 	bl	19c <igmp_lookup_group>
  38:	60f8      	str	r0, [r7, #12]

  if (group != NULL) {
  3a:	68fb      	ldr	r3, [r7, #12]
  3c:	2b00      	cmp	r3, #0
  3e:	d018      	beq.n	72 <igmp_start+0x4a>
    group->group_state = IGMP_GROUP_IDLE_MEMBER;
  40:	68fb      	ldr	r3, [r7, #12]
  42:	f04f 0202 	mov.w	r2, #2
  46:	735a      	strb	r2, [r3, #13]
    group->use++;
  48:	68fb      	ldr	r3, [r7, #12]
  4a:	7c1b      	ldrb	r3, [r3, #16]
  4c:	f103 0301 	add.w	r3, r3, #1
  50:	b2da      	uxtb	r2, r3
  52:	68fb      	ldr	r3, [r7, #12]
  54:	741a      	strb	r2, [r3, #16]

    /* Allow the igmp messages at the MAC level */
    if (netif->igmp_mac_filter != NULL) {
  56:	687b      	ldr	r3, [r7, #4]
  58:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  5a:	2b00      	cmp	r3, #0
  5c:	d006      	beq.n	6c <igmp_start+0x44>
      LWIP_DEBUGF(IGMP_DEBUG, ("igmp_start: igmp_mac_filter(ADD "));
      ip_addr_debug_print(IGMP_DEBUG, &allsystems);
      LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
      netif->igmp_mac_filter(netif, &allsystems, IGMP_ADD_MAC_FILTER);
  5e:	687b      	ldr	r3, [r7, #4]
  60:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  62:	6878      	ldr	r0, [r7, #4]
  64:	4907      	ldr	r1, [pc, #28]	; (84 <igmp_start+0x5c>)
  66:	f04f 0201 	mov.w	r2, #1
  6a:	4798      	blx	r3
    }

    return ERR_OK;
  6c:	f04f 0300 	mov.w	r3, #0
  70:	e001      	b.n	76 <igmp_start+0x4e>
  }

  return ERR_MEM;
  72:	f04f 03ff 	mov.w	r3, #255	; 0xff
  76:	b25b      	sxtb	r3, r3
}
  78:	4618      	mov	r0, r3
  7a:	f107 0710 	add.w	r7, r7, #16
  7e:	46bd      	mov	sp, r7
  80:	bd80      	pop	{r7, pc}
  82:	bf00      	nop
  84:	00000004 	.word	0x00000004
			84: R_ARM_ABS32	.bss

00000088 <igmp_stop>:
 *
 * @param netif network interface on which stop IGMP processing
 */
err_t
igmp_stop(struct netif *netif)
{
  88:	b580      	push	{r7, lr}
  8a:	b086      	sub	sp, #24
  8c:	af00      	add	r7, sp, #0
  8e:	6078      	str	r0, [r7, #4]
  struct igmp_group *group = igmp_group_list;
  90:	4b1f      	ldr	r3, [pc, #124]	; (110 <igmp_stop+0x88>)
  92:	681b      	ldr	r3, [r3, #0]
  94:	617b      	str	r3, [r7, #20]
  struct igmp_group *prev  = NULL;
  96:	f04f 0300 	mov.w	r3, #0
  9a:	613b      	str	r3, [r7, #16]
  struct igmp_group *next;

  /* look for groups joined on this interface further down the list */
  while (group != NULL) {
  9c:	e02d      	b.n	fa <igmp_stop+0x72>
    next = group->next;
  9e:	697b      	ldr	r3, [r7, #20]
  a0:	681b      	ldr	r3, [r3, #0]
  a2:	60fb      	str	r3, [r7, #12]
    /* is it a group joined on this interface? */
    if (group->netif == netif) {
  a4:	697b      	ldr	r3, [r7, #20]
  a6:	685a      	ldr	r2, [r3, #4]
  a8:	687b      	ldr	r3, [r7, #4]
  aa:	429a      	cmp	r2, r3
  ac:	d121      	bne.n	f2 <igmp_stop+0x6a>
      /* is it the first group of the list? */
      if (group == igmp_group_list) {
  ae:	4b18      	ldr	r3, [pc, #96]	; (110 <igmp_stop+0x88>)
  b0:	681b      	ldr	r3, [r3, #0]
  b2:	697a      	ldr	r2, [r7, #20]
  b4:	429a      	cmp	r2, r3
  b6:	d102      	bne.n	be <igmp_stop+0x36>
        igmp_group_list = next;
  b8:	4b15      	ldr	r3, [pc, #84]	; (110 <igmp_stop+0x88>)
  ba:	68fa      	ldr	r2, [r7, #12]
  bc:	601a      	str	r2, [r3, #0]
      }
      /* is there a "previous" group defined? */
      if (prev != NULL) {
  be:	693b      	ldr	r3, [r7, #16]
  c0:	2b00      	cmp	r3, #0
  c2:	d002      	beq.n	ca <igmp_stop+0x42>
        prev->next = next;
  c4:	693b      	ldr	r3, [r7, #16]
  c6:	68fa      	ldr	r2, [r7, #12]
  c8:	601a      	str	r2, [r3, #0]
      }
      /* disable the group at the MAC level */
      if (netif->igmp_mac_filter != NULL) {
  ca:	687b      	ldr	r3, [r7, #4]
  cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  ce:	2b00      	cmp	r3, #0
  d0:	d009      	beq.n	e6 <igmp_stop+0x5e>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_stop: igmp_mac_filter(DEL "));
        ip_addr_debug_print(IGMP_DEBUG, &group->group_address);
        LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
        netif->igmp_mac_filter(netif, &(group->group_address), IGMP_DEL_MAC_FILTER);
  d2:	687b      	ldr	r3, [r7, #4]
  d4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  d6:	697a      	ldr	r2, [r7, #20]
  d8:	f102 0208 	add.w	r2, r2, #8
  dc:	6878      	ldr	r0, [r7, #4]
  de:	4611      	mov	r1, r2
  e0:	f04f 0200 	mov.w	r2, #0
  e4:	4798      	blx	r3
      }
      /* free group */
      memp_free(MEMP_IGMP_GROUP, group);
  e6:	f04f 000b 	mov.w	r0, #11
  ea:	6979      	ldr	r1, [r7, #20]
  ec:	f7ff fffe 	bl	0 <memp_free>
			ec: R_ARM_THM_CALL	memp_free
  f0:	e001      	b.n	f6 <igmp_stop+0x6e>
    } else {
      /* change the "previous" */
      prev = group;
  f2:	697b      	ldr	r3, [r7, #20]
  f4:	613b      	str	r3, [r7, #16]
    }
    /* move to "next" */
    group = next;
  f6:	68fb      	ldr	r3, [r7, #12]
  f8:	617b      	str	r3, [r7, #20]
  struct igmp_group *group = igmp_group_list;
  struct igmp_group *prev  = NULL;
  struct igmp_group *next;

  /* look for groups joined on this interface further down the list */
  while (group != NULL) {
  fa:	697b      	ldr	r3, [r7, #20]
  fc:	2b00      	cmp	r3, #0
  fe:	d1ce      	bne.n	9e <igmp_stop+0x16>
      prev = group;
    }
    /* move to "next" */
    group = next;
  }
  return ERR_OK;
 100:	f04f 0300 	mov.w	r3, #0
 104:	b25b      	sxtb	r3, r3
}
 106:	4618      	mov	r0, r3
 108:	f107 0718 	add.w	r7, r7, #24
 10c:	46bd      	mov	sp, r7
 10e:	bd80      	pop	{r7, pc}
 110:	00000000 	.word	0x00000000
			110: R_ARM_ABS32	.bss

00000114 <igmp_report_groups>:
 *
 * @param netif network interface on which report IGMP memberships
 */
void
igmp_report_groups(struct netif *netif)
{
 114:	b580      	push	{r7, lr}
 116:	b084      	sub	sp, #16
 118:	af00      	add	r7, sp, #0
 11a:	6078      	str	r0, [r7, #4]
  struct igmp_group *group = igmp_group_list;
 11c:	4b0b      	ldr	r3, [pc, #44]	; (14c <igmp_report_groups+0x38>)
 11e:	681b      	ldr	r3, [r3, #0]
 120:	60fb      	str	r3, [r7, #12]

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_report_groups: sending IGMP reports on if %p\n", netif));

  while (group != NULL) {
 122:	e00c      	b.n	13e <igmp_report_groups+0x2a>
    if (group->netif == netif) {
 124:	68fb      	ldr	r3, [r7, #12]
 126:	685a      	ldr	r2, [r3, #4]
 128:	687b      	ldr	r3, [r7, #4]
 12a:	429a      	cmp	r2, r3
 12c:	d104      	bne.n	138 <igmp_report_groups+0x24>
      igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 12e:	68f8      	ldr	r0, [r7, #12]
 130:	f04f 0105 	mov.w	r1, #5
 134:	f000 fabe 	bl	6b4 <igmp_delaying_member>
    }
    group = group->next;
 138:	68fb      	ldr	r3, [r7, #12]
 13a:	681b      	ldr	r3, [r3, #0]
 13c:	60fb      	str	r3, [r7, #12]
{
  struct igmp_group *group = igmp_group_list;

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_report_groups: sending IGMP reports on if %p\n", netif));

  while (group != NULL) {
 13e:	68fb      	ldr	r3, [r7, #12]
 140:	2b00      	cmp	r3, #0
 142:	d1ef      	bne.n	124 <igmp_report_groups+0x10>
    if (group->netif == netif) {
      igmp_delaying_member(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
    }
    group = group->next;
  }
}
 144:	f107 0710 	add.w	r7, r7, #16
 148:	46bd      	mov	sp, r7
 14a:	bd80      	pop	{r7, pc}
 14c:	00000000 	.word	0x00000000
			14c: R_ARM_ABS32	.bss

00000150 <igmp_lookfor_group>:
 * @return a struct igmp_group* if the group has been found,
 *         NULL if the group wasn't found.
 */
struct igmp_group *
igmp_lookfor_group(struct netif *ifp, ip_addr_t *addr)
{
 150:	b480      	push	{r7}
 152:	b085      	sub	sp, #20
 154:	af00      	add	r7, sp, #0
 156:	6078      	str	r0, [r7, #4]
 158:	6039      	str	r1, [r7, #0]
  struct igmp_group *group = igmp_group_list;
 15a:	4b0f      	ldr	r3, [pc, #60]	; (198 <igmp_lookfor_group+0x48>)
 15c:	681b      	ldr	r3, [r3, #0]
 15e:	60fb      	str	r3, [r7, #12]

  while (group != NULL) {
 160:	e00f      	b.n	182 <igmp_lookfor_group+0x32>
    if ((group->netif == ifp) && (ip_addr_cmp(&(group->group_address), addr))) {
 162:	68fb      	ldr	r3, [r7, #12]
 164:	685a      	ldr	r2, [r3, #4]
 166:	687b      	ldr	r3, [r7, #4]
 168:	429a      	cmp	r2, r3
 16a:	d107      	bne.n	17c <igmp_lookfor_group+0x2c>
 16c:	68fb      	ldr	r3, [r7, #12]
 16e:	689a      	ldr	r2, [r3, #8]
 170:	683b      	ldr	r3, [r7, #0]
 172:	681b      	ldr	r3, [r3, #0]
 174:	429a      	cmp	r2, r3
 176:	d101      	bne.n	17c <igmp_lookfor_group+0x2c>
      return group;
 178:	68fb      	ldr	r3, [r7, #12]
 17a:	e007      	b.n	18c <igmp_lookfor_group+0x3c>
    }
    group = group->next;
 17c:	68fb      	ldr	r3, [r7, #12]
 17e:	681b      	ldr	r3, [r3, #0]
 180:	60fb      	str	r3, [r7, #12]
struct igmp_group *
igmp_lookfor_group(struct netif *ifp, ip_addr_t *addr)
{
  struct igmp_group *group = igmp_group_list;

  while (group != NULL) {
 182:	68fb      	ldr	r3, [r7, #12]
 184:	2b00      	cmp	r3, #0
 186:	d1ec      	bne.n	162 <igmp_lookfor_group+0x12>
  }

  /* to be clearer, we return NULL here instead of
   * 'group' (which is also NULL at this point).
   */
  return NULL;
 188:	f04f 0300 	mov.w	r3, #0
}
 18c:	4618      	mov	r0, r3
 18e:	f107 0714 	add.w	r7, r7, #20
 192:	46bd      	mov	sp, r7
 194:	bc80      	pop	{r7}
 196:	4770      	bx	lr
 198:	00000000 	.word	0x00000000
			198: R_ARM_ABS32	.bss

0000019c <igmp_lookup_group>:
 * @return a struct igmp_group*,
 *         NULL on memory error.
 */
struct igmp_group *
igmp_lookup_group(struct netif *ifp, ip_addr_t *addr)
{
 19c:	b580      	push	{r7, lr}
 19e:	b084      	sub	sp, #16
 1a0:	af00      	add	r7, sp, #0
 1a2:	6078      	str	r0, [r7, #4]
 1a4:	6039      	str	r1, [r7, #0]
  struct igmp_group *group = igmp_group_list;
 1a6:	4b20      	ldr	r3, [pc, #128]	; (228 <igmp_lookup_group+0x8c>)
 1a8:	681b      	ldr	r3, [r3, #0]
 1aa:	60fb      	str	r3, [r7, #12]
  
  /* Search if the group already exists */
  group = igmp_lookfor_group(ifp, addr);
 1ac:	6878      	ldr	r0, [r7, #4]
 1ae:	6839      	ldr	r1, [r7, #0]
 1b0:	f7ff fffe 	bl	150 <igmp_lookfor_group>
			1b0: R_ARM_THM_CALL	igmp_lookfor_group
 1b4:	60f8      	str	r0, [r7, #12]
  if (group != NULL) {
 1b6:	68fb      	ldr	r3, [r7, #12]
 1b8:	2b00      	cmp	r3, #0
 1ba:	d001      	beq.n	1c0 <igmp_lookup_group+0x24>
    /* Group already exists. */
    return group;
 1bc:	68fb      	ldr	r3, [r7, #12]
 1be:	e02d      	b.n	21c <igmp_lookup_group+0x80>
  }

  /* Group doesn't exist yet, create a new one */
  group = (struct igmp_group *)memp_malloc(MEMP_IGMP_GROUP);
 1c0:	f04f 000b 	mov.w	r0, #11
 1c4:	f7ff fffe 	bl	0 <memp_malloc>
			1c4: R_ARM_THM_CALL	memp_malloc
 1c8:	4603      	mov	r3, r0
 1ca:	60fb      	str	r3, [r7, #12]
  if (group != NULL) {
 1cc:	68fb      	ldr	r3, [r7, #12]
 1ce:	2b00      	cmp	r3, #0
 1d0:	d023      	beq.n	21a <igmp_lookup_group+0x7e>
    group->netif              = ifp;
 1d2:	68fb      	ldr	r3, [r7, #12]
 1d4:	687a      	ldr	r2, [r7, #4]
 1d6:	605a      	str	r2, [r3, #4]
    ip_addr_set(&(group->group_address), addr);
 1d8:	683b      	ldr	r3, [r7, #0]
 1da:	2b00      	cmp	r3, #0
 1dc:	d002      	beq.n	1e4 <igmp_lookup_group+0x48>
 1de:	683b      	ldr	r3, [r7, #0]
 1e0:	681b      	ldr	r3, [r3, #0]
 1e2:	e001      	b.n	1e8 <igmp_lookup_group+0x4c>
 1e4:	f04f 0300 	mov.w	r3, #0
 1e8:	68fa      	ldr	r2, [r7, #12]
 1ea:	6093      	str	r3, [r2, #8]
    group->timer              = 0; /* Not running */
 1ec:	68fb      	ldr	r3, [r7, #12]
 1ee:	f04f 0200 	mov.w	r2, #0
 1f2:	81da      	strh	r2, [r3, #14]
    group->group_state        = IGMP_GROUP_NON_MEMBER;
 1f4:	68fb      	ldr	r3, [r7, #12]
 1f6:	f04f 0200 	mov.w	r2, #0
 1fa:	735a      	strb	r2, [r3, #13]
    group->last_reporter_flag = 0;
 1fc:	68fb      	ldr	r3, [r7, #12]
 1fe:	f04f 0200 	mov.w	r2, #0
 202:	731a      	strb	r2, [r3, #12]
    group->use                = 0;
 204:	68fb      	ldr	r3, [r7, #12]
 206:	f04f 0200 	mov.w	r2, #0
 20a:	741a      	strb	r2, [r3, #16]
    group->next               = igmp_group_list;
 20c:	4b06      	ldr	r3, [pc, #24]	; (228 <igmp_lookup_group+0x8c>)
 20e:	681a      	ldr	r2, [r3, #0]
 210:	68fb      	ldr	r3, [r7, #12]
 212:	601a      	str	r2, [r3, #0]
    
    igmp_group_list = group;
 214:	4b04      	ldr	r3, [pc, #16]	; (228 <igmp_lookup_group+0x8c>)
 216:	68fa      	ldr	r2, [r7, #12]
 218:	601a      	str	r2, [r3, #0]

  LWIP_DEBUGF(IGMP_DEBUG, ("igmp_lookup_group: %sallocated a new group with address ", (group?"":"impossible to ")));
  ip_addr_debug_print(IGMP_DEBUG, addr);
  LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", ifp));

  return group;
 21a:	68fb      	ldr	r3, [r7, #12]
}
 21c:	4618      	mov	r0, r3
 21e:	f107 0710 	add.w	r7, r7, #16
 222:	46bd      	mov	sp, r7
 224:	bd80      	pop	{r7, pc}
 226:	bf00      	nop
 228:	00000000 	.word	0x00000000
			228: R_ARM_ABS32	.bss

0000022c <igmp_remove_group>:
 * @param group the group to remove from the global igmp_group_list
 * @return ERR_OK if group was removed from the list, an err_t otherwise
 */
static err_t
igmp_remove_group(struct igmp_group *group)
{
 22c:	b580      	push	{r7, lr}
 22e:	b084      	sub	sp, #16
 230:	af00      	add	r7, sp, #0
 232:	6078      	str	r0, [r7, #4]
  err_t err = ERR_OK;
 234:	f04f 0300 	mov.w	r3, #0
 238:	73fb      	strb	r3, [r7, #15]

  /* Is it the first group? */
  if (igmp_group_list == group) {
 23a:	4b18      	ldr	r3, [pc, #96]	; (29c <igmp_remove_group+0x70>)
 23c:	681a      	ldr	r2, [r3, #0]
 23e:	687b      	ldr	r3, [r7, #4]
 240:	429a      	cmp	r2, r3
 242:	d104      	bne.n	24e <igmp_remove_group+0x22>
    igmp_group_list = group->next;
 244:	687b      	ldr	r3, [r7, #4]
 246:	681a      	ldr	r2, [r3, #0]
 248:	4b14      	ldr	r3, [pc, #80]	; (29c <igmp_remove_group+0x70>)
 24a:	601a      	str	r2, [r3, #0]
 24c:	e019      	b.n	282 <igmp_remove_group+0x56>
  } else {
    /* look for group further down the list */
    struct igmp_group *tmpGroup;
    for (tmpGroup = igmp_group_list; tmpGroup != NULL; tmpGroup = tmpGroup->next) {
 24e:	4b13      	ldr	r3, [pc, #76]	; (29c <igmp_remove_group+0x70>)
 250:	681b      	ldr	r3, [r3, #0]
 252:	60bb      	str	r3, [r7, #8]
 254:	e00c      	b.n	270 <igmp_remove_group+0x44>
      if (tmpGroup->next == group) {
 256:	68bb      	ldr	r3, [r7, #8]
 258:	681a      	ldr	r2, [r3, #0]
 25a:	687b      	ldr	r3, [r7, #4]
 25c:	429a      	cmp	r2, r3
 25e:	d104      	bne.n	26a <igmp_remove_group+0x3e>
        tmpGroup->next = group->next;
 260:	687b      	ldr	r3, [r7, #4]
 262:	681a      	ldr	r2, [r3, #0]
 264:	68bb      	ldr	r3, [r7, #8]
 266:	601a      	str	r2, [r3, #0]
        break;
 268:	e005      	b.n	276 <igmp_remove_group+0x4a>
  if (igmp_group_list == group) {
    igmp_group_list = group->next;
  } else {
    /* look for group further down the list */
    struct igmp_group *tmpGroup;
    for (tmpGroup = igmp_group_list; tmpGroup != NULL; tmpGroup = tmpGroup->next) {
 26a:	68bb      	ldr	r3, [r7, #8]
 26c:	681b      	ldr	r3, [r3, #0]
 26e:	60bb      	str	r3, [r7, #8]
 270:	68bb      	ldr	r3, [r7, #8]
 272:	2b00      	cmp	r3, #0
 274:	d1ef      	bne.n	256 <igmp_remove_group+0x2a>
        tmpGroup->next = group->next;
        break;
      }
    }
    /* Group not found in the global igmp_group_list */
    if (tmpGroup == NULL)
 276:	68bb      	ldr	r3, [r7, #8]
 278:	2b00      	cmp	r3, #0
 27a:	d102      	bne.n	282 <igmp_remove_group+0x56>
      err = ERR_ARG;
 27c:	f04f 03f2 	mov.w	r3, #242	; 0xf2
 280:	73fb      	strb	r3, [r7, #15]
  }
  /* free group */
  memp_free(MEMP_IGMP_GROUP, group);
 282:	f04f 000b 	mov.w	r0, #11
 286:	6879      	ldr	r1, [r7, #4]
 288:	f7ff fffe 	bl	0 <memp_free>
			288: R_ARM_THM_CALL	memp_free

  return err;
 28c:	7bfb      	ldrb	r3, [r7, #15]
 28e:	b25b      	sxtb	r3, r3
}
 290:	4618      	mov	r0, r3
 292:	f107 0710 	add.w	r7, r7, #16
 296:	46bd      	mov	sp, r7
 298:	bd80      	pop	{r7, pc}
 29a:	bf00      	nop
 29c:	00000000 	.word	0x00000000
			29c: R_ARM_ABS32	.bss

000002a0 <igmp_input>:
 * @param inp network interface on which the packet was received
 * @param dest destination ip address of the igmp packet
 */
void
igmp_input(struct pbuf *p, struct netif *inp, ip_addr_t *dest)
{
 2a0:	b580      	push	{r7, lr}
 2a2:	b08a      	sub	sp, #40	; 0x28
 2a4:	af00      	add	r7, sp, #0
 2a6:	60f8      	str	r0, [r7, #12]
 2a8:	60b9      	str	r1, [r7, #8]
 2aa:	607a      	str	r2, [r7, #4]
  struct igmp_group* groupref;

  IGMP_STATS_INC(igmp.recv);

  /* Note that the length CAN be greater than 8 but only 8 are used - All are included in the checksum */    
  iphdr = (struct ip_hdr *)p->payload;
 2ac:	68fb      	ldr	r3, [r7, #12]
 2ae:	685b      	ldr	r3, [r3, #4]
 2b0:	61fb      	str	r3, [r7, #28]
  if (pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4)) || (p->len < IGMP_MINLEN)) {
 2b2:	69fb      	ldr	r3, [r7, #28]
 2b4:	781b      	ldrb	r3, [r3, #0]
 2b6:	f003 030f 	and.w	r3, r3, #15
 2ba:	b29b      	uxth	r3, r3
 2bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
 2c0:	b29b      	uxth	r3, r3
 2c2:	f1c3 0300 	rsb	r3, r3, #0
 2c6:	b29b      	uxth	r3, r3
 2c8:	b29b      	uxth	r3, r3
 2ca:	b21b      	sxth	r3, r3
 2cc:	68f8      	ldr	r0, [r7, #12]
 2ce:	4619      	mov	r1, r3
 2d0:	f7ff fffe 	bl	0 <pbuf_header>
			2d0: R_ARM_THM_CALL	pbuf_header
 2d4:	4603      	mov	r3, r0
 2d6:	2b00      	cmp	r3, #0
 2d8:	d103      	bne.n	2e2 <igmp_input+0x42>
 2da:	68fb      	ldr	r3, [r7, #12]
 2dc:	895b      	ldrh	r3, [r3, #10]
 2de:	2b07      	cmp	r3, #7
 2e0:	d803      	bhi.n	2ea <igmp_input+0x4a>
    pbuf_free(p);
 2e2:	68f8      	ldr	r0, [r7, #12]
 2e4:	f7ff fffe 	bl	0 <pbuf_free>
			2e4: R_ARM_THM_CALL	pbuf_free
    IGMP_STATS_INC(igmp.lenerr);
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: length error\n"));
    return;
 2e8:	e095      	b.n	416 <igmp_input+0x176>
  LWIP_DEBUGF(IGMP_DEBUG, (" to address "));
  ip_addr_debug_print(IGMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", inp));

  /* Now calculate and check the checksum */
  igmp = (struct igmp_msg *)p->payload;
 2ea:	68fb      	ldr	r3, [r7, #12]
 2ec:	685b      	ldr	r3, [r3, #4]
 2ee:	61bb      	str	r3, [r7, #24]
  if (inet_chksum(igmp, p->len)) {
 2f0:	68fb      	ldr	r3, [r7, #12]
 2f2:	895b      	ldrh	r3, [r3, #10]
 2f4:	69b8      	ldr	r0, [r7, #24]
 2f6:	4619      	mov	r1, r3
 2f8:	f7ff fffe 	bl	0 <inet_chksum>
			2f8: R_ARM_THM_CALL	inet_chksum
 2fc:	4603      	mov	r3, r0
 2fe:	2b00      	cmp	r3, #0
 300:	d003      	beq.n	30a <igmp_input+0x6a>
    pbuf_free(p);
 302:	68f8      	ldr	r0, [r7, #12]
 304:	f7ff fffe 	bl	0 <pbuf_free>
			304: R_ARM_THM_CALL	pbuf_free
    IGMP_STATS_INC(igmp.chkerr);
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: checksum error\n"));
    return;
 308:	e085      	b.n	416 <igmp_input+0x176>
  }

  /* Packet is ok so find an existing group */
  group = igmp_lookfor_group(inp, dest); /* use the destination IP address of incoming packet */
 30a:	68b8      	ldr	r0, [r7, #8]
 30c:	6879      	ldr	r1, [r7, #4]
 30e:	f7ff fffe 	bl	150 <igmp_lookfor_group>
			30e: R_ARM_THM_CALL	igmp_lookfor_group
 312:	6278      	str	r0, [r7, #36]	; 0x24
  
  /* If group can be found or create... */
  if (!group) {
 314:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 316:	2b00      	cmp	r3, #0
 318:	d103      	bne.n	322 <igmp_input+0x82>
    pbuf_free(p);
 31a:	68f8      	ldr	r0, [r7, #12]
 31c:	f7ff fffe 	bl	0 <pbuf_free>
			31c: R_ARM_THM_CALL	pbuf_free
    IGMP_STATS_INC(igmp.drop);
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP frame not for us\n"));
    return;
 320:	e079      	b.n	416 <igmp_input+0x176>
  }

  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
  switch (igmp->igmp_msgtype) {
 322:	69bb      	ldr	r3, [r7, #24]
 324:	781b      	ldrb	r3, [r3, #0]
 326:	2b11      	cmp	r3, #17
 328:	d002      	beq.n	330 <igmp_input+0x90>
 32a:	2b16      	cmp	r3, #22
 32c:	d057      	beq.n	3de <igmp_input+0x13e>
   }
   default: {
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: unexpected msg %d in state %d on group %p on if %p\n",
       igmp->igmp_msgtype, group->group_state, &group, group->netif));
     IGMP_STATS_INC(igmp.proterr);
     break;
 32e:	e06e      	b.n	40e <igmp_input+0x16e>

  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
  switch (igmp->igmp_msgtype) {
   case IGMP_MEMB_QUERY: {
     /* IGMP_MEMB_QUERY to the "all systems" address ? */
     if ((ip_addr_cmp(dest, &allsystems)) && ip_addr_isany(&igmp->igmp_group_address)) {
 330:	687b      	ldr	r3, [r7, #4]
 332:	681a      	ldr	r2, [r3, #0]
 334:	4b3a      	ldr	r3, [pc, #232]	; (420 <igmp_input+0x180>)
 336:	681b      	ldr	r3, [r3, #0]
 338:	429a      	cmp	r2, r3
 33a:	d12d      	bne.n	398 <igmp_input+0xf8>
 33c:	69bb      	ldr	r3, [r7, #24]
 33e:	f103 0304 	add.w	r3, r3, #4
 342:	2b00      	cmp	r3, #0
 344:	d003      	beq.n	34e <igmp_input+0xae>
 346:	69bb      	ldr	r3, [r7, #24]
 348:	685b      	ldr	r3, [r3, #4]
 34a:	2b00      	cmp	r3, #0
 34c:	d124      	bne.n	398 <igmp_input+0xf8>
       /* THIS IS THE GENERAL QUERY */
       LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: General IGMP_MEMB_QUERY on \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));

       if (igmp->igmp_maxresp == 0) {
 34e:	69bb      	ldr	r3, [r7, #24]
 350:	785b      	ldrb	r3, [r3, #1]
 352:	2b00      	cmp	r3, #0
 354:	d103      	bne.n	35e <igmp_input+0xbe>
         IGMP_STATS_INC(igmp.rx_v1);
         LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: got an all hosts query with time== 0 - this is V1 and not implemented - treat as v2\n"));
         igmp->igmp_maxresp = IGMP_V1_DELAYING_MEMBER_TMR;
 356:	69bb      	ldr	r3, [r7, #24]
 358:	f04f 020a 	mov.w	r2, #10
 35c:	705a      	strb	r2, [r3, #1]
       } else {
         IGMP_STATS_INC(igmp.rx_general);
       }

       groupref = igmp_group_list;
 35e:	4b31      	ldr	r3, [pc, #196]	; (424 <igmp_input+0x184>)
 360:	681b      	ldr	r3, [r3, #0]
 362:	623b      	str	r3, [r7, #32]
       while (groupref) {
 364:	e013      	b.n	38e <igmp_input+0xee>
         /* Do not send messages on the all systems group address! */
         if ((groupref->netif == inp) && (!(ip_addr_cmp(&(groupref->group_address), &allsystems)))) {
 366:	6a3b      	ldr	r3, [r7, #32]
 368:	685a      	ldr	r2, [r3, #4]
 36a:	68bb      	ldr	r3, [r7, #8]
 36c:	429a      	cmp	r2, r3
 36e:	d10b      	bne.n	388 <igmp_input+0xe8>
 370:	6a3b      	ldr	r3, [r7, #32]
 372:	689a      	ldr	r2, [r3, #8]
 374:	4b2a      	ldr	r3, [pc, #168]	; (420 <igmp_input+0x180>)
 376:	681b      	ldr	r3, [r3, #0]
 378:	429a      	cmp	r2, r3
 37a:	d005      	beq.n	388 <igmp_input+0xe8>
           igmp_delaying_member(groupref, igmp->igmp_maxresp);
 37c:	69bb      	ldr	r3, [r7, #24]
 37e:	785b      	ldrb	r3, [r3, #1]
 380:	6a38      	ldr	r0, [r7, #32]
 382:	4619      	mov	r1, r3
 384:	f000 f996 	bl	6b4 <igmp_delaying_member>
         }
         groupref = groupref->next;
 388:	6a3b      	ldr	r3, [r7, #32]
 38a:	681b      	ldr	r3, [r3, #0]
 38c:	623b      	str	r3, [r7, #32]
       } else {
         IGMP_STATS_INC(igmp.rx_general);
       }

       groupref = igmp_group_list;
       while (groupref) {
 38e:	6a3b      	ldr	r3, [r7, #32]
 390:	2b00      	cmp	r3, #0
 392:	d1e8      	bne.n	366 <igmp_input+0xc6>

  /* NOW ACT ON THE INCOMING MESSAGE TYPE... */
  switch (igmp->igmp_msgtype) {
   case IGMP_MEMB_QUERY: {
     /* IGMP_MEMB_QUERY to the "all systems" address ? */
     if ((ip_addr_cmp(dest, &allsystems)) && ip_addr_isany(&igmp->igmp_group_address)) {
 394:	bf00      	nop
         }
       } else {
         IGMP_STATS_INC(igmp.proterr);
       }
     }
     break;
 396:	e03a      	b.n	40e <igmp_input+0x16e>
         }
         groupref = groupref->next;
       }
     } else {
       /* IGMP_MEMB_QUERY to a specific group ? */
       if (!ip_addr_isany(&igmp->igmp_group_address)) {
 398:	69bb      	ldr	r3, [r7, #24]
 39a:	f103 0304 	add.w	r3, r3, #4
 39e:	2b00      	cmp	r3, #0
 3a0:	d02e      	beq.n	400 <igmp_input+0x160>
 3a2:	69bb      	ldr	r3, [r7, #24]
 3a4:	685b      	ldr	r3, [r3, #4]
 3a6:	2b00      	cmp	r3, #0
 3a8:	d02c      	beq.n	404 <igmp_input+0x164>
         LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_MEMB_QUERY to a specific group "));
         ip_addr_debug_print(IGMP_DEBUG, &igmp->igmp_group_address);
         if (ip_addr_cmp(dest, &allsystems)) {
 3aa:	687b      	ldr	r3, [r7, #4]
 3ac:	681a      	ldr	r2, [r3, #0]
 3ae:	4b1c      	ldr	r3, [pc, #112]	; (420 <igmp_input+0x180>)
 3b0:	681b      	ldr	r3, [r3, #0]
 3b2:	429a      	cmp	r2, r3
 3b4:	d109      	bne.n	3ca <igmp_input+0x12a>
           ip_addr_t groupaddr;
           LWIP_DEBUGF(IGMP_DEBUG, (" using \"ALL SYSTEMS\" address (224.0.0.1) [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
           /* we first need to re-look for the group since we used dest last time */
           ip_addr_copy(groupaddr, igmp->igmp_group_address);
 3b6:	69bb      	ldr	r3, [r7, #24]
 3b8:	685b      	ldr	r3, [r3, #4]
 3ba:	617b      	str	r3, [r7, #20]
           group = igmp_lookfor_group(inp, &groupaddr);
 3bc:	f107 0314 	add.w	r3, r7, #20
 3c0:	68b8      	ldr	r0, [r7, #8]
 3c2:	4619      	mov	r1, r3
 3c4:	f7ff fffe 	bl	150 <igmp_lookfor_group>
			3c4: R_ARM_THM_CALL	igmp_lookfor_group
 3c8:	6278      	str	r0, [r7, #36]	; 0x24
         } else {
           LWIP_DEBUGF(IGMP_DEBUG, (" with the group address as destination [igmp_maxresp=%i]\n", (int)(igmp->igmp_maxresp)));
         }

         if (group != NULL) {
 3ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3cc:	2b00      	cmp	r3, #0
 3ce:	d01b      	beq.n	408 <igmp_input+0x168>
           IGMP_STATS_INC(igmp.rx_group);
           igmp_delaying_member(group, igmp->igmp_maxresp);
 3d0:	69bb      	ldr	r3, [r7, #24]
 3d2:	785b      	ldrb	r3, [r3, #1]
 3d4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 3d6:	4619      	mov	r1, r3
 3d8:	f000 f96c 	bl	6b4 <igmp_delaying_member>
         }
       } else {
         IGMP_STATS_INC(igmp.proterr);
       }
     }
     break;
 3dc:	e017      	b.n	40e <igmp_input+0x16e>
   }
   case IGMP_V2_MEMB_REPORT: {
     LWIP_DEBUGF(IGMP_DEBUG, ("igmp_input: IGMP_V2_MEMB_REPORT\n"));
     IGMP_STATS_INC(igmp.rx_report);
     if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
 3de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3e0:	7b5b      	ldrb	r3, [r3, #13]
 3e2:	2b01      	cmp	r3, #1
 3e4:	d112      	bne.n	40c <igmp_input+0x16c>
       /* This is on a specific group we have already looked up */
       group->timer = 0; /* stopped */
 3e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3e8:	f04f 0200 	mov.w	r2, #0
 3ec:	81da      	strh	r2, [r3, #14]
       group->group_state = IGMP_GROUP_IDLE_MEMBER;
 3ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3f0:	f04f 0202 	mov.w	r2, #2
 3f4:	735a      	strb	r2, [r3, #13]
       group->last_reporter_flag = 0;
 3f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3f8:	f04f 0200 	mov.w	r2, #0
 3fc:	731a      	strb	r2, [r3, #12]
     }
     break;
 3fe:	e006      	b.n	40e <igmp_input+0x16e>
         }
       } else {
         IGMP_STATS_INC(igmp.proterr);
       }
     }
     break;
 400:	bf00      	nop
 402:	e004      	b.n	40e <igmp_input+0x16e>
 404:	bf00      	nop
 406:	e002      	b.n	40e <igmp_input+0x16e>
 408:	bf00      	nop
 40a:	e000      	b.n	40e <igmp_input+0x16e>
       /* This is on a specific group we have already looked up */
       group->timer = 0; /* stopped */
       group->group_state = IGMP_GROUP_IDLE_MEMBER;
       group->last_reporter_flag = 0;
     }
     break;
 40c:	bf00      	nop
     IGMP_STATS_INC(igmp.proterr);
     break;
   }
  }

  pbuf_free(p);
 40e:	68f8      	ldr	r0, [r7, #12]
 410:	f7ff fffe 	bl	0 <pbuf_free>
			410: R_ARM_THM_CALL	pbuf_free
  return;
 414:	bf00      	nop
}
 416:	f107 0728 	add.w	r7, r7, #40	; 0x28
 41a:	46bd      	mov	sp, r7
 41c:	bd80      	pop	{r7, pc}
 41e:	bf00      	nop
 420:	00000004 	.word	0x00000004
			420: R_ARM_ABS32	.bss
 424:	00000000 	.word	0x00000000
			424: R_ARM_ABS32	.bss

00000428 <igmp_joingroup>:
 * @param groupaddr the ip address of the group which to join
 * @return ERR_OK if group was joined on the netif(s), an err_t otherwise
 */
err_t
igmp_joingroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr)
{
 428:	b580      	push	{r7, lr}
 42a:	b086      	sub	sp, #24
 42c:	af00      	add	r7, sp, #0
 42e:	6078      	str	r0, [r7, #4]
 430:	6039      	str	r1, [r7, #0]
  err_t              err = ERR_VAL; /* no matching interface */
 432:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 436:	75fb      	strb	r3, [r7, #23]
  struct igmp_group *group;
  struct netif      *netif;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
 438:	683b      	ldr	r3, [r7, #0]
 43a:	681b      	ldr	r3, [r3, #0]
 43c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 440:	2be0      	cmp	r3, #224	; 0xe0
 442:	d002      	beq.n	44a <igmp_joingroup+0x22>
 444:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 448:	e05e      	b.n	508 <igmp_joingroup+0xe0>
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 44a:	683b      	ldr	r3, [r7, #0]
 44c:	681a      	ldr	r2, [r3, #0]
 44e:	4b31      	ldr	r3, [pc, #196]	; (514 <igmp_joingroup+0xec>)
 450:	681b      	ldr	r3, [r3, #0]
 452:	429a      	cmp	r2, r3
 454:	d102      	bne.n	45c <igmp_joingroup+0x34>
 456:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 45a:	e055      	b.n	508 <igmp_joingroup+0xe0>

  /* loop through netif's */
  netif = netif_list;
 45c:	4b2e      	ldr	r3, [pc, #184]	; (518 <igmp_joingroup+0xf0>)
 45e:	681b      	ldr	r3, [r3, #0]
 460:	613b      	str	r3, [r7, #16]
  while (netif != NULL) {
 462:	e04d      	b.n	500 <igmp_joingroup+0xd8>
    /* Should we join this interface ? */
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {
 464:	693b      	ldr	r3, [r7, #16]
 466:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 46a:	b2db      	uxtb	r3, r3
 46c:	b25b      	sxtb	r3, r3
 46e:	2b00      	cmp	r3, #0
 470:	da43      	bge.n	4fa <igmp_joingroup+0xd2>
 472:	687b      	ldr	r3, [r7, #4]
 474:	2b00      	cmp	r3, #0
 476:	d009      	beq.n	48c <igmp_joingroup+0x64>
 478:	687b      	ldr	r3, [r7, #4]
 47a:	681b      	ldr	r3, [r3, #0]
 47c:	2b00      	cmp	r3, #0
 47e:	d005      	beq.n	48c <igmp_joingroup+0x64>
 480:	693b      	ldr	r3, [r7, #16]
 482:	685a      	ldr	r2, [r3, #4]
 484:	687b      	ldr	r3, [r7, #4]
 486:	681b      	ldr	r3, [r3, #0]
 488:	429a      	cmp	r2, r3
 48a:	d136      	bne.n	4fa <igmp_joingroup+0xd2>
      /* find group or create a new one if not found */
      group = igmp_lookup_group(netif, groupaddr);
 48c:	6938      	ldr	r0, [r7, #16]
 48e:	6839      	ldr	r1, [r7, #0]
 490:	f7ff fe84 	bl	19c <igmp_lookup_group>
 494:	60f8      	str	r0, [r7, #12]

      if (group != NULL) {
 496:	68fb      	ldr	r3, [r7, #12]
 498:	2b00      	cmp	r3, #0
 49a:	d02b      	beq.n	4f4 <igmp_joingroup+0xcc>
        /* This should create a new group, check the state to make sure */
        if (group->group_state != IGMP_GROUP_NON_MEMBER) {
 49c:	68fb      	ldr	r3, [r7, #12]
 49e:	7b5b      	ldrb	r3, [r3, #13]
 4a0:	2b00      	cmp	r3, #0
 4a2:	d11c      	bne.n	4de <igmp_joingroup+0xb6>
          LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: join to new group: "));
          ip_addr_debug_print(IGMP_DEBUG, groupaddr);
          LWIP_DEBUGF(IGMP_DEBUG, ("\n"));

          /* If first use of the group, allow the group at the MAC level */
          if ((group->use==0) && (netif->igmp_mac_filter != NULL)) {
 4a4:	68fb      	ldr	r3, [r7, #12]
 4a6:	7c1b      	ldrb	r3, [r3, #16]
 4a8:	2b00      	cmp	r3, #0
 4aa:	d10a      	bne.n	4c2 <igmp_joingroup+0x9a>
 4ac:	693b      	ldr	r3, [r7, #16]
 4ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 4b0:	2b00      	cmp	r3, #0
 4b2:	d006      	beq.n	4c2 <igmp_joingroup+0x9a>
            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: igmp_mac_filter(ADD "));
            ip_addr_debug_print(IGMP_DEBUG, groupaddr);
            LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
            netif->igmp_mac_filter(netif, groupaddr, IGMP_ADD_MAC_FILTER);
 4b4:	693b      	ldr	r3, [r7, #16]
 4b6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 4b8:	6938      	ldr	r0, [r7, #16]
 4ba:	6839      	ldr	r1, [r7, #0]
 4bc:	f04f 0201 	mov.w	r2, #1
 4c0:	4798      	blx	r3
          }

          IGMP_STATS_INC(igmp.tx_join);
          igmp_send(group, IGMP_V2_MEMB_REPORT);
 4c2:	68f8      	ldr	r0, [r7, #12]
 4c4:	f04f 0116 	mov.w	r1, #22
 4c8:	f000 f942 	bl	750 <igmp_send>

          igmp_start_timer(group, IGMP_JOIN_DELAYING_MEMBER_TMR);
 4cc:	68f8      	ldr	r0, [r7, #12]
 4ce:	f04f 0105 	mov.w	r1, #5
 4d2:	f000 f8cd 	bl	670 <igmp_start_timer>

          /* Need to work out where this timer comes from */
          group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 4d6:	68fb      	ldr	r3, [r7, #12]
 4d8:	f04f 0201 	mov.w	r2, #1
 4dc:	735a      	strb	r2, [r3, #13]
        }
        /* Increment group use */
        group->use++;
 4de:	68fb      	ldr	r3, [r7, #12]
 4e0:	7c1b      	ldrb	r3, [r3, #16]
 4e2:	f103 0301 	add.w	r3, r3, #1
 4e6:	b2da      	uxtb	r2, r3
 4e8:	68fb      	ldr	r3, [r7, #12]
 4ea:	741a      	strb	r2, [r3, #16]
        /* Join on this interface */
        err = ERR_OK;
 4ec:	f04f 0300 	mov.w	r3, #0
 4f0:	75fb      	strb	r3, [r7, #23]
 4f2:	e002      	b.n	4fa <igmp_joingroup+0xd2>
      } else {
        /* Return an error even if some network interfaces are joined */
        /** @todo undo any other netif already joined */
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_joingroup: Not enought memory to join to group\n"));
        return ERR_MEM;
 4f4:	f04f 03ff 	mov.w	r3, #255	; 0xff
 4f8:	e006      	b.n	508 <igmp_joingroup+0xe0>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 4fa:	693b      	ldr	r3, [r7, #16]
 4fc:	681b      	ldr	r3, [r3, #0]
 4fe:	613b      	str	r3, [r7, #16]
  LWIP_ERROR("igmp_joingroup: attempt to join non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
  LWIP_ERROR("igmp_joingroup: attempt to join allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);

  /* loop through netif's */
  netif = netif_list;
  while (netif != NULL) {
 500:	693b      	ldr	r3, [r7, #16]
 502:	2b00      	cmp	r3, #0
 504:	d1ae      	bne.n	464 <igmp_joingroup+0x3c>
    }
    /* proceed to next network interface */
    netif = netif->next;
  }

  return err;
 506:	7dfb      	ldrb	r3, [r7, #23]
 508:	b25b      	sxtb	r3, r3
}
 50a:	4618      	mov	r0, r3
 50c:	f107 0718 	add.w	r7, r7, #24
 510:	46bd      	mov	sp, r7
 512:	bd80      	pop	{r7, pc}
 514:	00000004 	.word	0x00000004
			514: R_ARM_ABS32	.bss
 518:	00000000 	.word	0x00000000
			518: R_ARM_ABS32	netif_list

0000051c <igmp_leavegroup>:
 * @param groupaddr the ip address of the group which to leave
 * @return ERR_OK if group was left on the netif(s), an err_t otherwise
 */
err_t
igmp_leavegroup(ip_addr_t *ifaddr, ip_addr_t *groupaddr)
{
 51c:	b580      	push	{r7, lr}
 51e:	b086      	sub	sp, #24
 520:	af00      	add	r7, sp, #0
 522:	6078      	str	r0, [r7, #4]
 524:	6039      	str	r1, [r7, #0]
  err_t              err = ERR_VAL; /* no matching interface */
 526:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 52a:	75fb      	strb	r3, [r7, #23]
  struct igmp_group *group;
  struct netif      *netif;

  /* make sure it is multicast address */
  LWIP_ERROR("igmp_leavegroup: attempt to leave non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
 52c:	683b      	ldr	r3, [r7, #0]
 52e:	681b      	ldr	r3, [r3, #0]
 530:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 534:	2be0      	cmp	r3, #224	; 0xe0
 536:	d002      	beq.n	53e <igmp_leavegroup+0x22>
 538:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 53c:	e055      	b.n	5ea <igmp_leavegroup+0xce>
  LWIP_ERROR("igmp_leavegroup: attempt to leave allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);
 53e:	683b      	ldr	r3, [r7, #0]
 540:	681a      	ldr	r2, [r3, #0]
 542:	4b2d      	ldr	r3, [pc, #180]	; (5f8 <igmp_leavegroup+0xdc>)
 544:	681b      	ldr	r3, [r3, #0]
 546:	429a      	cmp	r2, r3
 548:	d102      	bne.n	550 <igmp_leavegroup+0x34>
 54a:	f04f 03fa 	mov.w	r3, #250	; 0xfa
 54e:	e04c      	b.n	5ea <igmp_leavegroup+0xce>

  /* loop through netif's */
  netif = netif_list;
 550:	4b2a      	ldr	r3, [pc, #168]	; (5fc <igmp_leavegroup+0xe0>)
 552:	681b      	ldr	r3, [r3, #0]
 554:	613b      	str	r3, [r7, #16]
  while (netif != NULL) {
 556:	e044      	b.n	5e2 <igmp_leavegroup+0xc6>
    /* Should we leave this interface ? */
    if ((netif->flags & NETIF_FLAG_IGMP) && ((ip_addr_isany(ifaddr) || ip_addr_cmp(&(netif->ip_addr), ifaddr)))) {
 558:	693b      	ldr	r3, [r7, #16]
 55a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 55e:	b2db      	uxtb	r3, r3
 560:	b25b      	sxtb	r3, r3
 562:	2b00      	cmp	r3, #0
 564:	da3a      	bge.n	5dc <igmp_leavegroup+0xc0>
 566:	687b      	ldr	r3, [r7, #4]
 568:	2b00      	cmp	r3, #0
 56a:	d009      	beq.n	580 <igmp_leavegroup+0x64>
 56c:	687b      	ldr	r3, [r7, #4]
 56e:	681b      	ldr	r3, [r3, #0]
 570:	2b00      	cmp	r3, #0
 572:	d005      	beq.n	580 <igmp_leavegroup+0x64>
 574:	693b      	ldr	r3, [r7, #16]
 576:	685a      	ldr	r2, [r3, #4]
 578:	687b      	ldr	r3, [r7, #4]
 57a:	681b      	ldr	r3, [r3, #0]
 57c:	429a      	cmp	r2, r3
 57e:	d12d      	bne.n	5dc <igmp_leavegroup+0xc0>
      /* find group */
      group = igmp_lookfor_group(netif, groupaddr);
 580:	6938      	ldr	r0, [r7, #16]
 582:	6839      	ldr	r1, [r7, #0]
 584:	f7ff fffe 	bl	150 <igmp_lookfor_group>
			584: R_ARM_THM_CALL	igmp_lookfor_group
 588:	60f8      	str	r0, [r7, #12]

      if (group != NULL) {
 58a:	68fb      	ldr	r3, [r7, #12]
 58c:	2b00      	cmp	r3, #0
 58e:	d025      	beq.n	5dc <igmp_leavegroup+0xc0>
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: Leaving group: "));
        ip_addr_debug_print(IGMP_DEBUG, groupaddr);
        LWIP_DEBUGF(IGMP_DEBUG, ("\n"));

        /* If there is no other use of the group */
        if (group->use <= 1) {
 590:	68fb      	ldr	r3, [r7, #12]
 592:	7c1b      	ldrb	r3, [r3, #16]
 594:	2b01      	cmp	r3, #1
 596:	d817      	bhi.n	5c8 <igmp_leavegroup+0xac>
          /* If we are the last reporter for this group */
          if (group->last_reporter_flag) {
 598:	68fb      	ldr	r3, [r7, #12]
 59a:	7b1b      	ldrb	r3, [r3, #12]
 59c:	2b00      	cmp	r3, #0
 59e:	d004      	beq.n	5aa <igmp_leavegroup+0x8e>
            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: sending leaving group\n"));
            IGMP_STATS_INC(igmp.tx_leave);
            igmp_send(group, IGMP_LEAVE_GROUP);
 5a0:	68f8      	ldr	r0, [r7, #12]
 5a2:	f04f 0117 	mov.w	r1, #23
 5a6:	f000 f8d3 	bl	750 <igmp_send>
          }
          
          /* Disable the group at the MAC level */
          if (netif->igmp_mac_filter != NULL) {
 5aa:	693b      	ldr	r3, [r7, #16]
 5ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 5ae:	2b00      	cmp	r3, #0
 5b0:	d006      	beq.n	5c0 <igmp_leavegroup+0xa4>
            LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: igmp_mac_filter(DEL "));
            ip_addr_debug_print(IGMP_DEBUG, groupaddr);
            LWIP_DEBUGF(IGMP_DEBUG, (") on if %p\n", netif));
            netif->igmp_mac_filter(netif, groupaddr, IGMP_DEL_MAC_FILTER);
 5b2:	693b      	ldr	r3, [r7, #16]
 5b4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 5b6:	6938      	ldr	r0, [r7, #16]
 5b8:	6839      	ldr	r1, [r7, #0]
 5ba:	f04f 0200 	mov.w	r2, #0
 5be:	4798      	blx	r3
          LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: remove group: "));
          ip_addr_debug_print(IGMP_DEBUG, groupaddr);
          LWIP_DEBUGF(IGMP_DEBUG, ("\n"));          
          
          /* Free the group */
          igmp_remove_group(group);
 5c0:	68f8      	ldr	r0, [r7, #12]
 5c2:	f7ff fe33 	bl	22c <igmp_remove_group>
 5c6:	e006      	b.n	5d6 <igmp_leavegroup+0xba>
        } else {
          /* Decrement group use */
          group->use--;
 5c8:	68fb      	ldr	r3, [r7, #12]
 5ca:	7c1b      	ldrb	r3, [r3, #16]
 5cc:	f103 33ff 	add.w	r3, r3, #4294967295
 5d0:	b2da      	uxtb	r2, r3
 5d2:	68fb      	ldr	r3, [r7, #12]
 5d4:	741a      	strb	r2, [r3, #16]
        }
        /* Leave on this interface */
        err = ERR_OK;
 5d6:	f04f 0300 	mov.w	r3, #0
 5da:	75fb      	strb	r3, [r7, #23]
        /* It's not a fatal error on "leavegroup" */
        LWIP_DEBUGF(IGMP_DEBUG, ("igmp_leavegroup: not member of group\n"));
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
 5dc:	693b      	ldr	r3, [r7, #16]
 5de:	681b      	ldr	r3, [r3, #0]
 5e0:	613b      	str	r3, [r7, #16]
  LWIP_ERROR("igmp_leavegroup: attempt to leave non-multicast address", ip_addr_ismulticast(groupaddr), return ERR_VAL;);
  LWIP_ERROR("igmp_leavegroup: attempt to leave allsystems address", (!ip_addr_cmp(groupaddr, &allsystems)), return ERR_VAL;);

  /* loop through netif's */
  netif = netif_list;
  while (netif != NULL) {
 5e2:	693b      	ldr	r3, [r7, #16]
 5e4:	2b00      	cmp	r3, #0
 5e6:	d1b7      	bne.n	558 <igmp_leavegroup+0x3c>
    }
    /* proceed to next network interface */
    netif = netif->next;
  }

  return err;
 5e8:	7dfb      	ldrb	r3, [r7, #23]
 5ea:	b25b      	sxtb	r3, r3
}
 5ec:	4618      	mov	r0, r3
 5ee:	f107 0718 	add.w	r7, r7, #24
 5f2:	46bd      	mov	sp, r7
 5f4:	bd80      	pop	{r7, pc}
 5f6:	bf00      	nop
 5f8:	00000004 	.word	0x00000004
			5f8: R_ARM_ABS32	.bss
 5fc:	00000000 	.word	0x00000000
			5fc: R_ARM_ABS32	netif_list

00000600 <igmp_tmr>:
 * The igmp timer function (both for NO_SYS=1 and =0)
 * Should be called every IGMP_TMR_INTERVAL milliseconds (100 ms is default).
 */
void
igmp_tmr(void)
{
 600:	b580      	push	{r7, lr}
 602:	b082      	sub	sp, #8
 604:	af00      	add	r7, sp, #0
  struct igmp_group *group = igmp_group_list;
 606:	4b10      	ldr	r3, [pc, #64]	; (648 <igmp_tmr+0x48>)
 608:	681b      	ldr	r3, [r3, #0]
 60a:	607b      	str	r3, [r7, #4]

  while (group != NULL) {
 60c:	e014      	b.n	638 <igmp_tmr+0x38>
    if (group->timer > 0) {
 60e:	687b      	ldr	r3, [r7, #4]
 610:	89db      	ldrh	r3, [r3, #14]
 612:	2b00      	cmp	r3, #0
 614:	d00d      	beq.n	632 <igmp_tmr+0x32>
      group->timer--;
 616:	687b      	ldr	r3, [r7, #4]
 618:	89db      	ldrh	r3, [r3, #14]
 61a:	f103 33ff 	add.w	r3, r3, #4294967295
 61e:	b29a      	uxth	r2, r3
 620:	687b      	ldr	r3, [r7, #4]
 622:	81da      	strh	r2, [r3, #14]
      if (group->timer == 0) {
 624:	687b      	ldr	r3, [r7, #4]
 626:	89db      	ldrh	r3, [r3, #14]
 628:	2b00      	cmp	r3, #0
 62a:	d102      	bne.n	632 <igmp_tmr+0x32>
        igmp_timeout(group);
 62c:	6878      	ldr	r0, [r7, #4]
 62e:	f000 f80d 	bl	64c <igmp_timeout>
      }
    }
    group = group->next;
 632:	687b      	ldr	r3, [r7, #4]
 634:	681b      	ldr	r3, [r3, #0]
 636:	607b      	str	r3, [r7, #4]
void
igmp_tmr(void)
{
  struct igmp_group *group = igmp_group_list;

  while (group != NULL) {
 638:	687b      	ldr	r3, [r7, #4]
 63a:	2b00      	cmp	r3, #0
 63c:	d1e7      	bne.n	60e <igmp_tmr+0xe>
        igmp_timeout(group);
      }
    }
    group = group->next;
  }
}
 63e:	f107 0708 	add.w	r7, r7, #8
 642:	46bd      	mov	sp, r7
 644:	bd80      	pop	{r7, pc}
 646:	bf00      	nop
 648:	00000000 	.word	0x00000000
			648: R_ARM_ABS32	.bss

0000064c <igmp_timeout>:
 *
 * @param group an igmp_group for which a timeout is reached
 */
static void
igmp_timeout(struct igmp_group *group)
{
 64c:	b580      	push	{r7, lr}
 64e:	b082      	sub	sp, #8
 650:	af00      	add	r7, sp, #0
 652:	6078      	str	r0, [r7, #4]
  /* If the state is IGMP_GROUP_DELAYING_MEMBER then we send a report for this group */
  if (group->group_state == IGMP_GROUP_DELAYING_MEMBER) {
 654:	687b      	ldr	r3, [r7, #4]
 656:	7b5b      	ldrb	r3, [r3, #13]
 658:	2b01      	cmp	r3, #1
 65a:	d104      	bne.n	666 <igmp_timeout+0x1a>
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_timeout: report membership for group with address "));
    ip_addr_debug_print(IGMP_DEBUG, &(group->group_address));
    LWIP_DEBUGF(IGMP_DEBUG, (" on if %p\n", group->netif));

    IGMP_STATS_INC(igmp.tx_report);
    igmp_send(group, IGMP_V2_MEMB_REPORT);
 65c:	6878      	ldr	r0, [r7, #4]
 65e:	f04f 0116 	mov.w	r1, #22
 662:	f000 f875 	bl	750 <igmp_send>
  }
}
 666:	f107 0708 	add.w	r7, r7, #8
 66a:	46bd      	mov	sp, r7
 66c:	bd80      	pop	{r7, pc}
 66e:	bf00      	nop

00000670 <igmp_start_timer>:
 * @param max_time the time in multiples of IGMP_TMR_INTERVAL (decrease with
 *        every call to igmp_tmr())
 */
static void
igmp_start_timer(struct igmp_group *group, u8_t max_time)
{
 670:	b580      	push	{r7, lr}
 672:	b082      	sub	sp, #8
 674:	af00      	add	r7, sp, #0
 676:	6078      	str	r0, [r7, #4]
 678:	460b      	mov	r3, r1
 67a:	70fb      	strb	r3, [r7, #3]
  /* ensure the input value is > 0 */
  if (max_time == 0) {
 67c:	78fb      	ldrb	r3, [r7, #3]
 67e:	2b00      	cmp	r3, #0
 680:	d102      	bne.n	688 <igmp_start_timer+0x18>
    max_time = 1;
 682:	f04f 0301 	mov.w	r3, #1
 686:	70fb      	strb	r3, [r7, #3]
  }
  /* ensure the random value is > 0 */
  group->timer = (LWIP_RAND() % (max_time - 1)) + 1;
 688:	f7ff fffe 	bl	0 <lwip_rand_arch>
			688: R_ARM_THM_CALL	lwip_rand_arch
 68c:	4603      	mov	r3, r0
 68e:	78fa      	ldrb	r2, [r7, #3]
 690:	f102 32ff 	add.w	r2, r2, #4294967295
 694:	fbb3 f1f2 	udiv	r1, r3, r2
 698:	fb02 f201 	mul.w	r2, r2, r1
 69c:	1a9b      	subs	r3, r3, r2
 69e:	b29b      	uxth	r3, r3
 6a0:	f103 0301 	add.w	r3, r3, #1
 6a4:	b29a      	uxth	r2, r3
 6a6:	687b      	ldr	r3, [r7, #4]
 6a8:	81da      	strh	r2, [r3, #14]
}
 6aa:	f107 0708 	add.w	r7, r7, #8
 6ae:	46bd      	mov	sp, r7
 6b0:	bd80      	pop	{r7, pc}
 6b2:	bf00      	nop

000006b4 <igmp_delaying_member>:
 * @param group the igmp_group for which "delaying" membership report
 * @param maxresp query delay
 */
static void
igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
{
 6b4:	b580      	push	{r7, lr}
 6b6:	b082      	sub	sp, #8
 6b8:	af00      	add	r7, sp, #0
 6ba:	6078      	str	r0, [r7, #4]
 6bc:	460b      	mov	r3, r1
 6be:	70fb      	strb	r3, [r7, #3]
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
 6c0:	687b      	ldr	r3, [r7, #4]
 6c2:	7b5b      	ldrb	r3, [r3, #13]
 6c4:	2b02      	cmp	r3, #2
 6c6:	d00d      	beq.n	6e4 <igmp_delaying_member+0x30>
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 6c8:	687b      	ldr	r3, [r7, #4]
 6ca:	7b5b      	ldrb	r3, [r3, #13]
 * @param maxresp query delay
 */
static void
igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
{
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
 6cc:	2b01      	cmp	r3, #1
 6ce:	d112      	bne.n	6f6 <igmp_delaying_member+0x42>
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
      ((group->timer == 0) || (maxresp < group->timer)))) {
 6d0:	687b      	ldr	r3, [r7, #4]
 6d2:	89db      	ldrh	r3, [r3, #14]
 */
static void
igmp_delaying_member(struct igmp_group *group, u8_t maxresp)
{
  if ((group->group_state == IGMP_GROUP_IDLE_MEMBER) ||
     ((group->group_state == IGMP_GROUP_DELAYING_MEMBER) &&
 6d4:	2b00      	cmp	r3, #0
 6d6:	d005      	beq.n	6e4 <igmp_delaying_member+0x30>
      ((group->timer == 0) || (maxresp < group->timer)))) {
 6d8:	78fb      	ldrb	r3, [r7, #3]
 6da:	b29a      	uxth	r2, r3
 6dc:	687b      	ldr	r3, [r7, #4]
 6de:	89db      	ldrh	r3, [r3, #14]
 6e0:	429a      	cmp	r2, r3
 6e2:	d208      	bcs.n	6f6 <igmp_delaying_member+0x42>
    igmp_start_timer(group, maxresp);
 6e4:	78fb      	ldrb	r3, [r7, #3]
 6e6:	6878      	ldr	r0, [r7, #4]
 6e8:	4619      	mov	r1, r3
 6ea:	f7ff ffc1 	bl	670 <igmp_start_timer>
    group->group_state = IGMP_GROUP_DELAYING_MEMBER;
 6ee:	687b      	ldr	r3, [r7, #4]
 6f0:	f04f 0201 	mov.w	r2, #1
 6f4:	735a      	strb	r2, [r3, #13]
  }
}
 6f6:	f107 0708 	add.w	r7, r7, #8
 6fa:	46bd      	mov	sp, r7
 6fc:	bd80      	pop	{r7, pc}
 6fe:	bf00      	nop

00000700 <igmp_ip_output_if>:
 *         ERR_BUF if p doesn't have enough space for IP/LINK headers
 *         returns errors returned by netif->output
 */
static err_t
igmp_ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest, struct netif *netif)
{
 700:	b580      	push	{r7, lr}
 702:	b08c      	sub	sp, #48	; 0x30
 704:	af06      	add	r7, sp, #24
 706:	60f8      	str	r0, [r7, #12]
 708:	60b9      	str	r1, [r7, #8]
 70a:	607a      	str	r2, [r7, #4]
 70c:	603b      	str	r3, [r7, #0]
  /* This is the "router alert" option */
  u16_t ra[2];
  ra[0] = PP_HTONS(ROUTER_ALERT);
 70e:	f240 4394 	movw	r3, #1172	; 0x494
 712:	82bb      	strh	r3, [r7, #20]
  ra[1] = 0x0000; /* Router shall examine packet */
 714:	f04f 0300 	mov.w	r3, #0
 718:	82fb      	strh	r3, [r7, #22]
  IGMP_STATS_INC(igmp.xmit);
  return ip_output_if_opt(p, src, dest, IGMP_TTL, 0, IP_PROTO_IGMP, netif, ra, ROUTER_ALERTLEN);
 71a:	f04f 0300 	mov.w	r3, #0
 71e:	9300      	str	r3, [sp, #0]
 720:	f04f 0302 	mov.w	r3, #2
 724:	9301      	str	r3, [sp, #4]
 726:	683b      	ldr	r3, [r7, #0]
 728:	9302      	str	r3, [sp, #8]
 72a:	f107 0314 	add.w	r3, r7, #20
 72e:	9303      	str	r3, [sp, #12]
 730:	f04f 0304 	mov.w	r3, #4
 734:	9304      	str	r3, [sp, #16]
 736:	68f8      	ldr	r0, [r7, #12]
 738:	68b9      	ldr	r1, [r7, #8]
 73a:	687a      	ldr	r2, [r7, #4]
 73c:	f04f 0301 	mov.w	r3, #1
 740:	f7ff fffe 	bl	0 <ip_output_if_opt>
			740: R_ARM_THM_CALL	ip_output_if_opt
 744:	4603      	mov	r3, r0
}
 746:	4618      	mov	r0, r3
 748:	f107 0718 	add.w	r7, r7, #24
 74c:	46bd      	mov	sp, r7
 74e:	bd80      	pop	{r7, pc}

00000750 <igmp_send>:
 * @param group the group to which to send the packet
 * @param type the type of igmp packet to send
 */
static void
igmp_send(struct igmp_group *group, u8_t type)
{
 750:	b580      	push	{r7, lr}
 752:	b086      	sub	sp, #24
 754:	af00      	add	r7, sp, #0
 756:	6078      	str	r0, [r7, #4]
 758:	460b      	mov	r3, r1
 75a:	70fb      	strb	r3, [r7, #3]
  struct pbuf*     p    = NULL;
 75c:	f04f 0300 	mov.w	r3, #0
 760:	613b      	str	r3, [r7, #16]
  struct igmp_msg* igmp = NULL;
 762:	f04f 0300 	mov.w	r3, #0
 766:	60fb      	str	r3, [r7, #12]
  ip_addr_t   src  = *IP_ADDR_ANY;
 768:	4b2f      	ldr	r3, [pc, #188]	; (828 <igmp_send+0xd8>)
 76a:	681b      	ldr	r3, [r3, #0]
 76c:	60bb      	str	r3, [r7, #8]
  ip_addr_t*  dest = NULL;
 76e:	f04f 0300 	mov.w	r3, #0
 772:	617b      	str	r3, [r7, #20]

  /* IP header + "router alert" option + IGMP header */
  p = pbuf_alloc(PBUF_TRANSPORT, IGMP_MINLEN, PBUF_RAM);
 774:	f04f 0000 	mov.w	r0, #0
 778:	f04f 0108 	mov.w	r1, #8
 77c:	f04f 0200 	mov.w	r2, #0
 780:	f7ff fffe 	bl	0 <pbuf_alloc>
			780: R_ARM_THM_CALL	pbuf_alloc
 784:	6138      	str	r0, [r7, #16]
  
  if (p) {
 786:	693b      	ldr	r3, [r7, #16]
 788:	2b00      	cmp	r3, #0
 78a:	d048      	beq.n	81e <igmp_send+0xce>
    igmp = (struct igmp_msg *)p->payload;
 78c:	693b      	ldr	r3, [r7, #16]
 78e:	685b      	ldr	r3, [r3, #4]
 790:	60fb      	str	r3, [r7, #12]
    LWIP_ASSERT("igmp_send: check that first pbuf can hold struct igmp_msg",
               (p->len >= sizeof(struct igmp_msg)));
    ip_addr_copy(src, group->netif->ip_addr);
 792:	687b      	ldr	r3, [r7, #4]
 794:	685b      	ldr	r3, [r3, #4]
 796:	685b      	ldr	r3, [r3, #4]
 798:	60bb      	str	r3, [r7, #8]
     
    if (type == IGMP_V2_MEMB_REPORT) {
 79a:	78fb      	ldrb	r3, [r7, #3]
 79c:	2b16      	cmp	r3, #22
 79e:	d10c      	bne.n	7ba <igmp_send+0x6a>
      dest = &(group->group_address);
 7a0:	687b      	ldr	r3, [r7, #4]
 7a2:	f103 0308 	add.w	r3, r3, #8
 7a6:	617b      	str	r3, [r7, #20]
      ip_addr_copy(igmp->igmp_group_address, group->group_address);
 7a8:	687b      	ldr	r3, [r7, #4]
 7aa:	689a      	ldr	r2, [r3, #8]
 7ac:	68fb      	ldr	r3, [r7, #12]
 7ae:	605a      	str	r2, [r3, #4]
      group->last_reporter_flag = 1; /* Remember we were the last to report */
 7b0:	687b      	ldr	r3, [r7, #4]
 7b2:	f04f 0201 	mov.w	r2, #1
 7b6:	731a      	strb	r2, [r3, #12]
 7b8:	e008      	b.n	7cc <igmp_send+0x7c>
    } else {
      if (type == IGMP_LEAVE_GROUP) {
 7ba:	78fb      	ldrb	r3, [r7, #3]
 7bc:	2b17      	cmp	r3, #23
 7be:	d105      	bne.n	7cc <igmp_send+0x7c>
        dest = &allrouters;
 7c0:	4b1a      	ldr	r3, [pc, #104]	; (82c <igmp_send+0xdc>)
 7c2:	617b      	str	r3, [r7, #20]
        ip_addr_copy(igmp->igmp_group_address, group->group_address);
 7c4:	687b      	ldr	r3, [r7, #4]
 7c6:	689a      	ldr	r2, [r3, #8]
 7c8:	68fb      	ldr	r3, [r7, #12]
 7ca:	605a      	str	r2, [r3, #4]
      }
    }

    if ((type == IGMP_V2_MEMB_REPORT) || (type == IGMP_LEAVE_GROUP)) {
 7cc:	78fb      	ldrb	r3, [r7, #3]
 7ce:	2b16      	cmp	r3, #22
 7d0:	d002      	beq.n	7d8 <igmp_send+0x88>
 7d2:	78fb      	ldrb	r3, [r7, #3]
 7d4:	2b17      	cmp	r3, #23
 7d6:	d11f      	bne.n	818 <igmp_send+0xc8>
      igmp->igmp_msgtype  = type;
 7d8:	68fb      	ldr	r3, [r7, #12]
 7da:	78fa      	ldrb	r2, [r7, #3]
 7dc:	701a      	strb	r2, [r3, #0]
      igmp->igmp_maxresp  = 0;
 7de:	68fb      	ldr	r3, [r7, #12]
 7e0:	f04f 0200 	mov.w	r2, #0
 7e4:	705a      	strb	r2, [r3, #1]
      igmp->igmp_checksum = 0;
 7e6:	68fb      	ldr	r3, [r7, #12]
 7e8:	f04f 0200 	mov.w	r2, #0
 7ec:	709a      	strb	r2, [r3, #2]
 7ee:	f04f 0200 	mov.w	r2, #0
 7f2:	70da      	strb	r2, [r3, #3]
      igmp->igmp_checksum = inet_chksum(igmp, IGMP_MINLEN);
 7f4:	68f8      	ldr	r0, [r7, #12]
 7f6:	f04f 0108 	mov.w	r1, #8
 7fa:	f7ff fffe 	bl	0 <inet_chksum>
			7fa: R_ARM_THM_CALL	inet_chksum
 7fe:	4603      	mov	r3, r0
 800:	461a      	mov	r2, r3
 802:	68fb      	ldr	r3, [r7, #12]
 804:	805a      	strh	r2, [r3, #2]

      igmp_ip_output_if(p, &src, dest, group->netif);
 806:	687b      	ldr	r3, [r7, #4]
 808:	685b      	ldr	r3, [r3, #4]
 80a:	f107 0208 	add.w	r2, r7, #8
 80e:	6938      	ldr	r0, [r7, #16]
 810:	4611      	mov	r1, r2
 812:	697a      	ldr	r2, [r7, #20]
 814:	f7ff ff74 	bl	700 <igmp_ip_output_if>
    }

    pbuf_free(p);
 818:	6938      	ldr	r0, [r7, #16]
 81a:	f7ff fffe 	bl	0 <pbuf_free>
			81a: R_ARM_THM_CALL	pbuf_free
  } else {
    LWIP_DEBUGF(IGMP_DEBUG, ("igmp_send: not enough memory for igmp_send\n"));
    IGMP_STATS_INC(igmp.memerr);
  }
}
 81e:	f107 0718 	add.w	r7, r7, #24
 822:	46bd      	mov	sp, r7
 824:	bd80      	pop	{r7, pc}
 826:	bf00      	nop
 828:	00000000 	.word	0x00000000
			828: R_ARM_ABS32	ip_addr_any
 82c:	00000008 	.word	0x00000008
			82c: R_ARM_ABS32	.bss

inet.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  25348 Jul 30 19:07 2021 inet.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_abbrev 0000002a  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000005e  00000000  00000000  0000005e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000020c  00000000  00000000  000000bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 00005a73  00000000  00000000  000002c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubtypes 00000012  00000000  00000000  00005d3b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000c5  00000000  00000000  00005d4d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002b  00000000  00000000  00005e12  2**0
                  CONTENTS, READONLY
 10 .ARM.attributes 00000031  00000000  00000000  00005e3d  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 inet.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes



inet_chksum.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  38612 Jul 30 19:07 2021 inet_chksum.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000484  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000004b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000004b8  2**0
                  ALLOC
  3 .debug_abbrev 00000124  00000000  00000000  000004b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000003bb  00000000  00000000  000005dc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000507  00000000  00000000  00000997  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000799a  00000000  00000000  00000e9e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000118  00000000  00000000  00008838  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000006d  00000000  00000000  00008950  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000060  00000000  00000000  000089bd  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00008a1d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000001e4  00000000  00000000  00008a3d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00008c21  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00008c4c  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000ac  00000000  00000000  00008c80  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 inet_chksum.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     F .text	000000e4 lwip_standard_chksum
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
000000e4 g     F .text	0000014e inet_chksum_pseudo
00000000         *UND*	00000000 lwip_htons
00000234 g     F .text	0000016c inet_chksum_pseudo_partial
000003a0 g     F .text	00000028 inet_chksum
000003c8 g     F .text	000000ba inet_chksum_pbuf



Disassembly of section .text:

00000000 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
   0:	b480      	push	{r7}
   2:	b089      	sub	sp, #36	; 0x24
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
  u8_t *pb = (u8_t *)dataptr;
   a:	687b      	ldr	r3, [r7, #4]
   c:	61fb      	str	r3, [r7, #28]
  u16_t *ps, t = 0;
   e:	f04f 0300 	mov.w	r3, #0
  12:	81fb      	strh	r3, [r7, #14]
  u32_t sum = 0;
  14:	f04f 0300 	mov.w	r3, #0
  18:	617b      	str	r3, [r7, #20]
  int odd = ((mem_ptr_t)pb & 1);
  1a:	69fb      	ldr	r3, [r7, #28]
  1c:	f003 0301 	and.w	r3, r3, #1
  20:	613b      	str	r3, [r7, #16]

  /* Get aligned to u16_t */
  if (odd && len > 0) {
  22:	693b      	ldr	r3, [r7, #16]
  24:	2b00      	cmp	r3, #0
  26:	d011      	beq.n	4c <lwip_standard_chksum+0x4c>
  28:	683b      	ldr	r3, [r7, #0]
  2a:	2b00      	cmp	r3, #0
  2c:	dd0e      	ble.n	4c <lwip_standard_chksum+0x4c>
    ((u8_t *)&t)[1] = *pb++;
  2e:	f107 030e 	add.w	r3, r7, #14
  32:	f103 0301 	add.w	r3, r3, #1
  36:	69fa      	ldr	r2, [r7, #28]
  38:	7812      	ldrb	r2, [r2, #0]
  3a:	701a      	strb	r2, [r3, #0]
  3c:	69fb      	ldr	r3, [r7, #28]
  3e:	f103 0301 	add.w	r3, r3, #1
  42:	61fb      	str	r3, [r7, #28]
    len--;
  44:	683b      	ldr	r3, [r7, #0]
  46:	f103 33ff 	add.w	r3, r3, #4294967295
  4a:	603b      	str	r3, [r7, #0]
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  4c:	69fb      	ldr	r3, [r7, #28]
  4e:	61bb      	str	r3, [r7, #24]
  while (len > 1) {
  50:	e00c      	b.n	6c <lwip_standard_chksum+0x6c>
    sum += *ps++;
  52:	69bb      	ldr	r3, [r7, #24]
  54:	881b      	ldrh	r3, [r3, #0]
  56:	697a      	ldr	r2, [r7, #20]
  58:	18d3      	adds	r3, r2, r3
  5a:	617b      	str	r3, [r7, #20]
  5c:	69bb      	ldr	r3, [r7, #24]
  5e:	f103 0302 	add.w	r3, r3, #2
  62:	61bb      	str	r3, [r7, #24]
    len -= 2;
  64:	683b      	ldr	r3, [r7, #0]
  66:	f1a3 0302 	sub.w	r3, r3, #2
  6a:	603b      	str	r3, [r7, #0]
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
  6c:	683b      	ldr	r3, [r7, #0]
  6e:	2b01      	cmp	r3, #1
  70:	dcef      	bgt.n	52 <lwip_standard_chksum+0x52>
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
  72:	683b      	ldr	r3, [r7, #0]
  74:	2b00      	cmp	r3, #0
  76:	dd04      	ble.n	82 <lwip_standard_chksum+0x82>
    ((u8_t *)&t)[0] = *(u8_t *)ps;
  78:	f107 030e 	add.w	r3, r7, #14
  7c:	69ba      	ldr	r2, [r7, #24]
  7e:	7812      	ldrb	r2, [r2, #0]
  80:	701a      	strb	r2, [r3, #0]
  }

  /* Add end bytes */
  sum += t;
  82:	89fb      	ldrh	r3, [r7, #14]
  84:	697a      	ldr	r2, [r7, #20]
  86:	18d3      	adds	r3, r2, r3
  88:	617b      	str	r3, [r7, #20]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
  8a:	697b      	ldr	r3, [r7, #20]
  8c:	ea4f 4213 	mov.w	r2, r3, lsr #16
  90:	697b      	ldr	r3, [r7, #20]
  92:	ea4f 4303 	mov.w	r3, r3, lsl #16
  96:	ea4f 4313 	mov.w	r3, r3, lsr #16
  9a:	18d3      	adds	r3, r2, r3
  9c:	617b      	str	r3, [r7, #20]
  sum = FOLD_U32T(sum);
  9e:	697b      	ldr	r3, [r7, #20]
  a0:	ea4f 4213 	mov.w	r2, r3, lsr #16
  a4:	697b      	ldr	r3, [r7, #20]
  a6:	ea4f 4303 	mov.w	r3, r3, lsl #16
  aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
  ae:	18d3      	adds	r3, r2, r3
  b0:	617b      	str	r3, [r7, #20]

  /* Swap if alignment was odd */
  if (odd) {
  b2:	693b      	ldr	r3, [r7, #16]
  b4:	2b00      	cmp	r3, #0
  b6:	d00d      	beq.n	d4 <lwip_standard_chksum+0xd4>
    sum = SWAP_BYTES_IN_WORD(sum);
  b8:	697b      	ldr	r3, [r7, #20]
  ba:	ea4f 2303 	mov.w	r3, r3, lsl #8
  be:	ea4f 4303 	mov.w	r3, r3, lsl #16
  c2:	ea4f 4313 	mov.w	r3, r3, lsr #16
  c6:	697a      	ldr	r2, [r7, #20]
  c8:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
  cc:	ea4f 2212 	mov.w	r2, r2, lsr #8
  d0:	4313      	orrs	r3, r2
  d2:	617b      	str	r3, [r7, #20]
  }

  return (u16_t)sum;
  d4:	697b      	ldr	r3, [r7, #20]
  d6:	b29b      	uxth	r3, r3
}
  d8:	4618      	mov	r0, r3
  da:	f107 0724 	add.w	r7, r7, #36	; 0x24
  de:	46bd      	mov	sp, r7
  e0:	bc80      	pop	{r7}
  e2:	4770      	bx	lr

000000e4 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
  e4:	b580      	push	{r7, lr}
  e6:	b088      	sub	sp, #32
  e8:	af00      	add	r7, sp, #0
  ea:	60f8      	str	r0, [r7, #12]
  ec:	60b9      	str	r1, [r7, #8]
  ee:	607a      	str	r2, [r7, #4]
  f0:	70fb      	strb	r3, [r7, #3]
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  f2:	f04f 0300 	mov.w	r3, #0
  f6:	61fb      	str	r3, [r7, #28]
  swapped = 0;
  f8:	f04f 0300 	mov.w	r3, #0
  fc:	75fb      	strb	r3, [r7, #23]
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  fe:	68fb      	ldr	r3, [r7, #12]
 100:	61bb      	str	r3, [r7, #24]
 102:	e031      	b.n	168 <inet_chksum_pseudo+0x84>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 104:	69bb      	ldr	r3, [r7, #24]
 106:	685a      	ldr	r2, [r3, #4]
 108:	69bb      	ldr	r3, [r7, #24]
 10a:	895b      	ldrh	r3, [r3, #10]
 10c:	4610      	mov	r0, r2
 10e:	4619      	mov	r1, r3
 110:	f7ff ff76 	bl	0 <lwip_standard_chksum>
 114:	4603      	mov	r3, r0
 116:	69fa      	ldr	r2, [r7, #28]
 118:	18d3      	adds	r3, r2, r3
 11a:	61fb      	str	r3, [r7, #28]
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 11c:	69fb      	ldr	r3, [r7, #28]
 11e:	ea4f 4213 	mov.w	r2, r3, lsr #16
 122:	69fb      	ldr	r3, [r7, #28]
 124:	ea4f 4303 	mov.w	r3, r3, lsl #16
 128:	ea4f 4313 	mov.w	r3, r3, lsr #16
 12c:	18d3      	adds	r3, r2, r3
 12e:	61fb      	str	r3, [r7, #28]
    if (q->len % 2 != 0) {
 130:	69bb      	ldr	r3, [r7, #24]
 132:	895b      	ldrh	r3, [r3, #10]
 134:	f003 0301 	and.w	r3, r3, #1
 138:	b2db      	uxtb	r3, r3
 13a:	2b00      	cmp	r3, #0
 13c:	d011      	beq.n	162 <inet_chksum_pseudo+0x7e>
      swapped = 1 - swapped;
 13e:	7dfb      	ldrb	r3, [r7, #23]
 140:	f1c3 0301 	rsb	r3, r3, #1
 144:	75fb      	strb	r3, [r7, #23]
      acc = SWAP_BYTES_IN_WORD(acc);
 146:	69fb      	ldr	r3, [r7, #28]
 148:	ea4f 2303 	mov.w	r3, r3, lsl #8
 14c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 150:	ea4f 4313 	mov.w	r3, r3, lsr #16
 154:	69fa      	ldr	r2, [r7, #28]
 156:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 15a:	ea4f 2212 	mov.w	r2, r2, lsr #8
 15e:	4313      	orrs	r3, r2
 160:	61fb      	str	r3, [r7, #28]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 162:	69bb      	ldr	r3, [r7, #24]
 164:	681b      	ldr	r3, [r3, #0]
 166:	61bb      	str	r3, [r7, #24]
 168:	69bb      	ldr	r3, [r7, #24]
 16a:	2b00      	cmp	r3, #0
 16c:	d1ca      	bne.n	104 <inet_chksum_pseudo+0x20>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 16e:	7dfb      	ldrb	r3, [r7, #23]
 170:	2b00      	cmp	r3, #0
 172:	d00d      	beq.n	190 <inet_chksum_pseudo+0xac>
    acc = SWAP_BYTES_IN_WORD(acc);
 174:	69fb      	ldr	r3, [r7, #28]
 176:	ea4f 2303 	mov.w	r3, r3, lsl #8
 17a:	ea4f 4303 	mov.w	r3, r3, lsl #16
 17e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 182:	69fa      	ldr	r2, [r7, #28]
 184:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 188:	ea4f 2212 	mov.w	r2, r2, lsr #8
 18c:	4313      	orrs	r3, r2
 18e:	61fb      	str	r3, [r7, #28]
  }
  addr = ip4_addr_get_u32(src);
 190:	68bb      	ldr	r3, [r7, #8]
 192:	681b      	ldr	r3, [r3, #0]
 194:	613b      	str	r3, [r7, #16]
  acc += (addr & 0xffffUL);
 196:	693b      	ldr	r3, [r7, #16]
 198:	ea4f 4303 	mov.w	r3, r3, lsl #16
 19c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 1a0:	69fa      	ldr	r2, [r7, #28]
 1a2:	18d3      	adds	r3, r2, r3
 1a4:	61fb      	str	r3, [r7, #28]
  acc += ((addr >> 16) & 0xffffUL);
 1a6:	693b      	ldr	r3, [r7, #16]
 1a8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 1ac:	69fa      	ldr	r2, [r7, #28]
 1ae:	18d3      	adds	r3, r2, r3
 1b0:	61fb      	str	r3, [r7, #28]
  addr = ip4_addr_get_u32(dest);
 1b2:	687b      	ldr	r3, [r7, #4]
 1b4:	681b      	ldr	r3, [r3, #0]
 1b6:	613b      	str	r3, [r7, #16]
  acc += (addr & 0xffffUL);
 1b8:	693b      	ldr	r3, [r7, #16]
 1ba:	ea4f 4303 	mov.w	r3, r3, lsl #16
 1be:	ea4f 4313 	mov.w	r3, r3, lsr #16
 1c2:	69fa      	ldr	r2, [r7, #28]
 1c4:	18d3      	adds	r3, r2, r3
 1c6:	61fb      	str	r3, [r7, #28]
  acc += ((addr >> 16) & 0xffffUL);
 1c8:	693b      	ldr	r3, [r7, #16]
 1ca:	ea4f 4313 	mov.w	r3, r3, lsr #16
 1ce:	69fa      	ldr	r2, [r7, #28]
 1d0:	18d3      	adds	r3, r2, r3
 1d2:	61fb      	str	r3, [r7, #28]
  acc += (u32_t)htons((u16_t)proto);
 1d4:	78fb      	ldrb	r3, [r7, #3]
 1d6:	b29b      	uxth	r3, r3
 1d8:	4618      	mov	r0, r3
 1da:	f7ff fffe 	bl	0 <lwip_htons>
			1da: R_ARM_THM_CALL	lwip_htons
 1de:	4603      	mov	r3, r0
 1e0:	69fa      	ldr	r2, [r7, #28]
 1e2:	18d3      	adds	r3, r2, r3
 1e4:	61fb      	str	r3, [r7, #28]
  acc += (u32_t)htons(proto_len);
 1e6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 1e8:	4618      	mov	r0, r3
 1ea:	f7ff fffe 	bl	0 <lwip_htons>
			1ea: R_ARM_THM_CALL	lwip_htons
 1ee:	4603      	mov	r3, r0
 1f0:	69fa      	ldr	r2, [r7, #28]
 1f2:	18d3      	adds	r3, r2, r3
 1f4:	61fb      	str	r3, [r7, #28]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 1f6:	69fb      	ldr	r3, [r7, #28]
 1f8:	ea4f 4213 	mov.w	r2, r3, lsr #16
 1fc:	69fb      	ldr	r3, [r7, #28]
 1fe:	ea4f 4303 	mov.w	r3, r3, lsl #16
 202:	ea4f 4313 	mov.w	r3, r3, lsr #16
 206:	18d3      	adds	r3, r2, r3
 208:	61fb      	str	r3, [r7, #28]
  acc = FOLD_U32T(acc);
 20a:	69fb      	ldr	r3, [r7, #28]
 20c:	ea4f 4213 	mov.w	r2, r3, lsr #16
 210:	69fb      	ldr	r3, [r7, #28]
 212:	ea4f 4303 	mov.w	r3, r3, lsl #16
 216:	ea4f 4313 	mov.w	r3, r3, lsr #16
 21a:	18d3      	adds	r3, r2, r3
 21c:	61fb      	str	r3, [r7, #28]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 21e:	69fb      	ldr	r3, [r7, #28]
 220:	b29b      	uxth	r3, r3
 222:	ea6f 0303 	mvn.w	r3, r3
 226:	b29b      	uxth	r3, r3
}
 228:	4618      	mov	r0, r3
 22a:	f107 0720 	add.w	r7, r7, #32
 22e:	46bd      	mov	sp, r7
 230:	bd80      	pop	{r7, pc}
 232:	bf00      	nop

00000234 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
 234:	b580      	push	{r7, lr}
 236:	b088      	sub	sp, #32
 238:	af00      	add	r7, sp, #0
 23a:	60f8      	str	r0, [r7, #12]
 23c:	60b9      	str	r1, [r7, #8]
 23e:	607a      	str	r2, [r7, #4]
 240:	70fb      	strb	r3, [r7, #3]
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
 242:	f04f 0300 	mov.w	r3, #0
 246:	61fb      	str	r3, [r7, #28]
  swapped = 0;
 248:	f04f 0300 	mov.w	r3, #0
 24c:	75fb      	strb	r3, [r7, #23]
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 24e:	68fb      	ldr	r3, [r7, #12]
 250:	61bb      	str	r3, [r7, #24]
 252:	e03d      	b.n	2d0 <inet_chksum_pseudo_partial+0x9c>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
 254:	69bb      	ldr	r3, [r7, #24]
 256:	895b      	ldrh	r3, [r3, #10]
 258:	82bb      	strh	r3, [r7, #20]
    if (chklen > chksum_len) {
 25a:	8aba      	ldrh	r2, [r7, #20]
 25c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 25e:	429a      	cmp	r2, r3
 260:	d901      	bls.n	266 <inet_chksum_pseudo_partial+0x32>
      chklen = chksum_len;
 262:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 264:	82bb      	strh	r3, [r7, #20]
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 266:	69bb      	ldr	r3, [r7, #24]
 268:	685a      	ldr	r2, [r3, #4]
 26a:	8abb      	ldrh	r3, [r7, #20]
 26c:	4610      	mov	r0, r2
 26e:	4619      	mov	r1, r3
 270:	f7ff fec6 	bl	0 <lwip_standard_chksum>
 274:	4603      	mov	r3, r0
 276:	69fa      	ldr	r2, [r7, #28]
 278:	18d3      	adds	r3, r2, r3
 27a:	61fb      	str	r3, [r7, #28]
    chksum_len -= chklen;
 27c:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 27e:	8abb      	ldrh	r3, [r7, #20]
 280:	1ad3      	subs	r3, r2, r3
 282:	85bb      	strh	r3, [r7, #44]	; 0x2c
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 284:	69fb      	ldr	r3, [r7, #28]
 286:	ea4f 4213 	mov.w	r2, r3, lsr #16
 28a:	69fb      	ldr	r3, [r7, #28]
 28c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 290:	ea4f 4313 	mov.w	r3, r3, lsr #16
 294:	18d3      	adds	r3, r2, r3
 296:	61fb      	str	r3, [r7, #28]
    if (q->len % 2 != 0) {
 298:	69bb      	ldr	r3, [r7, #24]
 29a:	895b      	ldrh	r3, [r3, #10]
 29c:	f003 0301 	and.w	r3, r3, #1
 2a0:	b2db      	uxtb	r3, r3
 2a2:	2b00      	cmp	r3, #0
 2a4:	d011      	beq.n	2ca <inet_chksum_pseudo_partial+0x96>
      swapped = 1 - swapped;
 2a6:	7dfb      	ldrb	r3, [r7, #23]
 2a8:	f1c3 0301 	rsb	r3, r3, #1
 2ac:	75fb      	strb	r3, [r7, #23]
      acc = SWAP_BYTES_IN_WORD(acc);
 2ae:	69fb      	ldr	r3, [r7, #28]
 2b0:	ea4f 2303 	mov.w	r3, r3, lsl #8
 2b4:	ea4f 4303 	mov.w	r3, r3, lsl #16
 2b8:	ea4f 4313 	mov.w	r3, r3, lsr #16
 2bc:	69fa      	ldr	r2, [r7, #28]
 2be:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 2c2:	ea4f 2212 	mov.w	r2, r2, lsr #8
 2c6:	4313      	orrs	r3, r2
 2c8:	61fb      	str	r3, [r7, #28]
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 2ca:	69bb      	ldr	r3, [r7, #24]
 2cc:	681b      	ldr	r3, [r3, #0]
 2ce:	61bb      	str	r3, [r7, #24]
 2d0:	69bb      	ldr	r3, [r7, #24]
 2d2:	2b00      	cmp	r3, #0
 2d4:	d002      	beq.n	2dc <inet_chksum_pseudo_partial+0xa8>
 2d6:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 2d8:	2b00      	cmp	r3, #0
 2da:	d1bb      	bne.n	254 <inet_chksum_pseudo_partial+0x20>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 2dc:	7dfb      	ldrb	r3, [r7, #23]
 2de:	2b00      	cmp	r3, #0
 2e0:	d00d      	beq.n	2fe <inet_chksum_pseudo_partial+0xca>
    acc = SWAP_BYTES_IN_WORD(acc);
 2e2:	69fb      	ldr	r3, [r7, #28]
 2e4:	ea4f 2303 	mov.w	r3, r3, lsl #8
 2e8:	ea4f 4303 	mov.w	r3, r3, lsl #16
 2ec:	ea4f 4313 	mov.w	r3, r3, lsr #16
 2f0:	69fa      	ldr	r2, [r7, #28]
 2f2:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 2f6:	ea4f 2212 	mov.w	r2, r2, lsr #8
 2fa:	4313      	orrs	r3, r2
 2fc:	61fb      	str	r3, [r7, #28]
  }
  addr = ip4_addr_get_u32(src);
 2fe:	68bb      	ldr	r3, [r7, #8]
 300:	681b      	ldr	r3, [r3, #0]
 302:	613b      	str	r3, [r7, #16]
  acc += (addr & 0xffffUL);
 304:	693b      	ldr	r3, [r7, #16]
 306:	ea4f 4303 	mov.w	r3, r3, lsl #16
 30a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 30e:	69fa      	ldr	r2, [r7, #28]
 310:	18d3      	adds	r3, r2, r3
 312:	61fb      	str	r3, [r7, #28]
  acc += ((addr >> 16) & 0xffffUL);
 314:	693b      	ldr	r3, [r7, #16]
 316:	ea4f 4313 	mov.w	r3, r3, lsr #16
 31a:	69fa      	ldr	r2, [r7, #28]
 31c:	18d3      	adds	r3, r2, r3
 31e:	61fb      	str	r3, [r7, #28]
  addr = ip4_addr_get_u32(dest);
 320:	687b      	ldr	r3, [r7, #4]
 322:	681b      	ldr	r3, [r3, #0]
 324:	613b      	str	r3, [r7, #16]
  acc += (addr & 0xffffUL);
 326:	693b      	ldr	r3, [r7, #16]
 328:	ea4f 4303 	mov.w	r3, r3, lsl #16
 32c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 330:	69fa      	ldr	r2, [r7, #28]
 332:	18d3      	adds	r3, r2, r3
 334:	61fb      	str	r3, [r7, #28]
  acc += ((addr >> 16) & 0xffffUL);
 336:	693b      	ldr	r3, [r7, #16]
 338:	ea4f 4313 	mov.w	r3, r3, lsr #16
 33c:	69fa      	ldr	r2, [r7, #28]
 33e:	18d3      	adds	r3, r2, r3
 340:	61fb      	str	r3, [r7, #28]
  acc += (u32_t)htons((u16_t)proto);
 342:	78fb      	ldrb	r3, [r7, #3]
 344:	b29b      	uxth	r3, r3
 346:	4618      	mov	r0, r3
 348:	f7ff fffe 	bl	0 <lwip_htons>
			348: R_ARM_THM_CALL	lwip_htons
 34c:	4603      	mov	r3, r0
 34e:	69fa      	ldr	r2, [r7, #28]
 350:	18d3      	adds	r3, r2, r3
 352:	61fb      	str	r3, [r7, #28]
  acc += (u32_t)htons(proto_len);
 354:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 356:	4618      	mov	r0, r3
 358:	f7ff fffe 	bl	0 <lwip_htons>
			358: R_ARM_THM_CALL	lwip_htons
 35c:	4603      	mov	r3, r0
 35e:	69fa      	ldr	r2, [r7, #28]
 360:	18d3      	adds	r3, r2, r3
 362:	61fb      	str	r3, [r7, #28]

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 364:	69fb      	ldr	r3, [r7, #28]
 366:	ea4f 4213 	mov.w	r2, r3, lsr #16
 36a:	69fb      	ldr	r3, [r7, #28]
 36c:	ea4f 4303 	mov.w	r3, r3, lsl #16
 370:	ea4f 4313 	mov.w	r3, r3, lsr #16
 374:	18d3      	adds	r3, r2, r3
 376:	61fb      	str	r3, [r7, #28]
  acc = FOLD_U32T(acc);
 378:	69fb      	ldr	r3, [r7, #28]
 37a:	ea4f 4213 	mov.w	r2, r3, lsr #16
 37e:	69fb      	ldr	r3, [r7, #28]
 380:	ea4f 4303 	mov.w	r3, r3, lsl #16
 384:	ea4f 4313 	mov.w	r3, r3, lsr #16
 388:	18d3      	adds	r3, r2, r3
 38a:	61fb      	str	r3, [r7, #28]
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 38c:	69fb      	ldr	r3, [r7, #28]
 38e:	b29b      	uxth	r3, r3
 390:	ea6f 0303 	mvn.w	r3, r3
 394:	b29b      	uxth	r3, r3
}
 396:	4618      	mov	r0, r3
 398:	f107 0720 	add.w	r7, r7, #32
 39c:	46bd      	mov	sp, r7
 39e:	bd80      	pop	{r7, pc}

000003a0 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 3a0:	b580      	push	{r7, lr}
 3a2:	b082      	sub	sp, #8
 3a4:	af00      	add	r7, sp, #0
 3a6:	6078      	str	r0, [r7, #4]
 3a8:	460b      	mov	r3, r1
 3aa:	807b      	strh	r3, [r7, #2]
  return ~LWIP_CHKSUM(dataptr, len);
 3ac:	887b      	ldrh	r3, [r7, #2]
 3ae:	6878      	ldr	r0, [r7, #4]
 3b0:	4619      	mov	r1, r3
 3b2:	f7ff fe25 	bl	0 <lwip_standard_chksum>
 3b6:	4603      	mov	r3, r0
 3b8:	ea6f 0303 	mvn.w	r3, r3
 3bc:	b29b      	uxth	r3, r3
}
 3be:	4618      	mov	r0, r3
 3c0:	f107 0708 	add.w	r7, r7, #8
 3c4:	46bd      	mov	sp, r7
 3c6:	bd80      	pop	{r7, pc}

000003c8 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 3c8:	b580      	push	{r7, lr}
 3ca:	b086      	sub	sp, #24
 3cc:	af00      	add	r7, sp, #0
 3ce:	6078      	str	r0, [r7, #4]
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 3d0:	f04f 0300 	mov.w	r3, #0
 3d4:	617b      	str	r3, [r7, #20]
  swapped = 0;
 3d6:	f04f 0300 	mov.w	r3, #0
 3da:	73fb      	strb	r3, [r7, #15]
  for(q = p; q != NULL; q = q->next) {
 3dc:	687b      	ldr	r3, [r7, #4]
 3de:	613b      	str	r3, [r7, #16]
 3e0:	e031      	b.n	446 <inet_chksum_pbuf+0x7e>
    acc += LWIP_CHKSUM(q->payload, q->len);
 3e2:	693b      	ldr	r3, [r7, #16]
 3e4:	685a      	ldr	r2, [r3, #4]
 3e6:	693b      	ldr	r3, [r7, #16]
 3e8:	895b      	ldrh	r3, [r3, #10]
 3ea:	4610      	mov	r0, r2
 3ec:	4619      	mov	r1, r3
 3ee:	f7ff fe07 	bl	0 <lwip_standard_chksum>
 3f2:	4603      	mov	r3, r0
 3f4:	697a      	ldr	r2, [r7, #20]
 3f6:	18d3      	adds	r3, r2, r3
 3f8:	617b      	str	r3, [r7, #20]
    acc = FOLD_U32T(acc);
 3fa:	697b      	ldr	r3, [r7, #20]
 3fc:	ea4f 4213 	mov.w	r2, r3, lsr #16
 400:	697b      	ldr	r3, [r7, #20]
 402:	ea4f 4303 	mov.w	r3, r3, lsl #16
 406:	ea4f 4313 	mov.w	r3, r3, lsr #16
 40a:	18d3      	adds	r3, r2, r3
 40c:	617b      	str	r3, [r7, #20]
    if (q->len % 2 != 0) {
 40e:	693b      	ldr	r3, [r7, #16]
 410:	895b      	ldrh	r3, [r3, #10]
 412:	f003 0301 	and.w	r3, r3, #1
 416:	b2db      	uxtb	r3, r3
 418:	2b00      	cmp	r3, #0
 41a:	d011      	beq.n	440 <inet_chksum_pbuf+0x78>
      swapped = 1 - swapped;
 41c:	7bfb      	ldrb	r3, [r7, #15]
 41e:	f1c3 0301 	rsb	r3, r3, #1
 422:	73fb      	strb	r3, [r7, #15]
      acc = SWAP_BYTES_IN_WORD(acc);
 424:	697b      	ldr	r3, [r7, #20]
 426:	ea4f 2303 	mov.w	r3, r3, lsl #8
 42a:	ea4f 4303 	mov.w	r3, r3, lsl #16
 42e:	ea4f 4313 	mov.w	r3, r3, lsr #16
 432:	697a      	ldr	r2, [r7, #20]
 434:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 438:	ea4f 2212 	mov.w	r2, r2, lsr #8
 43c:	4313      	orrs	r3, r2
 43e:	617b      	str	r3, [r7, #20]
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 440:	693b      	ldr	r3, [r7, #16]
 442:	681b      	ldr	r3, [r3, #0]
 444:	613b      	str	r3, [r7, #16]
 446:	693b      	ldr	r3, [r7, #16]
 448:	2b00      	cmp	r3, #0
 44a:	d1ca      	bne.n	3e2 <inet_chksum_pbuf+0x1a>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 44c:	7bfb      	ldrb	r3, [r7, #15]
 44e:	2b00      	cmp	r3, #0
 450:	d00d      	beq.n	46e <inet_chksum_pbuf+0xa6>
    acc = SWAP_BYTES_IN_WORD(acc);
 452:	697b      	ldr	r3, [r7, #20]
 454:	ea4f 2303 	mov.w	r3, r3, lsl #8
 458:	ea4f 4303 	mov.w	r3, r3, lsl #16
 45c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 460:	697a      	ldr	r2, [r7, #20]
 462:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 466:	ea4f 2212 	mov.w	r2, r2, lsr #8
 46a:	4313      	orrs	r3, r2
 46c:	617b      	str	r3, [r7, #20]
  }
  return (u16_t)~(acc & 0xffffUL);
 46e:	697b      	ldr	r3, [r7, #20]
 470:	b29b      	uxth	r3, r3
 472:	ea6f 0303 	mvn.w	r3, r3
 476:	b29b      	uxth	r3, r3
}
 478:	4618      	mov	r0, r3
 47a:	f107 0718 	add.w	r7, r7, #24
 47e:	46bd      	mov	sp, r7
 480:	bd80      	pop	{r7, pc}
 482:	bf00      	nop

ip.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  60332 Jul 30 19:07 2021 ip.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005a8  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000005dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  000005dc  2**1
                  ALLOC
  3 .debug_abbrev 00000182  00000000  00000000  000005dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000b71  00000000  00000000  0000075e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000061b  00000000  00000000  000012cf  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000b6b8  00000000  00000000  000018ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000118  00000000  00000000  0000cfa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000b2  00000000  00000000  0000d0ba  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000166  00000000  00000000  0000d16c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000d2d2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000580  00000000  00000000  0000d2f2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000d872  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000d89d  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000ac  00000000  00000000  0000d8d0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 ip.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 ip_id
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 current_netif
00000004       O *COM*	00000004 current_header
00000004       O *COM*	00000004 current_iphdr_src
00000004       O *COM*	00000004 current_iphdr_dest
00000000 g     F .text	00000080 ip_route
00000000         *UND*	00000000 netif_list
00000000         *UND*	00000000 netif_default
00000080 g     F .text	00000304 ip_input
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 lwip_ntohs
00000000         *UND*	00000000 pbuf_realloc
00000000         *UND*	00000000 igmp_lookfor_group
00000000         *UND*	00000000 ip4_addr_isbroadcast
00000000         *UND*	00000000 ip_reass
00000000         *UND*	00000000 raw_input
00000000         *UND*	00000000 udp_input
00000000         *UND*	00000000 tcp_input
00000000         *UND*	00000000 icmp_input
00000000         *UND*	00000000 igmp_input
00000000         *UND*	00000000 icmp_dest_unreach
00000384 g     F .text	0000003e ip_output_if
000003c4 g     F .text	00000198 ip_output_if_opt
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 memset
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 ip_frag
0000055c g     F .text	0000004c ip_output



Disassembly of section .text:

00000000 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
   8:	4b1b      	ldr	r3, [pc, #108]	; (78 <ip_route+0x78>)
   a:	681b      	ldr	r3, [r3, #0]
   c:	60fb      	str	r3, [r7, #12]
   e:	e017      	b.n	40 <ip_route+0x40>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  10:	68fb      	ldr	r3, [r7, #12]
  12:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  16:	f003 0301 	and.w	r3, r3, #1
  1a:	b2db      	uxtb	r3, r3
  1c:	2b00      	cmp	r3, #0
  1e:	d00c      	beq.n	3a <ip_route+0x3a>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  20:	687b      	ldr	r3, [r7, #4]
  22:	681a      	ldr	r2, [r3, #0]
  24:	68fb      	ldr	r3, [r7, #12]
  26:	685b      	ldr	r3, [r3, #4]
  28:	405a      	eors	r2, r3
  2a:	68fb      	ldr	r3, [r7, #12]
  2c:	689b      	ldr	r3, [r3, #8]
  2e:	ea02 0303 	and.w	r3, r2, r3
  32:	2b00      	cmp	r3, #0
  34:	d101      	bne.n	3a <ip_route+0x3a>
        /* return netif on which to forward IP packet */
        return netif;
  36:	68fb      	ldr	r3, [r7, #12]
  38:	e017      	b.n	6a <ip_route+0x6a>
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
  3a:	68fb      	ldr	r3, [r7, #12]
  3c:	681b      	ldr	r3, [r3, #0]
  3e:	60fb      	str	r3, [r7, #12]
  40:	68fb      	ldr	r3, [r7, #12]
  42:	2b00      	cmp	r3, #0
  44:	d1e4      	bne.n	10 <ip_route+0x10>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  46:	4b0d      	ldr	r3, [pc, #52]	; (7c <ip_route+0x7c>)
  48:	681b      	ldr	r3, [r3, #0]
  4a:	2b00      	cmp	r3, #0
  4c:	d008      	beq.n	60 <ip_route+0x60>
  4e:	4b0b      	ldr	r3, [pc, #44]	; (7c <ip_route+0x7c>)
  50:	681b      	ldr	r3, [r3, #0]
  52:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  56:	f003 0301 	and.w	r3, r3, #1
  5a:	b2db      	uxtb	r3, r3
  5c:	2b00      	cmp	r3, #0
  5e:	d102      	bne.n	66 <ip_route+0x66>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  60:	f04f 0300 	mov.w	r3, #0
  64:	e001      	b.n	6a <ip_route+0x6a>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  66:	4b05      	ldr	r3, [pc, #20]	; (7c <ip_route+0x7c>)
  68:	681b      	ldr	r3, [r3, #0]
}
  6a:	4618      	mov	r0, r3
  6c:	f107 0714 	add.w	r7, r7, #20
  70:	46bd      	mov	sp, r7
  72:	bc80      	pop	{r7}
  74:	4770      	bx	lr
  76:	bf00      	nop
	...
			78: R_ARM_ABS32	netif_list
			7c: R_ARM_ABS32	netif_default

00000080 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80:	b580      	push	{r7, lr}
  82:	b088      	sub	sp, #32
  84:	af00      	add	r7, sp, #0
  86:	6078      	str	r0, [r7, #4]
  88:	6039      	str	r1, [r7, #0]
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  int check_ip_src=1;
  8a:	f04f 0301 	mov.w	r3, #1
  8e:	617b      	str	r3, [r7, #20]

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  90:	687b      	ldr	r3, [r7, #4]
  92:	685b      	ldr	r3, [r3, #4]
  94:	61fb      	str	r3, [r7, #28]
  if (IPH_V(iphdr) != 4) {
  96:	69fb      	ldr	r3, [r7, #28]
  98:	781b      	ldrb	r3, [r3, #0]
  9a:	ea4f 1313 	mov.w	r3, r3, lsr #4
  9e:	b2db      	uxtb	r3, r3
  a0:	2b04      	cmp	r3, #4
  a2:	d005      	beq.n	b0 <ip_input+0x30>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  a4:	6878      	ldr	r0, [r7, #4]
  a6:	f7ff fffe 	bl	0 <pbuf_free>
			a6: R_ARM_THM_CALL	pbuf_free
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  aa:	f04f 0300 	mov.w	r3, #0
  ae:	e15b      	b.n	368 <ip_input+0x2e8>
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  b0:	69fb      	ldr	r3, [r7, #28]
  b2:	781b      	ldrb	r3, [r3, #0]
  b4:	f003 030f 	and.w	r3, r3, #15
  b8:	81fb      	strh	r3, [r7, #14]
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  ba:	89fb      	ldrh	r3, [r7, #14]
  bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
  c0:	81fb      	strh	r3, [r7, #14]
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  c2:	69fb      	ldr	r3, [r7, #28]
  c4:	885b      	ldrh	r3, [r3, #2]
  c6:	b29b      	uxth	r3, r3
  c8:	4618      	mov	r0, r3
  ca:	f7ff fffe 	bl	0 <lwip_ntohs>
			ca: R_ARM_THM_CALL	lwip_ntohs
  ce:	4603      	mov	r3, r0
  d0:	81bb      	strh	r3, [r7, #12]

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  d2:	687b      	ldr	r3, [r7, #4]
  d4:	895b      	ldrh	r3, [r3, #10]
  d6:	89fa      	ldrh	r2, [r7, #14]
  d8:	429a      	cmp	r2, r3
  da:	d804      	bhi.n	e6 <ip_input+0x66>
  dc:	687b      	ldr	r3, [r7, #4]
  de:	891b      	ldrh	r3, [r3, #8]
  e0:	89ba      	ldrh	r2, [r7, #12]
  e2:	429a      	cmp	r2, r3
  e4:	d905      	bls.n	f2 <ip_input+0x72>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        iphdr_len, p->tot_len));
    }
    /* free (drop) packet pbufs */
    pbuf_free(p);
  e6:	6878      	ldr	r0, [r7, #4]
  e8:	f7ff fffe 	bl	0 <pbuf_free>
			e8: R_ARM_THM_CALL	pbuf_free
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  ec:	f04f 0300 	mov.w	r3, #0
  f0:	e13a      	b.n	368 <ip_input+0x2e8>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  f2:	89bb      	ldrh	r3, [r7, #12]
  f4:	6878      	ldr	r0, [r7, #4]
  f6:	4619      	mov	r1, r3
  f8:	f7ff fffe 	bl	0 <pbuf_realloc>
			f8: R_ARM_THM_CALL	pbuf_realloc

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
  fc:	69fb      	ldr	r3, [r7, #28]
  fe:	691a      	ldr	r2, [r3, #16]
 100:	4b7e      	ldr	r3, [pc, #504]	; (2fc <ip_input+0x27c>)
 102:	601a      	str	r2, [r3, #0]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 104:	69fb      	ldr	r3, [r7, #28]
 106:	68da      	ldr	r2, [r3, #12]
 108:	4b7d      	ldr	r3, [pc, #500]	; (300 <ip_input+0x280>)
 10a:	601a      	str	r2, [r3, #0]

  /* match packet against an interface, i.e. is this packet for us? */
#if LWIP_IGMP
  if (ip_addr_ismulticast(&current_iphdr_dest)) {
 10c:	4b7b      	ldr	r3, [pc, #492]	; (2fc <ip_input+0x27c>)
 10e:	681b      	ldr	r3, [r3, #0]
 110:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 114:	2be0      	cmp	r3, #224	; 0xe0
 116:	d114      	bne.n	142 <ip_input+0xc2>
    if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, &current_iphdr_dest))) {
 118:	683b      	ldr	r3, [r7, #0]
 11a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 11e:	b2db      	uxtb	r3, r3
 120:	b25b      	sxtb	r3, r3
 122:	2b00      	cmp	r3, #0
 124:	da09      	bge.n	13a <ip_input+0xba>
 126:	6838      	ldr	r0, [r7, #0]
 128:	4974      	ldr	r1, [pc, #464]	; (2fc <ip_input+0x27c>)
 12a:	f7ff fffe 	bl	0 <igmp_lookfor_group>
			12a: R_ARM_THM_CALL	igmp_lookfor_group
 12e:	4603      	mov	r3, r0
 130:	2b00      	cmp	r3, #0
 132:	d002      	beq.n	13a <ip_input+0xba>
      netif = inp;
 134:	683b      	ldr	r3, [r7, #0]
 136:	61bb      	str	r3, [r7, #24]
 138:	e03f      	b.n	1ba <ip_input+0x13a>
    } else {
      netif = NULL;
 13a:	f04f 0300 	mov.w	r3, #0
 13e:	61bb      	str	r3, [r7, #24]
 140:	e03b      	b.n	1ba <ip_input+0x13a>
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 142:	f04f 0301 	mov.w	r3, #1
 146:	613b      	str	r3, [r7, #16]
    netif = inp;
 148:	683b      	ldr	r3, [r7, #0]
 14a:	61bb      	str	r3, [r7, #24]
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 14c:	69bb      	ldr	r3, [r7, #24]
 14e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 152:	f003 0301 	and.w	r3, r3, #1
 156:	b2db      	uxtb	r3, r3
 158:	2b00      	cmp	r3, #0
 15a:	d017      	beq.n	18c <ip_input+0x10c>
 15c:	69bb      	ldr	r3, [r7, #24]
 15e:	f103 0304 	add.w	r3, r3, #4
 162:	2b00      	cmp	r3, #0
 164:	d012      	beq.n	18c <ip_input+0x10c>
 166:	69bb      	ldr	r3, [r7, #24]
 168:	685b      	ldr	r3, [r3, #4]
 16a:	2b00      	cmp	r3, #0
 16c:	d00e      	beq.n	18c <ip_input+0x10c>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 16e:	4b63      	ldr	r3, [pc, #396]	; (2fc <ip_input+0x27c>)
 170:	681a      	ldr	r2, [r3, #0]
 172:	69bb      	ldr	r3, [r7, #24]
 174:	685b      	ldr	r3, [r3, #4]
 176:	429a      	cmp	r2, r3
 178:	d01f      	beq.n	1ba <ip_input+0x13a>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 17a:	4b60      	ldr	r3, [pc, #384]	; (2fc <ip_input+0x27c>)
 17c:	681b      	ldr	r3, [r3, #0]
 17e:	4618      	mov	r0, r3
 180:	69b9      	ldr	r1, [r7, #24]
 182:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			182: R_ARM_THM_CALL	ip4_addr_isbroadcast
 186:	4603      	mov	r3, r0
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 188:	2b00      	cmp	r3, #0
 18a:	d116      	bne.n	1ba <ip_input+0x13a>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
 18c:	693b      	ldr	r3, [r7, #16]
 18e:	2b00      	cmp	r3, #0
 190:	d006      	beq.n	1a0 <ip_input+0x120>
        first = 0;
 192:	f04f 0300 	mov.w	r3, #0
 196:	613b      	str	r3, [r7, #16]
        netif = netif_list;
 198:	4b5a      	ldr	r3, [pc, #360]	; (304 <ip_input+0x284>)
 19a:	681b      	ldr	r3, [r3, #0]
 19c:	61bb      	str	r3, [r7, #24]
 19e:	e002      	b.n	1a6 <ip_input+0x126>
      } else {
        netif = netif->next;
 1a0:	69bb      	ldr	r3, [r7, #24]
 1a2:	681b      	ldr	r3, [r3, #0]
 1a4:	61bb      	str	r3, [r7, #24]
      }
      if (netif == inp) {
 1a6:	69ba      	ldr	r2, [r7, #24]
 1a8:	683b      	ldr	r3, [r7, #0]
 1aa:	429a      	cmp	r2, r3
 1ac:	d102      	bne.n	1b4 <ip_input+0x134>
        netif = netif->next;
 1ae:	69bb      	ldr	r3, [r7, #24]
 1b0:	681b      	ldr	r3, [r3, #0]
 1b2:	61bb      	str	r3, [r7, #24]
      }
    } while(netif != NULL);
 1b4:	69bb      	ldr	r3, [r7, #24]
 1b6:	2b00      	cmp	r3, #0
 1b8:	d1c8      	bne.n	14c <ip_input+0xcc>
   * If you want to accept private broadcast communication while a netif is down,
   * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
   *
   * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
   */
  if (netif == NULL) {
 1ba:	69bb      	ldr	r3, [r7, #24]
 1bc:	2b00      	cmp	r3, #0
 1be:	d112      	bne.n	1e6 <ip_input+0x166>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
 1c0:	69fb      	ldr	r3, [r7, #28]
 1c2:	7a5b      	ldrb	r3, [r3, #9]
 1c4:	2b11      	cmp	r3, #17
 1c6:	d10e      	bne.n	1e6 <ip_input+0x166>
      struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
 1c8:	69fa      	ldr	r2, [r7, #28]
 1ca:	89fb      	ldrh	r3, [r7, #14]
 1cc:	18d3      	adds	r3, r2, r3
 1ce:	60bb      	str	r3, [r7, #8]
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(udphdr->dest)));
      if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
 1d0:	68bb      	ldr	r3, [r7, #8]
 1d2:	885b      	ldrh	r3, [r3, #2]
 1d4:	b29b      	uxth	r3, r3
 1d6:	f5b3 4f88 	cmp.w	r3, #17408	; 0x4400
 1da:	d104      	bne.n	1e6 <ip_input+0x166>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
 1dc:	683b      	ldr	r3, [r7, #0]
 1de:	61bb      	str	r3, [r7, #24]
        check_ip_src = 0;
 1e0:	f04f 0300 	mov.w	r3, #0
 1e4:	617b      	str	r3, [r7, #20]
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
 1e6:	697b      	ldr	r3, [r7, #20]
 1e8:	2b00      	cmp	r3, #0
 1ea:	d018      	beq.n	21e <ip_input+0x19e>
 1ec:	4b44      	ldr	r3, [pc, #272]	; (300 <ip_input+0x280>)
 1ee:	681b      	ldr	r3, [r3, #0]
 1f0:	2b00      	cmp	r3, #0
 1f2:	d014      	beq.n	21e <ip_input+0x19e>
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 1f4:	4b42      	ldr	r3, [pc, #264]	; (300 <ip_input+0x280>)
 1f6:	681b      	ldr	r3, [r3, #0]
 1f8:	4618      	mov	r0, r3
 1fa:	6839      	ldr	r1, [r7, #0]
 1fc:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			1fc: R_ARM_THM_CALL	ip4_addr_isbroadcast
 200:	4603      	mov	r3, r0
 202:	2b00      	cmp	r3, #0
 204:	d105      	bne.n	212 <ip_input+0x192>
         (ip_addr_ismulticast(&current_iphdr_src))) {
 206:	4b3e      	ldr	r3, [pc, #248]	; (300 <ip_input+0x280>)
 208:	681b      	ldr	r3, [r3, #0]
 20a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 20e:	2be0      	cmp	r3, #224	; 0xe0
 210:	d105      	bne.n	21e <ip_input+0x19e>
         (ip_addr_ismulticast(&current_iphdr_src))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
 212:	6878      	ldr	r0, [r7, #4]
 214:	f7ff fffe 	bl	0 <pbuf_free>
			214: R_ARM_THM_CALL	pbuf_free
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
 218:	f04f 0300 	mov.w	r3, #0
 21c:	e0a4      	b.n	368 <ip_input+0x2e8>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 21e:	69bb      	ldr	r3, [r7, #24]
 220:	2b00      	cmp	r3, #0
 222:	d105      	bne.n	230 <ip_input+0x1b0>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
 224:	6878      	ldr	r0, [r7, #4]
 226:	f7ff fffe 	bl	0 <pbuf_free>
			226: R_ARM_THM_CALL	pbuf_free
    return ERR_OK;
 22a:	f04f 0300 	mov.w	r3, #0
 22e:	e09b      	b.n	368 <ip_input+0x2e8>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 230:	69fb      	ldr	r3, [r7, #28]
 232:	88db      	ldrh	r3, [r3, #6]
 234:	b29b      	uxth	r3, r3
 236:	461a      	mov	r2, r3
 238:	f64f 733f 	movw	r3, #65343	; 0xff3f
 23c:	ea02 0303 	and.w	r3, r2, r3
 240:	2b00      	cmp	r3, #0
 242:	d00c      	beq.n	25e <ip_input+0x1de>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 244:	6878      	ldr	r0, [r7, #4]
 246:	f7ff fffe 	bl	0 <ip_reass>
			246: R_ARM_THM_CALL	ip_reass
 24a:	6078      	str	r0, [r7, #4]
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 24c:	687b      	ldr	r3, [r7, #4]
 24e:	2b00      	cmp	r3, #0
 250:	d102      	bne.n	258 <ip_input+0x1d8>
      return ERR_OK;
 252:	f04f 0300 	mov.w	r3, #0
 256:	e087      	b.n	368 <ip_input+0x2e8>
    }
    iphdr = (struct ip_hdr *)p->payload;
 258:	687b      	ldr	r3, [r7, #4]
 25a:	685b      	ldr	r3, [r3, #4]
 25c:	61fb      	str	r3, [r7, #28]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 25e:	4b2a      	ldr	r3, [pc, #168]	; (308 <ip_input+0x288>)
 260:	683a      	ldr	r2, [r7, #0]
 262:	601a      	str	r2, [r3, #0]
  current_header = iphdr;
 264:	4b29      	ldr	r3, [pc, #164]	; (30c <ip_input+0x28c>)
 266:	69fa      	ldr	r2, [r7, #28]
 268:	601a      	str	r2, [r3, #0]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 26a:	6878      	ldr	r0, [r7, #4]
 26c:	6839      	ldr	r1, [r7, #0]
 26e:	f7ff fffe 	bl	0 <raw_input>
			26e: R_ARM_THM_CALL	raw_input
 272:	4603      	mov	r3, r0
 274:	2b00      	cmp	r3, #0
 276:	d165      	bne.n	344 <ip_input+0x2c4>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
 278:	69fb      	ldr	r3, [r7, #28]
 27a:	7a5b      	ldrb	r3, [r3, #9]
 27c:	f103 33ff 	add.w	r3, r3, #4294967295
 280:	2b10      	cmp	r3, #16
 282:	d845      	bhi.n	310 <ip_input+0x290>
 284:	a201      	add	r2, pc, #4	; (adr r2, 28c <ip_input+0x20c>)
 286:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 28a:	bf00      	nop
 28c:	000002e5 	.word	0x000002e5
			28c: R_ARM_ABS32	.text
 290:	000002ef 	.word	0x000002ef
			290: R_ARM_ABS32	.text
 294:	00000311 	.word	0x00000311
			294: R_ARM_ABS32	.text
 298:	00000311 	.word	0x00000311
			298: R_ARM_ABS32	.text
 29c:	00000311 	.word	0x00000311
			29c: R_ARM_ABS32	.text
 2a0:	000002db 	.word	0x000002db
			2a0: R_ARM_ABS32	.text
 2a4:	00000311 	.word	0x00000311
			2a4: R_ARM_ABS32	.text
 2a8:	00000311 	.word	0x00000311
			2a8: R_ARM_ABS32	.text
 2ac:	00000311 	.word	0x00000311
			2ac: R_ARM_ABS32	.text
 2b0:	00000311 	.word	0x00000311
			2b0: R_ARM_ABS32	.text
 2b4:	00000311 	.word	0x00000311
			2b4: R_ARM_ABS32	.text
 2b8:	00000311 	.word	0x00000311
			2b8: R_ARM_ABS32	.text
 2bc:	00000311 	.word	0x00000311
			2bc: R_ARM_ABS32	.text
 2c0:	00000311 	.word	0x00000311
			2c0: R_ARM_ABS32	.text
 2c4:	00000311 	.word	0x00000311
			2c4: R_ARM_ABS32	.text
 2c8:	00000311 	.word	0x00000311
			2c8: R_ARM_ABS32	.text
 2cc:	000002d1 	.word	0x000002d1
			2cc: R_ARM_ABS32	.text
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 2d0:	6878      	ldr	r0, [r7, #4]
 2d2:	6839      	ldr	r1, [r7, #0]
 2d4:	f7ff fffe 	bl	0 <udp_input>
			2d4: R_ARM_THM_CALL	udp_input
      break;
 2d8:	e034      	b.n	344 <ip_input+0x2c4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 2da:	6878      	ldr	r0, [r7, #4]
 2dc:	6839      	ldr	r1, [r7, #0]
 2de:	f7ff fffe 	bl	0 <tcp_input>
			2de: R_ARM_THM_CALL	tcp_input
      break;
 2e2:	e02f      	b.n	344 <ip_input+0x2c4>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 2e4:	6878      	ldr	r0, [r7, #4]
 2e6:	6839      	ldr	r1, [r7, #0]
 2e8:	f7ff fffe 	bl	0 <icmp_input>
			2e8: R_ARM_THM_CALL	icmp_input
      break;
 2ec:	e02a      	b.n	344 <ip_input+0x2c4>
#endif /* LWIP_ICMP */
#if LWIP_IGMP
    case IP_PROTO_IGMP:
      igmp_input(p, inp, &current_iphdr_dest);
 2ee:	6878      	ldr	r0, [r7, #4]
 2f0:	6839      	ldr	r1, [r7, #0]
 2f2:	4a02      	ldr	r2, [pc, #8]	; (2fc <ip_input+0x27c>)
 2f4:	f7ff fffe 	bl	0 <igmp_input>
			2f4: R_ARM_THM_CALL	igmp_input
      break;
 2f8:	e024      	b.n	344 <ip_input+0x2c4>
 2fa:	bf00      	nop
	...
			2fc: R_ARM_ABS32	current_iphdr_dest
			300: R_ARM_ABS32	current_iphdr_src
			304: R_ARM_ABS32	netif_list
			308: R_ARM_ABS32	current_netif
			30c: R_ARM_ABS32	current_header
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 310:	4b18      	ldr	r3, [pc, #96]	; (64 <ip4_addr_isbroadcast+0x64>)
 312:	681b      	ldr	r3, [r3, #0]
 314:	4618      	mov	r0, r3
 316:	6839      	ldr	r1, [r7, #0]
 318:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			318: R_ARM_THM_CALL	ip4_addr_isbroadcast
 31c:	4603      	mov	r3, r0
 31e:	2b00      	cmp	r3, #0
 320:	d10d      	bne.n	33e <ip_input+0x2be>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
 322:	4b14      	ldr	r3, [pc, #80]	; (374 <ip_input+0x2f4>)
 324:	681b      	ldr	r3, [r3, #0]
 326:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 32a:	2be0      	cmp	r3, #224	; 0xe0
 32c:	d007      	beq.n	33e <ip_input+0x2be>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
 32e:	687b      	ldr	r3, [r7, #4]
 330:	69fa      	ldr	r2, [r7, #28]
 332:	605a      	str	r2, [r3, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 334:	6878      	ldr	r0, [r7, #4]
 336:	f04f 0102 	mov.w	r1, #2
 33a:	f7ff fffe 	bl	0 <icmp_dest_unreach>
			33a: R_ARM_THM_CALL	icmp_dest_unreach
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 33e:	6878      	ldr	r0, [r7, #4]
 340:	f7ff fffe 	bl	0 <pbuf_free>
			340: R_ARM_THM_CALL	pbuf_free
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 344:	4b0c      	ldr	r3, [pc, #48]	; (378 <ip_input+0x2f8>)
 346:	f04f 0200 	mov.w	r2, #0
 34a:	601a      	str	r2, [r3, #0]
  current_header = NULL;
 34c:	4b0b      	ldr	r3, [pc, #44]	; (37c <ip_input+0x2fc>)
 34e:	f04f 0200 	mov.w	r2, #0
 352:	601a      	str	r2, [r3, #0]
  ip_addr_set_any(&current_iphdr_src);
 354:	4b0a      	ldr	r3, [pc, #40]	; (380 <ip_input+0x300>)
 356:	f04f 0200 	mov.w	r2, #0
 35a:	601a      	str	r2, [r3, #0]
  ip_addr_set_any(&current_iphdr_dest);
 35c:	4b05      	ldr	r3, [pc, #20]	; (374 <ip_input+0x2f4>)
 35e:	f04f 0200 	mov.w	r2, #0
 362:	601a      	str	r2, [r3, #0]

  return ERR_OK;
 364:	f04f 0300 	mov.w	r3, #0
 368:	b25b      	sxtb	r3, r3
}
 36a:	4618      	mov	r0, r3
 36c:	f107 0720 	add.w	r7, r7, #32
 370:	46bd      	mov	sp, r7
 372:	bd80      	pop	{r7, pc}
	...
			374: R_ARM_ABS32	current_iphdr_dest
			378: R_ARM_ABS32	current_netif
			37c: R_ARM_ABS32	current_header
			380: R_ARM_ABS32	current_iphdr_src

00000384 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 384:	b580      	push	{r7, lr}
 386:	b08a      	sub	sp, #40	; 0x28
 388:	af06      	add	r7, sp, #24
 38a:	60f8      	str	r0, [r7, #12]
 38c:	60b9      	str	r1, [r7, #8]
 38e:	607a      	str	r2, [r7, #4]
 390:	70fb      	strb	r3, [r7, #3]
#if IP_OPTIONS_SEND
  return ip_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
 392:	78fb      	ldrb	r3, [r7, #3]
 394:	7e3a      	ldrb	r2, [r7, #24]
 396:	9200      	str	r2, [sp, #0]
 398:	7f3a      	ldrb	r2, [r7, #28]
 39a:	9201      	str	r2, [sp, #4]
 39c:	6a3a      	ldr	r2, [r7, #32]
 39e:	9202      	str	r2, [sp, #8]
 3a0:	f04f 0200 	mov.w	r2, #0
 3a4:	9203      	str	r2, [sp, #12]
 3a6:	f04f 0200 	mov.w	r2, #0
 3aa:	9204      	str	r2, [sp, #16]
 3ac:	68f8      	ldr	r0, [r7, #12]
 3ae:	68b9      	ldr	r1, [r7, #8]
 3b0:	687a      	ldr	r2, [r7, #4]
 3b2:	f7ff fffe 	bl	3c4 <ip_output_if_opt>
			3b2: R_ARM_THM_CALL	ip_output_if_opt
 3b6:	4603      	mov	r3, r0
}
 3b8:	4618      	mov	r0, r3
 3ba:	f107 0710 	add.w	r7, r7, #16
 3be:	46bd      	mov	sp, r7
 3c0:	bd80      	pop	{r7, pc}
 3c2:	bf00      	nop

000003c4 <ip_output_if_opt>:
 * @ param optlen length of ip_options
 */
err_t ip_output_if_opt(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
       u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
       u16_t optlen)
{
 3c4:	b580      	push	{r7, lr}
 3c6:	b088      	sub	sp, #32
 3c8:	af00      	add	r7, sp, #0
 3ca:	60f8      	str	r0, [r7, #12]
 3cc:	60b9      	str	r1, [r7, #8]
 3ce:	607a      	str	r2, [r7, #4]
 3d0:	70fb      	strb	r3, [r7, #3]
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 3d2:	687b      	ldr	r3, [r7, #4]
 3d4:	2b00      	cmp	r3, #0
 3d6:	f000 8098 	beq.w	50a <ip_output_if_opt+0x146>
    u16_t ip_hlen = IP_HLEN;
 3da:	f04f 0314 	mov.w	r3, #20
 3de:	83fb      	strh	r3, [r7, #30]
#if IP_OPTIONS_SEND
    u16_t optlen_aligned = 0;
 3e0:	f04f 0300 	mov.w	r3, #0
 3e4:	83bb      	strh	r3, [r7, #28]
    if (optlen != 0) {
 3e6:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 3e8:	2b00      	cmp	r3, #0
 3ea:	d02f      	beq.n	44c <ip_output_if_opt+0x88>
#if CHECKSUM_GEN_IP_INLINE
      int i;
#endif /* CHECKSUM_GEN_IP_INLINE */
      /* round up to a multiple of 4 */
      optlen_aligned = ((optlen + 3) & ~3);
 3ec:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 3ee:	f103 0303 	add.w	r3, r3, #3
 3f2:	b29b      	uxth	r3, r3
 3f4:	f023 0303 	bic.w	r3, r3, #3
 3f8:	83bb      	strh	r3, [r7, #28]
      ip_hlen += optlen_aligned;
 3fa:	8bfa      	ldrh	r2, [r7, #30]
 3fc:	8bbb      	ldrh	r3, [r7, #28]
 3fe:	18d3      	adds	r3, r2, r3
 400:	83fb      	strh	r3, [r7, #30]
      /* First write in the IP options */
      if (pbuf_header(p, optlen_aligned)) {
 402:	8bbb      	ldrh	r3, [r7, #28]
 404:	b21b      	sxth	r3, r3
 406:	68f8      	ldr	r0, [r7, #12]
 408:	4619      	mov	r1, r3
 40a:	f7ff fffe 	bl	0 <pbuf_header>
			40a: R_ARM_THM_CALL	pbuf_header
 40e:	4603      	mov	r3, r0
 410:	2b00      	cmp	r3, #0
 412:	d002      	beq.n	41a <ip_output_if_opt+0x56>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output_if_opt: not enough room for IP options in pbuf\n"));
        IP_STATS_INC(ip.err);
        snmp_inc_ipoutdiscards();
        return ERR_BUF;
 414:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 418:	e098      	b.n	54c <ip_output_if_opt+0x188>
      }
      MEMCPY(p->payload, ip_options, optlen);
 41a:	68fb      	ldr	r3, [r7, #12]
 41c:	685a      	ldr	r2, [r3, #4]
 41e:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 420:	4610      	mov	r0, r2
 422:	6b79      	ldr	r1, [r7, #52]	; 0x34
 424:	461a      	mov	r2, r3
 426:	f7ff fffe 	bl	0 <memcpy>
			426: R_ARM_THM_CALL	memcpy
      if (optlen < optlen_aligned) {
 42a:	8f3a      	ldrh	r2, [r7, #56]	; 0x38
 42c:	8bbb      	ldrh	r3, [r7, #28]
 42e:	429a      	cmp	r2, r3
 430:	d20c      	bcs.n	44c <ip_output_if_opt+0x88>
        /* zero the remaining bytes */
        memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
 432:	68fb      	ldr	r3, [r7, #12]
 434:	685a      	ldr	r2, [r3, #4]
 436:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 438:	18d2      	adds	r2, r2, r3
 43a:	8bb9      	ldrh	r1, [r7, #28]
 43c:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 43e:	1acb      	subs	r3, r1, r3
 440:	4610      	mov	r0, r2
 442:	f04f 0100 	mov.w	r1, #0
 446:	461a      	mov	r2, r3
 448:	f7ff fffe 	bl	0 <memset>
			448: R_ARM_THM_CALL	memset
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 44c:	68f8      	ldr	r0, [r7, #12]
 44e:	f04f 0114 	mov.w	r1, #20
 452:	f7ff fffe 	bl	0 <pbuf_header>
			452: R_ARM_THM_CALL	pbuf_header
 456:	4603      	mov	r3, r0
 458:	2b00      	cmp	r3, #0
 45a:	d002      	beq.n	462 <ip_output_if_opt+0x9e>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 45c:	f04f 03fe 	mov.w	r3, #254	; 0xfe
 460:	e074      	b.n	54c <ip_output_if_opt+0x188>
    }

    iphdr = (struct ip_hdr *)p->payload;
 462:	68fb      	ldr	r3, [r7, #12]
 464:	685b      	ldr	r3, [r3, #4]
 466:	61bb      	str	r3, [r7, #24]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 468:	69bb      	ldr	r3, [r7, #24]
 46a:	78fa      	ldrb	r2, [r7, #3]
 46c:	721a      	strb	r2, [r3, #8]
    IPH_PROTO_SET(iphdr, proto);
 46e:	69bb      	ldr	r3, [r7, #24]
 470:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 474:	725a      	strb	r2, [r3, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 476:	687b      	ldr	r3, [r7, #4]
 478:	681a      	ldr	r2, [r3, #0]
 47a:	69bb      	ldr	r3, [r7, #24]
 47c:	611a      	str	r2, [r3, #16]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 47e:	8bfb      	ldrh	r3, [r7, #30]
 480:	ea4f 0393 	mov.w	r3, r3, lsr #2
 484:	b29b      	uxth	r3, r3
 486:	b2db      	uxtb	r3, r3
 488:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 48c:	b2da      	uxtb	r2, r3
 48e:	69bb      	ldr	r3, [r7, #24]
 490:	701a      	strb	r2, [r3, #0]
    IPH_TOS_SET(iphdr, tos);
 492:	69bb      	ldr	r3, [r7, #24]
 494:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
 498:	705a      	strb	r2, [r3, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 49a:	68fb      	ldr	r3, [r7, #12]
 49c:	891b      	ldrh	r3, [r3, #8]
 49e:	4618      	mov	r0, r3
 4a0:	f7ff fffe 	bl	0 <lwip_htons>
			4a0: R_ARM_THM_CALL	lwip_htons
 4a4:	4603      	mov	r3, r0
 4a6:	461a      	mov	r2, r3
 4a8:	69bb      	ldr	r3, [r7, #24]
 4aa:	805a      	strh	r2, [r3, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 4ac:	69bb      	ldr	r3, [r7, #24]
 4ae:	f04f 0200 	mov.w	r2, #0
 4b2:	719a      	strb	r2, [r3, #6]
 4b4:	f04f 0200 	mov.w	r2, #0
 4b8:	71da      	strb	r2, [r3, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 4ba:	4b27      	ldr	r3, [pc, #156]	; (558 <ip_output_if_opt+0x194>)
 4bc:	881b      	ldrh	r3, [r3, #0]
 4be:	4618      	mov	r0, r3
 4c0:	f7ff fffe 	bl	0 <lwip_htons>
			4c0: R_ARM_THM_CALL	lwip_htons
 4c4:	4603      	mov	r3, r0
 4c6:	461a      	mov	r2, r3
 4c8:	69bb      	ldr	r3, [r7, #24]
 4ca:	809a      	strh	r2, [r3, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 4cc:	4b22      	ldr	r3, [pc, #136]	; (558 <ip_output_if_opt+0x194>)
 4ce:	881b      	ldrh	r3, [r3, #0]
 4d0:	f103 0301 	add.w	r3, r3, #1
 4d4:	b29a      	uxth	r2, r3
 4d6:	4b20      	ldr	r3, [pc, #128]	; (558 <ip_output_if_opt+0x194>)
 4d8:	801a      	strh	r2, [r3, #0]

    if (ip_addr_isany(src)) {
 4da:	68bb      	ldr	r3, [r7, #8]
 4dc:	2b00      	cmp	r3, #0
 4de:	d003      	beq.n	4e8 <ip_output_if_opt+0x124>
 4e0:	68bb      	ldr	r3, [r7, #8]
 4e2:	681b      	ldr	r3, [r3, #0]
 4e4:	2b00      	cmp	r3, #0
 4e6:	d104      	bne.n	4f2 <ip_output_if_opt+0x12e>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 4e8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 4ea:	685a      	ldr	r2, [r3, #4]
 4ec:	69bb      	ldr	r3, [r7, #24]
 4ee:	60da      	str	r2, [r3, #12]
 4f0:	e003      	b.n	4fa <ip_output_if_opt+0x136>
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
 4f2:	68bb      	ldr	r3, [r7, #8]
 4f4:	681a      	ldr	r2, [r3, #0]
 4f6:	69bb      	ldr	r3, [r7, #24]
 4f8:	60da      	str	r2, [r3, #12]
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
    chk_sum = (chk_sum >> 16) + chk_sum;
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
#else /* CHECKSUM_GEN_IP_INLINE */
    IPH_CHKSUM_SET(iphdr, 0);
 4fa:	69bb      	ldr	r3, [r7, #24]
 4fc:	f04f 0200 	mov.w	r2, #0
 500:	729a      	strb	r2, [r3, #10]
 502:	f04f 0200 	mov.w	r2, #0
 506:	72da      	strb	r2, [r3, #11]
 508:	e008      	b.n	51c <ip_output_if_opt+0x158>
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
 50a:	68fb      	ldr	r3, [r7, #12]
 50c:	685b      	ldr	r3, [r3, #4]
 50e:	61bb      	str	r3, [r7, #24]
    ip_addr_copy(dest_addr, iphdr->dest);
 510:	69bb      	ldr	r3, [r7, #24]
 512:	691b      	ldr	r3, [r3, #16]
 514:	617b      	str	r3, [r7, #20]
    dest = &dest_addr;
 516:	f107 0314 	add.w	r3, r7, #20
 51a:	607b      	str	r3, [r7, #4]
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 51c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 51e:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 520:	2b00      	cmp	r3, #0
 522:	d00c      	beq.n	53e <ip_output_if_opt+0x17a>
 524:	68fb      	ldr	r3, [r7, #12]
 526:	891a      	ldrh	r2, [r3, #8]
 528:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 52a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 52c:	429a      	cmp	r2, r3
 52e:	d906      	bls.n	53e <ip_output_if_opt+0x17a>
    return ip_frag(p, netif, dest);
 530:	68f8      	ldr	r0, [r7, #12]
 532:	6b39      	ldr	r1, [r7, #48]	; 0x30
 534:	687a      	ldr	r2, [r7, #4]
 536:	f7ff fffe 	bl	0 <ip_frag>
			536: R_ARM_THM_CALL	ip_frag
 53a:	4603      	mov	r3, r0
 53c:	e006      	b.n	54c <ip_output_if_opt+0x188>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 53e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 540:	695b      	ldr	r3, [r3, #20]
 542:	6b38      	ldr	r0, [r7, #48]	; 0x30
 544:	68f9      	ldr	r1, [r7, #12]
 546:	687a      	ldr	r2, [r7, #4]
 548:	4798      	blx	r3
 54a:	4603      	mov	r3, r0
 54c:	b25b      	sxtb	r3, r3
}
 54e:	4618      	mov	r0, r3
 550:	f107 0720 	add.w	r7, r7, #32
 554:	46bd      	mov	sp, r7
 556:	bd80      	pop	{r7, pc}
 558:	00000000 	.word	0x00000000
			558: R_ARM_ABS32	.bss

0000055c <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 55c:	b580      	push	{r7, lr}
 55e:	b08a      	sub	sp, #40	; 0x28
 560:	af04      	add	r7, sp, #16
 562:	60f8      	str	r0, [r7, #12]
 564:	60b9      	str	r1, [r7, #8]
 566:	607a      	str	r2, [r7, #4]
 568:	70fb      	strb	r3, [r7, #3]

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);

  if ((netif = ip_route(dest)) == NULL) {
 56a:	6878      	ldr	r0, [r7, #4]
 56c:	f7ff fffe 	bl	0 <ip_route>
			56c: R_ARM_THM_CALL	ip_route
 570:	6178      	str	r0, [r7, #20]
 572:	697b      	ldr	r3, [r7, #20]
 574:	2b00      	cmp	r3, #0
 576:	d102      	bne.n	57e <ip_output+0x22>
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
 578:	f04f 03fc 	mov.w	r3, #252	; 0xfc
 57c:	e00e      	b.n	59c <ip_output+0x40>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 57e:	78fb      	ldrb	r3, [r7, #3]
 580:	f897 2020 	ldrb.w	r2, [r7, #32]
 584:	9200      	str	r2, [sp, #0]
 586:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
 58a:	9201      	str	r2, [sp, #4]
 58c:	697a      	ldr	r2, [r7, #20]
 58e:	9202      	str	r2, [sp, #8]
 590:	68f8      	ldr	r0, [r7, #12]
 592:	68b9      	ldr	r1, [r7, #8]
 594:	687a      	ldr	r2, [r7, #4]
 596:	f7ff fffe 	bl	384 <ip_output_if>
			596: R_ARM_THM_CALL	ip_output_if
 59a:	4603      	mov	r3, r0
 59c:	b25b      	sxtb	r3, r3
}
 59e:	4618      	mov	r0, r3
 5a0:	f107 0718 	add.w	r7, r7, #24
 5a4:	46bd      	mov	sp, r7
 5a6:	bd80      	pop	{r7, pc}

ip_addr.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  32356 Jul 30 19:07 2021 ip_addr.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000051c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000550  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00000000  00000000  00000550  2**2
                  ALLOC
  3 .debug_abbrev 0000016c  00000000  00000000  00000550  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000602  00000000  00000000  000006bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000033e  00000000  00000000  00000cbe  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00005bab  00000000  00000000  00000ffc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000008  00000000  00000000  00006ba8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    00000150  00000000  00000000  00006bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000000ae  00000000  00000000  00006d00  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 000000e8  00000000  00000000  00006dae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  00006e96  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    000002ae  00000000  00000000  00006eb6  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  00007164  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000718f  2**0
                  CONTENTS, READONLY
 15 .debug_frame  000000c8  00000000  00000000  000071c0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 ip_addr.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .rodata	00000000 .rodata
00000000 l       .bss	00000000 str.4171
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .rodata	00000004 ip_addr_any
00000004 g     O .rodata	00000004 ip_addr_broadcast
00000000 g     F .text	00000088 ip4_addr_isbroadcast
00000088 g     F .text	00000066 ip4_addr_netmask_valid
00000000         *UND*	00000000 lwip_htonl
000000f0 g     F .text	0000002c ipaddr_addr
0000011c g     F .text	00000280 ipaddr_aton
0000039c g     F .text	00000024 ipaddr_ntoa
000003c0 g     F .text	0000015c ipaddr_ntoa_r



Disassembly of section .text:

00000000 <ip4_addr_isbroadcast>:
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
   8:	6039      	str	r1, [r7, #0]
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);
   a:	687b      	ldr	r3, [r7, #4]
   c:	60fb      	str	r3, [r7, #12]

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
   e:	687b      	ldr	r3, [r7, #4]
  10:	f1b3 3fff 	cmp.w	r3, #4294967295
  14:	d002      	beq.n	1c <ip4_addr_isbroadcast+0x1c>
  16:	687b      	ldr	r3, [r7, #4]
  18:	2b00      	cmp	r3, #0
  1a:	d102      	bne.n	22 <ip4_addr_isbroadcast+0x22>
      (addr == IPADDR_ANY)) {
    return 1;
  1c:	f04f 0301 	mov.w	r3, #1
  20:	e02c      	b.n	7c <ip4_addr_isbroadcast+0x7c>
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
  22:	683b      	ldr	r3, [r7, #0]
  24:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  28:	f003 0302 	and.w	r3, r3, #2
  2c:	2b00      	cmp	r3, #0
  2e:	d102      	bne.n	36 <ip4_addr_isbroadcast+0x36>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  30:	f04f 0300 	mov.w	r3, #0
  34:	e022      	b.n	7c <ip4_addr_isbroadcast+0x7c>
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
  36:	683b      	ldr	r3, [r7, #0]
  38:	685a      	ldr	r2, [r3, #4]
  3a:	687b      	ldr	r3, [r7, #4]
  3c:	429a      	cmp	r2, r3
  3e:	d102      	bne.n	46 <ip4_addr_isbroadcast+0x46>
    return 0;
  40:	f04f 0300 	mov.w	r3, #0
  44:	e01a      	b.n	7c <ip4_addr_isbroadcast+0x7c>
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
  46:	68fa      	ldr	r2, [r7, #12]
  48:	683b      	ldr	r3, [r7, #0]
  4a:	685b      	ldr	r3, [r3, #4]
  4c:	405a      	eors	r2, r3
  4e:	683b      	ldr	r3, [r7, #0]
  50:	689b      	ldr	r3, [r3, #8]
  52:	ea02 0303 	and.w	r3, r2, r3
  56:	2b00      	cmp	r3, #0
  58:	d10e      	bne.n	78 <ip4_addr_isbroadcast+0x78>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
  5a:	683b      	ldr	r3, [r7, #0]
  5c:	689b      	ldr	r3, [r3, #8]
  5e:	ea6f 0203 	mvn.w	r2, r3
  62:	687b      	ldr	r3, [r7, #4]
  64:	401a      	ands	r2, r3
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
  66:	683b      	ldr	r3, [r7, #0]
  68:	689b      	ldr	r3, [r3, #8]
  6a:	ea6f 0303 	mvn.w	r3, r3
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
  6e:	429a      	cmp	r2, r3
  70:	d102      	bne.n	78 <ip4_addr_isbroadcast+0x78>
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  72:	f04f 0301 	mov.w	r3, #1
  76:	e001      	b.n	7c <ip4_addr_isbroadcast+0x7c>
  } else {
    return 0;
  78:	f04f 0300 	mov.w	r3, #0
  }
}
  7c:	4618      	mov	r0, r3
  7e:	f107 0714 	add.w	r7, r7, #20
  82:	46bd      	mov	sp, r7
  84:	bc80      	pop	{r7}
  86:	4770      	bx	lr

00000088 <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
  88:	b580      	push	{r7, lr}
  8a:	b084      	sub	sp, #16
  8c:	af00      	add	r7, sp, #0
  8e:	6078      	str	r0, [r7, #4]
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
  90:	6878      	ldr	r0, [r7, #4]
  92:	f7ff fffe 	bl	0 <lwip_htonl>
			92: R_ARM_THM_CALL	lwip_htonl
  96:	60b8      	str	r0, [r7, #8]

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
  98:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  9c:	60fb      	str	r3, [r7, #12]
  9e:	e00b      	b.n	b8 <ip4_addr_netmask_valid+0x30>
    if ((nm_hostorder & mask) == 0) {
  a0:	68ba      	ldr	r2, [r7, #8]
  a2:	68fb      	ldr	r3, [r7, #12]
  a4:	ea02 0303 	and.w	r3, r2, r3
  a8:	2b00      	cmp	r3, #0
  aa:	d101      	bne.n	b0 <ip4_addr_netmask_valid+0x28>
      break;
  ac:	bf00      	nop
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
  ae:	e014      	b.n	da <ip4_addr_netmask_valid+0x52>
{
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
  b0:	68fb      	ldr	r3, [r7, #12]
  b2:	ea4f 0353 	mov.w	r3, r3, lsr #1
  b6:	60fb      	str	r3, [r7, #12]
  b8:	68fb      	ldr	r3, [r7, #12]
  ba:	2b00      	cmp	r3, #0
  bc:	d1f0      	bne.n	a0 <ip4_addr_netmask_valid+0x18>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
  be:	e00c      	b.n	da <ip4_addr_netmask_valid+0x52>
    if ((nm_hostorder & mask) != 0) {
  c0:	68ba      	ldr	r2, [r7, #8]
  c2:	68fb      	ldr	r3, [r7, #12]
  c4:	ea02 0303 	and.w	r3, r2, r3
  c8:	2b00      	cmp	r3, #0
  ca:	d002      	beq.n	d2 <ip4_addr_netmask_valid+0x4a>
      /* there is a one after the first zero -> invalid */
      return 0;
  cc:	f04f 0300 	mov.w	r3, #0
  d0:	e008      	b.n	e4 <ip4_addr_netmask_valid+0x5c>
    if ((nm_hostorder & mask) == 0) {
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
  d2:	68fb      	ldr	r3, [r7, #12]
  d4:	ea4f 0353 	mov.w	r3, r3, lsr #1
  d8:	60fb      	str	r3, [r7, #12]
  da:	68fb      	ldr	r3, [r7, #12]
  dc:	2b00      	cmp	r3, #0
  de:	d1ef      	bne.n	c0 <ip4_addr_netmask_valid+0x38>
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
  e0:	f04f 0301 	mov.w	r3, #1
}
  e4:	4618      	mov	r0, r3
  e6:	f107 0710 	add.w	r7, r7, #16
  ea:	46bd      	mov	sp, r7
  ec:	bd80      	pop	{r7, pc}
  ee:	bf00      	nop

000000f0 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
  f0:	b580      	push	{r7, lr}
  f2:	b084      	sub	sp, #16
  f4:	af00      	add	r7, sp, #0
  f6:	6078      	str	r0, [r7, #4]
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
  f8:	f107 030c 	add.w	r3, r7, #12
  fc:	6878      	ldr	r0, [r7, #4]
  fe:	4619      	mov	r1, r3
 100:	f7ff fffe 	bl	11c <ipaddr_aton>
			100: R_ARM_THM_CALL	ipaddr_aton
 104:	4603      	mov	r3, r0
 106:	2b00      	cmp	r3, #0
 108:	d001      	beq.n	10e <ipaddr_addr+0x1e>
    return ip4_addr_get_u32(&val);
 10a:	68fb      	ldr	r3, [r7, #12]
 10c:	e001      	b.n	112 <ipaddr_addr+0x22>
  }
  return (IPADDR_NONE);
 10e:	f04f 33ff 	mov.w	r3, #4294967295
}
 112:	4618      	mov	r0, r3
 114:	f107 0710 	add.w	r7, r7, #16
 118:	46bd      	mov	sp, r7
 11a:	bd80      	pop	{r7, pc}

0000011c <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
 11c:	b580      	push	{r7, lr}
 11e:	b08a      	sub	sp, #40	; 0x28
 120:	af00      	add	r7, sp, #0
 122:	6078      	str	r0, [r7, #4]
 124:	6039      	str	r1, [r7, #0]
  u32_t val;
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;
 126:	f107 030c 	add.w	r3, r7, #12
 12a:	61fb      	str	r3, [r7, #28]

  c = *cp;
 12c:	687b      	ldr	r3, [r7, #4]
 12e:	781b      	ldrb	r3, [r3, #0]
 130:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 134:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 138:	2b2f      	cmp	r3, #47	; 0x2f
 13a:	d903      	bls.n	144 <ipaddr_aton+0x28>
 13c:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 140:	2b39      	cmp	r3, #57	; 0x39
 142:	d902      	bls.n	14a <ipaddr_aton+0x2e>
      return (0);
 144:	f04f 0300 	mov.w	r3, #0
 148:	e123      	b.n	392 <ipaddr_aton+0x276>
    val = 0;
 14a:	f04f 0300 	mov.w	r3, #0
 14e:	627b      	str	r3, [r7, #36]	; 0x24
    base = 10;
 150:	f04f 030a 	mov.w	r3, #10
 154:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (c == '0') {
 158:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 15c:	2b30      	cmp	r3, #48	; 0x30
 15e:	d120      	bne.n	1a2 <ipaddr_aton+0x86>
      c = *++cp;
 160:	687b      	ldr	r3, [r7, #4]
 162:	f103 0301 	add.w	r3, r3, #1
 166:	607b      	str	r3, [r7, #4]
 168:	687b      	ldr	r3, [r7, #4]
 16a:	781b      	ldrb	r3, [r3, #0]
 16c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
      if (c == 'x' || c == 'X') {
 170:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 174:	2b78      	cmp	r3, #120	; 0x78
 176:	d003      	beq.n	180 <ipaddr_aton+0x64>
 178:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 17c:	2b58      	cmp	r3, #88	; 0x58
 17e:	d10c      	bne.n	19a <ipaddr_aton+0x7e>
        base = 16;
 180:	f04f 0310 	mov.w	r3, #16
 184:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        c = *++cp;
 188:	687b      	ldr	r3, [r7, #4]
 18a:	f103 0301 	add.w	r3, r3, #1
 18e:	607b      	str	r3, [r7, #4]
 190:	687b      	ldr	r3, [r7, #4]
 192:	781b      	ldrb	r3, [r3, #0]
 194:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
 198:	e003      	b.n	1a2 <ipaddr_aton+0x86>
      } else
        base = 8;
 19a:	f04f 0308 	mov.w	r3, #8
 19e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    }
    for (;;) {
      if (isdigit(c)) {
 1a2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1a6:	2b2f      	cmp	r3, #47	; 0x2f
 1a8:	d917      	bls.n	1da <ipaddr_aton+0xbe>
 1aa:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1ae:	2b39      	cmp	r3, #57	; 0x39
 1b0:	d813      	bhi.n	1da <ipaddr_aton+0xbe>
        val = (val * base) + (int)(c - '0');
 1b2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 1b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 1b8:	fb02 f203 	mul.w	r2, r2, r3
 1bc:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1c0:	18d3      	adds	r3, r2, r3
 1c2:	f1a3 0330 	sub.w	r3, r3, #48	; 0x30
 1c6:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 1c8:	687b      	ldr	r3, [r7, #4]
 1ca:	f103 0301 	add.w	r3, r3, #1
 1ce:	607b      	str	r3, [r7, #4]
 1d0:	687b      	ldr	r3, [r7, #4]
 1d2:	781b      	ldrb	r3, [r3, #0]
 1d4:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
 1d8:	e7e3      	b.n	1a2 <ipaddr_aton+0x86>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 1da:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 1de:	2b10      	cmp	r3, #16
 1e0:	d138      	bne.n	254 <ipaddr_aton+0x138>
 1e2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1e6:	2b2f      	cmp	r3, #47	; 0x2f
 1e8:	d903      	bls.n	1f2 <ipaddr_aton+0xd6>
 1ea:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1ee:	2b39      	cmp	r3, #57	; 0x39
 1f0:	d90f      	bls.n	212 <ipaddr_aton+0xf6>
 1f2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1f6:	2b60      	cmp	r3, #96	; 0x60
 1f8:	d903      	bls.n	202 <ipaddr_aton+0xe6>
 1fa:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 1fe:	2b66      	cmp	r3, #102	; 0x66
 200:	d907      	bls.n	212 <ipaddr_aton+0xf6>
 202:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 206:	2b40      	cmp	r3, #64	; 0x40
 208:	d924      	bls.n	254 <ipaddr_aton+0x138>
 20a:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 20e:	2b46      	cmp	r3, #70	; 0x46
 210:	d820      	bhi.n	254 <ipaddr_aton+0x138>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
 212:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 214:	ea4f 1203 	mov.w	r2, r3, lsl #4
 218:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 21c:	f103 010a 	add.w	r1, r3, #10
 220:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 224:	2b60      	cmp	r3, #96	; 0x60
 226:	d906      	bls.n	236 <ipaddr_aton+0x11a>
 228:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 22c:	2b7a      	cmp	r3, #122	; 0x7a
 22e:	d802      	bhi.n	236 <ipaddr_aton+0x11a>
 230:	f04f 0361 	mov.w	r3, #97	; 0x61
 234:	e001      	b.n	23a <ipaddr_aton+0x11e>
 236:	f04f 0341 	mov.w	r3, #65	; 0x41
 23a:	1acb      	subs	r3, r1, r3
 23c:	ea42 0303 	orr.w	r3, r2, r3
 240:	627b      	str	r3, [r7, #36]	; 0x24
        c = *++cp;
 242:	687b      	ldr	r3, [r7, #4]
 244:	f103 0301 	add.w	r3, r3, #1
 248:	607b      	str	r3, [r7, #4]
 24a:	687b      	ldr	r3, [r7, #4]
 24c:	781b      	ldrb	r3, [r3, #0]
 24e:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
      } else
        break;
    }
 252:	e7a6      	b.n	1a2 <ipaddr_aton+0x86>
    if (c == '.') {
 254:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 258:	2b2e      	cmp	r3, #46	; 0x2e
 25a:	d119      	bne.n	290 <ipaddr_aton+0x174>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 25c:	f107 030c 	add.w	r3, r7, #12
 260:	f103 030c 	add.w	r3, r3, #12
 264:	69fa      	ldr	r2, [r7, #28]
 266:	429a      	cmp	r2, r3
 268:	d302      	bcc.n	270 <ipaddr_aton+0x154>
        return (0);
 26a:	f04f 0300 	mov.w	r3, #0
 26e:	e090      	b.n	392 <ipaddr_aton+0x276>
      }
      *pp++ = val;
 270:	69fb      	ldr	r3, [r7, #28]
 272:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 274:	601a      	str	r2, [r3, #0]
 276:	69fb      	ldr	r3, [r7, #28]
 278:	f103 0304 	add.w	r3, r3, #4
 27c:	61fb      	str	r3, [r7, #28]
      c = *++cp;
 27e:	687b      	ldr	r3, [r7, #4]
 280:	f103 0301 	add.w	r3, r3, #1
 284:	607b      	str	r3, [r7, #4]
 286:	687b      	ldr	r3, [r7, #4]
 288:	781b      	ldrb	r3, [r3, #0]
 28a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    } else
      break;
  }
 28e:	e751      	b.n	134 <ipaddr_aton+0x18>
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
 290:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 294:	2b00      	cmp	r3, #0
 296:	d01a      	beq.n	2ce <ipaddr_aton+0x1b2>
 298:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 29c:	2b20      	cmp	r3, #32
 29e:	d016      	beq.n	2ce <ipaddr_aton+0x1b2>
 2a0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 2a4:	2b0c      	cmp	r3, #12
 2a6:	d012      	beq.n	2ce <ipaddr_aton+0x1b2>
 2a8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 2ac:	2b0a      	cmp	r3, #10
 2ae:	d00e      	beq.n	2ce <ipaddr_aton+0x1b2>
 2b0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 2b4:	2b0d      	cmp	r3, #13
 2b6:	d00a      	beq.n	2ce <ipaddr_aton+0x1b2>
 2b8:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 2bc:	2b09      	cmp	r3, #9
 2be:	d006      	beq.n	2ce <ipaddr_aton+0x1b2>
 2c0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 2c4:	2b0b      	cmp	r3, #11
 2c6:	d002      	beq.n	2ce <ipaddr_aton+0x1b2>
    return (0);
 2c8:	f04f 0300 	mov.w	r3, #0
 2cc:	e061      	b.n	392 <ipaddr_aton+0x276>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 2ce:	69fa      	ldr	r2, [r7, #28]
 2d0:	f107 030c 	add.w	r3, r7, #12
 2d4:	1ad3      	subs	r3, r2, r3
 2d6:	ea4f 03a3 	mov.w	r3, r3, asr #2
 2da:	f103 0301 	add.w	r3, r3, #1
 2de:	2b04      	cmp	r3, #4
 2e0:	d84b      	bhi.n	37a <ipaddr_aton+0x25e>
 2e2:	a201      	add	r2, pc, #4	; (adr r2, 2e8 <ipaddr_aton+0x1cc>)
 2e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 2e8:	000002fd 	.word	0x000002fd
			2e8: R_ARM_ABS32	.text
 2ec:	0000037b 	.word	0x0000037b
			2ec: R_ARM_ABS32	.text
 2f0:	00000303 	.word	0x00000303
			2f0: R_ARM_ABS32	.text
 2f4:	00000323 	.word	0x00000323
			2f4: R_ARM_ABS32	.text
 2f8:	0000034d 	.word	0x0000034d
			2f8: R_ARM_ABS32	.text

  case 0:
    return (0);       /* initial nondigit */
 2fc:	f04f 0300 	mov.w	r3, #0
 300:	e047      	b.n	392 <ipaddr_aton+0x276>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
 302:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 304:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 308:	429a      	cmp	r2, r3
 30a:	d902      	bls.n	312 <ipaddr_aton+0x1f6>
      return (0);
 30c:	f04f 0300 	mov.w	r3, #0
 310:	e03f      	b.n	392 <ipaddr_aton+0x276>
    }
    val |= parts[0] << 24;
 312:	68fb      	ldr	r3, [r7, #12]
 314:	ea4f 6303 	mov.w	r3, r3, lsl #24
 318:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 31a:	ea42 0303 	orr.w	r3, r2, r3
 31e:	627b      	str	r3, [r7, #36]	; 0x24
    break;
 320:	e02c      	b.n	37c <ipaddr_aton+0x260>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
 322:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 324:	f64f 73ff 	movw	r3, #65535	; 0xffff
 328:	429a      	cmp	r2, r3
 32a:	d902      	bls.n	332 <ipaddr_aton+0x216>
      return (0);
 32c:	f04f 0300 	mov.w	r3, #0
 330:	e02f      	b.n	392 <ipaddr_aton+0x276>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
 332:	68fb      	ldr	r3, [r7, #12]
 334:	ea4f 6203 	mov.w	r2, r3, lsl #24
 338:	693b      	ldr	r3, [r7, #16]
 33a:	ea4f 4303 	mov.w	r3, r3, lsl #16
 33e:	ea42 0303 	orr.w	r3, r2, r3
 342:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 344:	ea42 0303 	orr.w	r3, r2, r3
 348:	627b      	str	r3, [r7, #36]	; 0x24
    break;
 34a:	e017      	b.n	37c <ipaddr_aton+0x260>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
 34c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 34e:	2bff      	cmp	r3, #255	; 0xff
 350:	d902      	bls.n	358 <ipaddr_aton+0x23c>
      return (0);
 352:	f04f 0300 	mov.w	r3, #0
 356:	e01c      	b.n	392 <ipaddr_aton+0x276>
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 358:	68fb      	ldr	r3, [r7, #12]
 35a:	ea4f 6203 	mov.w	r2, r3, lsl #24
 35e:	693b      	ldr	r3, [r7, #16]
 360:	ea4f 4303 	mov.w	r3, r3, lsl #16
 364:	431a      	orrs	r2, r3
 366:	697b      	ldr	r3, [r7, #20]
 368:	ea4f 2303 	mov.w	r3, r3, lsl #8
 36c:	ea42 0303 	orr.w	r3, r2, r3
 370:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 372:	ea42 0303 	orr.w	r3, r2, r3
 376:	627b      	str	r3, [r7, #36]	; 0x24
    break;
 378:	e000      	b.n	37c <ipaddr_aton+0x260>
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
 37a:	bf00      	nop
  }
  if (addr) {
 37c:	683b      	ldr	r3, [r7, #0]
 37e:	2b00      	cmp	r3, #0
 380:	d005      	beq.n	38e <ipaddr_aton+0x272>
    ip4_addr_set_u32(addr, htonl(val));
 382:	6a78      	ldr	r0, [r7, #36]	; 0x24
 384:	f7ff fffe 	bl	0 <lwip_htonl>
			384: R_ARM_THM_CALL	lwip_htonl
 388:	4602      	mov	r2, r0
 38a:	683b      	ldr	r3, [r7, #0]
 38c:	601a      	str	r2, [r3, #0]
  }
  return (1);
 38e:	f04f 0301 	mov.w	r3, #1
}
 392:	4618      	mov	r0, r3
 394:	f107 0728 	add.w	r7, r7, #40	; 0x28
 398:	46bd      	mov	sp, r7
 39a:	bd80      	pop	{r7, pc}

0000039c <ipaddr_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
 39c:	b580      	push	{r7, lr}
 39e:	b082      	sub	sp, #8
 3a0:	af00      	add	r7, sp, #0
 3a2:	6078      	str	r0, [r7, #4]
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
 3a4:	6878      	ldr	r0, [r7, #4]
 3a6:	4905      	ldr	r1, [pc, #20]	; (3bc <ipaddr_ntoa+0x20>)
 3a8:	f04f 0210 	mov.w	r2, #16
 3ac:	f7ff fffe 	bl	3c0 <ipaddr_ntoa_r>
			3ac: R_ARM_THM_CALL	ipaddr_ntoa_r
 3b0:	4603      	mov	r3, r0
}
 3b2:	4618      	mov	r0, r3
 3b4:	f107 0708 	add.w	r7, r7, #8
 3b8:	46bd      	mov	sp, r7
 3ba:	bd80      	pop	{r7, pc}
 3bc:	00000000 	.word	0x00000000
			3bc: R_ARM_ABS32	.bss

000003c0 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
 3c0:	b480      	push	{r7}
 3c2:	b08d      	sub	sp, #52	; 0x34
 3c4:	af00      	add	r7, sp, #0
 3c6:	60f8      	str	r0, [r7, #12]
 3c8:	60b9      	str	r1, [r7, #8]
 3ca:	607a      	str	r2, [r7, #4]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 3cc:	f04f 0300 	mov.w	r3, #0
 3d0:	623b      	str	r3, [r7, #32]

  s_addr = ip4_addr_get_u32(addr);
 3d2:	68fb      	ldr	r3, [r7, #12]
 3d4:	681b      	ldr	r3, [r3, #0]
 3d6:	61bb      	str	r3, [r7, #24]

  rp = buf;
 3d8:	68bb      	ldr	r3, [r7, #8]
 3da:	62fb      	str	r3, [r7, #44]	; 0x2c
  ap = (u8_t *)&s_addr;
 3dc:	f107 0318 	add.w	r3, r7, #24
 3e0:	62bb      	str	r3, [r7, #40]	; 0x28
  for(n = 0; n < 4; n++) {
 3e2:	f04f 0300 	mov.w	r3, #0
 3e6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 3ea:	e080      	b.n	4ee <ipaddr_ntoa_r+0x12e>
    i = 0;
 3ec:	f04f 0300 	mov.w	r3, #0
 3f0:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
    do {
      rem = *ap % (u8_t)10;
 3f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 3f6:	781a      	ldrb	r2, [r3, #0]
 3f8:	4b47      	ldr	r3, [pc, #284]	; (518 <ipaddr_ntoa_r+0x158>)
 3fa:	fba3 1302 	umull	r1, r3, r3, r2
 3fe:	ea4f 01d3 	mov.w	r1, r3, lsr #3
 402:	460b      	mov	r3, r1
 404:	ea4f 0383 	mov.w	r3, r3, lsl #2
 408:	185b      	adds	r3, r3, r1
 40a:	ea4f 0343 	mov.w	r3, r3, lsl #1
 40e:	1ad3      	subs	r3, r2, r3
 410:	77fb      	strb	r3, [r7, #31]
      *ap /= (u8_t)10;
 412:	6abb      	ldr	r3, [r7, #40]	; 0x28
 414:	781a      	ldrb	r2, [r3, #0]
 416:	4b40      	ldr	r3, [pc, #256]	; (518 <ipaddr_ntoa_r+0x158>)
 418:	fba3 1302 	umull	r1, r3, r3, r2
 41c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 420:	b2da      	uxtb	r2, r3
 422:	6abb      	ldr	r3, [r7, #40]	; 0x28
 424:	701a      	strb	r2, [r3, #0]
      inv[i++] = '0' + rem;
 426:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 42a:	7ffa      	ldrb	r2, [r7, #31]
 42c:	f102 0230 	add.w	r2, r2, #48	; 0x30
 430:	b2d2      	uxtb	r2, r2
 432:	f107 0130 	add.w	r1, r7, #48	; 0x30
 436:	18cb      	adds	r3, r1, r3
 438:	f803 2c1c 	strb.w	r2, [r3, #-28]
 43c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 440:	f103 0301 	add.w	r3, r3, #1
 444:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
    } while(*ap);
 448:	6abb      	ldr	r3, [r7, #40]	; 0x28
 44a:	781b      	ldrb	r3, [r3, #0]
 44c:	2b00      	cmp	r3, #0
 44e:	d1d1      	bne.n	3f4 <ipaddr_ntoa_r+0x34>
    while(i--) {
 450:	e01c      	b.n	48c <ipaddr_ntoa_r+0xcc>
      if (len++ >= buflen) {
 452:	6a3a      	ldr	r2, [r7, #32]
 454:	687b      	ldr	r3, [r7, #4]
 456:	429a      	cmp	r2, r3
 458:	bfb4      	ite	lt
 45a:	2300      	movlt	r3, #0
 45c:	2301      	movge	r3, #1
 45e:	b2db      	uxtb	r3, r3
 460:	6a3a      	ldr	r2, [r7, #32]
 462:	f102 0201 	add.w	r2, r2, #1
 466:	623a      	str	r2, [r7, #32]
 468:	2b00      	cmp	r3, #0
 46a:	d002      	beq.n	472 <ipaddr_ntoa_r+0xb2>
        return NULL;
 46c:	f04f 0300 	mov.w	r3, #0
 470:	e04b      	b.n	50a <ipaddr_ntoa_r+0x14a>
      }
      *rp++ = inv[i];
 472:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 476:	f107 0230 	add.w	r2, r7, #48	; 0x30
 47a:	18d3      	adds	r3, r2, r3
 47c:	f813 2c1c 	ldrb.w	r2, [r3, #-28]
 480:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 482:	701a      	strb	r2, [r3, #0]
 484:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 486:	f103 0301 	add.w	r3, r3, #1
 48a:	62fb      	str	r3, [r7, #44]	; 0x2c
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
 48c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
 490:	2b00      	cmp	r3, #0
 492:	bf0c      	ite	eq
 494:	2300      	moveq	r3, #0
 496:	2301      	movne	r3, #1
 498:	b2db      	uxtb	r3, r3
 49a:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
 49e:	f102 32ff 	add.w	r2, r2, #4294967295
 4a2:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
 4a6:	2b00      	cmp	r3, #0
 4a8:	d1d3      	bne.n	452 <ipaddr_ntoa_r+0x92>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
 4aa:	6a3a      	ldr	r2, [r7, #32]
 4ac:	687b      	ldr	r3, [r7, #4]
 4ae:	429a      	cmp	r2, r3
 4b0:	bfb4      	ite	lt
 4b2:	2300      	movlt	r3, #0
 4b4:	2301      	movge	r3, #1
 4b6:	b2db      	uxtb	r3, r3
 4b8:	6a3a      	ldr	r2, [r7, #32]
 4ba:	f102 0201 	add.w	r2, r2, #1
 4be:	623a      	str	r2, [r7, #32]
 4c0:	2b00      	cmp	r3, #0
 4c2:	d002      	beq.n	4ca <ipaddr_ntoa_r+0x10a>
      return NULL;
 4c4:	f04f 0300 	mov.w	r3, #0
 4c8:	e01f      	b.n	50a <ipaddr_ntoa_r+0x14a>
    }
    *rp++ = '.';
 4ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 4cc:	f04f 022e 	mov.w	r2, #46	; 0x2e
 4d0:	701a      	strb	r2, [r3, #0]
 4d2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 4d4:	f103 0301 	add.w	r3, r3, #1
 4d8:	62fb      	str	r3, [r7, #44]	; 0x2c
    ap++;
 4da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 4dc:	f103 0301 	add.w	r3, r3, #1
 4e0:	62bb      	str	r3, [r7, #40]	; 0x28

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
 4e2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 4e6:	f103 0301 	add.w	r3, r3, #1
 4ea:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 4ee:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 4f2:	2b03      	cmp	r3, #3
 4f4:	f67f af7a 	bls.w	3ec <ipaddr_ntoa_r+0x2c>
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
 4f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 4fa:	f103 33ff 	add.w	r3, r3, #4294967295
 4fe:	62fb      	str	r3, [r7, #44]	; 0x2c
 500:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 502:	f04f 0200 	mov.w	r2, #0
 506:	701a      	strb	r2, [r3, #0]
  return buf;
 508:	68bb      	ldr	r3, [r7, #8]
}
 50a:	4618      	mov	r0, r3
 50c:	f107 0734 	add.w	r7, r7, #52	; 0x34
 510:	46bd      	mov	sp, r7
 512:	bc80      	pop	{r7}
 514:	4770      	bx	lr
 516:	bf00      	nop
 518:	cccccccd 	.word	0xcccccccd

ip_frag.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  53136 Jul 30 19:07 2021 ip_frag.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000092c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000960  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000005e8  00000000  00000000  00000960  2**2
                  ALLOC
  3 .debug_abbrev 000001d9  00000000  00000000  00000960  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000a12  00000000  00000000  00000b39  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000678  00000000  00000000  0000154b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000968c  00000000  00000000  00001bc3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000001c0  00000000  00000000  0000b24f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000003c  00000000  00000000  0000b40f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000015a  00000000  00000000  0000b44b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000b5a5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000005d9  00000000  00000000  0000b5c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000bb9e  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000bbc9  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000110  00000000  00000000  0000bbfc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 ip_frag.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 reassdatagrams
00000004 l       .bss	00000000 ip_reass_pbufcount
0000005c l     F .text	000000cc ip_reass_free_complete_datagram
00000278 l     F .text	0000003c ip_reass_dequeue_datagram
00000128 l     F .text	000000c4 ip_reass_remove_oldest_datagram
000001ec l     F .text	0000008c ip_reass_enqueue_new_datagram
000002b4 l     F .text	00000224 ip_reass_chain_frag_into_datagram_and_validate
00000008 l       .bss	00000000 buf
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	0000005c ip_reass_tmr
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 icmp_time_exceeded
00000000         *UND*	00000000 pbuf_clen
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 memp_malloc
00000000         *UND*	00000000 memset
00000000         *UND*	00000000 memp_free
00000000         *UND*	00000000 lwip_ntohs
000004d8 g     F .text	00000274 ip_reass
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 inet_chksum
00000000         *UND*	00000000 pbuf_header
00000000         *UND*	00000000 pbuf_cat
0000074c g     F .text	000001e0 ip_frag
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 pbuf_copy_partial
00000000         *UND*	00000000 pbuf_realloc
00000000         *UND*	00000000 pbuf_chain



Disassembly of section .text:

00000000 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
  struct ip_reassdata *r, *prev = NULL;
   6:	f04f 0300 	mov.w	r3, #0
   a:	60bb      	str	r3, [r7, #8]

  r = reassdatagrams;
   c:	4b12      	ldr	r3, [pc, #72]	; (58 <ip_reass_tmr+0x58>)
   e:	681b      	ldr	r3, [r3, #0]
  10:	60fb      	str	r3, [r7, #12]
  while (r != NULL) {
  12:	e019      	b.n	48 <ip_reass_tmr+0x48>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  14:	68fb      	ldr	r3, [r7, #12]
  16:	7fdb      	ldrb	r3, [r3, #31]
  18:	2b00      	cmp	r3, #0
  1a:	d00c      	beq.n	36 <ip_reass_tmr+0x36>
      r->timer--;
  1c:	68fb      	ldr	r3, [r7, #12]
  1e:	7fdb      	ldrb	r3, [r3, #31]
  20:	f103 33ff 	add.w	r3, r3, #4294967295
  24:	b2da      	uxtb	r2, r3
  26:	68fb      	ldr	r3, [r7, #12]
  28:	77da      	strb	r2, [r3, #31]
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  2a:	68fb      	ldr	r3, [r7, #12]
  2c:	60bb      	str	r3, [r7, #8]
      r = r->next;
  2e:	68fb      	ldr	r3, [r7, #12]
  30:	681b      	ldr	r3, [r3, #0]
  32:	60fb      	str	r3, [r7, #12]
  34:	e008      	b.n	48 <ip_reass_tmr+0x48>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  36:	68fb      	ldr	r3, [r7, #12]
  38:	607b      	str	r3, [r7, #4]
      /* get the next pointer before freeing */
      r = r->next;
  3a:	68fb      	ldr	r3, [r7, #12]
  3c:	681b      	ldr	r3, [r3, #0]
  3e:	60fb      	str	r3, [r7, #12]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  40:	6878      	ldr	r0, [r7, #4]
  42:	68b9      	ldr	r1, [r7, #8]
  44:	f000 f80a 	bl	5c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  48:	68fb      	ldr	r3, [r7, #12]
  4a:	2b00      	cmp	r3, #0
  4c:	d1e2      	bne.n	14 <ip_reass_tmr+0x14>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  4e:	f107 0710 	add.w	r7, r7, #16
  52:	46bd      	mov	sp, r7
  54:	bd80      	pop	{r7, pc}
  56:	bf00      	nop
  58:	00000000 	.word	0x00000000
			58: R_ARM_ABS32	.bss

0000005c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  5c:	b580      	push	{r7, lr}
  5e:	b088      	sub	sp, #32
  60:	af00      	add	r7, sp, #0
  62:	6078      	str	r0, [r7, #4]
  64:	6039      	str	r1, [r7, #0]
  u16_t pbufs_freed = 0;
  66:	f04f 0300 	mov.w	r3, #0
  6a:	83fb      	strh	r3, [r7, #30]
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  if (prev != NULL) {
  6c:	683b      	ldr	r3, [r7, #0]
  6e:	2b00      	cmp	r3, #0
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  70:	687b      	ldr	r3, [r7, #4]
  72:	685b      	ldr	r3, [r3, #4]
  74:	685b      	ldr	r3, [r3, #4]
  76:	617b      	str	r3, [r7, #20]
  if (iprh->start == 0) {
  78:	697b      	ldr	r3, [r7, #20]
  7a:	889b      	ldrh	r3, [r3, #4]
  7c:	b29b      	uxth	r3, r3
  7e:	2b00      	cmp	r3, #0
  80:	d123      	bne.n	ca <ip_reass_free_complete_datagram+0x6e>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  82:	687b      	ldr	r3, [r7, #4]
  84:	685b      	ldr	r3, [r3, #4]
  86:	61bb      	str	r3, [r7, #24]
    ipr->p = iprh->next_pbuf;
  88:	697b      	ldr	r3, [r7, #20]
  8a:	681a      	ldr	r2, [r3, #0]
  8c:	687b      	ldr	r3, [r7, #4]
  8e:	605a      	str	r2, [r3, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  90:	69bb      	ldr	r3, [r7, #24]
  92:	685a      	ldr	r2, [r3, #4]
  94:	687b      	ldr	r3, [r7, #4]
  96:	f103 0308 	add.w	r3, r3, #8
  9a:	4610      	mov	r0, r2
  9c:	4619      	mov	r1, r3
  9e:	f04f 0214 	mov.w	r2, #20
  a2:	f7ff fffe 	bl	0 <memcpy>
			a2: R_ARM_THM_CALL	memcpy
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  a6:	69b8      	ldr	r0, [r7, #24]
  a8:	f04f 0101 	mov.w	r1, #1
  ac:	f7ff fffe 	bl	0 <icmp_time_exceeded>
			ac: R_ARM_THM_CALL	icmp_time_exceeded
    clen = pbuf_clen(p);
  b0:	69b8      	ldr	r0, [r7, #24]
  b2:	f7ff fffe 	bl	0 <pbuf_clen>
			b2: R_ARM_THM_CALL	pbuf_clen
  b6:	4603      	mov	r3, r0
  b8:	74fb      	strb	r3, [r7, #19]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
  ba:	7cfb      	ldrb	r3, [r7, #19]
  bc:	b29a      	uxth	r2, r3
  be:	8bfb      	ldrh	r3, [r7, #30]
  c0:	18d3      	adds	r3, r2, r3
  c2:	83fb      	strh	r3, [r7, #30]
    pbuf_free(p);
  c4:	69b8      	ldr	r0, [r7, #24]
  c6:	f7ff fffe 	bl	0 <pbuf_free>
			c6: R_ARM_THM_CALL	pbuf_free
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  ca:	687b      	ldr	r3, [r7, #4]
  cc:	685b      	ldr	r3, [r3, #4]
  ce:	61bb      	str	r3, [r7, #24]
  while (p != NULL) {
  d0:	e014      	b.n	fc <ip_reass_free_complete_datagram+0xa0>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  d2:	69bb      	ldr	r3, [r7, #24]
  d4:	685b      	ldr	r3, [r3, #4]
  d6:	617b      	str	r3, [r7, #20]
    pcur = p;
  d8:	69bb      	ldr	r3, [r7, #24]
  da:	60fb      	str	r3, [r7, #12]
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  dc:	697b      	ldr	r3, [r7, #20]
  de:	681b      	ldr	r3, [r3, #0]
  e0:	61bb      	str	r3, [r7, #24]
    clen = pbuf_clen(pcur);
  e2:	68f8      	ldr	r0, [r7, #12]
  e4:	f7ff fffe 	bl	0 <pbuf_clen>
			e4: R_ARM_THM_CALL	pbuf_clen
  e8:	4603      	mov	r3, r0
  ea:	74fb      	strb	r3, [r7, #19]
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
  ec:	7cfb      	ldrb	r3, [r7, #19]
  ee:	b29a      	uxth	r2, r3
  f0:	8bfb      	ldrh	r3, [r7, #30]
  f2:	18d3      	adds	r3, r2, r3
  f4:	83fb      	strh	r3, [r7, #30]
    pbuf_free(pcur);
  f6:	68f8      	ldr	r0, [r7, #12]
  f8:	f7ff fffe 	bl	0 <pbuf_free>
			f8: R_ARM_THM_CALL	pbuf_free
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  fc:	69bb      	ldr	r3, [r7, #24]
  fe:	2b00      	cmp	r3, #0
 100:	d1e7      	bne.n	d2 <ip_reass_free_complete_datagram+0x76>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 102:	6878      	ldr	r0, [r7, #4]
 104:	6839      	ldr	r1, [r7, #0]
 106:	f000 f8b7 	bl	278 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  ip_reass_pbufcount -= pbufs_freed;
 10a:	4b06      	ldr	r3, [pc, #24]	; (124 <ip_reass_free_complete_datagram+0xc8>)
 10c:	881a      	ldrh	r2, [r3, #0]
 10e:	8bfb      	ldrh	r3, [r7, #30]
 110:	1ad3      	subs	r3, r2, r3
 112:	b29a      	uxth	r2, r3
 114:	4b03      	ldr	r3, [pc, #12]	; (124 <ip_reass_free_complete_datagram+0xc8>)
 116:	801a      	strh	r2, [r3, #0]

  return pbufs_freed;
 118:	8bfb      	ldrh	r3, [r7, #30]
}
 11a:	4618      	mov	r0, r3
 11c:	f107 0720 	add.w	r7, r7, #32
 120:	46bd      	mov	sp, r7
 122:	bd80      	pop	{r7, pc}
 124:	00000004 	.word	0x00000004
			124: R_ARM_ABS32	.bss

00000128 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 128:	b580      	push	{r7, lr}
 12a:	b088      	sub	sp, #32
 12c:	af00      	add	r7, sp, #0
 12e:	6078      	str	r0, [r7, #4]
 130:	6039      	str	r1, [r7, #0]
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 132:	f04f 0300 	mov.w	r3, #0
 136:	613b      	str	r3, [r7, #16]
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
 138:	f04f 0300 	mov.w	r3, #0
 13c:	61bb      	str	r3, [r7, #24]
    prev = NULL;
 13e:	f04f 0300 	mov.w	r3, #0
 142:	617b      	str	r3, [r7, #20]
    other_datagrams = 0;
 144:	f04f 0300 	mov.w	r3, #0
 148:	60fb      	str	r3, [r7, #12]
    r = reassdatagrams;
 14a:	4b27      	ldr	r3, [pc, #156]	; (1e8 <ip_reass_remove_oldest_datagram+0xc0>)
 14c:	681b      	ldr	r3, [r3, #0]
 14e:	61fb      	str	r3, [r7, #28]
    while (r != NULL) {
 150:	e02d      	b.n	1ae <ip_reass_remove_oldest_datagram+0x86>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 152:	69fb      	ldr	r3, [r7, #28]
 154:	695a      	ldr	r2, [r3, #20]
 156:	687b      	ldr	r3, [r7, #4]
 158:	68db      	ldr	r3, [r3, #12]
 15a:	429a      	cmp	r2, r3
 15c:	d10c      	bne.n	178 <ip_reass_remove_oldest_datagram+0x50>
 15e:	69fb      	ldr	r3, [r7, #28]
 160:	699a      	ldr	r2, [r3, #24]
 162:	687b      	ldr	r3, [r7, #4]
 164:	691b      	ldr	r3, [r3, #16]
 166:	429a      	cmp	r2, r3
 168:	d106      	bne.n	178 <ip_reass_remove_oldest_datagram+0x50>
 16a:	69fb      	ldr	r3, [r7, #28]
 16c:	899a      	ldrh	r2, [r3, #12]
 16e:	687b      	ldr	r3, [r7, #4]
 170:	889b      	ldrh	r3, [r3, #4]
 172:	b29b      	uxth	r3, r3
 174:	429a      	cmp	r2, r3
 176:	d011      	beq.n	19c <ip_reass_remove_oldest_datagram+0x74>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 178:	68fb      	ldr	r3, [r7, #12]
 17a:	f103 0301 	add.w	r3, r3, #1
 17e:	60fb      	str	r3, [r7, #12]
        if (oldest == NULL) {
 180:	69bb      	ldr	r3, [r7, #24]
 182:	2b00      	cmp	r3, #0
 184:	d102      	bne.n	18c <ip_reass_remove_oldest_datagram+0x64>
          oldest = r;
 186:	69fb      	ldr	r3, [r7, #28]
 188:	61bb      	str	r3, [r7, #24]
 18a:	e007      	b.n	19c <ip_reass_remove_oldest_datagram+0x74>
        } else if (r->timer <= oldest->timer) {
 18c:	69fb      	ldr	r3, [r7, #28]
 18e:	7fda      	ldrb	r2, [r3, #31]
 190:	69bb      	ldr	r3, [r7, #24]
 192:	7fdb      	ldrb	r3, [r3, #31]
 194:	429a      	cmp	r2, r3
 196:	d801      	bhi.n	19c <ip_reass_remove_oldest_datagram+0x74>
          /* older than the previous oldest */
          oldest = r;
 198:	69fb      	ldr	r3, [r7, #28]
 19a:	61bb      	str	r3, [r7, #24]
        }
      }
      if (r->next != NULL) {
 19c:	69fb      	ldr	r3, [r7, #28]
 19e:	681b      	ldr	r3, [r3, #0]
 1a0:	2b00      	cmp	r3, #0
 1a2:	d001      	beq.n	1a8 <ip_reass_remove_oldest_datagram+0x80>
        prev = r;
 1a4:	69fb      	ldr	r3, [r7, #28]
 1a6:	617b      	str	r3, [r7, #20]
      }
      r = r->next;
 1a8:	69fb      	ldr	r3, [r7, #28]
 1aa:	681b      	ldr	r3, [r3, #0]
 1ac:	61fb      	str	r3, [r7, #28]
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
 1ae:	69fb      	ldr	r3, [r7, #28]
 1b0:	2b00      	cmp	r3, #0
 1b2:	d1ce      	bne.n	152 <ip_reass_remove_oldest_datagram+0x2a>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 1b4:	69bb      	ldr	r3, [r7, #24]
 1b6:	2b00      	cmp	r3, #0
 1b8:	d008      	beq.n	1cc <ip_reass_remove_oldest_datagram+0xa4>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 1ba:	69b8      	ldr	r0, [r7, #24]
 1bc:	6979      	ldr	r1, [r7, #20]
 1be:	f7ff ff4d 	bl	5c <ip_reass_free_complete_datagram>
 1c2:	60b8      	str	r0, [r7, #8]
      pbufs_freed += pbufs_freed_current;
 1c4:	693a      	ldr	r2, [r7, #16]
 1c6:	68bb      	ldr	r3, [r7, #8]
 1c8:	18d3      	adds	r3, r2, r3
 1ca:	613b      	str	r3, [r7, #16]
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 1cc:	693a      	ldr	r2, [r7, #16]
 1ce:	683b      	ldr	r3, [r7, #0]
 1d0:	429a      	cmp	r2, r3
 1d2:	da02      	bge.n	1da <ip_reass_remove_oldest_datagram+0xb2>
 1d4:	68fb      	ldr	r3, [r7, #12]
 1d6:	2b01      	cmp	r3, #1
 1d8:	dcae      	bgt.n	138 <ip_reass_remove_oldest_datagram+0x10>
  return pbufs_freed;
 1da:	693b      	ldr	r3, [r7, #16]
}
 1dc:	4618      	mov	r0, r3
 1de:	f107 0720 	add.w	r7, r7, #32
 1e2:	46bd      	mov	sp, r7
 1e4:	bd80      	pop	{r7, pc}
 1e6:	bf00      	nop
 1e8:	00000000 	.word	0x00000000
			1e8: R_ARM_ABS32	.bss

000001ec <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
 1ec:	b580      	push	{r7, lr}
 1ee:	b084      	sub	sp, #16
 1f0:	af00      	add	r7, sp, #0
 1f2:	6078      	str	r0, [r7, #4]
 1f4:	6039      	str	r1, [r7, #0]
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 1f6:	f04f 0005 	mov.w	r0, #5
 1fa:	f7ff fffe 	bl	0 <memp_malloc>
			1fa: R_ARM_THM_CALL	memp_malloc
 1fe:	4603      	mov	r3, r0
 200:	60fb      	str	r3, [r7, #12]
  if (ipr == NULL) {
 202:	68fb      	ldr	r3, [r7, #12]
 204:	2b00      	cmp	r3, #0
 206:	d113      	bne.n	230 <ip_reass_enqueue_new_datagram+0x44>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 208:	6878      	ldr	r0, [r7, #4]
 20a:	6839      	ldr	r1, [r7, #0]
 20c:	f7ff ff8c 	bl	128 <ip_reass_remove_oldest_datagram>
 210:	4602      	mov	r2, r0
 212:	683b      	ldr	r3, [r7, #0]
 214:	429a      	cmp	r2, r3
 216:	db05      	blt.n	224 <ip_reass_enqueue_new_datagram+0x38>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 218:	f04f 0005 	mov.w	r0, #5
 21c:	f7ff fffe 	bl	0 <memp_malloc>
			21c: R_ARM_THM_CALL	memp_malloc
 220:	4603      	mov	r3, r0
 222:	60fb      	str	r3, [r7, #12]
    }
    if (ipr == NULL)
 224:	68fb      	ldr	r3, [r7, #12]
 226:	2b00      	cmp	r3, #0
 228:	d102      	bne.n	230 <ip_reass_enqueue_new_datagram+0x44>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
 22a:	f04f 0300 	mov.w	r3, #0
 22e:	e01b      	b.n	268 <ip_reass_enqueue_new_datagram+0x7c>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 230:	68f8      	ldr	r0, [r7, #12]
 232:	f04f 0100 	mov.w	r1, #0
 236:	f04f 0220 	mov.w	r2, #32
 23a:	f7ff fffe 	bl	0 <memset>
			23a: R_ARM_THM_CALL	memset
  ipr->timer = IP_REASS_MAXAGE;
 23e:	68fb      	ldr	r3, [r7, #12]
 240:	f04f 0203 	mov.w	r2, #3
 244:	77da      	strb	r2, [r3, #31]

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 246:	4b0b      	ldr	r3, [pc, #44]	; (274 <ip_reass_enqueue_new_datagram+0x88>)
 248:	681a      	ldr	r2, [r3, #0]
 24a:	68fb      	ldr	r3, [r7, #12]
 24c:	601a      	str	r2, [r3, #0]
  reassdatagrams = ipr;
 24e:	4b09      	ldr	r3, [pc, #36]	; (274 <ip_reass_enqueue_new_datagram+0x88>)
 250:	68fa      	ldr	r2, [r7, #12]
 252:	601a      	str	r2, [r3, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 254:	68fb      	ldr	r3, [r7, #12]
 256:	f103 0308 	add.w	r3, r3, #8
 25a:	4618      	mov	r0, r3
 25c:	6879      	ldr	r1, [r7, #4]
 25e:	f04f 0214 	mov.w	r2, #20
 262:	f7ff fffe 	bl	0 <memcpy>
			262: R_ARM_THM_CALL	memcpy
  return ipr;
 266:	68fb      	ldr	r3, [r7, #12]
}
 268:	4618      	mov	r0, r3
 26a:	f107 0710 	add.w	r7, r7, #16
 26e:	46bd      	mov	sp, r7
 270:	bd80      	pop	{r7, pc}
 272:	bf00      	nop
 274:	00000000 	.word	0x00000000
			274: R_ARM_ABS32	.bss

00000278 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 278:	b580      	push	{r7, lr}
 27a:	b082      	sub	sp, #8
 27c:	af00      	add	r7, sp, #0
 27e:	6078      	str	r0, [r7, #4]
 280:	6039      	str	r1, [r7, #0]
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 282:	4b0b      	ldr	r3, [pc, #44]	; (2b0 <ip_reass_dequeue_datagram+0x38>)
 284:	681a      	ldr	r2, [r3, #0]
 286:	687b      	ldr	r3, [r7, #4]
 288:	429a      	cmp	r2, r3
 28a:	d104      	bne.n	296 <ip_reass_dequeue_datagram+0x1e>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 28c:	687b      	ldr	r3, [r7, #4]
 28e:	681a      	ldr	r2, [r3, #0]
 290:	4b07      	ldr	r3, [pc, #28]	; (2b0 <ip_reass_dequeue_datagram+0x38>)
 292:	601a      	str	r2, [r3, #0]
 294:	e003      	b.n	29e <ip_reass_dequeue_datagram+0x26>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 296:	687b      	ldr	r3, [r7, #4]
 298:	681a      	ldr	r2, [r3, #0]
 29a:	683b      	ldr	r3, [r7, #0]
 29c:	601a      	str	r2, [r3, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 29e:	f04f 0005 	mov.w	r0, #5
 2a2:	6879      	ldr	r1, [r7, #4]
 2a4:	f7ff fffe 	bl	0 <memp_free>
			2a4: R_ARM_THM_CALL	memp_free
}
 2a8:	f107 0708 	add.w	r7, r7, #8
 2ac:	46bd      	mov	sp, r7
 2ae:	bd80      	pop	{r7, pc}
 2b0:	00000000 	.word	0x00000000
			2b0: R_ARM_ABS32	.bss

000002b4 <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
 2b4:	b590      	push	{r4, r7, lr}
 2b6:	b08b      	sub	sp, #44	; 0x2c
 2b8:	af00      	add	r7, sp, #0
 2ba:	6078      	str	r0, [r7, #4]
 2bc:	6039      	str	r1, [r7, #0]
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
 2be:	f04f 0300 	mov.w	r3, #0
 2c2:	623b      	str	r3, [r7, #32]
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
 2c4:	f04f 0301 	mov.w	r3, #1
 2c8:	61bb      	str	r3, [r7, #24]

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 2ca:	683b      	ldr	r3, [r7, #0]
 2cc:	685b      	ldr	r3, [r3, #4]
 2ce:	617b      	str	r3, [r7, #20]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 2d0:	697b      	ldr	r3, [r7, #20]
 2d2:	885b      	ldrh	r3, [r3, #2]
 2d4:	b29b      	uxth	r3, r3
 2d6:	4618      	mov	r0, r3
 2d8:	f7ff fffe 	bl	0 <lwip_ntohs>
			2d8: R_ARM_THM_CALL	lwip_ntohs
 2dc:	4603      	mov	r3, r0
 2de:	461a      	mov	r2, r3
 2e0:	697b      	ldr	r3, [r7, #20]
 2e2:	781b      	ldrb	r3, [r3, #0]
 2e4:	f003 030f 	and.w	r3, r3, #15
 2e8:	b29b      	uxth	r3, r3
 2ea:	4619      	mov	r1, r3
 2ec:	ea4f 3181 	mov.w	r1, r1, lsl #14
 2f0:	1acb      	subs	r3, r1, r3
 2f2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 2f6:	b29b      	uxth	r3, r3
 2f8:	18d3      	adds	r3, r2, r3
 2fa:	827b      	strh	r3, [r7, #18]
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 2fc:	697b      	ldr	r3, [r7, #20]
 2fe:	88db      	ldrh	r3, [r3, #6]
 300:	b29b      	uxth	r3, r3
 302:	4618      	mov	r0, r3
 304:	f7ff fffe 	bl	0 <lwip_ntohs>
			304: R_ARM_THM_CALL	lwip_ntohs
 308:	4603      	mov	r3, r0
 30a:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 30e:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 312:	b29b      	uxth	r3, r3
 314:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 318:	823b      	strh	r3, [r7, #16]
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 31a:	683b      	ldr	r3, [r7, #0]
 31c:	685b      	ldr	r3, [r3, #4]
 31e:	627b      	str	r3, [r7, #36]	; 0x24
  iprh->next_pbuf = NULL;
 320:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 322:	f04f 0200 	mov.w	r2, #0
 326:	701a      	strb	r2, [r3, #0]
 328:	f04f 0200 	mov.w	r2, #0
 32c:	705a      	strb	r2, [r3, #1]
 32e:	f04f 0200 	mov.w	r2, #0
 332:	709a      	strb	r2, [r3, #2]
 334:	f04f 0200 	mov.w	r2, #0
 338:	70da      	strb	r2, [r3, #3]
  iprh->start = offset;
 33a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 33c:	8a3a      	ldrh	r2, [r7, #16]
 33e:	809a      	strh	r2, [r3, #4]
  iprh->end = offset + len;
 340:	8a3a      	ldrh	r2, [r7, #16]
 342:	8a7b      	ldrh	r3, [r7, #18]
 344:	18d3      	adds	r3, r2, r3
 346:	b29a      	uxth	r2, r3
 348:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 34a:	80da      	strh	r2, [r3, #6]

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 34c:	687b      	ldr	r3, [r7, #4]
 34e:	685b      	ldr	r3, [r3, #4]
 350:	61fb      	str	r3, [r7, #28]
 352:	e04d      	b.n	3f0 <ip_reass_chain_frag_into_datagram_and_validate+0x13c>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 354:	69fb      	ldr	r3, [r7, #28]
 356:	685b      	ldr	r3, [r3, #4]
 358:	60fb      	str	r3, [r7, #12]
    if (iprh->start < iprh_tmp->start) {
 35a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 35c:	889b      	ldrh	r3, [r3, #4]
 35e:	b29a      	uxth	r2, r3
 360:	68fb      	ldr	r3, [r7, #12]
 362:	889b      	ldrh	r3, [r3, #4]
 364:	b29b      	uxth	r3, r3
 366:	429a      	cmp	r2, r3
 368:	d21f      	bcs.n	3aa <ip_reass_chain_frag_into_datagram_and_validate+0xf6>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 36a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 36c:	69fa      	ldr	r2, [r7, #28]
 36e:	601a      	str	r2, [r3, #0]
      if (iprh_prev != NULL) {
 370:	6a3b      	ldr	r3, [r7, #32]
 372:	2b00      	cmp	r3, #0
 374:	d015      	beq.n	3a2 <ip_reass_chain_frag_into_datagram_and_validate+0xee>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 376:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 378:	889b      	ldrh	r3, [r3, #4]
 37a:	b29a      	uxth	r2, r3
 37c:	6a3b      	ldr	r3, [r7, #32]
 37e:	88db      	ldrh	r3, [r3, #6]
 380:	b29b      	uxth	r3, r3
 382:	429a      	cmp	r2, r3
 384:	f0c0 8092 	bcc.w	4ac <ip_reass_chain_frag_into_datagram_and_validate+0x1f8>
 388:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 38a:	88db      	ldrh	r3, [r3, #6]
 38c:	b29a      	uxth	r2, r3
 38e:	68fb      	ldr	r3, [r7, #12]
 390:	889b      	ldrh	r3, [r3, #4]
 392:	b29b      	uxth	r3, r3
 394:	429a      	cmp	r2, r3
 396:	f200 8089 	bhi.w	4ac <ip_reass_chain_frag_into_datagram_and_validate+0x1f8>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 39a:	6a3b      	ldr	r3, [r7, #32]
 39c:	683a      	ldr	r2, [r7, #0]
 39e:	601a      	str	r2, [r3, #0]
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
 3a0:	e029      	b.n	3f6 <ip_reass_chain_frag_into_datagram_and_validate+0x142>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 3a2:	687b      	ldr	r3, [r7, #4]
 3a4:	683a      	ldr	r2, [r7, #0]
 3a6:	605a      	str	r2, [r3, #4]
      }
      break;
 3a8:	e025      	b.n	3f6 <ip_reass_chain_frag_into_datagram_and_validate+0x142>
    } else if(iprh->start == iprh_tmp->start) {
 3aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3ac:	889b      	ldrh	r3, [r3, #4]
 3ae:	b29a      	uxth	r2, r3
 3b0:	68fb      	ldr	r3, [r7, #12]
 3b2:	889b      	ldrh	r3, [r3, #4]
 3b4:	b29b      	uxth	r3, r3
 3b6:	429a      	cmp	r2, r3
 3b8:	d075      	beq.n	4a6 <ip_reass_chain_frag_into_datagram_and_validate+0x1f2>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 3ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 3bc:	889b      	ldrh	r3, [r3, #4]
 3be:	b29a      	uxth	r2, r3
 3c0:	68fb      	ldr	r3, [r7, #12]
 3c2:	88db      	ldrh	r3, [r3, #6]
 3c4:	b29b      	uxth	r3, r3
 3c6:	429a      	cmp	r2, r3
 3c8:	d36f      	bcc.n	4aa <ip_reass_chain_frag_into_datagram_and_validate+0x1f6>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
 3ca:	6a3b      	ldr	r3, [r7, #32]
 3cc:	2b00      	cmp	r3, #0
 3ce:	d00a      	beq.n	3e6 <ip_reass_chain_frag_into_datagram_and_validate+0x132>
        if (iprh_prev->end != iprh_tmp->start) {
 3d0:	6a3b      	ldr	r3, [r7, #32]
 3d2:	88db      	ldrh	r3, [r3, #6]
 3d4:	b29a      	uxth	r2, r3
 3d6:	68fb      	ldr	r3, [r7, #12]
 3d8:	889b      	ldrh	r3, [r3, #4]
 3da:	b29b      	uxth	r3, r3
 3dc:	429a      	cmp	r2, r3
 3de:	d002      	beq.n	3e6 <ip_reass_chain_frag_into_datagram_and_validate+0x132>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 3e0:	f04f 0300 	mov.w	r3, #0
 3e4:	61bb      	str	r3, [r7, #24]
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 3e6:	68fb      	ldr	r3, [r7, #12]
 3e8:	681b      	ldr	r3, [r3, #0]
 3ea:	61fb      	str	r3, [r7, #28]
    iprh_prev = iprh_tmp;
 3ec:	68fb      	ldr	r3, [r7, #12]
 3ee:	623b      	str	r3, [r7, #32]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 3f0:	69fb      	ldr	r3, [r7, #28]
 3f2:	2b00      	cmp	r3, #0
 3f4:	d1ae      	bne.n	354 <ip_reass_chain_frag_into_datagram_and_validate+0xa0>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
 3f6:	69fb      	ldr	r3, [r7, #28]
 3f8:	2b00      	cmp	r3, #0
 3fa:	d118      	bne.n	42e <ip_reass_chain_frag_into_datagram_and_validate+0x17a>
    if (iprh_prev != NULL) {
 3fc:	6a3b      	ldr	r3, [r7, #32]
 3fe:	2b00      	cmp	r3, #0
 400:	d012      	beq.n	428 <ip_reass_chain_frag_into_datagram_and_validate+0x174>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 402:	6a3b      	ldr	r3, [r7, #32]
 404:	88db      	ldrh	r3, [r3, #6]
 406:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 408:	889b      	ldrh	r3, [r3, #4]
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 40a:	6a3b      	ldr	r3, [r7, #32]
 40c:	683a      	ldr	r2, [r7, #0]
 40e:	601a      	str	r2, [r3, #0]
      if (iprh_prev->end != iprh->start) {
 410:	6a3b      	ldr	r3, [r7, #32]
 412:	88db      	ldrh	r3, [r3, #6]
 414:	b29a      	uxth	r2, r3
 416:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 418:	889b      	ldrh	r3, [r3, #4]
 41a:	b29b      	uxth	r3, r3
 41c:	429a      	cmp	r2, r3
 41e:	d006      	beq.n	42e <ip_reass_chain_frag_into_datagram_and_validate+0x17a>
        valid = 0;
 420:	f04f 0300 	mov.w	r3, #0
 424:	61bb      	str	r3, [r7, #24]
 426:	e002      	b.n	42e <ip_reass_chain_frag_into_datagram_and_validate+0x17a>
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 428:	687b      	ldr	r3, [r7, #4]
 42a:	683a      	ldr	r2, [r7, #0]
 42c:	605a      	str	r2, [r3, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 42e:	687b      	ldr	r3, [r7, #4]
 430:	7f9b      	ldrb	r3, [r3, #30]
 432:	f003 0301 	and.w	r3, r3, #1
 436:	b2db      	uxtb	r3, r3
 438:	2b00      	cmp	r3, #0
 43a:	d031      	beq.n	4a0 <ip_reass_chain_frag_into_datagram_and_validate+0x1ec>
    /* and had no wholes so far */
    if (valid) {
 43c:	69bb      	ldr	r3, [r7, #24]
 43e:	2b00      	cmp	r3, #0
 440:	d02c      	beq.n	49c <ip_reass_chain_frag_into_datagram_and_validate+0x1e8>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 442:	687b      	ldr	r3, [r7, #4]
 444:	685b      	ldr	r3, [r3, #4]
 446:	685b      	ldr	r3, [r3, #4]
 448:	889b      	ldrh	r3, [r3, #4]
 44a:	b29b      	uxth	r3, r3
 44c:	2b00      	cmp	r3, #0
 44e:	d003      	beq.n	458 <ip_reass_chain_frag_into_datagram_and_validate+0x1a4>
        valid = 0;
 450:	f04f 0300 	mov.w	r3, #0
 454:	61bb      	str	r3, [r7, #24]
 456:	e021      	b.n	49c <ip_reass_chain_frag_into_datagram_and_validate+0x1e8>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
 458:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 45a:	623b      	str	r3, [r7, #32]
        q = iprh->next_pbuf;
 45c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 45e:	681b      	ldr	r3, [r3, #0]
 460:	61fb      	str	r3, [r7, #28]
        while (q != NULL) {
 462:	e013      	b.n	48c <ip_reass_chain_frag_into_datagram_and_validate+0x1d8>
          iprh = (struct ip_reass_helper*)q->payload;
 464:	69fb      	ldr	r3, [r7, #28]
 466:	685b      	ldr	r3, [r3, #4]
 468:	627b      	str	r3, [r7, #36]	; 0x24
          if (iprh_prev->end != iprh->start) {
 46a:	6a3b      	ldr	r3, [r7, #32]
 46c:	88db      	ldrh	r3, [r3, #6]
 46e:	b29a      	uxth	r2, r3
 470:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 472:	889b      	ldrh	r3, [r3, #4]
 474:	b29b      	uxth	r3, r3
 476:	429a      	cmp	r2, r3
 478:	d003      	beq.n	482 <ip_reass_chain_frag_into_datagram_and_validate+0x1ce>
            valid = 0;
 47a:	f04f 0300 	mov.w	r3, #0
 47e:	61bb      	str	r3, [r7, #24]
            break;
 480:	e007      	b.n	492 <ip_reass_chain_frag_into_datagram_and_validate+0x1de>
          }
          iprh_prev = iprh;
 482:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 484:	623b      	str	r3, [r7, #32]
          q = iprh->next_pbuf;
 486:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 488:	681b      	ldr	r3, [r3, #0]
 48a:	61fb      	str	r3, [r7, #28]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 48c:	69fb      	ldr	r3, [r7, #28]
 48e:	2b00      	cmp	r3, #0
 490:	d1e8      	bne.n	464 <ip_reass_chain_frag_into_datagram_and_validate+0x1b0>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
 492:	69bb      	ldr	r3, [r7, #24]
 494:	2b00      	cmp	r3, #0
 496:	d001      	beq.n	49c <ip_reass_chain_frag_into_datagram_and_validate+0x1e8>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
 498:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 49a:	88db      	ldrh	r3, [r3, #6]
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
 49c:	69bb      	ldr	r3, [r7, #24]
 49e:	e014      	b.n	4ca <ip_reass_chain_frag_into_datagram_and_validate+0x216>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
 4a0:	f04f 0300 	mov.w	r3, #0
 4a4:	e011      	b.n	4ca <ip_reass_chain_frag_into_datagram_and_validate+0x216>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
 4a6:	bf00      	nop
 4a8:	e000      	b.n	4ac <ip_reass_chain_frag_into_datagram_and_validate+0x1f8>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
 4aa:	bf00      	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 4ac:	4b09      	ldr	r3, [pc, #36]	; (4d4 <ip_reass_chain_frag_into_datagram_and_validate+0x220>)
 4ae:	881c      	ldrh	r4, [r3, #0]
 4b0:	6838      	ldr	r0, [r7, #0]
 4b2:	f7ff fffe 	bl	0 <pbuf_clen>
			4b2: R_ARM_THM_CALL	pbuf_clen
 4b6:	4603      	mov	r3, r0
 4b8:	1ae3      	subs	r3, r4, r3
 4ba:	b29a      	uxth	r2, r3
 4bc:	4b05      	ldr	r3, [pc, #20]	; (4d4 <ip_reass_chain_frag_into_datagram_and_validate+0x220>)
 4be:	801a      	strh	r2, [r3, #0]
  pbuf_free(new_p);
 4c0:	6838      	ldr	r0, [r7, #0]
 4c2:	f7ff fffe 	bl	0 <pbuf_free>
			4c2: R_ARM_THM_CALL	pbuf_free
  return 0;
 4c6:	f04f 0300 	mov.w	r3, #0
#endif /* IP_REASS_CHECK_OVERLAP */
}
 4ca:	4618      	mov	r0, r3
 4cc:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 4d0:	46bd      	mov	sp, r7
 4d2:	bd90      	pop	{r4, r7, pc}
 4d4:	00000004 	.word	0x00000004
			4d4: R_ARM_ABS32	.bss

000004d8 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 4d8:	b590      	push	{r4, r7, lr}
 4da:	b08b      	sub	sp, #44	; 0x2c
 4dc:	af00      	add	r7, sp, #0
 4de:	6078      	str	r0, [r7, #4]
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
 4e0:	f04f 0300 	mov.w	r3, #0
 4e4:	61fb      	str	r3, [r7, #28]

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 4e6:	687b      	ldr	r3, [r7, #4]
 4e8:	685b      	ldr	r3, [r3, #4]
 4ea:	61bb      	str	r3, [r7, #24]

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 4ec:	69bb      	ldr	r3, [r7, #24]
 4ee:	781b      	ldrb	r3, [r3, #0]
 4f0:	f003 030f 	and.w	r3, r3, #15
 4f4:	ea4f 0383 	mov.w	r3, r3, lsl #2
 4f8:	2b14      	cmp	r3, #20
 4fa:	f040 8117 	bne.w	72c <ip_reass+0x254>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 4fe:	69bb      	ldr	r3, [r7, #24]
 500:	88db      	ldrh	r3, [r3, #6]
 502:	b29b      	uxth	r3, r3
 504:	4618      	mov	r0, r3
 506:	f7ff fffe 	bl	0 <lwip_ntohs>
			506: R_ARM_THM_CALL	lwip_ntohs
 50a:	4603      	mov	r3, r0
 50c:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 510:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 514:	b29b      	uxth	r3, r3
 516:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 51a:	82fb      	strh	r3, [r7, #22]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 51c:	69bb      	ldr	r3, [r7, #24]
 51e:	885b      	ldrh	r3, [r3, #2]
 520:	b29b      	uxth	r3, r3
 522:	4618      	mov	r0, r3
 524:	f7ff fffe 	bl	0 <lwip_ntohs>
			524: R_ARM_THM_CALL	lwip_ntohs
 528:	4603      	mov	r3, r0
 52a:	461a      	mov	r2, r3
 52c:	69bb      	ldr	r3, [r7, #24]
 52e:	781b      	ldrb	r3, [r3, #0]
 530:	f003 030f 	and.w	r3, r3, #15
 534:	b29b      	uxth	r3, r3
 536:	4619      	mov	r1, r3
 538:	ea4f 3181 	mov.w	r1, r1, lsl #14
 53c:	1acb      	subs	r3, r1, r3
 53e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 542:	b29b      	uxth	r3, r3
 544:	18d3      	adds	r3, r2, r3
 546:	82bb      	strh	r3, [r7, #20]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 548:	6878      	ldr	r0, [r7, #4]
 54a:	f7ff fffe 	bl	0 <pbuf_clen>
			54a: R_ARM_THM_CALL	pbuf_clen
 54e:	4603      	mov	r3, r0
 550:	74fb      	strb	r3, [r7, #19]
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 552:	4b7c      	ldr	r3, [pc, #496]	; (744 <ip_reass+0x26c>)
 554:	881b      	ldrh	r3, [r3, #0]
 556:	461a      	mov	r2, r3
 558:	7cfb      	ldrb	r3, [r7, #19]
 55a:	18d3      	adds	r3, r2, r3
 55c:	2b0a      	cmp	r3, #10
 55e:	dd10      	ble.n	582 <ip_reass+0xaa>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 560:	7cfb      	ldrb	r3, [r7, #19]
 562:	69b8      	ldr	r0, [r7, #24]
 564:	4619      	mov	r1, r3
 566:	f7ff fddf 	bl	128 <ip_reass_remove_oldest_datagram>
 56a:	4603      	mov	r3, r0
 56c:	2b00      	cmp	r3, #0
 56e:	f000 80de 	beq.w	72e <ip_reass+0x256>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
 572:	4b74      	ldr	r3, [pc, #464]	; (744 <ip_reass+0x26c>)
 574:	881b      	ldrh	r3, [r3, #0]
 576:	461a      	mov	r2, r3
 578:	7cfb      	ldrb	r3, [r7, #19]
 57a:	18d3      	adds	r3, r2, r3

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 57c:	2b0a      	cmp	r3, #10
 57e:	f300 80d6 	bgt.w	72e <ip_reass+0x256>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 582:	4b71      	ldr	r3, [pc, #452]	; (748 <ip_reass+0x270>)
 584:	681b      	ldr	r3, [r3, #0]
 586:	623b      	str	r3, [r7, #32]
 588:	e017      	b.n	5ba <ip_reass+0xe2>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 58a:	6a3b      	ldr	r3, [r7, #32]
 58c:	695a      	ldr	r2, [r3, #20]
 58e:	69bb      	ldr	r3, [r7, #24]
 590:	68db      	ldr	r3, [r3, #12]
 592:	429a      	cmp	r2, r3
 594:	d10c      	bne.n	5b0 <ip_reass+0xd8>
 596:	6a3b      	ldr	r3, [r7, #32]
 598:	699a      	ldr	r2, [r3, #24]
 59a:	69bb      	ldr	r3, [r7, #24]
 59c:	691b      	ldr	r3, [r3, #16]
 59e:	429a      	cmp	r2, r3
 5a0:	d106      	bne.n	5b0 <ip_reass+0xd8>
 5a2:	6a3b      	ldr	r3, [r7, #32]
 5a4:	899a      	ldrh	r2, [r3, #12]
 5a6:	69bb      	ldr	r3, [r7, #24]
 5a8:	889b      	ldrh	r3, [r3, #4]
 5aa:	b29b      	uxth	r3, r3
 5ac:	429a      	cmp	r2, r3
 5ae:	d008      	beq.n	5c2 <ip_reass+0xea>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
 5b0:	6a3b      	ldr	r3, [r7, #32]
 5b2:	61fb      	str	r3, [r7, #28]
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 5b4:	6a3b      	ldr	r3, [r7, #32]
 5b6:	681b      	ldr	r3, [r3, #0]
 5b8:	623b      	str	r3, [r7, #32]
 5ba:	6a3b      	ldr	r3, [r7, #32]
 5bc:	2b00      	cmp	r3, #0
 5be:	d1e4      	bne.n	58a <ip_reass+0xb2>
 5c0:	e000      	b.n	5c4 <ip_reass+0xec>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
 5c2:	bf00      	nop
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
 5c4:	6a3b      	ldr	r3, [r7, #32]
 5c6:	2b00      	cmp	r3, #0
 5c8:	d109      	bne.n	5de <ip_reass+0x106>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
 5ca:	7cfb      	ldrb	r3, [r7, #19]
 5cc:	69b8      	ldr	r0, [r7, #24]
 5ce:	4619      	mov	r1, r3
 5d0:	f7ff fe0c 	bl	1ec <ip_reass_enqueue_new_datagram>
 5d4:	6238      	str	r0, [r7, #32]
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
 5d6:	6a3b      	ldr	r3, [r7, #32]
 5d8:	2b00      	cmp	r3, #0
 5da:	d122      	bne.n	622 <ip_reass+0x14a>
      goto nullreturn;
 5dc:	e0a7      	b.n	72e <ip_reass+0x256>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 5de:	69bb      	ldr	r3, [r7, #24]
 5e0:	88db      	ldrh	r3, [r3, #6]
 5e2:	b29b      	uxth	r3, r3
 5e4:	4618      	mov	r0, r3
 5e6:	f7ff fffe 	bl	0 <lwip_ntohs>
			5e6: R_ARM_THM_CALL	lwip_ntohs
 5ea:	4603      	mov	r3, r0
 5ec:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 5f0:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 5f4:	2b00      	cmp	r3, #0
 5f6:	d114      	bne.n	622 <ip_reass+0x14a>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 5f8:	6a3b      	ldr	r3, [r7, #32]
 5fa:	89db      	ldrh	r3, [r3, #14]
 5fc:	4618      	mov	r0, r3
 5fe:	f7ff fffe 	bl	0 <lwip_ntohs>
			5fe: R_ARM_THM_CALL	lwip_ntohs
 602:	4603      	mov	r3, r0
 604:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 608:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 60c:	2b00      	cmp	r3, #0
 60e:	d008      	beq.n	622 <ip_reass+0x14a>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 610:	6a3b      	ldr	r3, [r7, #32]
 612:	f103 0308 	add.w	r3, r3, #8
 616:	4618      	mov	r0, r3
 618:	69b9      	ldr	r1, [r7, #24]
 61a:	f04f 0214 	mov.w	r2, #20
 61e:	f7ff fffe 	bl	0 <memcpy>
			61e: R_ARM_THM_CALL	memcpy
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 622:	7cfb      	ldrb	r3, [r7, #19]
 624:	b29a      	uxth	r2, r3
 626:	4b47      	ldr	r3, [pc, #284]	; (744 <ip_reass+0x26c>)
 628:	881b      	ldrh	r3, [r3, #0]
 62a:	18d3      	adds	r3, r2, r3
 62c:	b29a      	uxth	r2, r3
 62e:	4b45      	ldr	r3, [pc, #276]	; (744 <ip_reass+0x26c>)
 630:	801a      	strh	r2, [r3, #0]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 632:	69bb      	ldr	r3, [r7, #24]
 634:	88db      	ldrh	r3, [r3, #6]
 636:	b29b      	uxth	r3, r3
 638:	f003 0320 	and.w	r3, r3, #32
 63c:	2b00      	cmp	r3, #0
 63e:	d10c      	bne.n	65a <ip_reass+0x182>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 640:	6a3b      	ldr	r3, [r7, #32]
 642:	7f9b      	ldrb	r3, [r3, #30]
 644:	f043 0301 	orr.w	r3, r3, #1
 648:	b2da      	uxtb	r2, r3
 64a:	6a3b      	ldr	r3, [r7, #32]
 64c:	779a      	strb	r2, [r3, #30]
    ipr->datagram_len = offset + len;
 64e:	8afa      	ldrh	r2, [r7, #22]
 650:	8abb      	ldrh	r3, [r7, #20]
 652:	18d3      	adds	r3, r2, r3
 654:	b29a      	uxth	r2, r3
 656:	6a3b      	ldr	r3, [r7, #32]
 658:	839a      	strh	r2, [r3, #28]
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
 65a:	6a38      	ldr	r0, [r7, #32]
 65c:	6879      	ldr	r1, [r7, #4]
 65e:	f7ff fe29 	bl	2b4 <ip_reass_chain_frag_into_datagram_and_validate>
 662:	4603      	mov	r3, r0
 664:	2b00      	cmp	r3, #0
 666:	d05e      	beq.n	726 <ip_reass+0x24e>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 668:	6a3b      	ldr	r3, [r7, #32]
 66a:	8b9b      	ldrh	r3, [r3, #28]
 66c:	f103 0314 	add.w	r3, r3, #20
 670:	b29a      	uxth	r2, r3
 672:	6a3b      	ldr	r3, [r7, #32]
 674:	839a      	strh	r2, [r3, #28]

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 676:	6a3b      	ldr	r3, [r7, #32]
 678:	685b      	ldr	r3, [r3, #4]
 67a:	685b      	ldr	r3, [r3, #4]
 67c:	681b      	ldr	r3, [r3, #0]
 67e:	627b      	str	r3, [r7, #36]	; 0x24

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
 680:	6a3b      	ldr	r3, [r7, #32]
 682:	685b      	ldr	r3, [r3, #4]
 684:	685b      	ldr	r3, [r3, #4]
 686:	61bb      	str	r3, [r7, #24]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 688:	6a3b      	ldr	r3, [r7, #32]
 68a:	f103 0308 	add.w	r3, r3, #8
 68e:	69b8      	ldr	r0, [r7, #24]
 690:	4619      	mov	r1, r3
 692:	f04f 0214 	mov.w	r2, #20
 696:	f7ff fffe 	bl	0 <memcpy>
			696: R_ARM_THM_CALL	memcpy
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 69a:	6a3b      	ldr	r3, [r7, #32]
 69c:	8b9b      	ldrh	r3, [r3, #28]
 69e:	4618      	mov	r0, r3
 6a0:	f7ff fffe 	bl	0 <lwip_htons>
			6a0: R_ARM_THM_CALL	lwip_htons
 6a4:	4603      	mov	r3, r0
 6a6:	461a      	mov	r2, r3
 6a8:	69bb      	ldr	r3, [r7, #24]
 6aa:	805a      	strh	r2, [r3, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 6ac:	69bb      	ldr	r3, [r7, #24]
 6ae:	f04f 0200 	mov.w	r2, #0
 6b2:	719a      	strb	r2, [r3, #6]
 6b4:	f04f 0200 	mov.w	r2, #0
 6b8:	71da      	strb	r2, [r3, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 6ba:	69bb      	ldr	r3, [r7, #24]
 6bc:	f04f 0200 	mov.w	r2, #0
 6c0:	729a      	strb	r2, [r3, #10]
 6c2:	f04f 0200 	mov.w	r2, #0
 6c6:	72da      	strb	r2, [r3, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 6c8:	69b8      	ldr	r0, [r7, #24]
 6ca:	f04f 0114 	mov.w	r1, #20
 6ce:	f7ff fffe 	bl	0 <inet_chksum>
			6ce: R_ARM_THM_CALL	inet_chksum
 6d2:	4603      	mov	r3, r0
 6d4:	461a      	mov	r2, r3
 6d6:	69bb      	ldr	r3, [r7, #24]
 6d8:	815a      	strh	r2, [r3, #10]

    p = ipr->p;
 6da:	6a3b      	ldr	r3, [r7, #32]
 6dc:	685b      	ldr	r3, [r3, #4]
 6de:	607b      	str	r3, [r7, #4]

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 6e0:	e00e      	b.n	700 <ip_reass+0x228>
      iprh = (struct ip_reass_helper*)r->payload;
 6e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 6e4:	685b      	ldr	r3, [r3, #4]
 6e6:	60fb      	str	r3, [r7, #12]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 6e8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 6ea:	f06f 0113 	mvn.w	r1, #19
 6ee:	f7ff fffe 	bl	0 <pbuf_header>
			6ee: R_ARM_THM_CALL	pbuf_header
      pbuf_cat(p, r);
 6f2:	6878      	ldr	r0, [r7, #4]
 6f4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 6f6:	f7ff fffe 	bl	0 <pbuf_cat>
			6f6: R_ARM_THM_CALL	pbuf_cat
      r = iprh->next_pbuf;
 6fa:	68fb      	ldr	r3, [r7, #12]
 6fc:	681b      	ldr	r3, [r3, #0]
 6fe:	627b      	str	r3, [r7, #36]	; 0x24
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 700:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 702:	2b00      	cmp	r3, #0
 704:	d1ed      	bne.n	6e2 <ip_reass+0x20a>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 706:	6a38      	ldr	r0, [r7, #32]
 708:	69f9      	ldr	r1, [r7, #28]
 70a:	f7ff fdb5 	bl	278 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 70e:	4b0d      	ldr	r3, [pc, #52]	; (744 <ip_reass+0x26c>)
 710:	881c      	ldrh	r4, [r3, #0]
 712:	6878      	ldr	r0, [r7, #4]
 714:	f7ff fffe 	bl	0 <pbuf_clen>
			714: R_ARM_THM_CALL	pbuf_clen
 718:	4603      	mov	r3, r0
 71a:	1ae3      	subs	r3, r4, r3
 71c:	b29a      	uxth	r2, r3
 71e:	4b09      	ldr	r3, [pc, #36]	; (744 <ip_reass+0x26c>)
 720:	801a      	strh	r2, [r3, #0]

    /* Return the pbuf chain */
    return p;
 722:	687b      	ldr	r3, [r7, #4]
 724:	e008      	b.n	738 <ip_reass+0x260>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 726:	f04f 0300 	mov.w	r3, #0
 72a:	e005      	b.n	738 <ip_reass+0x260>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
 72c:	bf00      	nop
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 72e:	6878      	ldr	r0, [r7, #4]
 730:	f7ff fffe 	bl	0 <pbuf_free>
			730: R_ARM_THM_CALL	pbuf_free
  return NULL;
 734:	f04f 0300 	mov.w	r3, #0
}
 738:	4618      	mov	r0, r3
 73a:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 73e:	46bd      	mov	sp, r7
 740:	bd90      	pop	{r4, r7, pc}
 742:	bf00      	nop
 744:	00000004 	.word	0x00000004
			744: R_ARM_ABS32	.bss
 748:	00000000 	.word	0x00000000
			748: R_ARM_ABS32	.bss

0000074c <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 74c:	b580      	push	{r7, lr}
 74e:	b08c      	sub	sp, #48	; 0x30
 750:	af00      	add	r7, sp, #0
 752:	60f8      	str	r0, [r7, #12]
 754:	60b9      	str	r1, [r7, #8]
 756:	607a      	str	r2, [r7, #4]
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 758:	68bb      	ldr	r3, [r7, #8]
 75a:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
 75c:	84fb      	strh	r3, [r7, #38]	; 0x26
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
 75e:	f04f 0314 	mov.w	r3, #20
 762:	857b      	strh	r3, [r7, #42]	; 0x2a
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
 764:	f04f 0002 	mov.w	r0, #2
 768:	f04f 0100 	mov.w	r1, #0
 76c:	f04f 0202 	mov.w	r2, #2
 770:	f7ff fffe 	bl	0 <pbuf_alloc>
			770: R_ARM_THM_CALL	pbuf_alloc
 774:	6238      	str	r0, [r7, #32]
  if (rambuf == NULL) {
 776:	6a3b      	ldr	r3, [r7, #32]
 778:	2b00      	cmp	r3, #0
 77a:	d102      	bne.n	782 <ip_frag+0x36>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
 77c:	f04f 03ff 	mov.w	r3, #255	; 0xff
 780:	e0cb      	b.n	91a <ip_frag+0x1ce>
  }
  rambuf->tot_len = rambuf->len = mtu;
 782:	6a3b      	ldr	r3, [r7, #32]
 784:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 786:	815a      	strh	r2, [r3, #10]
 788:	6a3b      	ldr	r3, [r7, #32]
 78a:	895a      	ldrh	r2, [r3, #10]
 78c:	6a3b      	ldr	r3, [r7, #32]
 78e:	811a      	strh	r2, [r3, #8]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
 790:	4b65      	ldr	r3, [pc, #404]	; (928 <ip_frag+0x1dc>)
 792:	f103 0303 	add.w	r3, r3, #3
 796:	f023 0303 	bic.w	r3, r3, #3
 79a:	461a      	mov	r2, r3
 79c:	6a3b      	ldr	r3, [r7, #32]
 79e:	605a      	str	r2, [r3, #4]

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
 7a0:	6a3b      	ldr	r3, [r7, #32]
 7a2:	685b      	ldr	r3, [r3, #4]
 7a4:	61fb      	str	r3, [r7, #28]
  SMEMCPY(iphdr, p->payload, IP_HLEN);
 7a6:	68fb      	ldr	r3, [r7, #12]
 7a8:	685b      	ldr	r3, [r3, #4]
 7aa:	69f8      	ldr	r0, [r7, #28]
 7ac:	4619      	mov	r1, r3
 7ae:	f04f 0214 	mov.w	r2, #20
 7b2:	f7ff fffe 	bl	0 <memcpy>
			7b2: R_ARM_THM_CALL	memcpy
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 7b6:	69fb      	ldr	r3, [r7, #28]
 7b8:	88db      	ldrh	r3, [r3, #6]
 7ba:	b29b      	uxth	r3, r3
 7bc:	4618      	mov	r0, r3
 7be:	f7ff fffe 	bl	0 <lwip_ntohs>
			7be: R_ARM_THM_CALL	lwip_ntohs
 7c2:	4603      	mov	r3, r0
 7c4:	853b      	strh	r3, [r7, #40]	; 0x28
  ofo = tmp & IP_OFFMASK;
 7c6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 7c8:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 7cc:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 7d0:	85bb      	strh	r3, [r7, #44]	; 0x2c
  omf = tmp & IP_MF;
 7d2:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 7d4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 7d8:	837b      	strh	r3, [r7, #26]

  left = p->tot_len - IP_HLEN;
 7da:	68fb      	ldr	r3, [r7, #12]
 7dc:	891b      	ldrh	r3, [r3, #8]
 7de:	f1a3 0314 	sub.w	r3, r3, #20
 7e2:	85fb      	strh	r3, [r7, #46]	; 0x2e

  nfb = (mtu - IP_HLEN) / 8;
 7e4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 7e6:	f1a3 0314 	sub.w	r3, r3, #20
 7ea:	2b00      	cmp	r3, #0
 7ec:	da01      	bge.n	7f2 <ip_frag+0xa6>
 7ee:	f103 0307 	add.w	r3, r3, #7
 7f2:	ea4f 03e3 	mov.w	r3, r3, asr #3
 7f6:	833b      	strh	r3, [r7, #24]

  while (left) {
 7f8:	e086      	b.n	908 <ip_frag+0x1bc>
    last = (left <= mtu - IP_HLEN);
 7fa:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 7fc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 7fe:	f1a3 0314 	sub.w	r3, r3, #20
 802:	429a      	cmp	r2, r3
 804:	bfcc      	ite	gt
 806:	2300      	movgt	r3, #0
 808:	2301      	movle	r3, #1
 80a:	82fb      	strh	r3, [r7, #22]

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 80c:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80e:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 812:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 816:	b29a      	uxth	r2, r3
 818:	8b7b      	ldrh	r3, [r7, #26]
 81a:	ea42 0303 	orr.w	r3, r2, r3
 81e:	853b      	strh	r3, [r7, #40]	; 0x28
    if (!last) {
 820:	8afb      	ldrh	r3, [r7, #22]
 822:	2b00      	cmp	r3, #0
 824:	d103      	bne.n	82e <ip_frag+0xe2>
      tmp = tmp | IP_MF;
 826:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 828:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 82c:	853b      	strh	r3, [r7, #40]	; 0x28
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 82e:	8afb      	ldrh	r3, [r7, #22]
 830:	2b00      	cmp	r3, #0
 832:	d104      	bne.n	83e <ip_frag+0xf2>
 834:	8b3b      	ldrh	r3, [r7, #24]
 836:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 83a:	b29b      	uxth	r3, r3
 83c:	e000      	b.n	840 <ip_frag+0xf4>
 83e:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 840:	82bb      	strh	r3, [r7, #20]

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 842:	69fb      	ldr	r3, [r7, #28]
 844:	f103 0114 	add.w	r1, r3, #20
 848:	8aba      	ldrh	r2, [r7, #20]
 84a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 84c:	68f8      	ldr	r0, [r7, #12]
 84e:	f7ff fffe 	bl	0 <pbuf_copy_partial>
			84e: R_ARM_THM_CALL	pbuf_copy_partial
 852:	4603      	mov	r3, r0
 854:	461a      	mov	r2, r3
 856:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 858:	18d3      	adds	r3, r2, r3
 85a:	857b      	strh	r3, [r7, #42]	; 0x2a
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 85c:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 85e:	4618      	mov	r0, r3
 860:	f7ff fffe 	bl	0 <lwip_htons>
			860: R_ARM_THM_CALL	lwip_htons
 864:	4603      	mov	r3, r0
 866:	461a      	mov	r2, r3
 868:	69fb      	ldr	r3, [r7, #28]
 86a:	80da      	strh	r2, [r3, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 86c:	8abb      	ldrh	r3, [r7, #20]
 86e:	f103 0314 	add.w	r3, r3, #20
 872:	b29b      	uxth	r3, r3
 874:	4618      	mov	r0, r3
 876:	f7ff fffe 	bl	0 <lwip_htons>
			876: R_ARM_THM_CALL	lwip_htons
 87a:	4603      	mov	r3, r0
 87c:	461a      	mov	r2, r3
 87e:	69fb      	ldr	r3, [r7, #28]
 880:	805a      	strh	r2, [r3, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 882:	69fb      	ldr	r3, [r7, #28]
 884:	f04f 0200 	mov.w	r2, #0
 888:	729a      	strb	r2, [r3, #10]
 88a:	f04f 0200 	mov.w	r2, #0
 88e:	72da      	strb	r2, [r3, #11]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 890:	69f8      	ldr	r0, [r7, #28]
 892:	f04f 0114 	mov.w	r1, #20
 896:	f7ff fffe 	bl	0 <inet_chksum>
			896: R_ARM_THM_CALL	inet_chksum
 89a:	4603      	mov	r3, r0
 89c:	461a      	mov	r2, r3
 89e:	69fb      	ldr	r3, [r7, #28]
 8a0:	815a      	strh	r2, [r3, #10]

#if IP_FRAG_USES_STATIC_BUF
    if (last) {
 8a2:	8afb      	ldrh	r3, [r7, #22]
 8a4:	2b00      	cmp	r3, #0
 8a6:	d007      	beq.n	8b8 <ip_frag+0x16c>
      pbuf_realloc(rambuf, left + IP_HLEN);
 8a8:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8aa:	f103 0314 	add.w	r3, r3, #20
 8ae:	b29b      	uxth	r3, r3
 8b0:	6a38      	ldr	r0, [r7, #32]
 8b2:	4619      	mov	r1, r3
 8b4:	f7ff fffe 	bl	0 <pbuf_realloc>
			8b4: R_ARM_THM_CALL	pbuf_realloc
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
 8b8:	f04f 0002 	mov.w	r0, #2
 8bc:	f04f 0100 	mov.w	r1, #0
 8c0:	f04f 0200 	mov.w	r2, #0
 8c4:	f7ff fffe 	bl	0 <pbuf_alloc>
			8c4: R_ARM_THM_CALL	pbuf_alloc
 8c8:	6138      	str	r0, [r7, #16]
    if (header != NULL) {
 8ca:	693b      	ldr	r3, [r7, #16]
 8cc:	2b00      	cmp	r3, #0
 8ce:	d015      	beq.n	8fc <ip_frag+0x1b0>
      pbuf_chain(header, rambuf);
 8d0:	6938      	ldr	r0, [r7, #16]
 8d2:	6a39      	ldr	r1, [r7, #32]
 8d4:	f7ff fffe 	bl	0 <pbuf_chain>
			8d4: R_ARM_THM_CALL	pbuf_chain
      netif->output(netif, header, dest);
 8d8:	68bb      	ldr	r3, [r7, #8]
 8da:	695b      	ldr	r3, [r3, #20]
 8dc:	68b8      	ldr	r0, [r7, #8]
 8de:	6939      	ldr	r1, [r7, #16]
 8e0:	687a      	ldr	r2, [r7, #4]
 8e2:	4798      	blx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
 8e4:	6938      	ldr	r0, [r7, #16]
 8e6:	f7ff fffe 	bl	0 <pbuf_free>
			8e6: R_ARM_THM_CALL	pbuf_free
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 8ea:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 8ec:	8abb      	ldrh	r3, [r7, #20]
 8ee:	1ad3      	subs	r3, r2, r3
 8f0:	85fb      	strh	r3, [r7, #46]	; 0x2e
    ofo += nfb;
 8f2:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
 8f4:	8b3b      	ldrh	r3, [r7, #24]
 8f6:	18d3      	adds	r3, r2, r3
 8f8:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8fa:	e005      	b.n	908 <ip_frag+0x1bc>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
 8fc:	6a38      	ldr	r0, [r7, #32]
 8fe:	f7ff fffe 	bl	0 <pbuf_free>
			8fe: R_ARM_THM_CALL	pbuf_free
      return ERR_MEM;
 902:	f04f 03ff 	mov.w	r3, #255	; 0xff
 906:	e008      	b.n	91a <ip_frag+0x1ce>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 908:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 90a:	2b00      	cmp	r3, #0
 90c:	f47f af75 	bne.w	7fa <ip_frag+0xae>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
 910:	6a38      	ldr	r0, [r7, #32]
 912:	f7ff fffe 	bl	0 <pbuf_free>
			912: R_ARM_THM_CALL	pbuf_free
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 916:	f04f 0300 	mov.w	r3, #0
 91a:	b25b      	sxtb	r3, r3
}
 91c:	4618      	mov	r0, r3
 91e:	f107 0730 	add.w	r7, r7, #48	; 0x30
 922:	46bd      	mov	sp, r7
 924:	bd80      	pop	{r7, pc}
 926:	bf00      	nop
 928:	00000008 	.word	0x00000008
			928: R_ARM_ABS32	.bss
