In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libbelle_drivers.a:

mux.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 333880 Jul 30 19:06 2021 mux.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001c8  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  000001fc  2**2
                  ALLOC
  3 .debug_abbrev 0000013f  00000000  00000000  000001fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004c5  00000000  00000000  0000033b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000087b  00000000  00000000  00000800  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0004f3d9  00000000  00000000  0000107b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000000e0  00000000  00000000  00050454  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000071  00000000  00000000  00050534  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000137  00000000  00000000  000505a5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  000506dc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000004fa  00000000  00000000  000506fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00050bf6  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00050c21  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000090  00000000  00000000  00050c54  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 mux.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 xme_core_config
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 xme_core_log_logCallback
00000000 g     F .text	00000082 mux_init
00000000         *UND*	00000000 belle_gpio_pin_init
00000084 g     F .text	00000068 mux_setEnable
00000000         *UND*	00000000 GPIO_WriteBit
000000ec g     F .text	0000009a mux_selectChannel
00000188 g     F .text	00000040 mux_fini



Disassembly of section .text:

00000000 <mux_init>:
#include "gpio_config.h"
/******************************************************************************/
/***   Implementation for 3:8 Demux					                        ***/
/******************************************************************************/
mux_status_t mux_init (mux_descr_t *mux)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
	// Initialize the pins that are needed for the 3:8 MUX driver.
	belle_gpio_pin_init(mux->mux_input0.clock, mux->mux_input0.port, mux->mux_input0.pin, GPIO_Mode_Out_PP);
   8:	687b      	ldr	r3, [r7, #4]
   a:	6819      	ldr	r1, [r3, #0]
   c:	687b      	ldr	r3, [r7, #4]
   e:	689a      	ldr	r2, [r3, #8]
  10:	687b      	ldr	r3, [r7, #4]
  12:	889b      	ldrh	r3, [r3, #4]
  14:	4608      	mov	r0, r1
  16:	4611      	mov	r1, r2
  18:	461a      	mov	r2, r3
  1a:	f04f 0310 	mov.w	r3, #16
  1e:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			1e: R_ARM_THM_CALL	belle_gpio_pin_init
	belle_gpio_pin_init(mux->mux_input1.clock, mux->mux_input1.port, mux->mux_input1.pin, GPIO_Mode_Out_PP);
  22:	687b      	ldr	r3, [r7, #4]
  24:	68d9      	ldr	r1, [r3, #12]
  26:	687b      	ldr	r3, [r7, #4]
  28:	695a      	ldr	r2, [r3, #20]
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	8a1b      	ldrh	r3, [r3, #16]
  2e:	4608      	mov	r0, r1
  30:	4611      	mov	r1, r2
  32:	461a      	mov	r2, r3
  34:	f04f 0310 	mov.w	r3, #16
  38:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			38: R_ARM_THM_CALL	belle_gpio_pin_init
	belle_gpio_pin_init(mux->mux_input2.clock, mux->mux_input2.port, mux->mux_input2.pin, GPIO_Mode_Out_PP);
  3c:	687b      	ldr	r3, [r7, #4]
  3e:	6999      	ldr	r1, [r3, #24]
  40:	687b      	ldr	r3, [r7, #4]
  42:	6a1a      	ldr	r2, [r3, #32]
  44:	687b      	ldr	r3, [r7, #4]
  46:	8b9b      	ldrh	r3, [r3, #28]
  48:	4608      	mov	r0, r1
  4a:	4611      	mov	r1, r2
  4c:	461a      	mov	r2, r3
  4e:	f04f 0310 	mov.w	r3, #16
  52:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			52: R_ARM_THM_CALL	belle_gpio_pin_init

	if (0 != mux->enable_pin.port)
  56:	687b      	ldr	r3, [r7, #4]
  58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  5a:	2b00      	cmp	r3, #0
  5c:	d009      	beq.n	72 <mux_init+0x72>
	{
		// Configure enable pin
		mux_setEnable(&(mux->enable_pin),mux->enable_pin_set);
  5e:	687b      	ldr	r3, [r7, #4]
  60:	f103 0224 	add.w	r2, r3, #36	; 0x24
  64:	687b      	ldr	r3, [r7, #4]
  66:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  6a:	4610      	mov	r0, r2
  6c:	4619      	mov	r1, r3
  6e:	f7ff fffe 	bl	84 <mux_setEnable>
			6e: R_ARM_THM_CALL	mux_setEnable
	}
	return MUX_STATUS_SUCCESS;
  72:	f04f 0300 	mov.w	r3, #0
  76:	b25b      	sxtb	r3, r3
}
  78:	4618      	mov	r0, r3
  7a:	f107 0708 	add.w	r7, r7, #8
  7e:	46bd      	mov	sp, r7
  80:	bd80      	pop	{r7, pc}
  82:	bf00      	nop

00000084 <mux_setEnable>:

mux_status_t mux_setEnable (pin_descr_t *pin, mux_enable_t enable)
{
  84:	b580      	push	{r7, lr}
  86:	b082      	sub	sp, #8
  88:	af00      	add	r7, sp, #0
  8a:	6078      	str	r0, [r7, #4]
  8c:	460b      	mov	r3, r1
  8e:	70fb      	strb	r3, [r7, #3]
	belle_gpio_pin_init(pin->clock,pin->port,pin->pin, GPIO_Mode_Out_PP);
  90:	687b      	ldr	r3, [r7, #4]
  92:	6819      	ldr	r1, [r3, #0]
  94:	687b      	ldr	r3, [r7, #4]
  96:	689a      	ldr	r2, [r3, #8]
  98:	687b      	ldr	r3, [r7, #4]
  9a:	889b      	ldrh	r3, [r3, #4]
  9c:	4608      	mov	r0, r1
  9e:	4611      	mov	r1, r2
  a0:	461a      	mov	r2, r3
  a2:	f04f 0310 	mov.w	r3, #16
  a6:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			a6: R_ARM_THM_CALL	belle_gpio_pin_init
	switch(enable)
  aa:	78fb      	ldrb	r3, [r7, #3]
  ac:	2b00      	cmp	r3, #0
  ae:	d002      	beq.n	b6 <mux_setEnable+0x32>
  b0:	2b01      	cmp	r3, #1
  b2:	d00b      	beq.n	cc <mux_setEnable+0x48>
	{
		default: break;
  b4:	e015      	b.n	e2 <mux_setEnable+0x5e>
		case 0:
			GPIO_WriteBit(pin->port, pin->pin, WRITE_PORT_0);
  b6:	687b      	ldr	r3, [r7, #4]
  b8:	689a      	ldr	r2, [r3, #8]
  ba:	687b      	ldr	r3, [r7, #4]
  bc:	889b      	ldrh	r3, [r3, #4]
  be:	4610      	mov	r0, r2
  c0:	4619      	mov	r1, r3
  c2:	f04f 0200 	mov.w	r2, #0
  c6:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			c6: R_ARM_THM_CALL	GPIO_WriteBit
			break;
  ca:	e00a      	b.n	e2 <mux_setEnable+0x5e>
		case 1:
			GPIO_WriteBit(pin->port, pin->pin, WRITE_PORT_1);
  cc:	687b      	ldr	r3, [r7, #4]
  ce:	689a      	ldr	r2, [r3, #8]
  d0:	687b      	ldr	r3, [r7, #4]
  d2:	889b      	ldrh	r3, [r3, #4]
  d4:	4610      	mov	r0, r2
  d6:	4619      	mov	r1, r3
  d8:	f04f 0201 	mov.w	r2, #1
  dc:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			dc: R_ARM_THM_CALL	GPIO_WriteBit
			break;
  e0:	bf00      	nop
		return MUX_STATUS_SUCCESS;
	}
}
  e2:	4618      	mov	r0, r3
  e4:	f107 0708 	add.w	r7, r7, #8
  e8:	46bd      	mov	sp, r7
  ea:	bd80      	pop	{r7, pc}

000000ec <mux_selectChannel>:

mux_status_t
mux_selectChannel (mux_descr_t* mux, mux_channel_t channel)
{
  ec:	b580      	push	{r7, lr}
  ee:	b084      	sub	sp, #16
  f0:	af00      	add	r7, sp, #0
  f2:	6078      	str	r0, [r7, #4]
  f4:	460b      	mov	r3, r1
  f6:	70fb      	strb	r3, [r7, #3]
	uint8_t value_pin_0;
	uint8_t value_pin_1;
	uint8_t value_pin_2;

	XME_CHECK(NULL != mux, MUX_STATUS_INVALID_MUX_DESCRIPTOR);
  f8:	687b      	ldr	r3, [r7, #4]
  fa:	2b00      	cmp	r3, #0
  fc:	d102      	bne.n	104 <mux_selectChannel+0x18>
  fe:	f04f 0301 	mov.w	r3, #1
 102:	e03a      	b.n	17a <mux_selectChannel+0x8e>
	XME_CHECK(mux->minChannel <= channel && mux->maxChannel >= channel, MUX_STATUS_INVALID_MUX_CHANNEL);
 104:	687b      	ldr	r3, [r7, #4]
 106:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 10a:	78fa      	ldrb	r2, [r7, #3]
 10c:	429a      	cmp	r2, r3
 10e:	d305      	bcc.n	11c <mux_selectChannel+0x30>
 110:	687b      	ldr	r3, [r7, #4]
 112:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 116:	78fa      	ldrb	r2, [r7, #3]
 118:	429a      	cmp	r2, r3
 11a:	d902      	bls.n	122 <mux_selectChannel+0x36>
 11c:	f04f 0302 	mov.w	r3, #2
 120:	e02b      	b.n	17a <mux_selectChannel+0x8e>

	value_pin_0 = channel & 0x01;
 122:	78fb      	ldrb	r3, [r7, #3]
 124:	f003 0301 	and.w	r3, r3, #1
 128:	73fb      	strb	r3, [r7, #15]
	value_pin_1 = channel & 0x02;
 12a:	78fb      	ldrb	r3, [r7, #3]
 12c:	f003 0302 	and.w	r3, r3, #2
 130:	73bb      	strb	r3, [r7, #14]
	value_pin_2 = channel & 0x04;
 132:	78fb      	ldrb	r3, [r7, #3]
 134:	f003 0304 	and.w	r3, r3, #4
 138:	737b      	strb	r3, [r7, #13]

	GPIO_WriteBit(mux->mux_input0.port, mux->mux_input0.pin, value_pin_0);
 13a:	687b      	ldr	r3, [r7, #4]
 13c:	6899      	ldr	r1, [r3, #8]
 13e:	687b      	ldr	r3, [r7, #4]
 140:	889a      	ldrh	r2, [r3, #4]
 142:	7bfb      	ldrb	r3, [r7, #15]
 144:	4608      	mov	r0, r1
 146:	4611      	mov	r1, r2
 148:	461a      	mov	r2, r3
 14a:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			14a: R_ARM_THM_CALL	GPIO_WriteBit
	GPIO_WriteBit(mux->mux_input1.port, mux->mux_input1.pin, value_pin_1);
 14e:	687b      	ldr	r3, [r7, #4]
 150:	6959      	ldr	r1, [r3, #20]
 152:	687b      	ldr	r3, [r7, #4]
 154:	8a1a      	ldrh	r2, [r3, #16]
 156:	7bbb      	ldrb	r3, [r7, #14]
 158:	4608      	mov	r0, r1
 15a:	4611      	mov	r1, r2
 15c:	461a      	mov	r2, r3
 15e:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			15e: R_ARM_THM_CALL	GPIO_WriteBit
	GPIO_WriteBit(mux->mux_input2.port, mux->mux_input2.pin, value_pin_2);
 162:	687b      	ldr	r3, [r7, #4]
 164:	6a19      	ldr	r1, [r3, #32]
 166:	687b      	ldr	r3, [r7, #4]
 168:	8b9a      	ldrh	r2, [r3, #28]
 16a:	7b7b      	ldrb	r3, [r7, #13]
 16c:	4608      	mov	r0, r1
 16e:	4611      	mov	r1, r2
 170:	461a      	mov	r2, r3
 172:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			172: R_ARM_THM_CALL	GPIO_WriteBit

	return MUX_STATUS_SUCCESS;
 176:	f04f 0300 	mov.w	r3, #0
 17a:	b25b      	sxtb	r3, r3
}
 17c:	4618      	mov	r0, r3
 17e:	f107 0710 	add.w	r7, r7, #16
 182:	46bd      	mov	sp, r7
 184:	bd80      	pop	{r7, pc}
 186:	bf00      	nop

00000188 <mux_fini>:

mux_status_t
mux_fini (mux_descr_t* mux)
{
 188:	b580      	push	{r7, lr}
 18a:	b082      	sub	sp, #8
 18c:	af00      	add	r7, sp, #0
 18e:	6078      	str	r0, [r7, #4]
	mux_selectChannel(mux, MUX_CHANNEL_0);
 190:	6878      	ldr	r0, [r7, #4]
 192:	f04f 0100 	mov.w	r1, #0
 196:	f7ff fffe 	bl	ec <mux_selectChannel>
			196: R_ARM_THM_CALL	mux_selectChannel

	GPIO_WriteBit(mux->enable_pin.port, mux->enable_pin.pin, (mux->enable_pin_set ^ INVERT_ENABLE_PIN));
 19a:	687b      	ldr	r3, [r7, #4]
 19c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 19e:	687b      	ldr	r3, [r7, #4]
 1a0:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 1a2:	687b      	ldr	r3, [r7, #4]
 1a4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 1a8:	f083 0301 	eor.w	r3, r3, #1
 1ac:	b2db      	uxtb	r3, r3
 1ae:	4608      	mov	r0, r1
 1b0:	4611      	mov	r1, r2
 1b2:	461a      	mov	r2, r3
 1b4:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			1b4: R_ARM_THM_CALL	GPIO_WriteBit

	return MUX_STATUS_SUCCESS;
 1b8:	f04f 0300 	mov.w	r3, #0
 1bc:	b25b      	sxtb	r3, r3
}
 1be:	4618      	mov	r0, r3
 1c0:	f107 0708 	add.w	r7, r7, #8
 1c4:	46bd      	mov	sp, r7
 1c6:	bd80      	pop	{r7, pc}

mux_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 317228 Jul 30 19:06 2021 mux_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000104  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000138  2**0
                  ALLOC
  3 .debug_abbrev 000000e2  00000000  00000000  00000138  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000002c0  00000000  00000000  0000021a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000041a  00000000  00000000  000004da  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0004c2dd  00000000  00000000  000008f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000074  00000000  00000000  0004cbd1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 000000b3  00000000  00000000  0004cc45  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000002a5  00000000  00000000  0004ccf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  0004cf9d  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  0004cfc8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 mux_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .data	00000034 mux_adc
00000034 g     O .data	00000034 dac_mux
00000068 g     O .data	00000034 board_selection_dac
0000009c g     O .data	00000034 board_selection_adc
000000d0 g     O .data	00000034 channel_selection_adc



gpio_config.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 314808 Jul 30 19:07 2021 gpio_config.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000040  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000074  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000074  2**0
                  ALLOC
  3 .debug_abbrev 00000113  00000000  00000000  00000074  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000024c  00000000  00000000  00000187  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000041b  00000000  00000000  000003d3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0004b956  00000000  00000000  000007ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000038  00000000  00000000  0004c144  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000002a  00000000  00000000  0004c17c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000007d  00000000  00000000  0004c1a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0004c223  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    0000026b  00000000  00000000  0004c243  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0004c4ae  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0004c4d9  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000030  00000000  00000000  0004c50c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 gpio_config.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000040 belle_gpio_pin_init
00000000         *UND*	00000000 RCC_APB2PeriphClockCmd
00000000         *UND*	00000000 GPIO_Init



Disassembly of section .text:

00000000 <belle_gpio_pin_init>:
/******************************************************************************/
/***   Implementation            					                        ***/
/******************************************************************************/
void
belle_gpio_pin_init(uint32_t clock, GPIO_TypeDef* port, uint16_t pin, GPIOMode_TypeDef gpio_mode)
{
   0:	b580      	push	{r7, lr}
   2:	b086      	sub	sp, #24
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	80fa      	strh	r2, [r7, #6]
   c:	717b      	strb	r3, [r7, #5]
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd(clock | RCC_APB2Periph_AFIO, ENABLE);
   e:	68fb      	ldr	r3, [r7, #12]
  10:	f043 0301 	orr.w	r3, r3, #1
  14:	4618      	mov	r0, r3
  16:	f04f 0101 	mov.w	r1, #1
  1a:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
			1a: R_ARM_THM_CALL	RCC_APB2PeriphClockCmd
	GPIO_InitStructure.GPIO_Mode = gpio_mode;
  1e:	797b      	ldrb	r3, [r7, #5]
  20:	75fb      	strb	r3, [r7, #23]
	GPIO_InitStructure.GPIO_Pin = pin;
  22:	88fb      	ldrh	r3, [r7, #6]
  24:	82bb      	strh	r3, [r7, #20]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  26:	f04f 0303 	mov.w	r3, #3
  2a:	75bb      	strb	r3, [r7, #22]

	GPIO_Init(port, &GPIO_InitStructure);
  2c:	f107 0314 	add.w	r3, r7, #20
  30:	68b8      	ldr	r0, [r7, #8]
  32:	4619      	mov	r1, r3
  34:	f7ff fffe 	bl	0 <GPIO_Init>
			34: R_ARM_THM_CALL	GPIO_Init
}
  38:	f107 0718 	add.w	r7, r7, #24
  3c:	46bd      	mov	sp, r7
  3e:	bd80      	pop	{r7, pc}

spi.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 342504 Jul 30 19:07 2021 spi.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003fc  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000430  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  00000430  2**2
                  ALLOC
  3 .debug_abbrev 0000016b  00000000  00000000  00000430  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000800  00000000  00000000  0000059b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000083f  00000000  00000000  00000d9b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0005082c  00000000  00000000  000015da  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000150  00000000  00000000  00051e06  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000009c  00000000  00000000  00051f56  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000001e3  00000000  00000000  00051ff2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  000521d5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000768  00000000  00000000  000521f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0005295d  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00052988  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000cc  00000000  00000000  000529bc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 spi.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 xme_core_config
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 xme_core_log_logCallback
00000000 g     F .text	000001a0 spi_init
00000000         *UND*	00000000 xQueueCreateMutex
00000000         *UND*	00000000 xQueueGenericReceive
00000000         *UND*	00000000 RCC_APB2PeriphClockCmd
00000000         *UND*	00000000 GPIO_PinRemapConfig
00000000         *UND*	00000000 RCC_APB1PeriphClockCmd
00000000         *UND*	00000000 belle_gpio_pin_init
00000000         *UND*	00000000 SPI_I2S_DeInit
00000000         *UND*	00000000 SPI_Init
00000000         *UND*	00000000 SPI_Cmd
00000000         *UND*	00000000 xQueueGenericSend
000001a0 g     F .text	0000001c spi_set_cselect
000001bc g     F .text	0000002c spi_ready
00000000         *UND*	00000000 SPI_I2S_GetFlagStatus
000001e8 g     F .text	0000002c spi_data_available
00000214 g     F .text	000001a2 spi_send_receive_data
00000000         *UND*	00000000 SPI_I2S_SendData
00000000         *UND*	00000000 SPI_I2S_ReceiveData
000003b8 g     F .text	00000044 spi_fini



Disassembly of section .text:

00000000 <spi_init>:
/******************************************************************************/
/***   Implementation for SPI					                        ***/
/******************************************************************************/
spi_status_t
spi_init (spi_descr_t* spi)
{
   0:	b580      	push	{r7, lr}
   2:	b088      	sub	sp, #32
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
	SPI_InitTypeDef    SPI_InitStructure;
	GPIO_InitTypeDef   GPIO_InitStructure;

	XME_CHECK(SPI_STATE_UNINITIALIZED == spi->state, SPI_STATUS_WRONG_STATE);
   8:	687b      	ldr	r3, [r7, #4]
   a:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   e:	2b00      	cmp	r3, #0
  10:	d002      	beq.n	18 <spi_init+0x18>
  12:	f04f 0306 	mov.w	r3, #6
  16:	e0b8      	b.n	18a <spi_init+0x18a>
	/* Create the Mutex */
	// Only one Mutex is created due to the fact that each Mutex needs memory and there is no way to destroy a Mutex and free the memory.
	if( (spi->xSPIMutex) == NULL )
  18:	687b      	ldr	r3, [r7, #4]
  1a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  1c:	2b00      	cmp	r3, #0
  1e:	d106      	bne.n	2e <spi_init+0x2e>
	{
	spi->xSPIMutex = xSemaphoreCreateMutex();
  20:	f04f 0001 	mov.w	r0, #1
  24:	f7ff fffe 	bl	0 <xQueueCreateMutex>
			24: R_ARM_THM_CALL	xQueueCreateMutex
  28:	4602      	mov	r2, r0
  2a:	687b      	ldr	r3, [r7, #4]
  2c:	631a      	str	r2, [r3, #48]	; 0x30
	}

	if( (spi->xSPIMutex) != NULL )
  2e:	687b      	ldr	r3, [r7, #4]
  30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  32:	2b00      	cmp	r3, #0
  34:	f000 80a7 	beq.w	186 <spi_init+0x186>
	{
		xSemaphoreTake(spi->xSPIMutex, portMAX_DELAY);
  38:	687b      	ldr	r3, [r7, #4]
  3a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  3c:	4618      	mov	r0, r3
  3e:	f04f 0100 	mov.w	r1, #0
  42:	f04f 32ff 	mov.w	r2, #4294967295
  46:	f04f 0300 	mov.w	r3, #0
  4a:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			4a: R_ARM_THM_CALL	xQueueGenericReceive

		switch (spi->data_length) {
  4e:	687b      	ldr	r3, [r7, #4]
  50:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
  54:	2b08      	cmp	r3, #8
  56:	d002      	beq.n	5e <spi_init+0x5e>
  58:	2b10      	cmp	r3, #16
  5a:	d004      	beq.n	66 <spi_init+0x66>
  5c:	e007      	b.n	6e <spi_init+0x6e>
			case SPI_DATA_LENGTH_8BIT:
				SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
  5e:	f04f 0300 	mov.w	r3, #0
  62:	823b      	strh	r3, [r7, #16]
				break;
  64:	e006      	b.n	74 <spi_init+0x74>
			case SPI_DATA_LENGTH_16BIT:
				SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
  66:	f44f 6300 	mov.w	r3, #2048	; 0x800
  6a:	823b      	strh	r3, [r7, #16]
				break;
  6c:	e002      	b.n	74 <spi_init+0x74>
			default:
				return SPI_STATUS_DATA_LENGTH_NOT_SUPPORTED;
  6e:	f04f 0304 	mov.w	r3, #4
  72:	e08a      	b.n	18a <spi_init+0x18a>
		RCC_APB2PeriphClockCmd( spi->nss_pin.clock , ENABLE);
		belle_gpio_pin_init(spi->nss_pin.clock, spi->nss_pin.port, spi->nss_pin.pin, GPIO_Mode_Out_PP);
		spi_set_cselect(spi, spi->nss_idle);
#endif
		/* Enable GPIO clock */
		RCC_APB2PeriphClockCmd( spi->sck.clock | RCC_APB2Periph_AFIO , ENABLE);
  74:	687b      	ldr	r3, [r7, #4]
  76:	689b      	ldr	r3, [r3, #8]
  78:	f043 0301 	orr.w	r3, r3, #1
  7c:	4618      	mov	r0, r3
  7e:	f04f 0101 	mov.w	r1, #1
  82:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
			82: R_ARM_THM_CALL	RCC_APB2PeriphClockCmd

		GPIO_PinRemapConfig(GPIO_Remap_SPI3, ENABLE);
  86:	4843      	ldr	r0, [pc, #268]	; (194 <spi_init+0x194>)
  88:	f04f 0101 	mov.w	r1, #1
  8c:	f7ff fffe 	bl	0 <GPIO_PinRemapConfig>
			8c: R_ARM_THM_CALL	GPIO_PinRemapConfig

		/* Enable SPI clock  */
		// Different PeriphClockCmd function has to be called in order to enable the corresponding SPI clock. (SPI1 or SPI3)
		if (spi->spiUsed == SPI3)
  90:	687b      	ldr	r3, [r7, #4]
  92:	681a      	ldr	r2, [r3, #0]
  94:	4b40      	ldr	r3, [pc, #256]	; (198 <spi_init+0x198>)
  96:	429a      	cmp	r2, r3
  98:	d106      	bne.n	a8 <spi_init+0xa8>
		{
			RCC_APB1PeriphClockCmd(spi->spi_clock, ENABLE);
  9a:	687b      	ldr	r3, [r7, #4]
  9c:	685b      	ldr	r3, [r3, #4]
  9e:	4618      	mov	r0, r3
  a0:	f04f 0101 	mov.w	r1, #1
  a4:	f7ff fffe 	bl	0 <RCC_APB1PeriphClockCmd>
			a4: R_ARM_THM_CALL	RCC_APB1PeriphClockCmd
		}

		if(spi->spiUsed == SPI1)
  a8:	687b      	ldr	r3, [r7, #4]
  aa:	681a      	ldr	r2, [r3, #0]
  ac:	4b3b      	ldr	r3, [pc, #236]	; (19c <spi_init+0x19c>)
  ae:	429a      	cmp	r2, r3
  b0:	d106      	bne.n	c0 <spi_init+0xc0>
		{
			RCC_APB2PeriphClockCmd(spi->spi_clock, ENABLE);
  b2:	687b      	ldr	r3, [r7, #4]
  b4:	685b      	ldr	r3, [r3, #4]
  b6:	4618      	mov	r0, r3
  b8:	f04f 0101 	mov.w	r1, #1
  bc:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
			bc: R_ARM_THM_CALL	RCC_APB2PeriphClockCmd
		}

		/* Configure SPI pins: SCK and MOSI as output*/
		belle_gpio_pin_init(spi->sck.clock, spi->sck.port, spi->sck.pin, GPIO_Mode_AF_PP);
  c0:	687b      	ldr	r3, [r7, #4]
  c2:	6899      	ldr	r1, [r3, #8]
  c4:	687b      	ldr	r3, [r7, #4]
  c6:	691a      	ldr	r2, [r3, #16]
  c8:	687b      	ldr	r3, [r7, #4]
  ca:	899b      	ldrh	r3, [r3, #12]
  cc:	4608      	mov	r0, r1
  ce:	4611      	mov	r1, r2
  d0:	461a      	mov	r2, r3
  d2:	f04f 0318 	mov.w	r3, #24
  d6:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			d6: R_ARM_THM_CALL	belle_gpio_pin_init
		belle_gpio_pin_init(spi->mosi.clock, spi->mosi.port, spi->mosi.pin, GPIO_Mode_AF_PP);
  da:	687b      	ldr	r3, [r7, #4]
  dc:	6959      	ldr	r1, [r3, #20]
  de:	687b      	ldr	r3, [r7, #4]
  e0:	69da      	ldr	r2, [r3, #28]
  e2:	687b      	ldr	r3, [r7, #4]
  e4:	8b1b      	ldrh	r3, [r3, #24]
  e6:	4608      	mov	r0, r1
  e8:	4611      	mov	r1, r2
  ea:	461a      	mov	r2, r3
  ec:	f04f 0318 	mov.w	r3, #24
  f0:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			f0: R_ARM_THM_CALL	belle_gpio_pin_init

		/* Configure SPI pins: MISO as input*/
		belle_gpio_pin_init(spi->miso.clock, spi->miso.port, spi->miso.pin, GPIO_Mode_AF_PP);
  f4:	687b      	ldr	r3, [r7, #4]
  f6:	6a19      	ldr	r1, [r3, #32]
  f8:	687b      	ldr	r3, [r7, #4]
  fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  fc:	687b      	ldr	r3, [r7, #4]
  fe:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 100:	4608      	mov	r0, r1
 102:	4611      	mov	r1, r2
 104:	461a      	mov	r2, r3
 106:	f04f 0318 	mov.w	r3, #24
 10a:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			10a: R_ARM_THM_CALL	belle_gpio_pin_init

		SPI_I2S_DeInit(spi->spiUsed);
 10e:	687b      	ldr	r3, [r7, #4]
 110:	681b      	ldr	r3, [r3, #0]
 112:	4618      	mov	r0, r3
 114:	f7ff fffe 	bl	0 <SPI_I2S_DeInit>
			114: R_ARM_THM_CALL	SPI_I2S_DeInit

		/* SPI Config */
		SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 118:	f04f 0300 	mov.w	r3, #0
 11c:	81bb      	strh	r3, [r7, #12]
		SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 11e:	f44f 7382 	mov.w	r3, #260	; 0x104
 122:	81fb      	strh	r3, [r7, #14]
		SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
 124:	f04f 0302 	mov.w	r3, #2
 128:	827b      	strh	r3, [r7, #18]
		SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 12a:	f04f 0300 	mov.w	r3, #0
 12e:	82bb      	strh	r3, [r7, #20]
		SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 130:	f44f 7300 	mov.w	r3, #512	; 0x200
 134:	82fb      	strh	r3, [r7, #22]
		SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
 136:	f04f 0328 	mov.w	r3, #40	; 0x28
 13a:	833b      	strh	r3, [r7, #24]
		SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 13c:	f04f 0300 	mov.w	r3, #0
 140:	837b      	strh	r3, [r7, #26]
		SPI_Init(spi->spiUsed, &SPI_InitStructure);
 142:	687b      	ldr	r3, [r7, #4]
 144:	681a      	ldr	r2, [r3, #0]
 146:	f107 030c 	add.w	r3, r7, #12
 14a:	4610      	mov	r0, r2
 14c:	4619      	mov	r1, r3
 14e:	f7ff fffe 	bl	0 <SPI_Init>
			14e: R_ARM_THM_CALL	SPI_Init

		/* SPI enable */
		SPI_Cmd(spi->spiUsed, ENABLE);
 152:	687b      	ldr	r3, [r7, #4]
 154:	681b      	ldr	r3, [r3, #0]
 156:	4618      	mov	r0, r3
 158:	f04f 0101 	mov.w	r1, #1
 15c:	f7ff fffe 	bl	0 <SPI_Cmd>
			15c: R_ARM_THM_CALL	SPI_Cmd
		xSemaphoreGive(spi->xSPIMutex);
 160:	687b      	ldr	r3, [r7, #4]
 162:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 164:	4618      	mov	r0, r3
 166:	f04f 0100 	mov.w	r1, #0
 16a:	f04f 0200 	mov.w	r2, #0
 16e:	f04f 0300 	mov.w	r3, #0
 172:	f7ff fffe 	bl	0 <xQueueGenericSend>
			172: R_ARM_THM_CALL	xQueueGenericSend

		spi->state = SPI_STATE_READY;
 176:	687b      	ldr	r3, [r7, #4]
 178:	f04f 0201 	mov.w	r2, #1
 17c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
		return SPI_STATUS_SUCCESS;
 180:	f04f 0300 	mov.w	r3, #0
 184:	e001      	b.n	18a <spi_init+0x18a>
	}
	else
	{
		return SPI_STATUS_OPERATION_FAILED;
 186:	f04f 0307 	mov.w	r3, #7
	}
}
 18a:	4618      	mov	r0, r3
 18c:	f107 0720 	add.w	r7, r7, #32
 190:	46bd      	mov	sp, r7
 192:	bd80      	pop	{r7, pc}
 194:	00201100 	.word	0x00201100
 198:	40003c00 	.word	0x40003c00
 19c:	40013000 	.word	0x40013000

000001a0 <spi_set_cselect>:

spi_status_t
spi_set_cselect (spi_descr_t* spi, spi_nss_t value)
{
 1a0:	b480      	push	{r7}
 1a2:	b083      	sub	sp, #12
 1a4:	af00      	add	r7, sp, #0
 1a6:	6078      	str	r0, [r7, #4]
 1a8:	460b      	mov	r3, r1
 1aa:	70fb      	strb	r3, [r7, #3]
#if GPIO_NSS_AVAILABLE
	GPIO_WriteBit(spi->nss_pin.port, spi->nss_pin.pin, value);
#endif
	return SPI_STATUS_SUCCESS;
 1ac:	f04f 0300 	mov.w	r3, #0
}
 1b0:	4618      	mov	r0, r3
 1b2:	f107 070c 	add.w	r7, r7, #12
 1b6:	46bd      	mov	sp, r7
 1b8:	bc80      	pop	{r7}
 1ba:	4770      	bx	lr

000001bc <spi_ready>:

bool
spi_ready (spi_descr_t* spi)
{
 1bc:	b580      	push	{r7, lr}
 1be:	b082      	sub	sp, #8
 1c0:	af00      	add	r7, sp, #0
 1c2:	6078      	str	r0, [r7, #4]
	return SET == SPI_I2S_GetFlagStatus(spi->spiUsed, SPI_I2S_FLAG_TXE);
 1c4:	687b      	ldr	r3, [r7, #4]
 1c6:	681b      	ldr	r3, [r3, #0]
 1c8:	4618      	mov	r0, r3
 1ca:	f04f 0102 	mov.w	r1, #2
 1ce:	f7ff fffe 	bl	0 <SPI_I2S_GetFlagStatus>
			1ce: R_ARM_THM_CALL	SPI_I2S_GetFlagStatus
 1d2:	4603      	mov	r3, r0
 1d4:	2b01      	cmp	r3, #1
 1d6:	bf14      	ite	ne
 1d8:	2300      	movne	r3, #0
 1da:	2301      	moveq	r3, #1
 1dc:	b2db      	uxtb	r3, r3
}
 1de:	4618      	mov	r0, r3
 1e0:	f107 0708 	add.w	r7, r7, #8
 1e4:	46bd      	mov	sp, r7
 1e6:	bd80      	pop	{r7, pc}

000001e8 <spi_data_available>:

bool
spi_data_available (spi_descr_t* spi)
{
 1e8:	b580      	push	{r7, lr}
 1ea:	b082      	sub	sp, #8
 1ec:	af00      	add	r7, sp, #0
 1ee:	6078      	str	r0, [r7, #4]
	return SET == SPI_I2S_GetFlagStatus(spi->spiUsed, SPI_I2S_FLAG_RXNE);
 1f0:	687b      	ldr	r3, [r7, #4]
 1f2:	681b      	ldr	r3, [r3, #0]
 1f4:	4618      	mov	r0, r3
 1f6:	f04f 0101 	mov.w	r1, #1
 1fa:	f7ff fffe 	bl	0 <SPI_I2S_GetFlagStatus>
			1fa: R_ARM_THM_CALL	SPI_I2S_GetFlagStatus
 1fe:	4603      	mov	r3, r0
 200:	2b01      	cmp	r3, #1
 202:	bf14      	ite	ne
 204:	2300      	movne	r3, #0
 206:	2301      	moveq	r3, #1
 208:	b2db      	uxtb	r3, r3
}
 20a:	4618      	mov	r0, r3
 20c:	f107 0708 	add.w	r7, r7, #8
 210:	46bd      	mov	sp, r7
 212:	bd80      	pop	{r7, pc}

00000214 <spi_send_receive_data>:

spi_status_t
spi_send_receive_data (spi_descr_t* spi, uint8_t data_send[], uint8_t size, uint8_t data_receive[])
{
 214:	b580      	push	{r7, lr}
 216:	b086      	sub	sp, #24
 218:	af00      	add	r7, sp, #0
 21a:	60f8      	str	r0, [r7, #12]
 21c:	60b9      	str	r1, [r7, #8]
 21e:	603b      	str	r3, [r7, #0]
 220:	4613      	mov	r3, r2
 222:	71fb      	strb	r3, [r7, #7]
	uint8_t bytesPerCommand;
	uint16_t spi_send_data=0, spi_received_data=0;
 224:	f04f 0300 	mov.w	r3, #0
 228:	82fb      	strh	r3, [r7, #22]
 22a:	f04f 0300 	mov.w	r3, #0
 22e:	827b      	strh	r3, [r7, #18]
	uint8_t numberCommands;
	uint8_t i;
	XME_CHECK(SPI_STATE_READY == spi->state, SPI_STATUS_WRONG_STATE);
 230:	68fb      	ldr	r3, [r7, #12]
 232:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 236:	2b01      	cmp	r3, #1
 238:	d002      	beq.n	240 <spi_send_receive_data+0x2c>
 23a:	f04f 0306 	mov.w	r3, #6
 23e:	e0b5      	b.n	3ac <spi_send_receive_data+0x198>

	xSemaphoreTake(spi->xSPIMutex, portMAX_DELAY);
 240:	68fb      	ldr	r3, [r7, #12]
 242:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 244:	4618      	mov	r0, r3
 246:	f04f 0100 	mov.w	r1, #0
 24a:	f04f 32ff 	mov.w	r2, #4294967295
 24e:	f04f 0300 	mov.w	r3, #0
 252:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			252: R_ARM_THM_CALL	xQueueGenericReceive

	bytesPerCommand = spi->data_length / 8;
 256:	68fb      	ldr	r3, [r7, #12]
 258:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 25c:	ea4f 03d3 	mov.w	r3, r3, lsr #3
 260:	747b      	strb	r3, [r7, #17]

	XME_CHECK(1 == bytesPerCommand || 2 == bytesPerCommand, SPI_STATUS_DATA_LENGTH_NOT_SUPPORTED);
 262:	7c7b      	ldrb	r3, [r7, #17]
 264:	2b01      	cmp	r3, #1
 266:	d005      	beq.n	274 <spi_send_receive_data+0x60>
 268:	7c7b      	ldrb	r3, [r7, #17]
 26a:	2b02      	cmp	r3, #2
 26c:	d002      	beq.n	274 <spi_send_receive_data+0x60>
 26e:	f04f 0304 	mov.w	r3, #4
 272:	e09b      	b.n	3ac <spi_send_receive_data+0x198>
	XME_CHECK(0 == size % bytesPerCommand, SPI_STATUS_WRONG_DATA_SIZE);
 274:	79fb      	ldrb	r3, [r7, #7]
 276:	7c7a      	ldrb	r2, [r7, #17]
 278:	fbb3 f1f2 	udiv	r1, r3, r2
 27c:	fb02 f201 	mul.w	r2, r2, r1
 280:	1a9b      	subs	r3, r3, r2
 282:	b2db      	uxtb	r3, r3
 284:	2b00      	cmp	r3, #0
 286:	d002      	beq.n	28e <spi_send_receive_data+0x7a>
 288:	f04f 0305 	mov.w	r3, #5
 28c:	e08e      	b.n	3ac <spi_send_receive_data+0x198>

	numberCommands = size / bytesPerCommand;
 28e:	79fa      	ldrb	r2, [r7, #7]
 290:	7c7b      	ldrb	r3, [r7, #17]
 292:	fbb2 f3f3 	udiv	r3, r2, r3
 296:	743b      	strb	r3, [r7, #16]
	spi_set_cselect(spi, SPI_NSS_LOW);
 298:	68f8      	ldr	r0, [r7, #12]
 29a:	f04f 0100 	mov.w	r1, #0
 29e:	f7ff fffe 	bl	1a0 <spi_set_cselect>
			29e: R_ARM_THM_CALL	spi_set_cselect
	for (i = 0; i < numberCommands; i++)
 2a2:	f04f 0300 	mov.w	r3, #0
 2a6:	757b      	strb	r3, [r7, #21]
 2a8:	e06a      	b.n	380 <spi_send_receive_data+0x16c>
	{
		//TODO MSBF, LSBF
		if (SPI_DATA_LENGTH_8BIT == spi->data_length)
 2aa:	68fb      	ldr	r3, [r7, #12]
 2ac:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 2b0:	2b08      	cmp	r3, #8
 2b2:	d105      	bne.n	2c0 <spi_send_receive_data+0xac>
		{
			spi_send_data = data_send[i];
 2b4:	7d7b      	ldrb	r3, [r7, #21]
 2b6:	68ba      	ldr	r2, [r7, #8]
 2b8:	18d3      	adds	r3, r2, r3
 2ba:	781b      	ldrb	r3, [r3, #0]
 2bc:	82fb      	strh	r3, [r7, #22]
		else //SPI_DATA_LENGTH_16BIT
		{
			spi_send_data = data_send[i * bytesPerCommand] << 8 | data_send[i * bytesPerCommand + 1];
		}

		while(!spi_ready(spi)); //TODO send buffer
 2be:	e017      	b.n	2f0 <spi_send_receive_data+0xdc>
		{
			spi_send_data = data_send[i];
		}
		else //SPI_DATA_LENGTH_16BIT
		{
			spi_send_data = data_send[i * bytesPerCommand] << 8 | data_send[i * bytesPerCommand + 1];
 2c0:	7d7b      	ldrb	r3, [r7, #21]
 2c2:	7c7a      	ldrb	r2, [r7, #17]
 2c4:	fb02 f303 	mul.w	r3, r2, r3
 2c8:	68ba      	ldr	r2, [r7, #8]
 2ca:	18d3      	adds	r3, r2, r3
 2cc:	781b      	ldrb	r3, [r3, #0]
 2ce:	ea4f 2303 	mov.w	r3, r3, lsl #8
 2d2:	b29a      	uxth	r2, r3
 2d4:	7d7b      	ldrb	r3, [r7, #21]
 2d6:	7c79      	ldrb	r1, [r7, #17]
 2d8:	fb01 f303 	mul.w	r3, r1, r3
 2dc:	f103 0301 	add.w	r3, r3, #1
 2e0:	68b9      	ldr	r1, [r7, #8]
 2e2:	18cb      	adds	r3, r1, r3
 2e4:	781b      	ldrb	r3, [r3, #0]
 2e6:	ea42 0303 	orr.w	r3, r2, r3
 2ea:	b29b      	uxth	r3, r3
 2ec:	82fb      	strh	r3, [r7, #22]
		}

		while(!spi_ready(spi)); //TODO send buffer
 2ee:	bf00      	nop
 2f0:	68f8      	ldr	r0, [r7, #12]
 2f2:	f7ff fffe 	bl	1bc <spi_ready>
			2f2: R_ARM_THM_CALL	spi_ready
 2f6:	4603      	mov	r3, r0
 2f8:	f083 0301 	eor.w	r3, r3, #1
 2fc:	b2db      	uxtb	r3, r3
 2fe:	2b00      	cmp	r3, #0
 300:	d1f6      	bne.n	2f0 <spi_send_receive_data+0xdc>

		SPI_I2S_SendData(spi->spiUsed, spi_send_data);
 302:	68fb      	ldr	r3, [r7, #12]
 304:	681a      	ldr	r2, [r3, #0]
 306:	8afb      	ldrh	r3, [r7, #22]
 308:	4610      	mov	r0, r2
 30a:	4619      	mov	r1, r3
 30c:	f7ff fffe 	bl	0 <SPI_I2S_SendData>
			30c: R_ARM_THM_CALL	SPI_I2S_SendData

		while(!spi_data_available(spi));
 310:	bf00      	nop
 312:	68f8      	ldr	r0, [r7, #12]
 314:	f7ff fffe 	bl	1e8 <spi_data_available>
			314: R_ARM_THM_CALL	spi_data_available
 318:	4603      	mov	r3, r0
 31a:	f083 0301 	eor.w	r3, r3, #1
 31e:	b2db      	uxtb	r3, r3
 320:	2b00      	cmp	r3, #0
 322:	d1f6      	bne.n	312 <spi_send_receive_data+0xfe>

		spi_received_data = SPI_I2S_ReceiveData(spi->spiUsed);
 324:	68fb      	ldr	r3, [r7, #12]
 326:	681b      	ldr	r3, [r3, #0]
 328:	4618      	mov	r0, r3
 32a:	f7ff fffe 	bl	0 <SPI_I2S_ReceiveData>
			32a: R_ARM_THM_CALL	SPI_I2S_ReceiveData
 32e:	4603      	mov	r3, r0
 330:	827b      	strh	r3, [r7, #18]
		if (SPI_DATA_LENGTH_8BIT == spi->data_length)
 332:	68fb      	ldr	r3, [r7, #12]
 334:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 338:	2b08      	cmp	r3, #8
 33a:	d106      	bne.n	34a <spi_send_receive_data+0x136>
		{
			data_receive[i] = spi_received_data;
 33c:	7d7b      	ldrb	r3, [r7, #21]
 33e:	683a      	ldr	r2, [r7, #0]
 340:	18d3      	adds	r3, r2, r3
 342:	8a7a      	ldrh	r2, [r7, #18]
 344:	b2d2      	uxtb	r2, r2
 346:	701a      	strb	r2, [r3, #0]
 348:	e016      	b.n	378 <spi_send_receive_data+0x164>
		}
		else //SPI_DATA_LENGTH_16BIT
		{
			data_receive[i * bytesPerCommand] = spi_received_data >> 8;
 34a:	7d7b      	ldrb	r3, [r7, #21]
 34c:	7c7a      	ldrb	r2, [r7, #17]
 34e:	fb02 f303 	mul.w	r3, r2, r3
 352:	683a      	ldr	r2, [r7, #0]
 354:	18d3      	adds	r3, r2, r3
 356:	8a7a      	ldrh	r2, [r7, #18]
 358:	ea4f 2212 	mov.w	r2, r2, lsr #8
 35c:	b292      	uxth	r2, r2
 35e:	b2d2      	uxtb	r2, r2
 360:	701a      	strb	r2, [r3, #0]
			data_receive[i * bytesPerCommand + 1] = spi_received_data;
 362:	7d7b      	ldrb	r3, [r7, #21]
 364:	7c7a      	ldrb	r2, [r7, #17]
 366:	fb02 f303 	mul.w	r3, r2, r3
 36a:	f103 0301 	add.w	r3, r3, #1
 36e:	683a      	ldr	r2, [r7, #0]
 370:	18d3      	adds	r3, r2, r3
 372:	8a7a      	ldrh	r2, [r7, #18]
 374:	b2d2      	uxtb	r2, r2
 376:	701a      	strb	r2, [r3, #0]
	XME_CHECK(1 == bytesPerCommand || 2 == bytesPerCommand, SPI_STATUS_DATA_LENGTH_NOT_SUPPORTED);
	XME_CHECK(0 == size % bytesPerCommand, SPI_STATUS_WRONG_DATA_SIZE);

	numberCommands = size / bytesPerCommand;
	spi_set_cselect(spi, SPI_NSS_LOW);
	for (i = 0; i < numberCommands; i++)
 378:	7d7b      	ldrb	r3, [r7, #21]
 37a:	f103 0301 	add.w	r3, r3, #1
 37e:	757b      	strb	r3, [r7, #21]
 380:	7d7a      	ldrb	r2, [r7, #21]
 382:	7c3b      	ldrb	r3, [r7, #16]
 384:	429a      	cmp	r2, r3
 386:	d390      	bcc.n	2aa <spi_send_receive_data+0x96>
		{
			data_receive[i * bytesPerCommand] = spi_received_data >> 8;
			data_receive[i * bytesPerCommand + 1] = spi_received_data;
		}
	}
	spi_set_cselect(spi, SPI_NSS_HIGH);
 388:	68f8      	ldr	r0, [r7, #12]
 38a:	f04f 0101 	mov.w	r1, #1
 38e:	f7ff fffe 	bl	1a0 <spi_set_cselect>
			38e: R_ARM_THM_CALL	spi_set_cselect
	xSemaphoreGive(spi->xSPIMutex);
 392:	68fb      	ldr	r3, [r7, #12]
 394:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 396:	4618      	mov	r0, r3
 398:	f04f 0100 	mov.w	r1, #0
 39c:	f04f 0200 	mov.w	r2, #0
 3a0:	f04f 0300 	mov.w	r3, #0
 3a4:	f7ff fffe 	bl	0 <xQueueGenericSend>
			3a4: R_ARM_THM_CALL	xQueueGenericSend
	return SPI_STATUS_SUCCESS;
 3a8:	f04f 0300 	mov.w	r3, #0
}
 3ac:	4618      	mov	r0, r3
 3ae:	f107 0718 	add.w	r7, r7, #24
 3b2:	46bd      	mov	sp, r7
 3b4:	bd80      	pop	{r7, pc}
 3b6:	bf00      	nop

000003b8 <spi_fini>:
spi_status_t
spi_fini (spi_descr_t* spi)
{
 3b8:	b580      	push	{r7, lr}
 3ba:	b082      	sub	sp, #8
 3bc:	af00      	add	r7, sp, #0
 3be:	6078      	str	r0, [r7, #4]
	XME_CHECK(SPI_STATE_READY == spi->state, SPI_STATUS_WRONG_STATE);
 3c0:	687b      	ldr	r3, [r7, #4]
 3c2:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
 3c6:	2b01      	cmp	r3, #1
 3c8:	d002      	beq.n	3d0 <spi_fini+0x18>
 3ca:	f04f 0306 	mov.w	r3, #6
 3ce:	e010      	b.n	3f2 <spi_fini+0x3a>
	SPI_I2S_DeInit(spi->spiUsed);
 3d0:	687b      	ldr	r3, [r7, #4]
 3d2:	681b      	ldr	r3, [r3, #0]
 3d4:	4618      	mov	r0, r3
 3d6:	f7ff fffe 	bl	0 <SPI_I2S_DeInit>
			3d6: R_ARM_THM_CALL	SPI_I2S_DeInit
	spi_set_cselect(spi, SPI_NSS_LOW);
 3da:	6878      	ldr	r0, [r7, #4]
 3dc:	f04f 0100 	mov.w	r1, #0
 3e0:	f7ff fffe 	bl	1a0 <spi_set_cselect>
			3e0: R_ARM_THM_CALL	spi_set_cselect
	spi->state = SPI_STATE_UNINITIALIZED;
 3e4:	687b      	ldr	r3, [r7, #4]
 3e6:	f04f 0200 	mov.w	r2, #0
 3ea:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
	return SPI_STATUS_SUCCESS;
 3ee:	f04f 0300 	mov.w	r3, #0
}
 3f2:	4618      	mov	r0, r3
 3f4:	f107 0708 	add.w	r7, r7, #8
 3f8:	46bd      	mov	sp, r7
 3fa:	bd80      	pop	{r7, pc}

spi_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 331480 Jul 30 19:07 2021 spi_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000068  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000009c  2**0
                  ALLOC
  3 .debug_abbrev 000000e9  00000000  00000000  0000009c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000003b9  00000000  00000000  00000185  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000005b9  00000000  00000000  0000053e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0004f8c3  00000000  00000000  00000af7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000002a  00000000  00000000  000503ba  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 000000ec  00000000  00000000  000503e4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000002c0  00000000  00000000  000504d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  00050790  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  000507bb  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 spi_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .data	00000034 dac_spi
00000034 g     O .data	00000034 adc_spi



adc_ad7322.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 344188 Jul 30 19:07 2021 adc_ad7322.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002ac  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  000002e0  2**2
                  ALLOC
  3 .debug_abbrev 00000197  00000000  00000000  000002e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000084e  00000000  00000000  00000477  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000008a0  00000000  00000000  00000cc5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0005105b  00000000  00000000  00001565  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000150  00000000  00000000  000525c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000fd  00000000  00000000  00052710  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000217  00000000  00000000  0005280d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00052a24  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    0000071d  00000000  00000000  00052a44  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00053161  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0005318c  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000d0  00000000  00000000  000531c0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 adc_ad7322.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 xme_core_config
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 xme_core_log_logCallback
00000000 g     F .text	00000038 ad7322_sign_extend_number
00000038 g     F .text	0000004e ad7322_write_register
00000000         *UND*	00000000 SPI_I2S_GetFlagStatus
00000000         *UND*	00000000 SPI_I2S_SendData
00000088 g     F .text	00000050 ad7322_read_spi_data
00000000         *UND*	00000000 SPI_I2S_ReceiveData
000000d8 g     F .text	000000b4 ad7322_process_spi_data
0000018c g     F .text	00000062 ad7322_configure_range_reg
00000000         *UND*	00000000 spi_send_receive_data
000001f0 g     F .text	000000ba ad7322_select_input_channel_read_channel_value_in_micro_scale



Disassembly of section .text:

00000000 <ad7322_sign_extend_number>:
	((uint8_t)(value & 0xFF))
/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
adc_status_t ad7322_sign_extend_number (uint16_t number_to_extend, ad7322_conversion_result_t *conversion_result)
{
   0:	b480      	push	{r7}
   2:	b085      	sub	sp, #20
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	6039      	str	r1, [r7, #0]
   a:	80fb      	strh	r3, [r7, #6]
	// Create sign mask.
	int const m = 1 << (NUMBERS_TO_EXTEND - 1);
   c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  10:	60fb      	str	r3, [r7, #12]
	uint16_t number_to_extend_temp;

	number_to_extend_temp = number_to_extend & ((1 << NUMBERS_TO_EXTEND) - 1);
  12:	88fb      	ldrh	r3, [r7, #6]
  14:	ea4f 43c3 	mov.w	r3, r3, lsl #19
  18:	ea4f 43d3 	mov.w	r3, r3, lsr #19
  1c:	817b      	strh	r3, [r7, #10]
	*conversion_result = (number_to_extend_temp ^ m) - m;
  1e:	897a      	ldrh	r2, [r7, #10]
  20:	68fb      	ldr	r3, [r7, #12]
  22:	405a      	eors	r2, r3
  24:	68fb      	ldr	r3, [r7, #12]
  26:	1ad2      	subs	r2, r2, r3
  28:	683b      	ldr	r3, [r7, #0]
  2a:	601a      	str	r2, [r3, #0]

}
  2c:	4618      	mov	r0, r3
  2e:	f107 0714 	add.w	r7, r7, #20
  32:	46bd      	mov	sp, r7
  34:	bc80      	pop	{r7}
  36:	4770      	bx	lr

00000038 <ad7322_write_register>:
adc_status_t ad7322_write_register (ad7322_descr_t *adc, ad7322_register_t reg, ad7322_register_value_t val)
{
  38:	b580      	push	{r7, lr}
  3a:	b082      	sub	sp, #8
  3c:	af00      	add	r7, sp, #0
  3e:	6078      	str	r0, [r7, #4]
  40:	4613      	mov	r3, r2
  42:	460a      	mov	r2, r1
  44:	807a      	strh	r2, [r7, #2]
  46:	803b      	strh	r3, [r7, #0]

	/* Wait until the transmit buffer is empty - TXE flag */
	while(SPI_I2S_GetFlagStatus(adc->spi->spiUsed, SPI_I2S_FLAG_TXE)!= SET);
  48:	bf00      	nop
  4a:	687b      	ldr	r3, [r7, #4]
  4c:	681b      	ldr	r3, [r3, #0]
  4e:	681b      	ldr	r3, [r3, #0]
  50:	4618      	mov	r0, r3
  52:	f04f 0102 	mov.w	r1, #2
  56:	f7ff fffe 	bl	0 <SPI_I2S_GetFlagStatus>
			56: R_ARM_THM_CALL	SPI_I2S_GetFlagStatus
  5a:	4603      	mov	r3, r0
  5c:	2b01      	cmp	r3, #1
  5e:	d1f4      	bne.n	4a <ad7322_write_register+0x12>

	/* Program the register */
	SPI_I2S_SendData(adc->spi->spiUsed, reg | val);
  60:	687b      	ldr	r3, [r7, #4]
  62:	681b      	ldr	r3, [r3, #0]
  64:	681a      	ldr	r2, [r3, #0]
  66:	8879      	ldrh	r1, [r7, #2]
  68:	883b      	ldrh	r3, [r7, #0]
  6a:	ea41 0303 	orr.w	r3, r1, r3
  6e:	b29b      	uxth	r3, r3
  70:	4610      	mov	r0, r2
  72:	4619      	mov	r1, r3
  74:	f7ff fffe 	bl	0 <SPI_I2S_SendData>
			74: R_ARM_THM_CALL	SPI_I2S_SendData

	return ADC_STATUS_SUCCESS;
  78:	f04f 0300 	mov.w	r3, #0
}
  7c:	4618      	mov	r0, r3
  7e:	f107 0708 	add.w	r7, r7, #8
  82:	46bd      	mov	sp, r7
  84:	bd80      	pop	{r7, pc}
  86:	bf00      	nop

00000088 <ad7322_read_spi_data>:

adc_status_t ad7322_read_spi_data (ad7322_descr_t *adc, ad7322_spi_data_t *spi_data)
{
  88:	b580      	push	{r7, lr}
  8a:	b082      	sub	sp, #8
  8c:	af00      	add	r7, sp, #0
  8e:	6078      	str	r0, [r7, #4]
  90:	6039      	str	r1, [r7, #0]
	/* Wait until a data is received - check on RXNE */
	while(SPI_I2S_GetFlagStatus(adc->spi->spiUsed, SPI_I2S_FLAG_RXNE) != SET);
  92:	bf00      	nop
  94:	687b      	ldr	r3, [r7, #4]
  96:	681b      	ldr	r3, [r3, #0]
  98:	681b      	ldr	r3, [r3, #0]
  9a:	4618      	mov	r0, r3
  9c:	f04f 0101 	mov.w	r1, #1
  a0:	f7ff fffe 	bl	0 <SPI_I2S_GetFlagStatus>
			a0: R_ARM_THM_CALL	SPI_I2S_GetFlagStatus
  a4:	4603      	mov	r3, r0
  a6:	2b01      	cmp	r3, #1
  a8:	d1f4      	bne.n	94 <ad7322_read_spi_data+0xc>

	if (0 != spi_data)
  aa:	683b      	ldr	r3, [r7, #0]
  ac:	2b00      	cmp	r3, #0
  ae:	d00c      	beq.n	ca <ad7322_read_spi_data+0x42>
	{
		/* Get the received data - Ignore data  */
		*spi_data = SPI_I2S_ReceiveData(adc->spi->spiUsed);
  b0:	687b      	ldr	r3, [r7, #4]
  b2:	681b      	ldr	r3, [r3, #0]
  b4:	681b      	ldr	r3, [r3, #0]
  b6:	4618      	mov	r0, r3
  b8:	f7ff fffe 	bl	0 <SPI_I2S_ReceiveData>
			b8: R_ARM_THM_CALL	SPI_I2S_ReceiveData
  bc:	4603      	mov	r3, r0
  be:	461a      	mov	r2, r3
  c0:	683b      	ldr	r3, [r7, #0]
  c2:	801a      	strh	r2, [r3, #0]
		return ADC_STATUS_SUCCESS;
  c4:	f04f 0300 	mov.w	r3, #0
  c8:	e001      	b.n	ce <ad7322_read_spi_data+0x46>
	}
	else
	{
		return ADC_ERROR_READING_DATA;
  ca:	f04f 0302 	mov.w	r3, #2
	}
}
  ce:	4618      	mov	r0, r3
  d0:	f107 0708 	add.w	r7, r7, #8
  d4:	46bd      	mov	sp, r7
  d6:	bd80      	pop	{r7, pc}

000000d8 <ad7322_process_spi_data>:

adc_status_t ad7322_process_spi_data (ad7322_descr_t *adc, ad7322_channel_t *channel, ad7322_spi_data_t *spi_data, ad7322_conversion_result_t *result)
{
  d8:	b5b0      	push	{r4, r5, r7, lr}
  da:	b08a      	sub	sp, #40	; 0x28
  dc:	af00      	add	r7, sp, #0
  de:	60f8      	str	r0, [r7, #12]
  e0:	60b9      	str	r1, [r7, #8]
  e2:	607a      	str	r2, [r7, #4]
  e4:	603b      	str	r3, [r7, #0]
	ad7322_conversion_result_t temp_res;
	uint16_t adc_conversion_result;
	int64_t conversion_temp;

	// Conversion result : extend and convert
	adc_conversion_result = ((*spi_data) & AD7322_DATA_MASK_SIGN);
  e6:	687b      	ldr	r3, [r7, #4]
  e8:	881b      	ldrh	r3, [r3, #0]
  ea:	ea4f 43c3 	mov.w	r3, r3, lsl #19
  ee:	ea4f 43d3 	mov.w	r3, r3, lsr #19
  f2:	84fb      	strh	r3, [r7, #38]	; 0x26
	ad7322_sign_extend_number (adc_conversion_result, &temp_res);
  f4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
  f6:	f107 0314 	add.w	r3, r7, #20
  fa:	4610      	mov	r0, r2
  fc:	4619      	mov	r1, r3
  fe:	f7ff fffe 	bl	0 <ad7322_sign_extend_number>
			fe: R_ARM_THM_CALL	ad7322_sign_extend_number
	// TODO: Check if this is necessary.
	conversion_temp = ((((int64_t)temp_res * ADC_VRANGE * ADC_PRECISION * ADC_PRECISION)) / ADC_BITS) ;
 102:	697b      	ldr	r3, [r7, #20]
 104:	461a      	mov	r2, r3
 106:	ea4f 73e3 	mov.w	r3, r3, asr #31
 10a:	491f      	ldr	r1, [pc, #124]	; (188 <ad7322_process_spi_data+0xb0>)
 10c:	fb01 f103 	mul.w	r1, r1, r3
 110:	f04f 0000 	mov.w	r0, #0
 114:	fb00 f002 	mul.w	r0, r0, r2
 118:	1809      	adds	r1, r1, r0
 11a:	481b      	ldr	r0, [pc, #108]	; (188 <ad7322_process_spi_data+0xb0>)
 11c:	fba2 2300 	umull	r2, r3, r2, r0
 120:	18c9      	adds	r1, r1, r3
 122:	460b      	mov	r3, r1
 124:	2a00      	cmp	r2, #0
 126:	f173 0100 	sbcs.w	r1, r3, #0
 12a:	da06      	bge.n	13a <ad7322_process_spi_data+0x62>
 12c:	f641 70ff 	movw	r0, #8191	; 0x1fff
 130:	f04f 0100 	mov.w	r1, #0
 134:	1812      	adds	r2, r2, r0
 136:	eb43 0301 	adc.w	r3, r3, r1
 13a:	ea4f 41c3 	mov.w	r1, r3, lsl #19
 13e:	ea4f 3452 	mov.w	r4, r2, lsr #13
 142:	ea41 0404 	orr.w	r4, r1, r4
 146:	ea4f 3563 	mov.w	r5, r3, asr #13
 14a:	e9c7 4506 	strd	r4, r5, [r7, #24]
	*result = (int32_t)conversion_temp;
 14e:	69ba      	ldr	r2, [r7, #24]
 150:	683b      	ldr	r3, [r7, #0]
 152:	601a      	str	r2, [r3, #0]
	//*result = (((temp_res * ADC_VRANGE * ADC_PRECISION) / ADC_BITS) * ADC_PRECISION); STR Change

	// Check for valid channel ID
	*channel = ((*spi_data) & AD7322_CHANNEL_ID_MASK);
 154:	687b      	ldr	r3, [r7, #4]
 156:	881b      	ldrh	r3, [r3, #0]
 158:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 15c:	b29a      	uxth	r2, r3
 15e:	68bb      	ldr	r3, [r7, #8]
 160:	801a      	strh	r2, [r3, #0]
	if ((AD7322_CHANNEL_ID_0 != *channel) && (AD7322_CHANNEL_ID_1 != *channel))
 162:	68bb      	ldr	r3, [r7, #8]
 164:	881b      	ldrh	r3, [r3, #0]
 166:	2b00      	cmp	r3, #0
 168:	d007      	beq.n	17a <ad7322_process_spi_data+0xa2>
 16a:	68bb      	ldr	r3, [r7, #8]
 16c:	881b      	ldrh	r3, [r3, #0]
 16e:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 172:	d002      	beq.n	17a <ad7322_process_spi_data+0xa2>
	{
		return ADC_ERROR;
 174:	f04f 0301 	mov.w	r3, #1
 178:	e001      	b.n	17e <ad7322_process_spi_data+0xa6>
	}

	return ADC_STATUS_SUCCESS;;
 17a:	f04f 0300 	mov.w	r3, #0
}
 17e:	4618      	mov	r0, r3
 180:	f107 0728 	add.w	r7, r7, #40	; 0x28
 184:	46bd      	mov	sp, r7
 186:	bdb0      	pop	{r4, r5, r7, pc}
 188:	00989680 	.word	0x00989680

0000018c <ad7322_configure_range_reg>:

adc_status_t ad7322_configure_range_reg (ad7322_descr_t *adc)
 {
 18c:	b580      	push	{r7, lr}
 18e:	b086      	sub	sp, #24
 190:	af00      	add	r7, sp, #0
 192:	6078      	str	r0, [r7, #4]
	ad7322_register_t reg;
	ad7322_register_value_t register_value;
	ad7322_spi_data_t spi_data;
	ad7322_channel_t channel_id;

	reg = AD7322_WRITE_RANGE_REGISTER;
 194:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 198:	82fb      	strh	r3, [r7, #22]
	register_value = AD7322_CHANNEL_1_M2_5V_2_5V | AD7322_CHANNEL_0_M2_5V_2_5V; //AD7322_CHANNEL_0_M5V_5V | AD7322_CHANNEL_1_M5V_5V;
 19a:	f44f 5388 	mov.w	r3, #4352	; 0x1100
 19e:	82bb      	strh	r3, [r7, #20]
	value = reg | register_value;
 1a0:	8afa      	ldrh	r2, [r7, #22]
 1a2:	8abb      	ldrh	r3, [r7, #20]
 1a4:	ea42 0303 	orr.w	r3, r2, r3
 1a8:	827b      	strh	r3, [r7, #18]
	data_send[0] = ADC_AD7322_HIGH_DATA_BYTE (value);
 1aa:	8a7b      	ldrh	r3, [r7, #18]
 1ac:	ea4f 2313 	mov.w	r3, r3, lsr #8
 1b0:	b29b      	uxth	r3, r3
 1b2:	b2db      	uxtb	r3, r3
 1b4:	743b      	strb	r3, [r7, #16]
	data_send[1] = ADC_AD7322_LOW_DATA_BYTE (value);
 1b6:	8a7b      	ldrh	r3, [r7, #18]
 1b8:	b2db      	uxtb	r3, r3
 1ba:	747b      	strb	r3, [r7, #17]

	// Send the data for the configuration of the range register and ignore converted result since the ADC has still not be configured
	if (SPI_STATUS_SUCCESS != spi_send_receive_data(adc->spi, data_send, sizeof(data_send), data_receive)) {return ADC_ERROR;}
 1bc:	687b      	ldr	r3, [r7, #4]
 1be:	6819      	ldr	r1, [r3, #0]
 1c0:	f107 0210 	add.w	r2, r7, #16
 1c4:	f107 030c 	add.w	r3, r7, #12
 1c8:	4608      	mov	r0, r1
 1ca:	4611      	mov	r1, r2
 1cc:	f04f 0202 	mov.w	r2, #2
 1d0:	f7ff fffe 	bl	0 <spi_send_receive_data>
			1d0: R_ARM_THM_CALL	spi_send_receive_data
 1d4:	4603      	mov	r3, r0
 1d6:	2b00      	cmp	r3, #0
 1d8:	d002      	beq.n	1e0 <ad7322_configure_range_reg+0x54>
 1da:	f04f 0301 	mov.w	r3, #1
 1de:	e001      	b.n	1e4 <ad7322_configure_range_reg+0x58>

 	return ADC_STATUS_SUCCESS;
 1e0:	f04f 0300 	mov.w	r3, #0
 }
 1e4:	4618      	mov	r0, r3
 1e6:	f107 0718 	add.w	r7, r7, #24
 1ea:	46bd      	mov	sp, r7
 1ec:	bd80      	pop	{r7, pc}
 1ee:	bf00      	nop

000001f0 <ad7322_select_input_channel_read_channel_value_in_micro_scale>:

adc_status_t ad7322_select_input_channel_read_channel_value_in_micro_scale (ad7322_descr_t *adc, ad7322_channel_t select_channel, ad7322_channel_t *read_channel, ad7322_conversion_result_t *result)
{
 1f0:	b580      	push	{r7, lr}
 1f2:	b08a      	sub	sp, #40	; 0x28
 1f4:	af00      	add	r7, sp, #0
 1f6:	60f8      	str	r0, [r7, #12]
 1f8:	607a      	str	r2, [r7, #4]
 1fa:	603b      	str	r3, [r7, #0]
 1fc:	460b      	mov	r3, r1
 1fe:	817b      	strh	r3, [r7, #10]
	uint32_t average;
	ad7322_channel_t channel_id;
	ad7322_conversion_result_t conversion_result;
	uint16_t difference;

	data_receive[0]=0;
 200:	f04f 0300 	mov.w	r3, #0
 204:	753b      	strb	r3, [r7, #20]
	data_receive[1]=0;
 206:	f04f 0300 	mov.w	r3, #0
 20a:	757b      	strb	r3, [r7, #21]

	if ((AD7322_CHANNEL_0_SELECTED != select_channel) && (AD7322_CHANNEL_1_SELECTED != select_channel))
 20c:	897b      	ldrh	r3, [r7, #10]
 20e:	2b00      	cmp	r3, #0
 210:	d006      	beq.n	220 <ad7322_select_input_channel_read_channel_value_in_micro_scale+0x30>
 212:	897b      	ldrh	r3, [r7, #10]
 214:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 218:	d002      	beq.n	220 <ad7322_select_input_channel_read_channel_value_in_micro_scale+0x30>
	 {
	 	return ADC_ERROR;
 21a:	f04f 0301 	mov.w	r3, #1
 21e:	e03f      	b.n	2a0 <ad7322_select_input_channel_read_channel_value_in_micro_scale+0xb0>
	 }
	// Select user-specified channel for next conversion
	reg = AD7322_WRITE_CONTROL_REGISTER;
 220:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 224:	84fb      	strh	r3, [r7, #38]	; 0x26
	register_value = select_channel |AD7322_INPUT_CONFIGURATION_2_SINGLE_ENDED_INPUTS | AD7322_NORMAL_MODE | AD7322_TWOS_COMPLEMENT | AD7322_INTERNAL_REF_ENABLE | AD7322_SEQUENCER_NOT_USED;
 226:	897b      	ldrh	r3, [r7, #10]
 228:	f043 031c 	orr.w	r3, r3, #28
 22c:	84bb      	strh	r3, [r7, #36]	; 0x24
	value = reg | register_value;
 22e:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 230:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 232:	ea42 0303 	orr.w	r3, r2, r3
 236:	847b      	strh	r3, [r7, #34]	; 0x22

	data_send[0] = ADC_AD7322_HIGH_DATA_BYTE (value);
 238:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 23a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 23e:	b29b      	uxth	r3, r3
 240:	b2db      	uxtb	r3, r3
 242:	763b      	strb	r3, [r7, #24]
	data_send[1] = ADC_AD7322_LOW_DATA_BYTE (value);
 244:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 246:	b2db      	uxtb	r3, r3
 248:	767b      	strb	r3, [r7, #25]
	// Send configuration for next conversion and read data from last conversion
	average=0;
 24a:	f04f 0300 	mov.w	r3, #0
 24e:	61fb      	str	r3, [r7, #28]
	uint8_t i;


		if (SPI_STATUS_SUCCESS != spi_send_receive_data(adc->spi, data_send, sizeof(data_send), data_receive)) {return ADC_ERROR;}
 250:	68fb      	ldr	r3, [r7, #12]
 252:	6819      	ldr	r1, [r3, #0]
 254:	f107 0218 	add.w	r2, r7, #24
 258:	f107 0314 	add.w	r3, r7, #20
 25c:	4608      	mov	r0, r1
 25e:	4611      	mov	r1, r2
 260:	f04f 0202 	mov.w	r2, #2
 264:	f7ff fffe 	bl	0 <spi_send_receive_data>
			264: R_ARM_THM_CALL	spi_send_receive_data
 268:	4603      	mov	r3, r0
 26a:	2b00      	cmp	r3, #0
 26c:	d002      	beq.n	274 <ad7322_select_input_channel_read_channel_value_in_micro_scale+0x84>
 26e:	f04f 0301 	mov.w	r3, #1
 272:	e015      	b.n	2a0 <ad7322_select_input_channel_read_channel_value_in_micro_scale+0xb0>
		spi_data = ((data_receive[0] & 0x3F) << 8) | data_receive[1];
 274:	7d3b      	ldrb	r3, [r7, #20]
 276:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 27a:	ea4f 2303 	mov.w	r3, r3, lsl #8
 27e:	b29a      	uxth	r2, r3
 280:	7d7b      	ldrb	r3, [r7, #21]
 282:	ea42 0303 	orr.w	r3, r2, r3
 286:	b29b      	uxth	r3, r3
 288:	b29b      	uxth	r3, r3
 28a:	827b      	strh	r3, [r7, #18]
		ad7322_process_spi_data (adc, read_channel, &spi_data, result);
 28c:	f107 0312 	add.w	r3, r7, #18
 290:	68f8      	ldr	r0, [r7, #12]
 292:	6879      	ldr	r1, [r7, #4]
 294:	461a      	mov	r2, r3
 296:	683b      	ldr	r3, [r7, #0]
 298:	f7ff fffe 	bl	d8 <ad7322_process_spi_data>
			298: R_ARM_THM_CALL	ad7322_process_spi_data





	return ADC_STATUS_SUCCESS;
 29c:	f04f 0300 	mov.w	r3, #0
}
 2a0:	4618      	mov	r0, r3
 2a2:	f107 0728 	add.w	r7, r7, #40	; 0x28
 2a6:	46bd      	mov	sp, r7
 2a8:	bd80      	pop	{r7, pc}
 2aa:	bf00      	nop

adc_ad7322_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 333344 Jul 30 19:07 2021 adc_ad7322_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  0000003c  2**0
                  ALLOC
  3 .debug_abbrev 000000fa  00000000  00000000  0000003c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000003fb  00000000  00000000  00000136  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000005d0  00000000  00000000  00000531  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0004ff52  00000000  00000000  00000b01  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000002d  00000000  00000000  00050a53  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 000000ff  00000000  00000000  00050a80  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000002e1  00000000  00000000  00050b7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  00050e60  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  00050e8b  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 adc_ad7322_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .data	00000004 bare_adc
00000000         *UND*	00000000 adc_spi
00000004 g     O .data	00000004 board_adc



dac_ad5392.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 356692 Jul 30 19:07 2021 dac_ad5392.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009d8  00000000  00000000  00000038  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000a10  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  00000a10  2**2
                  ALLOC
  3 .debug_abbrev 000001d3  00000000  00000000  00000a10  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000d40  00000000  00000000  00000be3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000b0b  00000000  00000000  00001923  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0005200f  00000000  00000000  0000242e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000003f0  00000000  00000000  0005443d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000026a  00000000  00000000  0005482d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000229  00000000  00000000  00054a97  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00054cc0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000c58  00000000  00000000  00054ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00055938  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00055963  2**0
                  CONTENTS, READONLY
 14 .debug_frame  0000024c  00000000  00000000  00055994  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 dac_ad5392.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 xme_core_config
000000e0 l     F .text	00000068 dac_receive_data
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 xme_core_log_logCallback
00000000 g     F .text	000000e0 dac_ad5392_init
00000000         *UND*	00000000 belle_gpio_pin_init
00000000         *UND*	00000000 GPIO_WriteBit
00000000         *UND*	00000000 vTaskDelay
00000000         *UND*	00000000 spi_send_receive_data
00000148 g     F .text	000000d6 dac_ad5392_setChannelConfiguration
00000220 g     F .text	000000de dac_ad5392_getChannelConfiguration
00000300 g     F .text	000000aa dac_ad5392_setChannelRawValue
00000000         *UND*	00000000 __aeabi_uldivmod
000003ac g     F .text	000000a4 dac_ad5392_setChannelValue_in_MicroScale
00000450 g     F .text	00000060 dac_ad5392_Scale_Input_DAC_Data_in_MicroScale
000004b0 g     F .text	00000084 dac_ad5392_getChannelValue_SetConfiguration
00000534 g     F .text	00000030 dac_ad5392_getChannelValue_GetData
00000564 g     F .text	00000098 dac_ad5392_getChannelValue
000005fc g     F .text	00000066 dac_ad5392_configure_control_register
00000664 g     F .text	0000007a dac_ad5392_set_monitoring_channel
000006e0 g     F .text	00000088 dac_ad5392_stop
00000768 g     F .text	00000096 dac_ad5392_powerDown
00000800 g     F .text	0000006e dac_ad5392_powerUp
00000870 g     F .text	000000aa dac_ad5392_clear
0000091c g     F .text	0000005a dac_ad5392_clear_outputs_to_zero
00000978 g     F .text	0000005c dac_ad5392_fini



Disassembly of section .text:

00000000 <dac_ad5392_init>:
/******************************************************************************/
/***   Implementation for DAC    					                        ***/
/******************************************************************************/
dac_status_t
dac_ad5392_init(dac_descr_t* dac)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
	uint8_t i;

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
   8:	687b      	ldr	r3, [r7, #4]
   a:	2b00      	cmp	r3, #0
   c:	d102      	bne.n	14 <dac_ad5392_init+0x14>
   e:	f04f 0301 	mov.w	r3, #1
  12:	e060      	b.n	d6 <dac_ad5392_init+0xd6>
	XME_CHECK(DAC_STATE_UNINITIALIZED == dac->state, DAC_STATUS_WRONG_STATE);
  14:	687b      	ldr	r3, [r7, #4]
  16:	7f1b      	ldrb	r3, [r3, #28]
  18:	2b00      	cmp	r3, #0
  1a:	d002      	beq.n	22 <dac_ad5392_init+0x22>
  1c:	f04f 0304 	mov.w	r3, #4
  20:	e059      	b.n	d6 <dac_ad5392_init+0xd6>
	XME_CHECK(NULL != dac->spi, DAC_STATUS_INVALID_SPI_DESCRIPTOR);
  22:	687b      	ldr	r3, [r7, #4]
  24:	681b      	ldr	r3, [r3, #0]
  26:	2b00      	cmp	r3, #0
  28:	d102      	bne.n	30 <dac_ad5392_init+0x30>
  2a:	f04f 0302 	mov.w	r3, #2
  2e:	e052      	b.n	d6 <dac_ad5392_init+0xd6>
	//Clear the DAC channels
	belle_gpio_pin_init(dac->clr_pin.clock, dac->clr_pin.port, dac->clr_pin.pin, GPIO_Mode_Out_PP);
  30:	687b      	ldr	r3, [r7, #4]
  32:	6919      	ldr	r1, [r3, #16]
  34:	687b      	ldr	r3, [r7, #4]
  36:	699a      	ldr	r2, [r3, #24]
  38:	687b      	ldr	r3, [r7, #4]
  3a:	8a9b      	ldrh	r3, [r3, #20]
  3c:	4608      	mov	r0, r1
  3e:	4611      	mov	r1, r2
  40:	461a      	mov	r2, r3
  42:	f04f 0310 	mov.w	r3, #16
  46:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			46: R_ARM_THM_CALL	belle_gpio_pin_init
#if BUSY_PIN_AVAILABLE
	belle_gpio_pin_init(dac->busy_pin.clock, dac->busy_pin.port, dac->busy_pin.pin, GPIO_Mode_IPU);
#endif

	//External reset of the DAC
	belle_gpio_pin_init(dac->reset_pin.clock, dac->reset_pin.port, dac->reset_pin.pin, GPIO_Mode_Out_PP);
  4a:	687b      	ldr	r3, [r7, #4]
  4c:	6859      	ldr	r1, [r3, #4]
  4e:	687b      	ldr	r3, [r7, #4]
  50:	68da      	ldr	r2, [r3, #12]
  52:	687b      	ldr	r3, [r7, #4]
  54:	891b      	ldrh	r3, [r3, #8]
  56:	4608      	mov	r0, r1
  58:	4611      	mov	r1, r2
  5a:	461a      	mov	r2, r3
  5c:	f04f 0310 	mov.w	r3, #16
  60:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			60: R_ARM_THM_CALL	belle_gpio_pin_init
	GPIO_WriteBit(dac->reset_pin.port, dac->reset_pin.pin, DAC_HIGH);
  64:	687b      	ldr	r3, [r7, #4]
  66:	68da      	ldr	r2, [r3, #12]
  68:	687b      	ldr	r3, [r7, #4]
  6a:	891b      	ldrh	r3, [r3, #8]
  6c:	4610      	mov	r0, r2
  6e:	4619      	mov	r1, r3
  70:	f04f 0201 	mov.w	r2, #1
  74:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			74: R_ARM_THM_CALL	GPIO_WriteBit
	GPIO_WriteBit(dac->reset_pin.port, dac->reset_pin.pin, DAC_LOW);
  78:	687b      	ldr	r3, [r7, #4]
  7a:	68da      	ldr	r2, [r3, #12]
  7c:	687b      	ldr	r3, [r7, #4]
  7e:	891b      	ldrh	r3, [r3, #8]
  80:	4610      	mov	r0, r2
  82:	4619      	mov	r1, r3
  84:	f04f 0200 	mov.w	r2, #0
  88:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			88: R_ARM_THM_CALL	GPIO_WriteBit
	while (DAC_LOW == GPIO_ReadInputDataBit(dac->busy_pin.port,dac->busy_pin.pin));
#endif

#if !BUSY_PIN_AVAILABLE
	// Simulate waiting of the busy pin.
	vTaskDelay(1);
  8c:	f04f 0001 	mov.w	r0, #1
  90:	f7ff fffe 	bl	0 <vTaskDelay>
			90: R_ARM_THM_CALL	vTaskDelay
#endif

	GPIO_WriteBit(dac->reset_pin.port, dac->reset_pin.pin, DAC_HIGH);
  94:	687b      	ldr	r3, [r7, #4]
  96:	68da      	ldr	r2, [r3, #12]
  98:	687b      	ldr	r3, [r7, #4]
  9a:	891b      	ldrh	r3, [r3, #8]
  9c:	4610      	mov	r0, r2
  9e:	4619      	mov	r1, r3
  a0:	f04f 0201 	mov.w	r2, #1
  a4:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			a4: R_ARM_THM_CALL	GPIO_WriteBit

	dac->state = DAC_STATE_READY;
  a8:	687b      	ldr	r3, [r7, #4]
  aa:	f04f 0201 	mov.w	r2, #1
  ae:	771a      	strb	r2, [r3, #28]

	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
  b0:	f04f 0300 	mov.w	r3, #0
  b4:	73fb      	strb	r3, [r7, #15]
  b6:	e009      	b.n	cc <dac_ad5392_init+0xcc>
	{
		dac->channelStates[i] = DAC_CHANNEL_STATE_INACTIVE;
  b8:	7bfb      	ldrb	r3, [r7, #15]
  ba:	687a      	ldr	r2, [r7, #4]
  bc:	18d3      	adds	r3, r2, r3
  be:	f04f 0200 	mov.w	r2, #0
  c2:	775a      	strb	r2, [r3, #29]

	GPIO_WriteBit(dac->reset_pin.port, dac->reset_pin.pin, DAC_HIGH);

	dac->state = DAC_STATE_READY;

	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
  c4:	7bfb      	ldrb	r3, [r7, #15]
  c6:	f103 0301 	add.w	r3, r3, #1
  ca:	73fb      	strb	r3, [r7, #15]
  cc:	7bfb      	ldrb	r3, [r7, #15]
  ce:	2b07      	cmp	r3, #7
  d0:	d9f2      	bls.n	b8 <dac_ad5392_init+0xb8>
	{
		dac->channelStates[i] = DAC_CHANNEL_STATE_INACTIVE;
	}
	return DAC_STATUS_SUCCESS;
  d2:	f04f 0300 	mov.w	r3, #0
}
  d6:	4618      	mov	r0, r3
  d8:	f107 0710 	add.w	r7, r7, #16
  dc:	46bd      	mov	sp, r7
  de:	bd80      	pop	{r7, pc}

000000e0 <dac_receive_data>:

static
dac_status_t
dac_receive_data (dac_descr_t* dac, uint16_t* receivedData)
{
  e0:	b580      	push	{r7, lr}
  e2:	b084      	sub	sp, #16
  e4:	af00      	add	r7, sp, #0
  e6:	6078      	str	r0, [r7, #4]
  e8:	6039      	str	r1, [r7, #0]
	uint8_t data_send[3], data_receive[3];
	// Introduce send and receive buffers if required.
	data_send[0] = DAC_NOP;
  ea:	f04f 0300 	mov.w	r3, #0
  ee:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_NOP;
  f0:	f04f 0300 	mov.w	r3, #0
  f4:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_NOP;
  f6:	f04f 0300 	mov.w	r3, #0
  fa:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
  fc:	687b      	ldr	r3, [r7, #4]
  fe:	6819      	ldr	r1, [r3, #0]
 100:	f107 020c 	add.w	r2, r7, #12
 104:	f107 0308 	add.w	r3, r7, #8
 108:	4608      	mov	r0, r1
 10a:	4611      	mov	r1, r2
 10c:	f04f 0203 	mov.w	r2, #3
 110:	f7ff fffe 	bl	0 <spi_send_receive_data>
			110: R_ARM_THM_CALL	spi_send_receive_data
 114:	4603      	mov	r3, r0
 116:	2b00      	cmp	r3, #0
 118:	d002      	beq.n	120 <dac_receive_data+0x40>
 11a:	f04f 0306 	mov.w	r3, #6
 11e:	e00e      	b.n	13e <dac_receive_data+0x5e>
	*receivedData = ((data_receive[1] & 0x3F) << 8) | data_receive[2];
 120:	7a7b      	ldrb	r3, [r7, #9]
 122:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 126:	ea4f 2303 	mov.w	r3, r3, lsl #8
 12a:	b29a      	uxth	r2, r3
 12c:	7abb      	ldrb	r3, [r7, #10]
 12e:	ea42 0303 	orr.w	r3, r2, r3
 132:	b29b      	uxth	r3, r3
 134:	b29a      	uxth	r2, r3
 136:	683b      	ldr	r3, [r7, #0]
 138:	801a      	strh	r2, [r3, #0]

	return DAC_STATUS_SUCCESS;
 13a:	f04f 0300 	mov.w	r3, #0
}
 13e:	4618      	mov	r0, r3
 140:	f107 0710 	add.w	r7, r7, #16
 144:	46bd      	mov	sp, r7
 146:	bd80      	pop	{r7, pc}

00000148 <dac_ad5392_setChannelConfiguration>:

dac_status_t
dac_ad5392_setChannelConfiguration(dac_descr_t* dac, dac_channel_t channel, uint16_t gain, uint16_t offset)
{
 148:	b580      	push	{r7, lr}
 14a:	b086      	sub	sp, #24
 14c:	af00      	add	r7, sp, #0
 14e:	60f8      	str	r0, [r7, #12]
 150:	72f9      	strb	r1, [r7, #11]
 152:	813a      	strh	r2, [r7, #8]
 154:	80fb      	strh	r3, [r7, #6]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 156:	68fb      	ldr	r3, [r7, #12]
 158:	2b00      	cmp	r3, #0
 15a:	d102      	bne.n	162 <dac_ad5392_setChannelConfiguration+0x1a>
 15c:	f04f 0301 	mov.w	r3, #1
 160:	e058      	b.n	214 <dac_ad5392_setChannelConfiguration+0xcc>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 162:	68fb      	ldr	r3, [r7, #12]
 164:	7f1b      	ldrb	r3, [r3, #28]
 166:	2b01      	cmp	r3, #1
 168:	d002      	beq.n	170 <dac_ad5392_setChannelConfiguration+0x28>
 16a:	f04f 0304 	mov.w	r3, #4
 16e:	e051      	b.n	214 <dac_ad5392_setChannelConfiguration+0xcc>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 170:	7afb      	ldrb	r3, [r7, #11]
 172:	2b07      	cmp	r3, #7
 174:	d902      	bls.n	17c <dac_ad5392_setChannelConfiguration+0x34>
 176:	f04f 0303 	mov.w	r3, #3
 17a:	e04b      	b.n	214 <dac_ad5392_setChannelConfiguration+0xcc>
	XME_CHECK(DAC_CHANNEL_STATE_INACTIVE == dac->channelStates[channel], DAC_STATUS_ACTIVE_CHANNEL);
 17c:	7afb      	ldrb	r3, [r7, #11]
 17e:	68fa      	ldr	r2, [r7, #12]
 180:	18d3      	adds	r3, r2, r3
 182:	7f5b      	ldrb	r3, [r3, #29]
 184:	2b00      	cmp	r3, #0
 186:	d002      	beq.n	18e <dac_ad5392_setChannelConfiguration+0x46>
 188:	f04f 0305 	mov.w	r3, #5
 18c:	e042      	b.n	214 <dac_ad5392_setChannelConfiguration+0xcc>

	data_send[0] = DAC_WRITE | DAC_AD5392_TRANSFORM_CHANNEL(channel);
 18e:	7afb      	ldrb	r3, [r7, #11]
 190:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 194:	b2db      	uxtb	r3, r3
 196:	753b      	strb	r3, [r7, #20]

	data_send[1] = DAC_GAIN_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(gain);
 198:	893b      	ldrh	r3, [r7, #8]
 19a:	ea4f 2313 	mov.w	r3, r3, lsr #8
 19e:	b29b      	uxth	r3, r3
 1a0:	b2db      	uxtb	r3, r3
 1a2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 1a6:	b2db      	uxtb	r3, r3
 1a8:	757b      	strb	r3, [r7, #21]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(gain);
 1aa:	893b      	ldrh	r3, [r7, #8]
 1ac:	b2db      	uxtb	r3, r3
 1ae:	75bb      	strb	r3, [r7, #22]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 1b0:	68fb      	ldr	r3, [r7, #12]
 1b2:	6819      	ldr	r1, [r3, #0]
 1b4:	f107 0214 	add.w	r2, r7, #20
 1b8:	f107 0310 	add.w	r3, r7, #16
 1bc:	4608      	mov	r0, r1
 1be:	4611      	mov	r1, r2
 1c0:	f04f 0203 	mov.w	r2, #3
 1c4:	f7ff fffe 	bl	0 <spi_send_receive_data>
			1c4: R_ARM_THM_CALL	spi_send_receive_data
 1c8:	4603      	mov	r3, r0
 1ca:	2b00      	cmp	r3, #0
 1cc:	d002      	beq.n	1d4 <dac_ad5392_setChannelConfiguration+0x8c>
 1ce:	f04f 0306 	mov.w	r3, #6
 1d2:	e01f      	b.n	214 <dac_ad5392_setChannelConfiguration+0xcc>

	data_send[1] = DAC_OFFSET_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(offset);
 1d4:	88fb      	ldrh	r3, [r7, #6]
 1d6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 1da:	b29b      	uxth	r3, r3
 1dc:	b2db      	uxtb	r3, r3
 1de:	f063 037f 	orn	r3, r3, #127	; 0x7f
 1e2:	b2db      	uxtb	r3, r3
 1e4:	757b      	strb	r3, [r7, #21]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(offset);
 1e6:	88fb      	ldrh	r3, [r7, #6]
 1e8:	b2db      	uxtb	r3, r3
 1ea:	75bb      	strb	r3, [r7, #22]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 1ec:	68fb      	ldr	r3, [r7, #12]
 1ee:	6819      	ldr	r1, [r3, #0]
 1f0:	f107 0214 	add.w	r2, r7, #20
 1f4:	f107 0310 	add.w	r3, r7, #16
 1f8:	4608      	mov	r0, r1
 1fa:	4611      	mov	r1, r2
 1fc:	f04f 0203 	mov.w	r2, #3
 200:	f7ff fffe 	bl	0 <spi_send_receive_data>
			200: R_ARM_THM_CALL	spi_send_receive_data
 204:	4603      	mov	r3, r0
 206:	2b00      	cmp	r3, #0
 208:	d002      	beq.n	210 <dac_ad5392_setChannelConfiguration+0xc8>
 20a:	f04f 0306 	mov.w	r3, #6
 20e:	e001      	b.n	214 <dac_ad5392_setChannelConfiguration+0xcc>

	return DAC_STATUS_SUCCESS;
 210:	f04f 0300 	mov.w	r3, #0
}
 214:	4618      	mov	r0, r3
 216:	f107 0718 	add.w	r7, r7, #24
 21a:	46bd      	mov	sp, r7
 21c:	bd80      	pop	{r7, pc}
 21e:	bf00      	nop

00000220 <dac_ad5392_getChannelConfiguration>:

dac_status_t
dac_ad5392_getChannelConfiguration(dac_descr_t* dac, dac_channel_t channel, uint16_t* gain, uint16_t* offset)
{
 220:	b580      	push	{r7, lr}
 222:	b086      	sub	sp, #24
 224:	af00      	add	r7, sp, #0
 226:	60f8      	str	r0, [r7, #12]
 228:	607a      	str	r2, [r7, #4]
 22a:	603b      	str	r3, [r7, #0]
 22c:	460b      	mov	r3, r1
 22e:	72fb      	strb	r3, [r7, #11]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 230:	68fb      	ldr	r3, [r7, #12]
 232:	2b00      	cmp	r3, #0
 234:	d102      	bne.n	23c <dac_ad5392_getChannelConfiguration+0x1c>
 236:	f04f 0301 	mov.w	r3, #1
 23a:	e05b      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 23c:	68fb      	ldr	r3, [r7, #12]
 23e:	7f1b      	ldrb	r3, [r3, #28]
 240:	2b01      	cmp	r3, #1
 242:	d002      	beq.n	24a <dac_ad5392_getChannelConfiguration+0x2a>
 244:	f04f 0304 	mov.w	r3, #4
 248:	e054      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 24a:	7afb      	ldrb	r3, [r7, #11]
 24c:	2b07      	cmp	r3, #7
 24e:	d902      	bls.n	256 <dac_ad5392_getChannelConfiguration+0x36>
 250:	f04f 0303 	mov.w	r3, #3
 254:	e04e      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>

	data_send[0] = DAC_READ | DAC_AD5392_TRANSFORM_CHANNEL(channel);
 256:	7afb      	ldrb	r3, [r7, #11]
 258:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 25c:	b2db      	uxtb	r3, r3
 25e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 262:	b2db      	uxtb	r3, r3
 264:	b2db      	uxtb	r3, r3
 266:	753b      	strb	r3, [r7, #20]

	data_send[1] = DAC_GAIN_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 268:	f04f 0340 	mov.w	r3, #64	; 0x40
 26c:	757b      	strb	r3, [r7, #21]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 26e:	f04f 0300 	mov.w	r3, #0
 272:	75bb      	strb	r3, [r7, #22]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 274:	68fb      	ldr	r3, [r7, #12]
 276:	6819      	ldr	r1, [r3, #0]
 278:	f107 0214 	add.w	r2, r7, #20
 27c:	f107 0310 	add.w	r3, r7, #16
 280:	4608      	mov	r0, r1
 282:	4611      	mov	r1, r2
 284:	f04f 0203 	mov.w	r2, #3
 288:	f7ff fffe 	bl	0 <spi_send_receive_data>
			288: R_ARM_THM_CALL	spi_send_receive_data
 28c:	4603      	mov	r3, r0
 28e:	2b00      	cmp	r3, #0
 290:	d002      	beq.n	298 <dac_ad5392_getChannelConfiguration+0x78>
 292:	f04f 0306 	mov.w	r3, #6
 296:	e02d      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>
	XME_CHECK(DAC_STATUS_SUCCESS == dac_receive_data(dac, gain), DAC_STATUS_OPERATION_FAILED);
 298:	68f8      	ldr	r0, [r7, #12]
 29a:	6879      	ldr	r1, [r7, #4]
 29c:	f7ff ff20 	bl	e0 <dac_receive_data>
 2a0:	4603      	mov	r3, r0
 2a2:	2b00      	cmp	r3, #0
 2a4:	d002      	beq.n	2ac <dac_ad5392_getChannelConfiguration+0x8c>
 2a6:	f04f 0306 	mov.w	r3, #6
 2aa:	e023      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>

	data_send[1] = DAC_OFFSET_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 2ac:	f04f 0380 	mov.w	r3, #128	; 0x80
 2b0:	757b      	strb	r3, [r7, #21]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 2b2:	f04f 0300 	mov.w	r3, #0
 2b6:	75bb      	strb	r3, [r7, #22]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 2b8:	68fb      	ldr	r3, [r7, #12]
 2ba:	6819      	ldr	r1, [r3, #0]
 2bc:	f107 0214 	add.w	r2, r7, #20
 2c0:	f107 0310 	add.w	r3, r7, #16
 2c4:	4608      	mov	r0, r1
 2c6:	4611      	mov	r1, r2
 2c8:	f04f 0203 	mov.w	r2, #3
 2cc:	f7ff fffe 	bl	0 <spi_send_receive_data>
			2cc: R_ARM_THM_CALL	spi_send_receive_data
 2d0:	4603      	mov	r3, r0
 2d2:	2b00      	cmp	r3, #0
 2d4:	d002      	beq.n	2dc <dac_ad5392_getChannelConfiguration+0xbc>
 2d6:	f04f 0306 	mov.w	r3, #6
 2da:	e00b      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>
	XME_CHECK(DAC_STATUS_SUCCESS == dac_receive_data(dac, offset), DAC_STATUS_OPERATION_FAILED);
 2dc:	68f8      	ldr	r0, [r7, #12]
 2de:	6839      	ldr	r1, [r7, #0]
 2e0:	f7ff fefe 	bl	e0 <dac_receive_data>
 2e4:	4603      	mov	r3, r0
 2e6:	2b00      	cmp	r3, #0
 2e8:	d002      	beq.n	2f0 <dac_ad5392_getChannelConfiguration+0xd0>
 2ea:	f04f 0306 	mov.w	r3, #6
 2ee:	e001      	b.n	2f4 <dac_ad5392_getChannelConfiguration+0xd4>

	return DAC_STATUS_SUCCESS;
 2f0:	f04f 0300 	mov.w	r3, #0
}
 2f4:	4618      	mov	r0, r3
 2f6:	f107 0718 	add.w	r7, r7, #24
 2fa:	46bd      	mov	sp, r7
 2fc:	bd80      	pop	{r7, pc}
 2fe:	bf00      	nop

00000300 <dac_ad5392_setChannelRawValue>:

dac_status_t
dac_ad5392_setChannelRawValue(dac_descr_t* dac, dac_channel_t channel, ad7322_raw_data_t value)
{
 300:	b580      	push	{r7, lr}
 302:	b084      	sub	sp, #16
 304:	af00      	add	r7, sp, #0
 306:	6078      	str	r0, [r7, #4]
 308:	4613      	mov	r3, r2
 30a:	460a      	mov	r2, r1
 30c:	70fa      	strb	r2, [r7, #3]
 30e:	803b      	strh	r3, [r7, #0]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 310:	687b      	ldr	r3, [r7, #4]
 312:	2b00      	cmp	r3, #0
 314:	d102      	bne.n	31c <dac_ad5392_setChannelRawValue+0x1c>
 316:	f04f 0301 	mov.w	r3, #1
 31a:	e041      	b.n	3a0 <dac_ad5392_setChannelRawValue+0xa0>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 31c:	687b      	ldr	r3, [r7, #4]
 31e:	7f1b      	ldrb	r3, [r3, #28]
 320:	2b01      	cmp	r3, #1
 322:	d002      	beq.n	32a <dac_ad5392_setChannelRawValue+0x2a>
 324:	f04f 0304 	mov.w	r3, #4
 328:	e03a      	b.n	3a0 <dac_ad5392_setChannelRawValue+0xa0>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 32a:	78fb      	ldrb	r3, [r7, #3]
 32c:	2b07      	cmp	r3, #7
 32e:	d902      	bls.n	336 <dac_ad5392_setChannelRawValue+0x36>
 330:	f04f 0303 	mov.w	r3, #3
 334:	e034      	b.n	3a0 <dac_ad5392_setChannelRawValue+0xa0>

	data_send[0] = DAC_WRITE | DAC_AD5392_TRANSFORM_CHANNEL(channel);
 336:	78fb      	ldrb	r3, [r7, #3]
 338:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 33c:	b2db      	uxtb	r3, r3
 33e:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_VALUE_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(value);
 340:	883b      	ldrh	r3, [r7, #0]
 342:	ea4f 2313 	mov.w	r3, r3, lsr #8
 346:	b29b      	uxth	r3, r3
 348:	b2db      	uxtb	r3, r3
 34a:	f063 033f 	orn	r3, r3, #63	; 0x3f
 34e:	b2db      	uxtb	r3, r3
 350:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(value);
 352:	883b      	ldrh	r3, [r7, #0]
 354:	b2db      	uxtb	r3, r3
 356:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 358:	687b      	ldr	r3, [r7, #4]
 35a:	6819      	ldr	r1, [r3, #0]
 35c:	f107 020c 	add.w	r2, r7, #12
 360:	f107 0308 	add.w	r3, r7, #8
 364:	4608      	mov	r0, r1
 366:	4611      	mov	r1, r2
 368:	f04f 0203 	mov.w	r2, #3
 36c:	f7ff fffe 	bl	0 <spi_send_receive_data>
			36c: R_ARM_THM_CALL	spi_send_receive_data
 370:	4603      	mov	r3, r0
 372:	2b00      	cmp	r3, #0
 374:	d002      	beq.n	37c <dac_ad5392_setChannelRawValue+0x7c>
 376:	f04f 0306 	mov.w	r3, #6
 37a:	e011      	b.n	3a0 <dac_ad5392_setChannelRawValue+0xa0>

	if (0 == value)
 37c:	883b      	ldrh	r3, [r7, #0]
 37e:	2b00      	cmp	r3, #0
 380:	d106      	bne.n	390 <dac_ad5392_setChannelRawValue+0x90>
	{
		dac->channelStates[channel] = DAC_CHANNEL_STATE_INACTIVE;
 382:	78fb      	ldrb	r3, [r7, #3]
 384:	687a      	ldr	r2, [r7, #4]
 386:	18d3      	adds	r3, r2, r3
 388:	f04f 0200 	mov.w	r2, #0
 38c:	775a      	strb	r2, [r3, #29]
 38e:	e005      	b.n	39c <dac_ad5392_setChannelRawValue+0x9c>
	}
	else
	{
		dac->channelStates[channel] = DAC_CHANNEL_STATE_ACTIVE;
 390:	78fb      	ldrb	r3, [r7, #3]
 392:	687a      	ldr	r2, [r7, #4]
 394:	18d3      	adds	r3, r2, r3
 396:	f04f 0201 	mov.w	r2, #1
 39a:	775a      	strb	r2, [r3, #29]
	}
	return DAC_STATUS_SUCCESS;
 39c:	f04f 0300 	mov.w	r3, #0
}
 3a0:	4618      	mov	r0, r3
 3a2:	f107 0710 	add.w	r7, r7, #16
 3a6:	46bd      	mov	sp, r7
 3a8:	bd80      	pop	{r7, pc}
 3aa:	bf00      	nop

000003ac <dac_ad5392_setChannelValue_in_MicroScale>:

dac_status_t
dac_ad5392_setChannelValue_in_MicroScale(dac_descr_t* dac, dac_channel_t channel, ad7322_dac_input_data_in_micro_scale_t value)
{
 3ac:	b5f0      	push	{r4, r5, r6, r7, lr}
 3ae:	b089      	sub	sp, #36	; 0x24
 3b0:	af00      	add	r7, sp, #0
 3b2:	60f8      	str	r0, [r7, #12]
 3b4:	460b      	mov	r3, r1
 3b6:	607a      	str	r2, [r7, #4]
 3b8:	72fb      	strb	r3, [r7, #11]

	uint16_t raw_value;
	uint64_t temp_value;

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 3ba:	68fb      	ldr	r3, [r7, #12]
 3bc:	2b00      	cmp	r3, #0
 3be:	d102      	bne.n	3c6 <dac_ad5392_setChannelValue_in_MicroScale+0x1a>
 3c0:	f04f 0301 	mov.w	r3, #1
 3c4:	e03b      	b.n	43e <dac_ad5392_setChannelValue_in_MicroScale+0x92>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 3c6:	68fb      	ldr	r3, [r7, #12]
 3c8:	7f1b      	ldrb	r3, [r3, #28]
 3ca:	2b01      	cmp	r3, #1
 3cc:	d002      	beq.n	3d4 <dac_ad5392_setChannelValue_in_MicroScale+0x28>
 3ce:	f04f 0304 	mov.w	r3, #4
 3d2:	e034      	b.n	43e <dac_ad5392_setChannelValue_in_MicroScale+0x92>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 3d4:	7afb      	ldrb	r3, [r7, #11]
 3d6:	2b07      	cmp	r3, #7
 3d8:	d902      	bls.n	3e0 <dac_ad5392_setChannelValue_in_MicroScale+0x34>
 3da:	f04f 0303 	mov.w	r3, #3
 3de:	e02e      	b.n	43e <dac_ad5392_setChannelValue_in_MicroScale+0x92>
	//raw_value = (((value / 1000) * (DAC_BITS - 1)) / (DAC_VRANGE*1000));
	// TODO: Check if this is required
	//temp_value = (value * (DAC_BITS - 1));
	temp_value = (((uint64_t)value * (DAC_BITS - 1)) / DAC_VRANGE)/(1000*1000);
 3e0:	687b      	ldr	r3, [r7, #4]
 3e2:	4618      	mov	r0, r3
 3e4:	f04f 0100 	mov.w	r1, #0
 3e8:	4602      	mov	r2, r0
 3ea:	460b      	mov	r3, r1
 3ec:	ea4f 4692 	mov.w	r6, r2, lsr #18
 3f0:	ea4f 3583 	mov.w	r5, r3, lsl #14
 3f4:	ea46 0505 	orr.w	r5, r6, r5
 3f8:	ea4f 3482 	mov.w	r4, r2, lsl #14
 3fc:	4622      	mov	r2, r4
 3fe:	462b      	mov	r3, r5
 400:	1a12      	subs	r2, r2, r0
 402:	eb63 0301 	sbc.w	r3, r3, r1
 406:	4610      	mov	r0, r2
 408:	4619      	mov	r1, r3
 40a:	a30f      	add	r3, pc, #60	; (adr r3, 448 <dac_ad5392_setChannelValue_in_MicroScale+0x9c>)
 40c:	e9d3 2300 	ldrd	r2, r3, [r3]
 410:	f7ff fffe 	bl	0 <__aeabi_uldivmod>
			410: R_ARM_THM_CALL	__aeabi_uldivmod
 414:	4602      	mov	r2, r0
 416:	460b      	mov	r3, r1
 418:	e9c7 2306 	strd	r2, r3, [r7, #24]
	// raw_value = (temp_value / (DAC_VRANGE * 1000000));
	raw_value=(uint16_t)temp_value;
 41c:	69bb      	ldr	r3, [r7, #24]
 41e:	82fb      	strh	r3, [r7, #22]
	if (DAC_STATUS_SUCCESS != dac_ad5392_setChannelRawValue(dac, channel, raw_value)){return DAC_STATUS_OPERATION_FAILED;}
 420:	7afa      	ldrb	r2, [r7, #11]
 422:	8afb      	ldrh	r3, [r7, #22]
 424:	68f8      	ldr	r0, [r7, #12]
 426:	4611      	mov	r1, r2
 428:	461a      	mov	r2, r3
 42a:	f7ff fffe 	bl	300 <dac_ad5392_setChannelRawValue>
			42a: R_ARM_THM_CALL	dac_ad5392_setChannelRawValue
 42e:	4603      	mov	r3, r0
 430:	2b00      	cmp	r3, #0
 432:	d002      	beq.n	43a <dac_ad5392_setChannelValue_in_MicroScale+0x8e>
 434:	f04f 0306 	mov.w	r3, #6
 438:	e001      	b.n	43e <dac_ad5392_setChannelValue_in_MicroScale+0x92>
	return DAC_STATUS_SUCCESS;
 43a:	f04f 0300 	mov.w	r3, #0
}
 43e:	4618      	mov	r0, r3
 440:	f107 0724 	add.w	r7, r7, #36	; 0x24
 444:	46bd      	mov	sp, r7
 446:	bdf0      	pop	{r4, r5, r6, r7, pc}
 448:	004c4b40 	.word	0x004c4b40
 44c:	00000000 	.word	0x00000000

00000450 <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale>:

ad7322_dac_input_data_in_micro_scale_t
dac_ad5392_Scale_Input_DAC_Data_in_MicroScale(dac_descr_t* dac, dac_channel_t channel, ad7322_input_data_to_scale_t value_to_convert_in_volts)
{
 450:	b480      	push	{r7}
 452:	b087      	sub	sp, #28
 454:	af00      	add	r7, sp, #0
 456:	60f8      	str	r0, [r7, #12]
 458:	460b      	mov	r3, r1
 45a:	607a      	str	r2, [r7, #4]
 45c:	72fb      	strb	r3, [r7, #11]
// Never used in actual code...
	// TODO: Maybe the value_to_convert_in_volts should be uint8_t;
	ad7322_dac_input_data_in_micro_scale_t value_micro_scale;

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 45e:	68fb      	ldr	r3, [r7, #12]
 460:	2b00      	cmp	r3, #0
 462:	d102      	bne.n	46a <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x1a>
 464:	f04f 0301 	mov.w	r3, #1
 468:	e017      	b.n	49a <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x4a>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 46a:	68fb      	ldr	r3, [r7, #12]
 46c:	7f1b      	ldrb	r3, [r3, #28]
 46e:	2b01      	cmp	r3, #1
 470:	d002      	beq.n	478 <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x28>
 472:	f04f 0304 	mov.w	r3, #4
 476:	e010      	b.n	49a <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x4a>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 478:	7afb      	ldrb	r3, [r7, #11]
 47a:	2b07      	cmp	r3, #7
 47c:	d902      	bls.n	484 <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x34>
 47e:	f04f 0303 	mov.w	r3, #3
 482:	e00a      	b.n	49a <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x4a>
	value_micro_scale = ((value_to_convert_in_volts * DAC_PRECISSION * DAC_VRANGE) / DAC_INPUT_SIGNAL_VRANGE);
 484:	687b      	ldr	r3, [r7, #4]
 486:	4a08      	ldr	r2, [pc, #32]	; (4a8 <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x58>)
 488:	fb02 f203 	mul.w	r2, r2, r3
 48c:	4b07      	ldr	r3, [pc, #28]	; (4ac <dac_ad5392_Scale_Input_DAC_Data_in_MicroScale+0x5c>)
 48e:	fba3 1302 	umull	r1, r3, r3, r2
 492:	ea4f 1313 	mov.w	r3, r3, lsr #4
 496:	617b      	str	r3, [r7, #20]
	return value_micro_scale;
 498:	697b      	ldr	r3, [r7, #20]
}
 49a:	4618      	mov	r0, r3
 49c:	f107 071c 	add.w	r7, r7, #28
 4a0:	46bd      	mov	sp, r7
 4a2:	bc80      	pop	{r7}
 4a4:	4770      	bx	lr
 4a6:	bf00      	nop
 4a8:	004c4b40 	.word	0x004c4b40
 4ac:	88888889 	.word	0x88888889

000004b0 <dac_ad5392_getChannelValue_SetConfiguration>:

dac_status_t
dac_ad5392_getChannelValue_SetConfiguration(dac_descr_t* dac, dac_channel_t channel, ad7322_raw_data_t* value)
{
 4b0:	b580      	push	{r7, lr}
 4b2:	b086      	sub	sp, #24
 4b4:	af00      	add	r7, sp, #0
 4b6:	60f8      	str	r0, [r7, #12]
 4b8:	460b      	mov	r3, r1
 4ba:	607a      	str	r2, [r7, #4]
 4bc:	72fb      	strb	r3, [r7, #11]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 4be:	68fb      	ldr	r3, [r7, #12]
 4c0:	2b00      	cmp	r3, #0
 4c2:	d102      	bne.n	4ca <dac_ad5392_getChannelValue_SetConfiguration+0x1a>
 4c4:	f04f 0301 	mov.w	r3, #1
 4c8:	e02f      	b.n	52a <dac_ad5392_getChannelValue_SetConfiguration+0x7a>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 4ca:	68fb      	ldr	r3, [r7, #12]
 4cc:	7f1b      	ldrb	r3, [r3, #28]
 4ce:	2b01      	cmp	r3, #1
 4d0:	d002      	beq.n	4d8 <dac_ad5392_getChannelValue_SetConfiguration+0x28>
 4d2:	f04f 0304 	mov.w	r3, #4
 4d6:	e028      	b.n	52a <dac_ad5392_getChannelValue_SetConfiguration+0x7a>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 4d8:	7afb      	ldrb	r3, [r7, #11]
 4da:	2b07      	cmp	r3, #7
 4dc:	d902      	bls.n	4e4 <dac_ad5392_getChannelValue_SetConfiguration+0x34>
 4de:	f04f 0303 	mov.w	r3, #3
 4e2:	e022      	b.n	52a <dac_ad5392_getChannelValue_SetConfiguration+0x7a>

	data_send[0] = DAC_READ | DAC_AD5392_TRANSFORM_CHANNEL(channel);
 4e4:	7afb      	ldrb	r3, [r7, #11]
 4e6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 4ea:	b2db      	uxtb	r3, r3
 4ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 4f0:	b2db      	uxtb	r3, r3
 4f2:	b2db      	uxtb	r3, r3
 4f4:	753b      	strb	r3, [r7, #20]
	data_send[1] = DAC_VALUE_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 4f6:	f04f 03c0 	mov.w	r3, #192	; 0xc0
 4fa:	757b      	strb	r3, [r7, #21]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 4fc:	f04f 0300 	mov.w	r3, #0
 500:	75bb      	strb	r3, [r7, #22]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 502:	68fb      	ldr	r3, [r7, #12]
 504:	6819      	ldr	r1, [r3, #0]
 506:	f107 0214 	add.w	r2, r7, #20
 50a:	f107 0310 	add.w	r3, r7, #16
 50e:	4608      	mov	r0, r1
 510:	4611      	mov	r1, r2
 512:	f04f 0203 	mov.w	r2, #3
 516:	f7ff fffe 	bl	0 <spi_send_receive_data>
			516: R_ARM_THM_CALL	spi_send_receive_data
 51a:	4603      	mov	r3, r0
 51c:	2b00      	cmp	r3, #0
 51e:	d002      	beq.n	526 <dac_ad5392_getChannelValue_SetConfiguration+0x76>
 520:	f04f 0306 	mov.w	r3, #6
 524:	e001      	b.n	52a <dac_ad5392_getChannelValue_SetConfiguration+0x7a>

	return DAC_STATUS_SUCCESS;
 526:	f04f 0300 	mov.w	r3, #0
}
 52a:	4618      	mov	r0, r3
 52c:	f107 0718 	add.w	r7, r7, #24
 530:	46bd      	mov	sp, r7
 532:	bd80      	pop	{r7, pc}

00000534 <dac_ad5392_getChannelValue_GetData>:

dac_status_t
dac_ad5392_getChannelValue_GetData(dac_descr_t* dac, dac_channel_t channel, ad7322_raw_data_t* value)
{
 534:	b580      	push	{r7, lr}
 536:	b086      	sub	sp, #24
 538:	af00      	add	r7, sp, #0
 53a:	60f8      	str	r0, [r7, #12]
 53c:	460b      	mov	r3, r1
 53e:	607a      	str	r2, [r7, #4]
 540:	72fb      	strb	r3, [r7, #11]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(DAC_STATUS_SUCCESS == dac_receive_data(dac, value), DAC_STATUS_OPERATION_FAILED);
 542:	68f8      	ldr	r0, [r7, #12]
 544:	6879      	ldr	r1, [r7, #4]
 546:	f7ff fdcb 	bl	e0 <dac_receive_data>
 54a:	4603      	mov	r3, r0
 54c:	2b00      	cmp	r3, #0
 54e:	d002      	beq.n	556 <dac_ad5392_getChannelValue_GetData+0x22>
 550:	f04f 0306 	mov.w	r3, #6
 554:	e001      	b.n	55a <dac_ad5392_getChannelValue_GetData+0x26>
	return DAC_STATUS_SUCCESS;
 556:	f04f 0300 	mov.w	r3, #0
}
 55a:	4618      	mov	r0, r3
 55c:	f107 0718 	add.w	r7, r7, #24
 560:	46bd      	mov	sp, r7
 562:	bd80      	pop	{r7, pc}

00000564 <dac_ad5392_getChannelValue>:


dac_status_t
dac_ad5392_getChannelValue(dac_descr_t* dac, dac_channel_t channel, ad7322_raw_data_t* value)
{
 564:	b580      	push	{r7, lr}
 566:	b086      	sub	sp, #24
 568:	af00      	add	r7, sp, #0
 56a:	60f8      	str	r0, [r7, #12]
 56c:	460b      	mov	r3, r1
 56e:	607a      	str	r2, [r7, #4]
 570:	72fb      	strb	r3, [r7, #11]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 572:	68fb      	ldr	r3, [r7, #12]
 574:	2b00      	cmp	r3, #0
 576:	d102      	bne.n	57e <dac_ad5392_getChannelValue+0x1a>
 578:	f04f 0301 	mov.w	r3, #1
 57c:	e039      	b.n	5f2 <dac_ad5392_getChannelValue+0x8e>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 57e:	68fb      	ldr	r3, [r7, #12]
 580:	7f1b      	ldrb	r3, [r3, #28]
 582:	2b01      	cmp	r3, #1
 584:	d002      	beq.n	58c <dac_ad5392_getChannelValue+0x28>
 586:	f04f 0304 	mov.w	r3, #4
 58a:	e032      	b.n	5f2 <dac_ad5392_getChannelValue+0x8e>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 58c:	7afb      	ldrb	r3, [r7, #11]
 58e:	2b07      	cmp	r3, #7
 590:	d902      	bls.n	598 <dac_ad5392_getChannelValue+0x34>
 592:	f04f 0303 	mov.w	r3, #3
 596:	e02c      	b.n	5f2 <dac_ad5392_getChannelValue+0x8e>

	data_send[0] = DAC_READ | DAC_AD5392_TRANSFORM_CHANNEL(channel);
 598:	7afb      	ldrb	r3, [r7, #11]
 59a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 59e:	b2db      	uxtb	r3, r3
 5a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 5a4:	b2db      	uxtb	r3, r3
 5a6:	b2db      	uxtb	r3, r3
 5a8:	753b      	strb	r3, [r7, #20]
	data_send[1] = DAC_VALUE_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 5aa:	f04f 03c0 	mov.w	r3, #192	; 0xc0
 5ae:	757b      	strb	r3, [r7, #21]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 5b0:	f04f 0300 	mov.w	r3, #0
 5b4:	75bb      	strb	r3, [r7, #22]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 5b6:	68fb      	ldr	r3, [r7, #12]
 5b8:	6819      	ldr	r1, [r3, #0]
 5ba:	f107 0214 	add.w	r2, r7, #20
 5be:	f107 0310 	add.w	r3, r7, #16
 5c2:	4608      	mov	r0, r1
 5c4:	4611      	mov	r1, r2
 5c6:	f04f 0203 	mov.w	r2, #3
 5ca:	f7ff fffe 	bl	0 <spi_send_receive_data>
			5ca: R_ARM_THM_CALL	spi_send_receive_data
 5ce:	4603      	mov	r3, r0
 5d0:	2b00      	cmp	r3, #0
 5d2:	d002      	beq.n	5da <dac_ad5392_getChannelValue+0x76>
 5d4:	f04f 0306 	mov.w	r3, #6
 5d8:	e00b      	b.n	5f2 <dac_ad5392_getChannelValue+0x8e>

	XME_CHECK(DAC_STATUS_SUCCESS == dac_receive_data(dac, value), DAC_STATUS_OPERATION_FAILED);
 5da:	68f8      	ldr	r0, [r7, #12]
 5dc:	6879      	ldr	r1, [r7, #4]
 5de:	f7ff fd7f 	bl	e0 <dac_receive_data>
 5e2:	4603      	mov	r3, r0
 5e4:	2b00      	cmp	r3, #0
 5e6:	d002      	beq.n	5ee <dac_ad5392_getChannelValue+0x8a>
 5e8:	f04f 0306 	mov.w	r3, #6
 5ec:	e001      	b.n	5f2 <dac_ad5392_getChannelValue+0x8e>
	return DAC_STATUS_SUCCESS;
 5ee:	f04f 0300 	mov.w	r3, #0
}
 5f2:	4618      	mov	r0, r3
 5f4:	f107 0718 	add.w	r7, r7, #24
 5f8:	46bd      	mov	sp, r7
 5fa:	bd80      	pop	{r7, pc}

000005fc <dac_ad5392_configure_control_register>:
dac_status_t
dac_ad5392_configure_control_register(dac_descr_t* dac)
{
 5fc:	b580      	push	{r7, lr}
 5fe:	b084      	sub	sp, #16
 600:	af00      	add	r7, sp, #0
 602:	6078      	str	r0, [r7, #4]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 604:	687b      	ldr	r3, [r7, #4]
 606:	2b00      	cmp	r3, #0
 608:	d102      	bne.n	610 <dac_ad5392_configure_control_register+0x14>
 60a:	f04f 0301 	mov.w	r3, #1
 60e:	e023      	b.n	658 <dac_ad5392_configure_control_register+0x5c>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 610:	687b      	ldr	r3, [r7, #4]
 612:	7f1b      	ldrb	r3, [r3, #28]
 614:	2b01      	cmp	r3, #1
 616:	d002      	beq.n	61e <dac_ad5392_configure_control_register+0x22>
 618:	f04f 0304 	mov.w	r3, #4
 61c:	e01c      	b.n	658 <dac_ad5392_configure_control_register+0x5c>

	data_send[0] = DAC_WRITE | DAC_WRITE_CONTROL_REGISTER;
 61e:	f04f 030c 	mov.w	r3, #12
 622:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_CONTROL_REGISTER_HIGH_SET_INTERNAL_REFERENCE | DAC_CONTROL_REGISTER_HIGH_ENABLE_CHANNEL_MONITORING | DAC_CONTROL_REGISTER_HIGH_ENABLE_THERMAL_MONITOR;
 624:	f04f 0317 	mov.w	r3, #23
 628:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_NOP;
 62a:	f04f 0300 	mov.w	r3, #0
 62e:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 630:	687b      	ldr	r3, [r7, #4]
 632:	6819      	ldr	r1, [r3, #0]
 634:	f107 020c 	add.w	r2, r7, #12
 638:	f107 0308 	add.w	r3, r7, #8
 63c:	4608      	mov	r0, r1
 63e:	4611      	mov	r1, r2
 640:	f04f 0203 	mov.w	r2, #3
 644:	f7ff fffe 	bl	0 <spi_send_receive_data>
			644: R_ARM_THM_CALL	spi_send_receive_data
 648:	4603      	mov	r3, r0
 64a:	2b00      	cmp	r3, #0
 64c:	d002      	beq.n	654 <dac_ad5392_configure_control_register+0x58>
 64e:	f04f 0306 	mov.w	r3, #6
 652:	e001      	b.n	658 <dac_ad5392_configure_control_register+0x5c>

	return DAC_STATUS_SUCCESS;
 654:	f04f 0300 	mov.w	r3, #0
}
 658:	4618      	mov	r0, r3
 65a:	f107 0710 	add.w	r7, r7, #16
 65e:	46bd      	mov	sp, r7
 660:	bd80      	pop	{r7, pc}
 662:	bf00      	nop

00000664 <dac_ad5392_set_monitoring_channel>:

dac_status_t
dac_ad5392_set_monitoring_channel(dac_descr_t* dac,dac_channel_t channel)
{
 664:	b580      	push	{r7, lr}
 666:	b084      	sub	sp, #16
 668:	af00      	add	r7, sp, #0
 66a:	6078      	str	r0, [r7, #4]
 66c:	460b      	mov	r3, r1
 66e:	70fb      	strb	r3, [r7, #3]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 670:	687b      	ldr	r3, [r7, #4]
 672:	2b00      	cmp	r3, #0
 674:	d102      	bne.n	67c <dac_ad5392_set_monitoring_channel+0x18>
 676:	f04f 0301 	mov.w	r3, #1
 67a:	e02b      	b.n	6d4 <dac_ad5392_set_monitoring_channel+0x70>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 67c:	687b      	ldr	r3, [r7, #4]
 67e:	7f1b      	ldrb	r3, [r3, #28]
 680:	2b01      	cmp	r3, #1
 682:	d002      	beq.n	68a <dac_ad5392_set_monitoring_channel+0x26>
 684:	f04f 0304 	mov.w	r3, #4
 688:	e024      	b.n	6d4 <dac_ad5392_set_monitoring_channel+0x70>
	XME_CHECK(DAC_MIN_CHANNEL <= channel && DAC_MAX_CHANNEL >= channel, DAC_STATUS_INVALID_CHANNEL_NUMBER);
 68a:	78fb      	ldrb	r3, [r7, #3]
 68c:	2b07      	cmp	r3, #7
 68e:	d902      	bls.n	696 <dac_ad5392_set_monitoring_channel+0x32>
 690:	f04f 0303 	mov.w	r3, #3
 694:	e01e      	b.n	6d4 <dac_ad5392_set_monitoring_channel+0x70>

	data_send[0] = DAC_WRITE | DAC_WRITE_SFR_MONITOR_CHANEL;
 696:	f04f 030a 	mov.w	r3, #10
 69a:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_AD5392_TRANSFORM_CHANNEL(channel);
 69c:	78fb      	ldrb	r3, [r7, #3]
 69e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 6a2:	b2db      	uxtb	r3, r3
 6a4:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_NOP;
 6a6:	f04f 0300 	mov.w	r3, #0
 6aa:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 6ac:	687b      	ldr	r3, [r7, #4]
 6ae:	6819      	ldr	r1, [r3, #0]
 6b0:	f107 020c 	add.w	r2, r7, #12
 6b4:	f107 0308 	add.w	r3, r7, #8
 6b8:	4608      	mov	r0, r1
 6ba:	4611      	mov	r1, r2
 6bc:	f04f 0203 	mov.w	r2, #3
 6c0:	f7ff fffe 	bl	0 <spi_send_receive_data>
			6c0: R_ARM_THM_CALL	spi_send_receive_data
 6c4:	4603      	mov	r3, r0
 6c6:	2b00      	cmp	r3, #0
 6c8:	d002      	beq.n	6d0 <dac_ad5392_set_monitoring_channel+0x6c>
 6ca:	f04f 0306 	mov.w	r3, #6
 6ce:	e001      	b.n	6d4 <dac_ad5392_set_monitoring_channel+0x70>

	return DAC_STATUS_SUCCESS;
 6d0:	f04f 0300 	mov.w	r3, #0
}
 6d4:	4618      	mov	r0, r3
 6d6:	f107 0710 	add.w	r7, r7, #16
 6da:	46bd      	mov	sp, r7
 6dc:	bd80      	pop	{r7, pc}
 6de:	bf00      	nop

000006e0 <dac_ad5392_stop>:

dac_status_t
dac_ad5392_stop(dac_descr_t* dac)
{
 6e0:	b580      	push	{r7, lr}
 6e2:	b084      	sub	sp, #16
 6e4:	af00      	add	r7, sp, #0
 6e6:	6078      	str	r0, [r7, #4]
	// Alternative use dac_ad5392_clear function.
	uint8_t i;
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 6e8:	687b      	ldr	r3, [r7, #4]
 6ea:	2b00      	cmp	r3, #0
 6ec:	d102      	bne.n	6f4 <dac_ad5392_stop+0x14>
 6ee:	f04f 0301 	mov.w	r3, #1
 6f2:	e034      	b.n	75e <dac_ad5392_stop+0x7e>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 6f4:	687b      	ldr	r3, [r7, #4]
 6f6:	7f1b      	ldrb	r3, [r3, #28]
 6f8:	2b01      	cmp	r3, #1
 6fa:	d002      	beq.n	702 <dac_ad5392_stop+0x22>
 6fc:	f04f 0304 	mov.w	r3, #4
 700:	e02d      	b.n	75e <dac_ad5392_stop+0x7e>

	data_send[0] = DAC_WRITE | DAC_SOFT_CLR;
 702:	f04f 0302 	mov.w	r3, #2
 706:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 708:	f04f 0300 	mov.w	r3, #0
 70c:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 70e:	f04f 0300 	mov.w	r3, #0
 712:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 714:	687b      	ldr	r3, [r7, #4]
 716:	6819      	ldr	r1, [r3, #0]
 718:	f107 020c 	add.w	r2, r7, #12
 71c:	f107 0308 	add.w	r3, r7, #8
 720:	4608      	mov	r0, r1
 722:	4611      	mov	r1, r2
 724:	f04f 0203 	mov.w	r2, #3
 728:	f7ff fffe 	bl	0 <spi_send_receive_data>
			728: R_ARM_THM_CALL	spi_send_receive_data
 72c:	4603      	mov	r3, r0
 72e:	2b00      	cmp	r3, #0
 730:	d002      	beq.n	738 <dac_ad5392_stop+0x58>
 732:	f04f 0306 	mov.w	r3, #6
 736:	e012      	b.n	75e <dac_ad5392_stop+0x7e>

	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
 738:	f04f 0300 	mov.w	r3, #0
 73c:	73fb      	strb	r3, [r7, #15]
 73e:	e009      	b.n	754 <dac_ad5392_stop+0x74>
	{
		dac->channelStates[i] = DAC_CHANNEL_STATE_INACTIVE;
 740:	7bfb      	ldrb	r3, [r7, #15]
 742:	687a      	ldr	r2, [r7, #4]
 744:	18d3      	adds	r3, r2, r3
 746:	f04f 0200 	mov.w	r2, #0
 74a:	775a      	strb	r2, [r3, #29]
	data_send[0] = DAC_WRITE | DAC_SOFT_CLR;
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);

	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
 74c:	7bfb      	ldrb	r3, [r7, #15]
 74e:	f103 0301 	add.w	r3, r3, #1
 752:	73fb      	strb	r3, [r7, #15]
 754:	7bfb      	ldrb	r3, [r7, #15]
 756:	2b07      	cmp	r3, #7
 758:	d9f2      	bls.n	740 <dac_ad5392_stop+0x60>
	{
		dac->channelStates[i] = DAC_CHANNEL_STATE_INACTIVE;
	}

	return DAC_STATUS_SUCCESS;
 75a:	f04f 0300 	mov.w	r3, #0
}
 75e:	4618      	mov	r0, r3
 760:	f107 0710 	add.w	r7, r7, #16
 764:	46bd      	mov	sp, r7
 766:	bd80      	pop	{r7, pc}

00000768 <dac_ad5392_powerDown>:

dac_status_t
dac_ad5392_powerDown(dac_descr_t* dac)
{
 768:	b580      	push	{r7, lr}
 76a:	b084      	sub	sp, #16
 76c:	af00      	add	r7, sp, #0
 76e:	6078      	str	r0, [r7, #4]
	uint8_t i;
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 770:	687b      	ldr	r3, [r7, #4]
 772:	2b00      	cmp	r3, #0
 774:	d102      	bne.n	77c <dac_ad5392_powerDown+0x14>
 776:	f04f 0301 	mov.w	r3, #1
 77a:	e03b      	b.n	7f4 <dac_ad5392_powerDown+0x8c>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 77c:	687b      	ldr	r3, [r7, #4]
 77e:	7f1b      	ldrb	r3, [r3, #28]
 780:	2b01      	cmp	r3, #1
 782:	d002      	beq.n	78a <dac_ad5392_powerDown+0x22>
 784:	f04f 0304 	mov.w	r3, #4
 788:	e034      	b.n	7f4 <dac_ad5392_powerDown+0x8c>
	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
 78a:	f04f 0300 	mov.w	r3, #0
 78e:	73fb      	strb	r3, [r7, #15]
 790:	e00c      	b.n	7ac <dac_ad5392_powerDown+0x44>
	{
		XME_CHECK(DAC_CHANNEL_STATE_INACTIVE == dac->channelStates[i], DAC_STATUS_ACTIVE_CHANNEL);
 792:	7bfb      	ldrb	r3, [r7, #15]
 794:	687a      	ldr	r2, [r7, #4]
 796:	18d3      	adds	r3, r2, r3
 798:	7f5b      	ldrb	r3, [r3, #29]
 79a:	2b00      	cmp	r3, #0
 79c:	d002      	beq.n	7a4 <dac_ad5392_powerDown+0x3c>
 79e:	f04f 0305 	mov.w	r3, #5
 7a2:	e027      	b.n	7f4 <dac_ad5392_powerDown+0x8c>
	uint8_t i;
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
 7a4:	7bfb      	ldrb	r3, [r7, #15]
 7a6:	f103 0301 	add.w	r3, r3, #1
 7aa:	73fb      	strb	r3, [r7, #15]
 7ac:	7bfb      	ldrb	r3, [r7, #15]
 7ae:	2b07      	cmp	r3, #7
 7b0:	d9ef      	bls.n	792 <dac_ad5392_powerDown+0x2a>
	{
		XME_CHECK(DAC_CHANNEL_STATE_INACTIVE == dac->channelStates[i], DAC_STATUS_ACTIVE_CHANNEL);
	}

	data_send[0] = DAC_WRITE | DAC_SOFT_POWER_DOWN;
 7b2:	f04f 0308 	mov.w	r3, #8
 7b6:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 7b8:	f04f 0300 	mov.w	r3, #0
 7bc:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 7be:	f04f 0300 	mov.w	r3, #0
 7c2:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 7c4:	687b      	ldr	r3, [r7, #4]
 7c6:	6819      	ldr	r1, [r3, #0]
 7c8:	f107 020c 	add.w	r2, r7, #12
 7cc:	f107 0308 	add.w	r3, r7, #8
 7d0:	4608      	mov	r0, r1
 7d2:	4611      	mov	r1, r2
 7d4:	f04f 0203 	mov.w	r2, #3
 7d8:	f7ff fffe 	bl	0 <spi_send_receive_data>
			7d8: R_ARM_THM_CALL	spi_send_receive_data
 7dc:	4603      	mov	r3, r0
 7de:	2b00      	cmp	r3, #0
 7e0:	d002      	beq.n	7e8 <dac_ad5392_powerDown+0x80>
 7e2:	f04f 0306 	mov.w	r3, #6
 7e6:	e005      	b.n	7f4 <dac_ad5392_powerDown+0x8c>

	dac->state = DAC_STATE_POWER_DOWN;
 7e8:	687b      	ldr	r3, [r7, #4]
 7ea:	f04f 0202 	mov.w	r2, #2
 7ee:	771a      	strb	r2, [r3, #28]

	return DAC_STATUS_SUCCESS;
 7f0:	f04f 0300 	mov.w	r3, #0
}
 7f4:	4618      	mov	r0, r3
 7f6:	f107 0710 	add.w	r7, r7, #16
 7fa:	46bd      	mov	sp, r7
 7fc:	bd80      	pop	{r7, pc}
 7fe:	bf00      	nop

00000800 <dac_ad5392_powerUp>:

dac_status_t
dac_ad5392_powerUp(dac_descr_t* dac)
{
 800:	b580      	push	{r7, lr}
 802:	b084      	sub	sp, #16
 804:	af00      	add	r7, sp, #0
 806:	6078      	str	r0, [r7, #4]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 808:	687b      	ldr	r3, [r7, #4]
 80a:	2b00      	cmp	r3, #0
 80c:	d102      	bne.n	814 <dac_ad5392_powerUp+0x14>
 80e:	f04f 0301 	mov.w	r3, #1
 812:	e027      	b.n	864 <dac_ad5392_powerUp+0x64>
	XME_CHECK(DAC_STATE_POWER_DOWN == dac->state, DAC_STATUS_WRONG_STATE);
 814:	687b      	ldr	r3, [r7, #4]
 816:	7f1b      	ldrb	r3, [r3, #28]
 818:	2b02      	cmp	r3, #2
 81a:	d002      	beq.n	822 <dac_ad5392_powerUp+0x22>
 81c:	f04f 0304 	mov.w	r3, #4
 820:	e020      	b.n	864 <dac_ad5392_powerUp+0x64>

	data_send[0] = DAC_WRITE | DAC_SOFT_POWER_UP;
 822:	f04f 0309 	mov.w	r3, #9
 826:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_AD5392_HIGH_DATA_BYTE(DAC_DONT_CARE);
 828:	f04f 0300 	mov.w	r3, #0
 82c:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_AD5392_LOW_DATA_BYTE(DAC_DONT_CARE);
 82e:	f04f 0300 	mov.w	r3, #0
 832:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 834:	687b      	ldr	r3, [r7, #4]
 836:	6819      	ldr	r1, [r3, #0]
 838:	f107 020c 	add.w	r2, r7, #12
 83c:	f107 0308 	add.w	r3, r7, #8
 840:	4608      	mov	r0, r1
 842:	4611      	mov	r1, r2
 844:	f04f 0203 	mov.w	r2, #3
 848:	f7ff fffe 	bl	0 <spi_send_receive_data>
			848: R_ARM_THM_CALL	spi_send_receive_data
 84c:	4603      	mov	r3, r0
 84e:	2b00      	cmp	r3, #0
 850:	d002      	beq.n	858 <dac_ad5392_powerUp+0x58>
 852:	f04f 0306 	mov.w	r3, #6
 856:	e005      	b.n	864 <dac_ad5392_powerUp+0x64>

	dac->state = DAC_STATE_READY;
 858:	687b      	ldr	r3, [r7, #4]
 85a:	f04f 0201 	mov.w	r2, #1
 85e:	771a      	strb	r2, [r3, #28]

	return DAC_STATUS_SUCCESS;
 860:	f04f 0300 	mov.w	r3, #0
}
 864:	4618      	mov	r0, r3
 866:	f107 0710 	add.w	r7, r7, #16
 86a:	46bd      	mov	sp, r7
 86c:	bd80      	pop	{r7, pc}
 86e:	bf00      	nop

00000870 <dac_ad5392_clear>:

dac_status_t
dac_ad5392_clear(dac_descr_t* dac)
{
 870:	b580      	push	{r7, lr}
 872:	b084      	sub	sp, #16
 874:	af00      	add	r7, sp, #0
 876:	6078      	str	r0, [r7, #4]
	uint8_t data_send[3], data_receive[3];

	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 878:	687b      	ldr	r3, [r7, #4]
 87a:	2b00      	cmp	r3, #0
 87c:	d102      	bne.n	884 <dac_ad5392_clear+0x14>
 87e:	f04f 0301 	mov.w	r3, #1
 882:	e045      	b.n	910 <dac_ad5392_clear+0xa0>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 884:	687b      	ldr	r3, [r7, #4]
 886:	7f1b      	ldrb	r3, [r3, #28]
 888:	2b01      	cmp	r3, #1
 88a:	d002      	beq.n	892 <dac_ad5392_clear+0x22>
 88c:	f04f 0304 	mov.w	r3, #4
 890:	e03e      	b.n	910 <dac_ad5392_clear+0xa0>

	data_send[0] = DAC_WRITE | DAC_WRITE_CLR_CODE_REGISTER;
 892:	f04f 0301 	mov.w	r3, #1
 896:	733b      	strb	r3, [r7, #12]
	data_send[1] = DAC_SPECIAL_FUNCTION_REGISTER | DAC_CLR_CODE_REGISTER_HIGH;
 898:	f04f 0300 	mov.w	r3, #0
 89c:	737b      	strb	r3, [r7, #13]
	data_send[2] = DAC_CLR_CODE_REGISTER_LOW;
 89e:	f04f 0300 	mov.w	r3, #0
 8a2:	73bb      	strb	r3, [r7, #14]
	XME_CHECK(SPI_STATUS_SUCCESS == spi_send_receive_data(dac->spi, data_send, sizeof(data_send), data_receive), DAC_STATUS_OPERATION_FAILED);
 8a4:	687b      	ldr	r3, [r7, #4]
 8a6:	6819      	ldr	r1, [r3, #0]
 8a8:	f107 020c 	add.w	r2, r7, #12
 8ac:	f107 0308 	add.w	r3, r7, #8
 8b0:	4608      	mov	r0, r1
 8b2:	4611      	mov	r1, r2
 8b4:	f04f 0203 	mov.w	r2, #3
 8b8:	f7ff fffe 	bl	0 <spi_send_receive_data>
			8b8: R_ARM_THM_CALL	spi_send_receive_data
 8bc:	4603      	mov	r3, r0
 8be:	2b00      	cmp	r3, #0
 8c0:	d002      	beq.n	8c8 <dac_ad5392_clear+0x58>
 8c2:	f04f 0306 	mov.w	r3, #6
 8c6:	e023      	b.n	910 <dac_ad5392_clear+0xa0>

	GPIO_WriteBit(dac->clr_pin.port, dac->clr_pin.pin, DAC_HIGH);
 8c8:	687b      	ldr	r3, [r7, #4]
 8ca:	699a      	ldr	r2, [r3, #24]
 8cc:	687b      	ldr	r3, [r7, #4]
 8ce:	8a9b      	ldrh	r3, [r3, #20]
 8d0:	4610      	mov	r0, r2
 8d2:	4619      	mov	r1, r3
 8d4:	f04f 0201 	mov.w	r2, #1
 8d8:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			8d8: R_ARM_THM_CALL	GPIO_WriteBit
	GPIO_WriteBit(dac->clr_pin.port, dac->clr_pin.pin, DAC_LOW);
 8dc:	687b      	ldr	r3, [r7, #4]
 8de:	699a      	ldr	r2, [r3, #24]
 8e0:	687b      	ldr	r3, [r7, #4]
 8e2:	8a9b      	ldrh	r3, [r3, #20]
 8e4:	4610      	mov	r0, r2
 8e6:	4619      	mov	r1, r3
 8e8:	f04f 0200 	mov.w	r2, #0
 8ec:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			8ec: R_ARM_THM_CALL	GPIO_WriteBit
	while (DAC_LOW == GPIO_ReadInputDataBit(dac->busy_pin.port,dac->busy_pin.pin));
#endif

#if !BUSY_PIN_AVAILABLE
	// Simulate waiting of the busy pin.
	vTaskDelay(1);
 8f0:	f04f 0001 	mov.w	r0, #1
 8f4:	f7ff fffe 	bl	0 <vTaskDelay>
			8f4: R_ARM_THM_CALL	vTaskDelay
#endif

	GPIO_WriteBit(dac->clr_pin.port, dac->clr_pin.pin, DAC_HIGH);
 8f8:	687b      	ldr	r3, [r7, #4]
 8fa:	699a      	ldr	r2, [r3, #24]
 8fc:	687b      	ldr	r3, [r7, #4]
 8fe:	8a9b      	ldrh	r3, [r3, #20]
 900:	4610      	mov	r0, r2
 902:	4619      	mov	r1, r3
 904:	f04f 0201 	mov.w	r2, #1
 908:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			908: R_ARM_THM_CALL	GPIO_WriteBit
	return DAC_STATUS_SUCCESS;
 90c:	f04f 0300 	mov.w	r3, #0
}
 910:	4618      	mov	r0, r3
 912:	f107 0710 	add.w	r7, r7, #16
 916:	46bd      	mov	sp, r7
 918:	bd80      	pop	{r7, pc}
 91a:	bf00      	nop

0000091c <dac_ad5392_clear_outputs_to_zero>:

dac_status_t
dac_ad5392_clear_outputs_to_zero(dac_descr_t* dac)
{
 91c:	b580      	push	{r7, lr}
 91e:	b082      	sub	sp, #8
 920:	af00      	add	r7, sp, #0
 922:	6078      	str	r0, [r7, #4]

	GPIO_WriteBit(dac->clr_pin.port, dac->clr_pin.pin, DAC_HIGH);
 924:	687b      	ldr	r3, [r7, #4]
 926:	699a      	ldr	r2, [r3, #24]
 928:	687b      	ldr	r3, [r7, #4]
 92a:	8a9b      	ldrh	r3, [r3, #20]
 92c:	4610      	mov	r0, r2
 92e:	4619      	mov	r1, r3
 930:	f04f 0201 	mov.w	r2, #1
 934:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			934: R_ARM_THM_CALL	GPIO_WriteBit
	GPIO_WriteBit(dac->clr_pin.port, dac->clr_pin.pin, DAC_LOW);
 938:	687b      	ldr	r3, [r7, #4]
 93a:	699a      	ldr	r2, [r3, #24]
 93c:	687b      	ldr	r3, [r7, #4]
 93e:	8a9b      	ldrh	r3, [r3, #20]
 940:	4610      	mov	r0, r2
 942:	4619      	mov	r1, r3
 944:	f04f 0200 	mov.w	r2, #0
 948:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			948: R_ARM_THM_CALL	GPIO_WriteBit
	while (DAC_LOW == GPIO_ReadInputDataBit(dac->busy_pin.port,dac->busy_pin.pin));
#endif

#if !BUSY_PIN_AVAILABLE
	// Simulate waiting of the busy pin.
	vTaskDelay(1);
 94c:	f04f 0001 	mov.w	r0, #1
 950:	f7ff fffe 	bl	0 <vTaskDelay>
			950: R_ARM_THM_CALL	vTaskDelay
#endif

	GPIO_WriteBit(dac->clr_pin.port, dac->clr_pin.pin, DAC_HIGH);
 954:	687b      	ldr	r3, [r7, #4]
 956:	699a      	ldr	r2, [r3, #24]
 958:	687b      	ldr	r3, [r7, #4]
 95a:	8a9b      	ldrh	r3, [r3, #20]
 95c:	4610      	mov	r0, r2
 95e:	4619      	mov	r1, r3
 960:	f04f 0201 	mov.w	r2, #1
 964:	f7ff fffe 	bl	0 <GPIO_WriteBit>
			964: R_ARM_THM_CALL	GPIO_WriteBit
	return DAC_STATUS_SUCCESS;
 968:	f04f 0300 	mov.w	r3, #0
}
 96c:	4618      	mov	r0, r3
 96e:	f107 0708 	add.w	r7, r7, #8
 972:	46bd      	mov	sp, r7
 974:	bd80      	pop	{r7, pc}
 976:	bf00      	nop

00000978 <dac_ad5392_fini>:

dac_status_t
dac_ad5392_fini(dac_descr_t* dac)
{
 978:	b480      	push	{r7}
 97a:	b085      	sub	sp, #20
 97c:	af00      	add	r7, sp, #0
 97e:	6078      	str	r0, [r7, #4]
	uint8_t i;
	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
 980:	687b      	ldr	r3, [r7, #4]
 982:	2b00      	cmp	r3, #0
 984:	d102      	bne.n	98c <dac_ad5392_fini+0x14>
 986:	f04f 0301 	mov.w	r3, #1
 98a:	e01d      	b.n	9c8 <dac_ad5392_fini+0x50>
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
 98c:	687b      	ldr	r3, [r7, #4]
 98e:	7f1b      	ldrb	r3, [r3, #28]
 990:	2b01      	cmp	r3, #1
 992:	d002      	beq.n	99a <dac_ad5392_fini+0x22>
 994:	f04f 0304 	mov.w	r3, #4
 998:	e016      	b.n	9c8 <dac_ad5392_fini+0x50>
	// TODO: See if the state of the channels should be INACTIVE and if the state of the DAC has to be changed
	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
 99a:	f04f 0300 	mov.w	r3, #0
 99e:	73fb      	strb	r3, [r7, #15]
 9a0:	e009      	b.n	9b6 <dac_ad5392_fini+0x3e>
	{
		dac->channelStates[i] = DAC_CHANNEL_STATE_INACTIVE;
 9a2:	7bfb      	ldrb	r3, [r7, #15]
 9a4:	687a      	ldr	r2, [r7, #4]
 9a6:	18d3      	adds	r3, r2, r3
 9a8:	f04f 0200 	mov.w	r2, #0
 9ac:	775a      	strb	r2, [r3, #29]
{
	uint8_t i;
	XME_CHECK(NULL != dac, DAC_STATUS_INVALID_DAC_DESCRIPTOR);
	XME_CHECK(DAC_STATE_READY == dac->state, DAC_STATUS_WRONG_STATE);
	// TODO: See if the state of the channels should be INACTIVE and if the state of the DAC has to be changed
	for (i = DAC_MIN_CHANNEL; i <= DAC_MAX_CHANNEL; i++)
 9ae:	7bfb      	ldrb	r3, [r7, #15]
 9b0:	f103 0301 	add.w	r3, r3, #1
 9b4:	73fb      	strb	r3, [r7, #15]
 9b6:	7bfb      	ldrb	r3, [r7, #15]
 9b8:	2b07      	cmp	r3, #7
 9ba:	d9f2      	bls.n	9a2 <dac_ad5392_fini+0x2a>
	{
		dac->channelStates[i] = DAC_CHANNEL_STATE_INACTIVE;
	}
	dac->state = DAC_STATE_UNINITIALIZED;
 9bc:	687b      	ldr	r3, [r7, #4]
 9be:	f04f 0200 	mov.w	r2, #0
 9c2:	771a      	strb	r2, [r3, #28]

	return DAC_STATUS_SUCCESS;
 9c4:	f04f 0300 	mov.w	r3, #0
}
 9c8:	4618      	mov	r0, r3
 9ca:	f107 0714 	add.w	r7, r7, #20
 9ce:	46bd      	mov	sp, r7
 9d0:	bc80      	pop	{r7}
 9d2:	4770      	bx	lr
 9d4:	f3af 8000 	nop.w

dac_ad5392_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 333668 Jul 30 19:07 2021 dac_ad5392_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  00000084  2**0
                  ALLOC
  3 .debug_abbrev 0000010c  00000000  00000000  00000084  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004dd  00000000  00000000  00000190  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000005e5  00000000  00000000  0000066d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0004fcee  00000000  00000000  00000c52  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000003d  00000000  00000000  00050940  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 00000124  00000000  00000000  0005097d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000446  00000000  00000000  00050aa1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  00050ee7  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  00050f12  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 dac_ad5392_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .data	00000028 board_dac_digital
00000000         *UND*	00000000 dac_spi
00000028 g     O .data	00000028 board_dac_analog



adc_intern_stm32f107.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 318832 Jul 30 19:07 2021 adc_intern_stm32f107.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001d8  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000020c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000020c  2**0
                  ALLOC
  3 .debug_abbrev 00000120  00000000  00000000  0000020c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000056c  00000000  00000000  0000032c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000499  00000000  00000000  00000898  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0004ba69  00000000  00000000  00000d31  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000118  00000000  00000000  0004c79a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000089  00000000  00000000  0004c8b2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000102  00000000  00000000  0004c93b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0004ca3d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000474  00000000  00000000  0004ca5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0004ced1  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0004cefc  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000a4  00000000  00000000  0004cf30  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 adc_intern_stm32f107.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	000000cc stm32f107_adc_init
00000000         *UND*	00000000 GPIO_Init
00000000         *UND*	00000000 RCC_APB2PeriphClockCmd
00000000         *UND*	00000000 ADC_DeInit
00000000         *UND*	00000000 ADC_Init
00000000         *UND*	00000000 ADC_RegularChannelConfig
00000000         *UND*	00000000 ADC_Cmd
00000000         *UND*	00000000 ADC_SoftwareStartConvCmd
00000000         *UND*	00000000 ADC_ResetCalibration
00000000         *UND*	00000000 ADC_GetResetCalibrationStatus
00000000         *UND*	00000000 ADC_StartCalibration
00000000         *UND*	00000000 ADC_GetCalibrationStatus
000000cc g     F .text	0000002c stm32f107_adc_done
00000000         *UND*	00000000 temperature_adc
000000f8 g     F .text	00000058 stm32f107_adc_conv
00000000         *UND*	00000000 ADC_GetFlagStatus
00000000         *UND*	00000000 ADC_GetConversionValue
00000150 g     F .text	00000038 stm32f107_adc_rawValue
00000188 g     F .text	00000050 stm32f107_adc_volt



Disassembly of section .text:

00000000 <stm32f107_adc_init>:

/******************************************************************************/
/***   Implementation for built-in 12-bit ADC                               ***/
/******************************************************************************/
stm32f107_adc_status_t
stm32f107_adc_init (stm32f107_adc_descr_t *adc) {
   0:	b580      	push	{r7, lr}
   2:	b08a      	sub	sp, #40	; 0x28
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
	ADC_InitTypeDef   ADC_InitStructure;
	ADC_TypeDef*     ADCx;

	// Initialize the GPIO pin PB1 as analogue input.
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   8:	f04f 0300 	mov.w	r3, #0
   c:	73fb      	strb	r3, [r7, #15]
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
   e:	f04f 0302 	mov.w	r3, #2
  12:	81bb      	strh	r3, [r7, #12]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
  14:	f107 030c 	add.w	r3, r7, #12
  18:	482a      	ldr	r0, [pc, #168]	; (c4 <stm32f107_adc_init+0xc4>)
  1a:	4619      	mov	r1, r3
  1c:	f7ff fffe 	bl	0 <GPIO_Init>
			1c: R_ARM_THM_CALL	GPIO_Init

	/* Enable ADC1 clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
  20:	f44f 7000 	mov.w	r0, #512	; 0x200
  24:	f04f 0101 	mov.w	r1, #1
  28:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
			28: R_ARM_THM_CALL	RCC_APB2PeriphClockCmd
	ADCx = ADC1;
  2c:	4b26      	ldr	r3, [pc, #152]	; (c8 <stm32f107_adc_init+0xc8>)
  2e:	627b      	str	r3, [r7, #36]	; 0x24

	ADC_DeInit(ADCx);
  30:	6a78      	ldr	r0, [r7, #36]	; 0x24
  32:	f7ff fffe 	bl	0 <ADC_DeInit>
			32: R_ARM_THM_CALL	ADC_DeInit

	/* ADC configuration ------------------------------------------------------*/
	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
  36:	f04f 0300 	mov.w	r3, #0
  3a:	613b      	str	r3, [r7, #16]
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
  3c:	f04f 0300 	mov.w	r3, #0
  40:	753b      	strb	r3, [r7, #20]
	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;
  42:	f04f 0300 	mov.w	r3, #0
  46:	757b      	strb	r3, [r7, #21]
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
  48:	f44f 2360 	mov.w	r3, #917504	; 0xe0000
  4c:	61bb      	str	r3, [r7, #24]
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
  4e:	f04f 0300 	mov.w	r3, #0
  52:	61fb      	str	r3, [r7, #28]
	ADC_InitStructure.ADC_NbrOfChannel = 1;
  54:	f04f 0301 	mov.w	r3, #1
  58:	f887 3020 	strb.w	r3, [r7, #32]
	ADC_Init(ADCx, &ADC_InitStructure);
  5c:	f107 0310 	add.w	r3, r7, #16
  60:	6a78      	ldr	r0, [r7, #36]	; 0x24
  62:	4619      	mov	r1, r3
  64:	f7ff fffe 	bl	0 <ADC_Init>
			64: R_ARM_THM_CALL	ADC_Init

	// Pin B1 where the temperature sensor is connected can be connected only to Channel 9 from the internal ADC1 or ADC2.
	ADC_RegularChannelConfig(ADCx,ADC_Channel_9,1,ADC_SampleTime_13Cycles5);
  68:	6a78      	ldr	r0, [r7, #36]	; 0x24
  6a:	f04f 0109 	mov.w	r1, #9
  6e:	f04f 0201 	mov.w	r2, #1
  72:	f04f 0302 	mov.w	r3, #2
  76:	f7ff fffe 	bl	0 <ADC_RegularChannelConfig>
			76: R_ARM_THM_CALL	ADC_RegularChannelConfig

	/* Enable ADC */
	ADC_Cmd(ADCx, ENABLE);
  7a:	6a78      	ldr	r0, [r7, #36]	; 0x24
  7c:	f04f 0101 	mov.w	r1, #1
  80:	f7ff fffe 	bl	0 <ADC_Cmd>
			80: R_ARM_THM_CALL	ADC_Cmd

	ADC_SoftwareStartConvCmd(ADCx, ENABLE);
  84:	6a78      	ldr	r0, [r7, #36]	; 0x24
  86:	f04f 0101 	mov.w	r1, #1
  8a:	f7ff fffe 	bl	0 <ADC_SoftwareStartConvCmd>
			8a: R_ARM_THM_CALL	ADC_SoftwareStartConvCmd
	// Enable ADC reset calibration register
	ADC_ResetCalibration(ADCx);
  8e:	6a78      	ldr	r0, [r7, #36]	; 0x24
  90:	f7ff fffe 	bl	0 <ADC_ResetCalibration>
			90: R_ARM_THM_CALL	ADC_ResetCalibration
	// Check the end of ADC reset calibration register
	while(ADC_GetResetCalibrationStatus(ADCx));
  94:	bf00      	nop
  96:	6a78      	ldr	r0, [r7, #36]	; 0x24
  98:	f7ff fffe 	bl	0 <ADC_GetResetCalibrationStatus>
			98: R_ARM_THM_CALL	ADC_GetResetCalibrationStatus
  9c:	4603      	mov	r3, r0
  9e:	2b00      	cmp	r3, #0
  a0:	d1f9      	bne.n	96 <stm32f107_adc_init+0x96>

	// Start ADC calibration
	ADC_StartCalibration(ADCx);
  a2:	6a78      	ldr	r0, [r7, #36]	; 0x24
  a4:	f7ff fffe 	bl	0 <ADC_StartCalibration>
			a4: R_ARM_THM_CALL	ADC_StartCalibration
	// Check the end of ADC calibration
	while(ADC_GetCalibrationStatus(ADCx));
  a8:	bf00      	nop
  aa:	6a78      	ldr	r0, [r7, #36]	; 0x24
  ac:	f7ff fffe 	bl	0 <ADC_GetCalibrationStatus>
			ac: R_ARM_THM_CALL	ADC_GetCalibrationStatus
  b0:	4603      	mov	r3, r0
  b2:	2b00      	cmp	r3, #0
  b4:	d1f9      	bne.n	aa <stm32f107_adc_init+0xaa>

	return STM32F107_ADC_STATUS_SUCCESS;
  b6:	f04f 0300 	mov.w	r3, #0
}
  ba:	4618      	mov	r0, r3
  bc:	f107 0728 	add.w	r7, r7, #40	; 0x28
  c0:	46bd      	mov	sp, r7
  c2:	bd80      	pop	{r7, pc}
  c4:	40010c00 	.word	0x40010c00
  c8:	40012400 	.word	0x40012400

000000cc <stm32f107_adc_done>:

stm32f107_adc_status_t
stm32f107_adc_done (stm32f107_adc_descr_t *adc) {
  cc:	b480      	push	{r7}
  ce:	b083      	sub	sp, #12
  d0:	af00      	add	r7, sp, #0
  d2:	6078      	str	r0, [r7, #4]
	if(&temperature_adc == adc) {
  d4:	687a      	ldr	r2, [r7, #4]
  d6:	4b07      	ldr	r3, [pc, #28]	; (f4 <stm32f107_adc_done+0x28>)
  d8:	429a      	cmp	r2, r3
  da:	d102      	bne.n	e2 <stm32f107_adc_done+0x16>
		return STM32F107_ADC_STATUS_SUCCESS;
  dc:	f04f 0300 	mov.w	r3, #0
  e0:	e001      	b.n	e6 <stm32f107_adc_done+0x1a>
	}
	return STM32F107_ADC_STATUS_CHANNEL_NOT_SUPPORTED;
  e2:	f04f 0302 	mov.w	r3, #2
}
  e6:	4618      	mov	r0, r3
  e8:	f107 070c 	add.w	r7, r7, #12
  ec:	46bd      	mov	sp, r7
  ee:	bc80      	pop	{r7}
  f0:	4770      	bx	lr
  f2:	bf00      	nop
  f4:	00000000 	.word	0x00000000
			f4: R_ARM_ABS32	temperature_adc

000000f8 <stm32f107_adc_conv>:

stm32f107_adc_status_t
stm32f107_adc_conv (stm32f107_adc_descr_t *adc) {
  f8:	b580      	push	{r7, lr}
  fa:	b084      	sub	sp, #16
  fc:	af00      	add	r7, sp, #0
  fe:	6078      	str	r0, [r7, #4]

	uint16_t ADC_Data;
	if(&temperature_adc == adc) {
 100:	687a      	ldr	r2, [r7, #4]
 102:	4b11      	ldr	r3, [pc, #68]	; (148 <stm32f107_adc_conv+0x50>)
 104:	429a      	cmp	r2, r3
 106:	d118      	bne.n	13a <stm32f107_adc_conv+0x42>
		ADC_SoftwareStartConvCmd(ADC1,ENABLE);
 108:	4810      	ldr	r0, [pc, #64]	; (14c <stm32f107_adc_conv+0x54>)
 10a:	f04f 0101 	mov.w	r1, #1
 10e:	f7ff fffe 	bl	0 <ADC_SoftwareStartConvCmd>
			10e: R_ARM_THM_CALL	ADC_SoftwareStartConvCmd
		while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
 112:	bf00      	nop
 114:	480d      	ldr	r0, [pc, #52]	; (14c <stm32f107_adc_conv+0x54>)
 116:	f04f 0102 	mov.w	r1, #2
 11a:	f7ff fffe 	bl	0 <ADC_GetFlagStatus>
			11a: R_ARM_THM_CALL	ADC_GetFlagStatus
 11e:	4603      	mov	r3, r0
 120:	2b00      	cmp	r3, #0
 122:	d0f7      	beq.n	114 <stm32f107_adc_conv+0x1c>
		ADC_Data = ADC_GetConversionValue(ADC1);
 124:	4809      	ldr	r0, [pc, #36]	; (14c <stm32f107_adc_conv+0x54>)
 126:	f7ff fffe 	bl	0 <ADC_GetConversionValue>
			126: R_ARM_THM_CALL	ADC_GetConversionValue
 12a:	4603      	mov	r3, r0
 12c:	81fb      	strh	r3, [r7, #14]
		adc->rawValue = ADC_Data;
 12e:	89fa      	ldrh	r2, [r7, #14]
 130:	687b      	ldr	r3, [r7, #4]
 132:	801a      	strh	r2, [r3, #0]
		return STM32F107_ADC_STATUS_SUCCESS;
 134:	f04f 0300 	mov.w	r3, #0
 138:	e001      	b.n	13e <stm32f107_adc_conv+0x46>
	}
	else
	{
		return STM32F107_ADC_STATUS_CHANNEL_NOT_SUPPORTED;
 13a:	f04f 0302 	mov.w	r3, #2
	}
}
 13e:	4618      	mov	r0, r3
 140:	f107 0710 	add.w	r7, r7, #16
 144:	46bd      	mov	sp, r7
 146:	bd80      	pop	{r7, pc}
 148:	00000000 	.word	0x00000000
			148: R_ARM_ABS32	temperature_adc
 14c:	40012400 	.word	0x40012400

00000150 <stm32f107_adc_rawValue>:

stm32f107_adc_status_t
stm32f107_adc_rawValue (stm32f107_adc_descr_t *adc, uint16_t* r) {
 150:	b480      	push	{r7}
 152:	b083      	sub	sp, #12
 154:	af00      	add	r7, sp, #0
 156:	6078      	str	r0, [r7, #4]
 158:	6039      	str	r1, [r7, #0]
	if(&temperature_adc == adc) {
 15a:	687a      	ldr	r2, [r7, #4]
 15c:	4b09      	ldr	r3, [pc, #36]	; (184 <stm32f107_adc_rawValue+0x34>)
 15e:	429a      	cmp	r2, r3
 160:	d107      	bne.n	172 <stm32f107_adc_rawValue+0x22>
		*r = adc->rawValue;
 162:	687b      	ldr	r3, [r7, #4]
 164:	881b      	ldrh	r3, [r3, #0]
 166:	b29a      	uxth	r2, r3
 168:	683b      	ldr	r3, [r7, #0]
 16a:	801a      	strh	r2, [r3, #0]
		return STM32F107_ADC_STATUS_SUCCESS;
 16c:	f04f 0300 	mov.w	r3, #0
 170:	e001      	b.n	176 <stm32f107_adc_rawValue+0x26>
	}
	return STM32F107_ADC_STATUS_CHANNEL_NOT_SUPPORTED;
 172:	f04f 0302 	mov.w	r3, #2
}
 176:	4618      	mov	r0, r3
 178:	f107 070c 	add.w	r7, r7, #12
 17c:	46bd      	mov	sp, r7
 17e:	bc80      	pop	{r7}
 180:	4770      	bx	lr
 182:	bf00      	nop
 184:	00000000 	.word	0x00000000
			184: R_ARM_ABS32	temperature_adc

00000188 <stm32f107_adc_volt>:

stm32f107_adc_status_t
stm32f107_adc_volt (stm32f107_adc_descr_t *adc, uint32_t* v) {
 188:	b480      	push	{r7}
 18a:	b083      	sub	sp, #12
 18c:	af00      	add	r7, sp, #0
 18e:	6078      	str	r0, [r7, #4]
 190:	6039      	str	r1, [r7, #0]
	if(&temperature_adc == adc) {
 192:	687a      	ldr	r2, [r7, #4]
 194:	4b0f      	ldr	r3, [pc, #60]	; (1d4 <stm32f107_adc_volt+0x4c>)
 196:	429a      	cmp	r2, r3
 198:	d114      	bne.n	1c4 <stm32f107_adc_volt+0x3c>
		// Calculate voltage in mV
		*v = (ADC_INTERN_VREF * adc->rawValue) / ADC_INTERN_BITS;
 19a:	687b      	ldr	r3, [r7, #4]
 19c:	881b      	ldrh	r3, [r3, #0]
 19e:	b21b      	sxth	r3, r3
 1a0:	f640 12c4 	movw	r2, #2500	; 0x9c4
 1a4:	fb02 f303 	mul.w	r3, r2, r3
 1a8:	2b00      	cmp	r3, #0
 1aa:	da03      	bge.n	1b4 <stm32f107_adc_volt+0x2c>
 1ac:	f503 637e 	add.w	r3, r3, #4064	; 0xfe0
 1b0:	f103 031f 	add.w	r3, r3, #31
 1b4:	ea4f 3323 	mov.w	r3, r3, asr #12
 1b8:	461a      	mov	r2, r3
 1ba:	683b      	ldr	r3, [r7, #0]
 1bc:	601a      	str	r2, [r3, #0]
		return STM32F107_ADC_STATUS_SUCCESS;
 1be:	f04f 0300 	mov.w	r3, #0
 1c2:	e001      	b.n	1c8 <stm32f107_adc_volt+0x40>
	}
	return STM32F107_ADC_STATUS_CHANNEL_NOT_SUPPORTED;
 1c4:	f04f 0302 	mov.w	r3, #2
}
 1c8:	4618      	mov	r0, r3
 1ca:	f107 070c 	add.w	r7, r7, #12
 1ce:	46bd      	mov	sp, r7
 1d0:	bc80      	pop	{r7}
 1d2:	4770      	bx	lr
 1d4:	00000000 	.word	0x00000000
			1d4: R_ARM_ABS32	temperature_adc

adc_intern_stm32f107_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  14516 Jul 30 19:07 2021 adc_intern_stm32f107_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000004  00000000  00000000  00000034  2**2
                  ALLOC
  3 .debug_abbrev 00000064  00000000  00000000  00000034  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000000ab  00000000  00000000  00000098  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000001cd  00000000  00000000  00000143  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 00002e30  00000000  00000000  00000310  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000026  00000000  00000000  00003140  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 00000038  00000000  00000000  00003166  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000129  00000000  00000000  0000319e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  000032c7  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  000032f2  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 adc_intern_stm32f107_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .bss	00000002 temperature_adc



i2c.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 329420 Jul 30 19:07 2021 i2c.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000bc  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000f0  2**0
                  ALLOC
  3 .debug_abbrev 00000115  00000000  00000000  000000f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004c9  00000000  00000000  00000205  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000005bc  00000000  00000000  000006ce  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0004e9fb  00000000  00000000  00000c8a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000038  00000000  00000000  0004f685  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000001f  00000000  00000000  0004f6bd  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000115  00000000  00000000  0004f6dc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0004f7f1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000406  00000000  00000000  0004f811  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0004fc17  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0004fc42  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000030  00000000  00000000  0004fc74  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	000000bc i2c_init
00000000         *UND*	00000000 RCC_APB1PeriphClockCmd
00000000         *UND*	00000000 RCC_APB2PeriphClockCmd
00000000         *UND*	00000000 GPIO_PinRemapConfig
00000000         *UND*	00000000 belle_gpio_pin_init
00000000         *UND*	00000000 I2C_Cmd
00000000         *UND*	00000000 I2C_Init



Disassembly of section .text:

00000000 <i2c_init>:
/******************************************************************************/
/***   Implementation for SPI				     	                        ***/
/******************************************************************************/
i2c_status_t
i2c_init (i2c_descr_t *i2c)
{
   0:	b580      	push	{r7, lr}
   2:	b088      	sub	sp, #32
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
	GPIO_InitTypeDef  GPIO_InitStructure;
	I2C_InitTypeDef  I2C_InitStructure;

	RCC_APB1PeriphClockCmd(i2c->i2c_clock, ENABLE);
   8:	687b      	ldr	r3, [r7, #4]
   a:	685b      	ldr	r3, [r3, #4]
   c:	4618      	mov	r0, r3
   e:	f04f 0101 	mov.w	r1, #1
  12:	f7ff fffe 	bl	0 <RCC_APB1PeriphClockCmd>
			12: R_ARM_THM_CALL	RCC_APB1PeriphClockCmd

	/* GPIOB clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
  16:	f04f 0009 	mov.w	r0, #9
  1a:	f04f 0101 	mov.w	r1, #1
  1e:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
			1e: R_ARM_THM_CALL	RCC_APB2PeriphClockCmd

	GPIO_PinRemapConfig(GPIO_Remap_I2C1,ENABLE);
  22:	f04f 0002 	mov.w	r0, #2
  26:	f04f 0101 	mov.w	r1, #1
  2a:	f7ff fffe 	bl	0 <GPIO_PinRemapConfig>
			2a: R_ARM_THM_CALL	GPIO_PinRemapConfig

	/* I2C1 SDA and SCL configuration */
	belle_gpio_pin_init(i2c->scl.clock, i2c->scl.port, i2c->scl.pin, GPIO_Mode_AF_OD);
  2e:	687b      	ldr	r3, [r7, #4]
  30:	6899      	ldr	r1, [r3, #8]
  32:	687b      	ldr	r3, [r7, #4]
  34:	691a      	ldr	r2, [r3, #16]
  36:	687b      	ldr	r3, [r7, #4]
  38:	899b      	ldrh	r3, [r3, #12]
  3a:	4608      	mov	r0, r1
  3c:	4611      	mov	r1, r2
  3e:	461a      	mov	r2, r3
  40:	f04f 031c 	mov.w	r3, #28
  44:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			44: R_ARM_THM_CALL	belle_gpio_pin_init
	belle_gpio_pin_init(i2c->sda.clock, i2c->sda.port, i2c->sda.pin, GPIO_Mode_AF_OD);
  48:	687b      	ldr	r3, [r7, #4]
  4a:	6959      	ldr	r1, [r3, #20]
  4c:	687b      	ldr	r3, [r7, #4]
  4e:	69da      	ldr	r2, [r3, #28]
  50:	687b      	ldr	r3, [r7, #4]
  52:	8b1b      	ldrh	r3, [r3, #24]
  54:	4608      	mov	r0, r1
  56:	4611      	mov	r1, r2
  58:	461a      	mov	r2, r3
  5a:	f04f 031c 	mov.w	r3, #28
  5e:	f7ff fffe 	bl	0 <belle_gpio_pin_init>
			5e: R_ARM_THM_CALL	belle_gpio_pin_init

	/* I2C1 and I2C2 configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
  62:	f04f 0300 	mov.w	r3, #0
  66:	823b      	strh	r3, [r7, #16]
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
  68:	f64b 73ff 	movw	r3, #49151	; 0xbfff
  6c:	827b      	strh	r3, [r7, #18]
	I2C_InitStructure.I2C_OwnAddress1 = OWN_ADDRESS1;
  6e:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  72:	82bb      	strh	r3, [r7, #20]
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
  74:	f44f 6380 	mov.w	r3, #1024	; 0x400
  78:	82fb      	strh	r3, [r7, #22]
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
  7a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  7e:	833b      	strh	r3, [r7, #24]
	I2C_InitStructure.I2C_ClockSpeed = CLOCK_SPEEED;
  80:	f242 7310 	movw	r3, #10000	; 0x2710
  84:	60fb      	str	r3, [r7, #12]
	I2C_Cmd(i2c->i2c_eeprom, ENABLE);
  86:	687b      	ldr	r3, [r7, #4]
  88:	681b      	ldr	r3, [r3, #0]
  8a:	4618      	mov	r0, r3
  8c:	f04f 0101 	mov.w	r1, #1
  90:	f7ff fffe 	bl	0 <I2C_Cmd>
			90: R_ARM_THM_CALL	I2C_Cmd
	I2C_Init(i2c->i2c_eeprom, &I2C_InitStructure);
  94:	687b      	ldr	r3, [r7, #4]
  96:	681a      	ldr	r2, [r3, #0]
  98:	f107 030c 	add.w	r3, r7, #12
  9c:	4610      	mov	r0, r2
  9e:	4619      	mov	r1, r3
  a0:	f7ff fffe 	bl	0 <I2C_Init>
			a0: R_ARM_THM_CALL	I2C_Init
	i2c->state = I2C_STATE_READY;
  a4:	687b      	ldr	r3, [r7, #4]
  a6:	f04f 0201 	mov.w	r2, #1
  aa:	f883 2020 	strb.w	r2, [r3, #32]

	return I2C_STATUS_SUCCESS;
  ae:	f04f 0300 	mov.w	r3, #0
}
  b2:	4618      	mov	r0, r3
  b4:	f107 0720 	add.w	r7, r7, #32
  b8:	46bd      	mov	sp, r7
  ba:	bd80      	pop	{r7, pc}

i2c_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 327128 Jul 30 19:07 2021 i2c_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000058  2**0
                  ALLOC
  3 .debug_abbrev 000000e2  00000000  00000000  00000058  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000346  00000000  00000000  0000013a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000005a2  00000000  00000000  00000480  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0004e9f3  00000000  00000000  00000a22  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 00000021  00000000  00000000  0004f415  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 000000b0  00000000  00000000  0004f436  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000226  00000000  00000000  0004f4e6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  0004f70c  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  0004f737  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 i2c_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .data	00000024 i2c_eeprom



eeprom.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 345840 Jul 30 19:07 2021 eeprom.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006e0  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000714  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000714  2**0
                  ALLOC
  3 .debug_abbrev 000001ef  00000000  00000000  00000714  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000008e7  00000000  00000000  00000903  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000008e9  00000000  00000000  000011ea  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 000509e4  00000000  00000000  00001ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000310  00000000  00000000  000524b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000001df  00000000  00000000  000527c7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000168  00000000  00000000  000529a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00052b0e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000005a7  00000000  00000000  00052b2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  000530d5  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00053100  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000001cc  00000000  00000000  00053134  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 eeprom.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000040       O *COM*	00000004 buffer
00000040       O *COM*	00000004 buffer2
00000000 g     F .text	00000148 eeprom_write_page
00000000         *UND*	00000000 I2C_GetFlagStatus
00000000         *UND*	00000000 I2C_GenerateSTART
00000000         *UND*	00000000 I2C_CheckEvent
00000000         *UND*	00000000 I2C_Send7bitAddress
00000000         *UND*	00000000 I2C_SendData
00000000         *UND*	00000000 I2C_GenerateSTOP
000002fc g     F .text	0000008c wait_eeprom_standby_state
00000148 g     F .text	000001b4 eeprom_read_page
00000000         *UND*	00000000 I2C_AcknowledgeConfig
00000000         *UND*	00000000 I2C_ReceiveData
00000000         *UND*	00000000 I2C_ReadRegister
00000000         *UND*	00000000 I2C_ClearFlag
00000388 g     F .text	00000090 eeprom_crc8
00000418 g     F .text	0000002c calibration_structure_padding
00000000         *UND*	00000000 memset
00000000         *UND*	00000000 memcpy
00000444 g     F .text	00000058 eeprom_write_calibration_page_values
000004ec g     F .text	0000002c eeprom_calibration_page_values_padding
0000049c g     F .text	00000050 eeprom_read_calibration_page_values
00000518 g     F .text	00000050 eeprom_read_mac_address
00000568 g     F .text	00000032 eeprom_mac_address_padding
0000059c g     F .text	0000005c eeprom_write_mac_address
000005f8 g     F .text	00000054 eeprom_read_firmware_version
0000064c g     F .text	00000032 eeprom_firmware_version_padding
00000680 g     F .text	00000060 eeprom_write_firmware_version



Disassembly of section .text:

00000000 <eeprom_write_page>:
#include "stm32f10x_i2c.h"
/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
eeprom_status_t eeprom_write_page(eeprom_descr_t *eeprom, uint8_t* pBuffer, uint16_t WriteAddr, uint8_t NumByteToWrite)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	60f8      	str	r0, [r7, #12]
   8:	60b9      	str	r1, [r7, #8]
   a:	80fa      	strh	r2, [r7, #6]
   c:	717b      	strb	r3, [r7, #5]
    uint16_t timeout;
	/* While the bus is busy */
    while(I2C_GetFlagStatus(eeprom->i2c->i2c_eeprom, I2C_FLAG_BUSY));
   e:	bf00      	nop
  10:	68fb      	ldr	r3, [r7, #12]
  12:	681b      	ldr	r3, [r3, #0]
  14:	681b      	ldr	r3, [r3, #0]
  16:	4618      	mov	r0, r3
  18:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  1c:	f7ff fffe 	bl	0 <I2C_GetFlagStatus>
			1c: R_ARM_THM_CALL	I2C_GetFlagStatus
  20:	4603      	mov	r3, r0
  22:	2b00      	cmp	r3, #0
  24:	d1f4      	bne.n	10 <eeprom_write_page+0x10>

    /* Send START condition */
    I2C_GenerateSTART(eeprom->i2c->i2c_eeprom, ENABLE);
  26:	68fb      	ldr	r3, [r7, #12]
  28:	681b      	ldr	r3, [r3, #0]
  2a:	681b      	ldr	r3, [r3, #0]
  2c:	4618      	mov	r0, r3
  2e:	f04f 0101 	mov.w	r1, #1
  32:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
			32: R_ARM_THM_CALL	I2C_GenerateSTART

    /* Test on EV5 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_MODE_SELECT));
  36:	bf00      	nop
  38:	68fb      	ldr	r3, [r7, #12]
  3a:	681b      	ldr	r3, [r3, #0]
  3c:	681b      	ldr	r3, [r3, #0]
  3e:	4618      	mov	r0, r3
  40:	493e      	ldr	r1, [pc, #248]	; (13c <eeprom_write_page+0x13c>)
  42:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			42: R_ARM_THM_CALL	I2C_CheckEvent
  46:	4603      	mov	r3, r0
  48:	2b00      	cmp	r3, #0
  4a:	d0f5      	beq.n	38 <eeprom_write_page+0x38>

    /* Send EEPROM address for write */
    I2C_Send7bitAddress(eeprom->i2c->i2c_eeprom, EEPROM_HW_ADDRESS, I2C_Direction_Transmitter);
  4c:	68fb      	ldr	r3, [r7, #12]
  4e:	681b      	ldr	r3, [r3, #0]
  50:	681b      	ldr	r3, [r3, #0]
  52:	4618      	mov	r0, r3
  54:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  58:	f04f 0200 	mov.w	r2, #0
  5c:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
			5c: R_ARM_THM_CALL	I2C_Send7bitAddress

    /* Test on EV6 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
  60:	bf00      	nop
  62:	68fb      	ldr	r3, [r7, #12]
  64:	681b      	ldr	r3, [r3, #0]
  66:	681b      	ldr	r3, [r3, #0]
  68:	4618      	mov	r0, r3
  6a:	4935      	ldr	r1, [pc, #212]	; (140 <eeprom_write_page+0x140>)
  6c:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			6c: R_ARM_THM_CALL	I2C_CheckEvent
  70:	4603      	mov	r3, r0
  72:	2b00      	cmp	r3, #0
  74:	d0f5      	beq.n	62 <eeprom_write_page+0x62>

    /* Send the EEPROM's internal address to write to : MSB of the address first */
    I2C_SendData(eeprom->i2c->i2c_eeprom, (uint8_t)((WriteAddr & 0xFF00) >> 8));
  76:	68fb      	ldr	r3, [r7, #12]
  78:	681b      	ldr	r3, [r3, #0]
  7a:	681a      	ldr	r2, [r3, #0]
  7c:	88fb      	ldrh	r3, [r7, #6]
  7e:	ea4f 2313 	mov.w	r3, r3, lsr #8
  82:	b29b      	uxth	r3, r3
  84:	b2db      	uxtb	r3, r3
  86:	4610      	mov	r0, r2
  88:	4619      	mov	r1, r3
  8a:	f7ff fffe 	bl	0 <I2C_SendData>
			8a: R_ARM_THM_CALL	I2C_SendData

    /* Test on EV8 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  8e:	bf00      	nop
  90:	68fb      	ldr	r3, [r7, #12]
  92:	681b      	ldr	r3, [r3, #0]
  94:	681b      	ldr	r3, [r3, #0]
  96:	4618      	mov	r0, r3
  98:	492a      	ldr	r1, [pc, #168]	; (144 <eeprom_write_page+0x144>)
  9a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			9a: R_ARM_THM_CALL	I2C_CheckEvent
  9e:	4603      	mov	r3, r0
  a0:	2b00      	cmp	r3, #0
  a2:	d0f5      	beq.n	90 <eeprom_write_page+0x90>

    /* Send the EEPROM's internal address to write to : LSB of the address */
    I2C_SendData(eeprom->i2c->i2c_eeprom, (uint8_t)(WriteAddr & 0x00FF));
  a4:	68fb      	ldr	r3, [r7, #12]
  a6:	681b      	ldr	r3, [r3, #0]
  a8:	681a      	ldr	r2, [r3, #0]
  aa:	88fb      	ldrh	r3, [r7, #6]
  ac:	b2db      	uxtb	r3, r3
  ae:	4610      	mov	r0, r2
  b0:	4619      	mov	r1, r3
  b2:	f7ff fffe 	bl	0 <I2C_SendData>
			b2: R_ARM_THM_CALL	I2C_SendData

    /* Test on EV8 and clear it */
    while(! I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  b6:	bf00      	nop
  b8:	68fb      	ldr	r3, [r7, #12]
  ba:	681b      	ldr	r3, [r3, #0]
  bc:	681b      	ldr	r3, [r3, #0]
  be:	4618      	mov	r0, r3
  c0:	4920      	ldr	r1, [pc, #128]	; (144 <eeprom_write_page+0x144>)
  c2:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			c2: R_ARM_THM_CALL	I2C_CheckEvent
  c6:	4603      	mov	r3, r0
  c8:	2b00      	cmp	r3, #0
  ca:	d0f5      	beq.n	b8 <eeprom_write_page+0xb8>

    /* While there is data to be written */
    while(NumByteToWrite--)
  cc:	e017      	b.n	fe <eeprom_write_page+0xfe>
    {
        /* Send the current byte */
        I2C_SendData(eeprom->i2c->i2c_eeprom, *pBuffer);
  ce:	68fb      	ldr	r3, [r7, #12]
  d0:	681b      	ldr	r3, [r3, #0]
  d2:	681a      	ldr	r2, [r3, #0]
  d4:	68bb      	ldr	r3, [r7, #8]
  d6:	781b      	ldrb	r3, [r3, #0]
  d8:	4610      	mov	r0, r2
  da:	4619      	mov	r1, r3
  dc:	f7ff fffe 	bl	0 <I2C_SendData>
			dc: R_ARM_THM_CALL	I2C_SendData

        /* Point to the next byte to be written */
        pBuffer++;
  e0:	68bb      	ldr	r3, [r7, #8]
  e2:	f103 0301 	add.w	r3, r3, #1
  e6:	60bb      	str	r3, [r7, #8]

        /* Test on EV8 and clear it */
        while (!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
  e8:	bf00      	nop
  ea:	68fb      	ldr	r3, [r7, #12]
  ec:	681b      	ldr	r3, [r3, #0]
  ee:	681b      	ldr	r3, [r3, #0]
  f0:	4618      	mov	r0, r3
  f2:	4914      	ldr	r1, [pc, #80]	; (144 <eeprom_write_page+0x144>)
  f4:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			f4: R_ARM_THM_CALL	I2C_CheckEvent
  f8:	4603      	mov	r3, r0
  fa:	2b00      	cmp	r3, #0
  fc:	d0f5      	beq.n	ea <eeprom_write_page+0xea>

    /* Test on EV8 and clear it */
    while(! I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));

    /* While there is data to be written */
    while(NumByteToWrite--)
  fe:	797b      	ldrb	r3, [r7, #5]
 100:	2b00      	cmp	r3, #0
 102:	bf0c      	ite	eq
 104:	2300      	moveq	r3, #0
 106:	2301      	movne	r3, #1
 108:	b2db      	uxtb	r3, r3
 10a:	797a      	ldrb	r2, [r7, #5]
 10c:	f102 32ff 	add.w	r2, r2, #4294967295
 110:	717a      	strb	r2, [r7, #5]
 112:	2b00      	cmp	r3, #0
 114:	d1db      	bne.n	ce <eeprom_write_page+0xce>
        /* Test on EV8 and clear it */
        while (!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
    }

    /* Send STOP condition */
    I2C_GenerateSTOP(eeprom->i2c->i2c_eeprom, ENABLE);
 116:	68fb      	ldr	r3, [r7, #12]
 118:	681b      	ldr	r3, [r3, #0]
 11a:	681b      	ldr	r3, [r3, #0]
 11c:	4618      	mov	r0, r3
 11e:	f04f 0101 	mov.w	r1, #1
 122:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
			122: R_ARM_THM_CALL	I2C_GenerateSTOP

    wait_eeprom_standby_state(eeprom);
 126:	68f8      	ldr	r0, [r7, #12]
 128:	f7ff fffe 	bl	2fc <wait_eeprom_standby_state>
			128: R_ARM_THM_CALL	wait_eeprom_standby_state

    return EEPROM_STATUS_SUCCESS;
 12c:	f04f 0300 	mov.w	r3, #0
}
 130:	4618      	mov	r0, r3
 132:	f107 0710 	add.w	r7, r7, #16
 136:	46bd      	mov	sp, r7
 138:	bd80      	pop	{r7, pc}
 13a:	bf00      	nop
 13c:	00030001 	.word	0x00030001
 140:	00070082 	.word	0x00070082
 144:	00070084 	.word	0x00070084

00000148 <eeprom_read_page>:


eeprom_status_t eeprom_read_page(eeprom_descr_t *eeprom, uint8_t* pBuffer, uint16_t ReadAddr, uint16_t NumByteToRead)
{
 148:	b580      	push	{r7, lr}
 14a:	b084      	sub	sp, #16
 14c:	af00      	add	r7, sp, #0
 14e:	60f8      	str	r0, [r7, #12]
 150:	60b9      	str	r1, [r7, #8]
 152:	80fa      	strh	r2, [r7, #6]
 154:	80bb      	strh	r3, [r7, #4]
    /* While the bus is busy */
    while(I2C_GetFlagStatus(eeprom->i2c->i2c_eeprom, I2C_FLAG_BUSY));
 156:	bf00      	nop
 158:	68fb      	ldr	r3, [r7, #12]
 15a:	681b      	ldr	r3, [r3, #0]
 15c:	681b      	ldr	r3, [r3, #0]
 15e:	4618      	mov	r0, r3
 160:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 164:	f7ff fffe 	bl	0 <I2C_GetFlagStatus>
			164: R_ARM_THM_CALL	I2C_GetFlagStatus
 168:	4603      	mov	r3, r0
 16a:	2b00      	cmp	r3, #0
 16c:	d1f4      	bne.n	158 <eeprom_read_page+0x10>

    /* Send START condition */
    I2C_GenerateSTART(eeprom->i2c->i2c_eeprom, ENABLE);
 16e:	68fb      	ldr	r3, [r7, #12]
 170:	681b      	ldr	r3, [r3, #0]
 172:	681b      	ldr	r3, [r3, #0]
 174:	4618      	mov	r0, r3
 176:	f04f 0101 	mov.w	r1, #1
 17a:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
			17a: R_ARM_THM_CALL	I2C_GenerateSTART

    /* Test on EV5 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_MODE_SELECT));
 17e:	bf00      	nop
 180:	68fb      	ldr	r3, [r7, #12]
 182:	681b      	ldr	r3, [r3, #0]
 184:	681b      	ldr	r3, [r3, #0]
 186:	4618      	mov	r0, r3
 188:	4957      	ldr	r1, [pc, #348]	; (2e8 <eeprom_read_page+0x1a0>)
 18a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			18a: R_ARM_THM_CALL	I2C_CheckEvent
 18e:	4603      	mov	r3, r0
 190:	2b00      	cmp	r3, #0
 192:	d0f5      	beq.n	180 <eeprom_read_page+0x38>

    /* Send EEPROM address for write */
    I2C_Send7bitAddress(eeprom->i2c->i2c_eeprom, EEPROM_HW_ADDRESS, I2C_Direction_Transmitter);
 194:	68fb      	ldr	r3, [r7, #12]
 196:	681b      	ldr	r3, [r3, #0]
 198:	681b      	ldr	r3, [r3, #0]
 19a:	4618      	mov	r0, r3
 19c:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 1a0:	f04f 0200 	mov.w	r2, #0
 1a4:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
			1a4: R_ARM_THM_CALL	I2C_Send7bitAddress

    /* Test on EV6 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
 1a8:	bf00      	nop
 1aa:	68fb      	ldr	r3, [r7, #12]
 1ac:	681b      	ldr	r3, [r3, #0]
 1ae:	681b      	ldr	r3, [r3, #0]
 1b0:	4618      	mov	r0, r3
 1b2:	494e      	ldr	r1, [pc, #312]	; (2ec <eeprom_read_page+0x1a4>)
 1b4:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			1b4: R_ARM_THM_CALL	I2C_CheckEvent
 1b8:	4603      	mov	r3, r0
 1ba:	2b00      	cmp	r3, #0
 1bc:	d0f5      	beq.n	1aa <eeprom_read_page+0x62>

    /* Send the EEPROM's internal address to read from: MSB of the address first */
    I2C_SendData(eeprom->i2c->i2c_eeprom, (uint8_t)((ReadAddr & 0xFF00) >> 8));
 1be:	68fb      	ldr	r3, [r7, #12]
 1c0:	681b      	ldr	r3, [r3, #0]
 1c2:	681a      	ldr	r2, [r3, #0]
 1c4:	88fb      	ldrh	r3, [r7, #6]
 1c6:	ea4f 2313 	mov.w	r3, r3, lsr #8
 1ca:	b29b      	uxth	r3, r3
 1cc:	b2db      	uxtb	r3, r3
 1ce:	4610      	mov	r0, r2
 1d0:	4619      	mov	r1, r3
 1d2:	f7ff fffe 	bl	0 <I2C_SendData>
			1d2: R_ARM_THM_CALL	I2C_SendData

    /* Test on EV8 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
 1d6:	bf00      	nop
 1d8:	68fb      	ldr	r3, [r7, #12]
 1da:	681b      	ldr	r3, [r3, #0]
 1dc:	681b      	ldr	r3, [r3, #0]
 1de:	4618      	mov	r0, r3
 1e0:	4943      	ldr	r1, [pc, #268]	; (2f0 <eeprom_read_page+0x1a8>)
 1e2:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			1e2: R_ARM_THM_CALL	I2C_CheckEvent
 1e6:	4603      	mov	r3, r0
 1e8:	2b00      	cmp	r3, #0
 1ea:	d0f5      	beq.n	1d8 <eeprom_read_page+0x90>

    /* Send the EEPROM's internal address to read from: LSB of the address */
    I2C_SendData(eeprom->i2c->i2c_eeprom, (uint8_t)(ReadAddr & 0x00FF));
 1ec:	68fb      	ldr	r3, [r7, #12]
 1ee:	681b      	ldr	r3, [r3, #0]
 1f0:	681a      	ldr	r2, [r3, #0]
 1f2:	88fb      	ldrh	r3, [r7, #6]
 1f4:	b2db      	uxtb	r3, r3
 1f6:	4610      	mov	r0, r2
 1f8:	4619      	mov	r1, r3
 1fa:	f7ff fffe 	bl	0 <I2C_SendData>
			1fa: R_ARM_THM_CALL	I2C_SendData

    /* Test on EV8 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
 1fe:	bf00      	nop
 200:	68fb      	ldr	r3, [r7, #12]
 202:	681b      	ldr	r3, [r3, #0]
 204:	681b      	ldr	r3, [r3, #0]
 206:	4618      	mov	r0, r3
 208:	4939      	ldr	r1, [pc, #228]	; (2f0 <eeprom_read_page+0x1a8>)
 20a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			20a: R_ARM_THM_CALL	I2C_CheckEvent
 20e:	4603      	mov	r3, r0
 210:	2b00      	cmp	r3, #0
 212:	d0f5      	beq.n	200 <eeprom_read_page+0xb8>

    /* Send START condition a second time */
    I2C_GenerateSTART(eeprom->i2c->i2c_eeprom, ENABLE);
 214:	68fb      	ldr	r3, [r7, #12]
 216:	681b      	ldr	r3, [r3, #0]
 218:	681b      	ldr	r3, [r3, #0]
 21a:	4618      	mov	r0, r3
 21c:	f04f 0101 	mov.w	r1, #1
 220:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
			220: R_ARM_THM_CALL	I2C_GenerateSTART

    /* Test on EV5 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_MODE_SELECT));
 224:	bf00      	nop
 226:	68fb      	ldr	r3, [r7, #12]
 228:	681b      	ldr	r3, [r3, #0]
 22a:	681b      	ldr	r3, [r3, #0]
 22c:	4618      	mov	r0, r3
 22e:	492e      	ldr	r1, [pc, #184]	; (2e8 <eeprom_read_page+0x1a0>)
 230:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			230: R_ARM_THM_CALL	I2C_CheckEvent
 234:	4603      	mov	r3, r0
 236:	2b00      	cmp	r3, #0
 238:	d0f5      	beq.n	226 <eeprom_read_page+0xde>

    /* Send EEPROM address for read */
    I2C_Send7bitAddress(eeprom->i2c->i2c_eeprom, EEPROM_HW_ADDRESS, I2C_Direction_Receiver);
 23a:	68fb      	ldr	r3, [r7, #12]
 23c:	681b      	ldr	r3, [r3, #0]
 23e:	681b      	ldr	r3, [r3, #0]
 240:	4618      	mov	r0, r3
 242:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 246:	f04f 0201 	mov.w	r2, #1
 24a:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
			24a: R_ARM_THM_CALL	I2C_Send7bitAddress

    /* Test on EV6 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
 24e:	bf00      	nop
 250:	68fb      	ldr	r3, [r7, #12]
 252:	681b      	ldr	r3, [r3, #0]
 254:	681b      	ldr	r3, [r3, #0]
 256:	4618      	mov	r0, r3
 258:	4926      	ldr	r1, [pc, #152]	; (2f4 <eeprom_read_page+0x1ac>)
 25a:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			25a: R_ARM_THM_CALL	I2C_CheckEvent
 25e:	4603      	mov	r3, r0
 260:	2b00      	cmp	r3, #0
 262:	d0f5      	beq.n	250 <eeprom_read_page+0x108>

    /* While there is data to be read */
    while(NumByteToRead)
 264:	e02e      	b.n	2c4 <eeprom_read_page+0x17c>
    {
        if(NumByteToRead == 1)
 266:	88bb      	ldrh	r3, [r7, #4]
 268:	2b01      	cmp	r3, #1
 26a:	d10f      	bne.n	28c <eeprom_read_page+0x144>
        {
            /* Disable Acknowledgement */
            I2C_AcknowledgeConfig(eeprom->i2c->i2c_eeprom, DISABLE);
 26c:	68fb      	ldr	r3, [r7, #12]
 26e:	681b      	ldr	r3, [r3, #0]
 270:	681b      	ldr	r3, [r3, #0]
 272:	4618      	mov	r0, r3
 274:	f04f 0100 	mov.w	r1, #0
 278:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
			278: R_ARM_THM_CALL	I2C_AcknowledgeConfig

            /* Send STOP Condition */
            I2C_GenerateSTOP(eeprom->i2c->i2c_eeprom, ENABLE);
 27c:	68fb      	ldr	r3, [r7, #12]
 27e:	681b      	ldr	r3, [r3, #0]
 280:	681b      	ldr	r3, [r3, #0]
 282:	4618      	mov	r0, r3
 284:	f04f 0101 	mov.w	r1, #1
 288:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
			288: R_ARM_THM_CALL	I2C_GenerateSTOP
        }

    /* Test on EV7 and clear it */
        if(I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_BYTE_RECEIVED))
 28c:	68fb      	ldr	r3, [r7, #12]
 28e:	681b      	ldr	r3, [r3, #0]
 290:	681b      	ldr	r3, [r3, #0]
 292:	4618      	mov	r0, r3
 294:	4918      	ldr	r1, [pc, #96]	; (2f8 <eeprom_read_page+0x1b0>)
 296:	f7ff fffe 	bl	0 <I2C_CheckEvent>
			296: R_ARM_THM_CALL	I2C_CheckEvent
 29a:	4603      	mov	r3, r0
 29c:	2b00      	cmp	r3, #0
 29e:	d011      	beq.n	2c4 <eeprom_read_page+0x17c>
        {
            /* Read a byte from the EEPROM */
            *pBuffer = I2C_ReceiveData(eeprom->i2c->i2c_eeprom);
 2a0:	68fb      	ldr	r3, [r7, #12]
 2a2:	681b      	ldr	r3, [r3, #0]
 2a4:	681b      	ldr	r3, [r3, #0]
 2a6:	4618      	mov	r0, r3
 2a8:	f7ff fffe 	bl	0 <I2C_ReceiveData>
			2a8: R_ARM_THM_CALL	I2C_ReceiveData
 2ac:	4603      	mov	r3, r0
 2ae:	461a      	mov	r2, r3
 2b0:	68bb      	ldr	r3, [r7, #8]
 2b2:	701a      	strb	r2, [r3, #0]

            /* Point to the next location where the byte read will be saved */
            pBuffer++;
 2b4:	68bb      	ldr	r3, [r7, #8]
 2b6:	f103 0301 	add.w	r3, r3, #1
 2ba:	60bb      	str	r3, [r7, #8]

            /* Decrement the read bytes counter */
            NumByteToRead--;
 2bc:	88bb      	ldrh	r3, [r7, #4]
 2be:	f103 33ff 	add.w	r3, r3, #4294967295
 2c2:	80bb      	strh	r3, [r7, #4]

    /* Test on EV6 and clear it */
    while(!I2C_CheckEvent(eeprom->i2c->i2c_eeprom, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));

    /* While there is data to be read */
    while(NumByteToRead)
 2c4:	88bb      	ldrh	r3, [r7, #4]
 2c6:	2b00      	cmp	r3, #0
 2c8:	d1cd      	bne.n	266 <eeprom_read_page+0x11e>
            NumByteToRead--;
        }
    }

    /* Enable Acknowledgement to be ready for another reception */
    I2C_AcknowledgeConfig(eeprom->i2c->i2c_eeprom, ENABLE);
 2ca:	68fb      	ldr	r3, [r7, #12]
 2cc:	681b      	ldr	r3, [r3, #0]
 2ce:	681b      	ldr	r3, [r3, #0]
 2d0:	4618      	mov	r0, r3
 2d2:	f04f 0101 	mov.w	r1, #1
 2d6:	f7ff fffe 	bl	0 <I2C_AcknowledgeConfig>
			2d6: R_ARM_THM_CALL	I2C_AcknowledgeConfig

    return EEPROM_STATUS_SUCCESS;
 2da:	f04f 0300 	mov.w	r3, #0
}
 2de:	4618      	mov	r0, r3
 2e0:	f107 0710 	add.w	r7, r7, #16
 2e4:	46bd      	mov	sp, r7
 2e6:	bd80      	pop	{r7, pc}
 2e8:	00030001 	.word	0x00030001
 2ec:	00070082 	.word	0x00070082
 2f0:	00070084 	.word	0x00070084
 2f4:	00030002 	.word	0x00030002
 2f8:	00030040 	.word	0x00030040

000002fc <wait_eeprom_standby_state>:

void wait_eeprom_standby_state(eeprom_descr_t *eeprom)
{
 2fc:	b580      	push	{r7, lr}
 2fe:	b084      	sub	sp, #16
 300:	af00      	add	r7, sp, #0
 302:	6078      	str	r0, [r7, #4]
    __IO uint16_t SR1_Tmp = 0;
 304:	f04f 0300 	mov.w	r3, #0
 308:	81fb      	strh	r3, [r7, #14]

    do
    {
        /* Send START condition */
        I2C_GenerateSTART(eeprom->i2c->i2c_eeprom, ENABLE);
 30a:	687b      	ldr	r3, [r7, #4]
 30c:	681b      	ldr	r3, [r3, #0]
 30e:	681b      	ldr	r3, [r3, #0]
 310:	4618      	mov	r0, r3
 312:	f04f 0101 	mov.w	r1, #1
 316:	f7ff fffe 	bl	0 <I2C_GenerateSTART>
			316: R_ARM_THM_CALL	I2C_GenerateSTART

        /* Read I2C_EE SR1 register to clear pending flags */
        SR1_Tmp = I2C_ReadRegister(eeprom->i2c->i2c_eeprom, I2C_Register_SR1);
 31a:	687b      	ldr	r3, [r7, #4]
 31c:	681b      	ldr	r3, [r3, #0]
 31e:	681b      	ldr	r3, [r3, #0]
 320:	4618      	mov	r0, r3
 322:	f04f 0114 	mov.w	r1, #20
 326:	f7ff fffe 	bl	0 <I2C_ReadRegister>
			326: R_ARM_THM_CALL	I2C_ReadRegister
 32a:	4603      	mov	r3, r0
 32c:	81fb      	strh	r3, [r7, #14]

        /* Send EEPROM address for write */
        I2C_Send7bitAddress(eeprom->i2c->i2c_eeprom, EEPROM_HW_ADDRESS, I2C_Direction_Transmitter);
 32e:	687b      	ldr	r3, [r7, #4]
 330:	681b      	ldr	r3, [r3, #0]
 332:	681b      	ldr	r3, [r3, #0]
 334:	4618      	mov	r0, r3
 336:	f04f 01a0 	mov.w	r1, #160	; 0xa0
 33a:	f04f 0200 	mov.w	r2, #0
 33e:	f7ff fffe 	bl	0 <I2C_Send7bitAddress>
			33e: R_ARM_THM_CALL	I2C_Send7bitAddress
    }while(!(I2C_ReadRegister(eeprom->i2c->i2c_eeprom, I2C_Register_SR1) & 0x0002));
 342:	687b      	ldr	r3, [r7, #4]
 344:	681b      	ldr	r3, [r3, #0]
 346:	681b      	ldr	r3, [r3, #0]
 348:	4618      	mov	r0, r3
 34a:	f04f 0114 	mov.w	r1, #20
 34e:	f7ff fffe 	bl	0 <I2C_ReadRegister>
			34e: R_ARM_THM_CALL	I2C_ReadRegister
 352:	4603      	mov	r3, r0
 354:	f003 0302 	and.w	r3, r3, #2
 358:	2b00      	cmp	r3, #0
 35a:	d0d6      	beq.n	30a <wait_eeprom_standby_state+0xe>

    /* Clear AF flag */
    I2C_ClearFlag(eeprom->i2c->i2c_eeprom, I2C_FLAG_AF);
 35c:	687b      	ldr	r3, [r7, #4]
 35e:	681b      	ldr	r3, [r3, #0]
 360:	681b      	ldr	r3, [r3, #0]
 362:	4618      	mov	r0, r3
 364:	4907      	ldr	r1, [pc, #28]	; (384 <wait_eeprom_standby_state+0x88>)
 366:	f7ff fffe 	bl	0 <I2C_ClearFlag>
			366: R_ARM_THM_CALL	I2C_ClearFlag

    /* STOP condition */
    I2C_GenerateSTOP(eeprom->i2c->i2c_eeprom, ENABLE);
 36a:	687b      	ldr	r3, [r7, #4]
 36c:	681b      	ldr	r3, [r3, #0]
 36e:	681b      	ldr	r3, [r3, #0]
 370:	4618      	mov	r0, r3
 372:	f04f 0101 	mov.w	r1, #1
 376:	f7ff fffe 	bl	0 <I2C_GenerateSTOP>
			376: R_ARM_THM_CALL	I2C_GenerateSTOP
}
 37a:	f107 0710 	add.w	r7, r7, #16
 37e:	46bd      	mov	sp, r7
 380:	bd80      	pop	{r7, pc}
 382:	bf00      	nop
 384:	10000400 	.word	0x10000400

00000388 <eeprom_crc8>:


uint8_t eeprom_crc8 (uint8_t *buf, uint8_t n)
{
 388:	b480      	push	{r7}
 38a:	b085      	sub	sp, #20
 38c:	af00      	add	r7, sp, #0
 38e:	6078      	str	r0, [r7, #4]
 390:	460b      	mov	r3, r1
 392:	70fb      	strb	r3, [r7, #3]
	uint8_t crc = 0;
 394:	f04f 0300 	mov.w	r3, #0
 398:	73fb      	strb	r3, [r7, #15]
    while (n--) {
 39a:	e02a      	b.n	3f2 <eeprom_crc8+0x6a>
		uint8_t i=8;
 39c:	f04f 0308 	mov.w	r3, #8
 3a0:	73bb      	strb	r3, [r7, #14]
        crc ^= *buf++;
 3a2:	687b      	ldr	r3, [r7, #4]
 3a4:	781a      	ldrb	r2, [r3, #0]
 3a6:	7bfb      	ldrb	r3, [r7, #15]
 3a8:	ea82 0303 	eor.w	r3, r2, r3
 3ac:	73fb      	strb	r3, [r7, #15]
 3ae:	687b      	ldr	r3, [r7, #4]
 3b0:	f103 0301 	add.w	r3, r3, #1
 3b4:	607b      	str	r3, [r7, #4]

		while(i--) {
 3b6:	e010      	b.n	3da <eeprom_crc8+0x52>
			if (crc & 0x80) {
 3b8:	7bfb      	ldrb	r3, [r7, #15]
 3ba:	b25b      	sxtb	r3, r3
 3bc:	2b00      	cmp	r3, #0
 3be:	da08      	bge.n	3d2 <eeprom_crc8+0x4a>
				crc <<= 1;
 3c0:	7bfb      	ldrb	r3, [r7, #15]
 3c2:	ea4f 0343 	mov.w	r3, r3, lsl #1
 3c6:	73fb      	strb	r3, [r7, #15]
				crc ^= 0x07;
 3c8:	7bfb      	ldrb	r3, [r7, #15]
 3ca:	f083 0307 	eor.w	r3, r3, #7
 3ce:	73fb      	strb	r3, [r7, #15]
 3d0:	e003      	b.n	3da <eeprom_crc8+0x52>
			} else {
				crc <<= 1;
 3d2:	7bfb      	ldrb	r3, [r7, #15]
 3d4:	ea4f 0343 	mov.w	r3, r3, lsl #1
 3d8:	73fb      	strb	r3, [r7, #15]
	uint8_t crc = 0;
    while (n--) {
		uint8_t i=8;
        crc ^= *buf++;

		while(i--) {
 3da:	7bbb      	ldrb	r3, [r7, #14]
 3dc:	2b00      	cmp	r3, #0
 3de:	bf0c      	ite	eq
 3e0:	2300      	moveq	r3, #0
 3e2:	2301      	movne	r3, #1
 3e4:	b2db      	uxtb	r3, r3
 3e6:	7bba      	ldrb	r2, [r7, #14]
 3e8:	f102 32ff 	add.w	r2, r2, #4294967295
 3ec:	73ba      	strb	r2, [r7, #14]
 3ee:	2b00      	cmp	r3, #0
 3f0:	d1e2      	bne.n	3b8 <eeprom_crc8+0x30>


uint8_t eeprom_crc8 (uint8_t *buf, uint8_t n)
{
	uint8_t crc = 0;
    while (n--) {
 3f2:	78fb      	ldrb	r3, [r7, #3]
 3f4:	2b00      	cmp	r3, #0
 3f6:	bf0c      	ite	eq
 3f8:	2300      	moveq	r3, #0
 3fa:	2301      	movne	r3, #1
 3fc:	b2db      	uxtb	r3, r3
 3fe:	78fa      	ldrb	r2, [r7, #3]
 400:	f102 32ff 	add.w	r2, r2, #4294967295
 404:	70fa      	strb	r2, [r7, #3]
 406:	2b00      	cmp	r3, #0
 408:	d1c8      	bne.n	39c <eeprom_crc8+0x14>
				crc <<= 1;
			}
		}
    }

    return crc;
 40a:	7bfb      	ldrb	r3, [r7, #15]
}
 40c:	4618      	mov	r0, r3
 40e:	f107 0714 	add.w	r7, r7, #20
 412:	46bd      	mov	sp, r7
 414:	bc80      	pop	{r7}
 416:	4770      	bx	lr

00000418 <calibration_structure_padding>:

void calibration_structure_padding(calibration_channel_t calibration_array[], char *padded_string)
{
 418:	b580      	push	{r7, lr}
 41a:	b082      	sub	sp, #8
 41c:	af00      	add	r7, sp, #0
 41e:	6078      	str	r0, [r7, #4]
 420:	6039      	str	r1, [r7, #0]
	// Fill the  padding string with zeros.
	memset(padded_string, 0, EEPROM_PAGESIZE);
 422:	6838      	ldr	r0, [r7, #0]
 424:	f04f 0100 	mov.w	r1, #0
 428:	f04f 0240 	mov.w	r2, #64	; 0x40
 42c:	f7ff fffe 	bl	0 <memset>
			42c: R_ARM_THM_CALL	memset

	// Copy the 10 calibration values for gain and offset of the channel.
	memcpy(padded_string, calibration_array, (sizeof(calibration_channel_t)*EEPROM_NUMBER_OF_CAL_UNITS_PER_CHANNEL));
 430:	6838      	ldr	r0, [r7, #0]
 432:	6879      	ldr	r1, [r7, #4]
 434:	f04f 0228 	mov.w	r2, #40	; 0x28
 438:	f7ff fffe 	bl	0 <memcpy>
			438: R_ARM_THM_CALL	memcpy
}
 43c:	f107 0708 	add.w	r7, r7, #8
 440:	46bd      	mov	sp, r7
 442:	bd80      	pop	{r7, pc}

00000444 <eeprom_write_calibration_page_values>:

eeprom_status_t eeprom_write_calibration_page_values(calibration_channel_values_t *calibration_channel_values, eeprom_descr_t *eeprom, uint16_t address)
{
 444:	b580      	push	{r7, lr}
 446:	b084      	sub	sp, #16
 448:	af00      	add	r7, sp, #0
 44a:	60f8      	str	r0, [r7, #12]
 44c:	60b9      	str	r1, [r7, #8]
 44e:	4613      	mov	r3, r2
 450:	80fb      	strh	r3, [r7, #6]
	// Pad calibration structure to 64 bytes
	eeprom_calibration_page_values_padding(calibration_channel_values, buffer);
 452:	68f8      	ldr	r0, [r7, #12]
 454:	4910      	ldr	r1, [pc, #64]	; (498 <eeprom_write_calibration_page_values+0x54>)
 456:	f7ff fffe 	bl	4ec <eeprom_calibration_page_values_padding>
			456: R_ARM_THM_CALL	eeprom_calibration_page_values_padding

	// Last byte = CRC8
	buffer[EEPROM_PAGESIZE-1] = eeprom_crc8 (buffer, (EEPROM_PAGESIZE-1));
 45a:	480f      	ldr	r0, [pc, #60]	; (498 <eeprom_write_calibration_page_values+0x54>)
 45c:	f04f 013f 	mov.w	r1, #63	; 0x3f
 460:	f7ff fffe 	bl	388 <eeprom_crc8>
			460: R_ARM_THM_CALL	eeprom_crc8
 464:	4603      	mov	r3, r0
 466:	461a      	mov	r2, r3
 468:	4b0b      	ldr	r3, [pc, #44]	; (498 <eeprom_write_calibration_page_values+0x54>)
 46a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

	// Write page
	if (EEPROM_STATUS_SUCCESS != eeprom_write_page(eeprom, buffer, address, EEPROM_PAGESIZE)){return EEPROM_ERROR;}
 46e:	88fb      	ldrh	r3, [r7, #6]
 470:	68b8      	ldr	r0, [r7, #8]
 472:	4909      	ldr	r1, [pc, #36]	; (498 <eeprom_write_calibration_page_values+0x54>)
 474:	461a      	mov	r2, r3
 476:	f04f 0340 	mov.w	r3, #64	; 0x40
 47a:	f7ff fffe 	bl	0 <eeprom_write_page>
			47a: R_ARM_THM_CALL	eeprom_write_page
 47e:	4603      	mov	r3, r0
 480:	2b00      	cmp	r3, #0
 482:	d002      	beq.n	48a <eeprom_write_calibration_page_values+0x46>
 484:	f04f 0301 	mov.w	r3, #1
 488:	e001      	b.n	48e <eeprom_write_calibration_page_values+0x4a>

	return EEPROM_STATUS_SUCCESS;
 48a:	f04f 0300 	mov.w	r3, #0
}
 48e:	4618      	mov	r0, r3
 490:	f107 0710 	add.w	r7, r7, #16
 494:	46bd      	mov	sp, r7
 496:	bd80      	pop	{r7, pc}
 498:	00000000 	.word	0x00000000
			498: R_ARM_ABS32	buffer

0000049c <eeprom_read_calibration_page_values>:

eeprom_status_t eeprom_read_calibration_page_values(calibration_channel_values_t *calibration_channel_values, eeprom_descr_t *eeprom, uint16_t address)
{
 49c:	b580      	push	{r7, lr}
 49e:	b086      	sub	sp, #24
 4a0:	af00      	add	r7, sp, #0
 4a2:	60f8      	str	r0, [r7, #12]
 4a4:	60b9      	str	r1, [r7, #8]
 4a6:	4613      	mov	r3, r2
 4a8:	80fb      	strh	r3, [r7, #6]
	uint8_t crc_check;
	int size;

	// Read page
	if (EEPROM_STATUS_SUCCESS != eeprom_read_page(eeprom, buffer, address, EEPROM_PAGESIZE)){return EEPROM_ERROR;}
 4aa:	88fb      	ldrh	r3, [r7, #6]
 4ac:	68b8      	ldr	r0, [r7, #8]
 4ae:	490e      	ldr	r1, [pc, #56]	; (4e8 <eeprom_read_calibration_page_values+0x4c>)
 4b0:	461a      	mov	r2, r3
 4b2:	f04f 0340 	mov.w	r3, #64	; 0x40
 4b6:	f7ff fffe 	bl	148 <eeprom_read_page>
			4b6: R_ARM_THM_CALL	eeprom_read_page
 4ba:	4603      	mov	r3, r0
 4bc:	2b00      	cmp	r3, #0
 4be:	d002      	beq.n	4c6 <eeprom_read_calibration_page_values+0x2a>
 4c0:	f04f 0301 	mov.w	r3, #1
 4c4:	e00a      	b.n	4dc <eeprom_read_calibration_page_values+0x40>

	// Copy the calibration data into the channel array.
	size= (sizeof(calibration_channel_t)*EEPROM_NUMBER_OF_CAL_UNITS_PER_CHANNEL) + sizeof (voltage_limit_t) + sizeof(current_limit_t)+ sizeof(amplitude_step_size_t) + sizeof(time_step_size_t);
 4c6:	f04f 0336 	mov.w	r3, #54	; 0x36
 4ca:	617b      	str	r3, [r7, #20]
	memcpy(calibration_channel_values, buffer, ((sizeof(calibration_channel_t)*EEPROM_NUMBER_OF_CAL_UNITS_PER_CHANNEL) + sizeof (voltage_limit_t) + sizeof(current_limit_t)+ sizeof(amplitude_step_size_t) + sizeof(time_step_size_t)));
 4cc:	68f8      	ldr	r0, [r7, #12]
 4ce:	4906      	ldr	r1, [pc, #24]	; (4e8 <eeprom_read_calibration_page_values+0x4c>)
 4d0:	f04f 0236 	mov.w	r2, #54	; 0x36
 4d4:	f7ff fffe 	bl	0 <memcpy>
			4d4: R_ARM_THM_CALL	memcpy
	return EEPROM_STATUS_SUCCESS;
 4d8:	f04f 0300 	mov.w	r3, #0
}
 4dc:	4618      	mov	r0, r3
 4de:	f107 0718 	add.w	r7, r7, #24
 4e2:	46bd      	mov	sp, r7
 4e4:	bd80      	pop	{r7, pc}
 4e6:	bf00      	nop
 4e8:	00000000 	.word	0x00000000
			4e8: R_ARM_ABS32	buffer

000004ec <eeprom_calibration_page_values_padding>:

void eeprom_calibration_page_values_padding(calibration_channel_values_t *calibration_channel_values, char *padded_string)
{
 4ec:	b580      	push	{r7, lr}
 4ee:	b082      	sub	sp, #8
 4f0:	af00      	add	r7, sp, #0
 4f2:	6078      	str	r0, [r7, #4]
 4f4:	6039      	str	r1, [r7, #0]
	// Fill the  padding string with zeros.
	memset(padded_string, 0, EEPROM_PAGESIZE);
 4f6:	6838      	ldr	r0, [r7, #0]
 4f8:	f04f 0100 	mov.w	r1, #0
 4fc:	f04f 0240 	mov.w	r2, #64	; 0x40
 500:	f7ff fffe 	bl	0 <memset>
			500: R_ARM_THM_CALL	memset

	// Copy the 10 calibratuion values for gain and offset of the channel.
	memcpy(padded_string, calibration_channel_values, ((sizeof(calibration_channel_values_t)*EEPROM_NUMBER_OF_CAL_UNITS_PER_CHANNEL) + sizeof (voltage_limit_t) + sizeof(current_limit_t)+ sizeof(amplitude_step_size_t) + sizeof(time_step_size_t)));
 504:	6838      	ldr	r0, [r7, #0]
 506:	6879      	ldr	r1, [r7, #4]
 508:	f44f 7289 	mov.w	r2, #274	; 0x112
 50c:	f7ff fffe 	bl	0 <memcpy>
			50c: R_ARM_THM_CALL	memcpy
}
 510:	f107 0708 	add.w	r7, r7, #8
 514:	46bd      	mov	sp, r7
 516:	bd80      	pop	{r7, pc}

00000518 <eeprom_read_mac_address>:

eeprom_status_t eeprom_read_mac_address(uint8_t macAddress[6], eeprom_descr_t *eeprom)
{
 518:	b580      	push	{r7, lr}
 51a:	b084      	sub	sp, #16
 51c:	af00      	add	r7, sp, #0
 51e:	6078      	str	r0, [r7, #4]
 520:	6039      	str	r1, [r7, #0]
	// The firmware version number is placed on the first page of the eeprom.
	uint16_t address = 0;
 522:	f04f 0300 	mov.w	r3, #0
 526:	81fb      	strh	r3, [r7, #14]

	// Read page
	if (EEPROM_STATUS_SUCCESS != eeprom_read_page(eeprom, buffer, address, EEPROM_PAGESIZE)){return EEPROM_ERROR;}
 528:	89fb      	ldrh	r3, [r7, #14]
 52a:	6838      	ldr	r0, [r7, #0]
 52c:	490c      	ldr	r1, [pc, #48]	; (560 <eeprom_read_mac_address+0x48>)
 52e:	461a      	mov	r2, r3
 530:	f04f 0340 	mov.w	r3, #64	; 0x40
 534:	f7ff fffe 	bl	148 <eeprom_read_page>
			534: R_ARM_THM_CALL	eeprom_read_page
 538:	4603      	mov	r3, r0
 53a:	2b00      	cmp	r3, #0
 53c:	d002      	beq.n	544 <eeprom_read_mac_address+0x2c>
 53e:	f04f 0301 	mov.w	r3, #1
 542:	e008      	b.n	556 <eeprom_read_mac_address+0x3e>

	// Copy the mac address from eeprom in the macAddress variable.
	memcpy(macAddress, &buffer[1], (sizeof(uint8_t)*6));
 544:	4b07      	ldr	r3, [pc, #28]	; (564 <eeprom_read_mac_address+0x4c>)
 546:	6878      	ldr	r0, [r7, #4]
 548:	4619      	mov	r1, r3
 54a:	f04f 0206 	mov.w	r2, #6
 54e:	f7ff fffe 	bl	0 <memcpy>
			54e: R_ARM_THM_CALL	memcpy
	return EEPROM_STATUS_SUCCESS;
 552:	f04f 0300 	mov.w	r3, #0
}
 556:	4618      	mov	r0, r3
 558:	f107 0710 	add.w	r7, r7, #16
 55c:	46bd      	mov	sp, r7
 55e:	bd80      	pop	{r7, pc}
 560:	00000000 	.word	0x00000000
			560: R_ARM_ABS32	buffer
 564:	00000001 	.word	0x00000001
			564: R_ARM_ABS32	buffer

00000568 <eeprom_mac_address_padding>:


void eeprom_mac_address_padding(uint8_t macAddress[6], char *padded_string)
{
 568:	b580      	push	{r7, lr}
 56a:	b082      	sub	sp, #8
 56c:	af00      	add	r7, sp, #0
 56e:	6078      	str	r0, [r7, #4]
 570:	6039      	str	r1, [r7, #0]
	// Fill the  padding string with zeros.
	memset(padded_string, 0, EEPROM_PAGESIZE);
 572:	6838      	ldr	r0, [r7, #0]
 574:	f04f 0100 	mov.w	r1, #0
 578:	f04f 0240 	mov.w	r2, #64	; 0x40
 57c:	f7ff fffe 	bl	0 <memset>
			57c: R_ARM_THM_CALL	memset

	// Copy the mac Address on byte 2-8 of the  eeprom.
	memcpy(&padded_string[1], macAddress, (sizeof(uint8_t)*6));
 580:	683b      	ldr	r3, [r7, #0]
 582:	f103 0301 	add.w	r3, r3, #1
 586:	4618      	mov	r0, r3
 588:	6879      	ldr	r1, [r7, #4]
 58a:	f04f 0206 	mov.w	r2, #6
 58e:	f7ff fffe 	bl	0 <memcpy>
			58e: R_ARM_THM_CALL	memcpy
}
 592:	f107 0708 	add.w	r7, r7, #8
 596:	46bd      	mov	sp, r7
 598:	bd80      	pop	{r7, pc}
 59a:	bf00      	nop

0000059c <eeprom_write_mac_address>:

eeprom_status_t eeprom_write_mac_address(uint8_t macAddress[6], eeprom_descr_t *eeprom)
{
 59c:	b580      	push	{r7, lr}
 59e:	b084      	sub	sp, #16
 5a0:	af00      	add	r7, sp, #0
 5a2:	6078      	str	r0, [r7, #4]
 5a4:	6039      	str	r1, [r7, #0]
	uint8_t crc_check;
	// The mac Address is placed on the first page of the eeprom starting from the second byte. The first byte is the firmware version.
	uint16_t address = 0;
 5a6:	f04f 0300 	mov.w	r3, #0
 5aa:	81fb      	strh	r3, [r7, #14]

	// Pad calibration structure to 64 bytes
	eeprom_mac_address_padding(macAddress, buffer);
 5ac:	6878      	ldr	r0, [r7, #4]
 5ae:	4911      	ldr	r1, [pc, #68]	; (5f4 <eeprom_write_mac_address+0x58>)
 5b0:	f7ff fffe 	bl	568 <eeprom_mac_address_padding>
			5b0: R_ARM_THM_CALL	eeprom_mac_address_padding

	// Last byte = CRC8
	buffer[EEPROM_PAGESIZE-1] = eeprom_crc8 (buffer, (EEPROM_PAGESIZE-1));
 5b4:	480f      	ldr	r0, [pc, #60]	; (5f4 <eeprom_write_mac_address+0x58>)
 5b6:	f04f 013f 	mov.w	r1, #63	; 0x3f
 5ba:	f7ff fffe 	bl	388 <eeprom_crc8>
			5ba: R_ARM_THM_CALL	eeprom_crc8
 5be:	4603      	mov	r3, r0
 5c0:	461a      	mov	r2, r3
 5c2:	4b0c      	ldr	r3, [pc, #48]	; (5f4 <eeprom_write_mac_address+0x58>)
 5c4:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

	// Write page
	if (EEPROM_STATUS_SUCCESS != eeprom_write_page(eeprom, buffer, address, EEPROM_PAGESIZE)){return EEPROM_ERROR;}
 5c8:	89fb      	ldrh	r3, [r7, #14]
 5ca:	6838      	ldr	r0, [r7, #0]
 5cc:	4909      	ldr	r1, [pc, #36]	; (5f4 <eeprom_write_mac_address+0x58>)
 5ce:	461a      	mov	r2, r3
 5d0:	f04f 0340 	mov.w	r3, #64	; 0x40
 5d4:	f7ff fffe 	bl	0 <eeprom_write_page>
			5d4: R_ARM_THM_CALL	eeprom_write_page
 5d8:	4603      	mov	r3, r0
 5da:	2b00      	cmp	r3, #0
 5dc:	d002      	beq.n	5e4 <eeprom_write_mac_address+0x48>
 5de:	f04f 0301 	mov.w	r3, #1
 5e2:	e001      	b.n	5e8 <eeprom_write_mac_address+0x4c>

	return EEPROM_STATUS_SUCCESS;
 5e4:	f04f 0300 	mov.w	r3, #0

}
 5e8:	4618      	mov	r0, r3
 5ea:	f107 0710 	add.w	r7, r7, #16
 5ee:	46bd      	mov	sp, r7
 5f0:	bd80      	pop	{r7, pc}
 5f2:	bf00      	nop
 5f4:	00000000 	.word	0x00000000
			5f4: R_ARM_ABS32	buffer

000005f8 <eeprom_read_firmware_version>:

eeprom_status_t eeprom_read_firmware_version(uint8_t *firmware_version, eeprom_descr_t *eeprom)
{
 5f8:	b580      	push	{r7, lr}
 5fa:	b084      	sub	sp, #16
 5fc:	af00      	add	r7, sp, #0
 5fe:	6078      	str	r0, [r7, #4]
 600:	6039      	str	r1, [r7, #0]
	uint8_t crc_check;
	// The firmware version number is placed on the first page of the eeprom.
	uint16_t address = 0;
 602:	f04f 0300 	mov.w	r3, #0
 606:	81fb      	strh	r3, [r7, #14]

	// Read page
	if (EEPROM_STATUS_SUCCESS != eeprom_read_page(eeprom, buffer, address, EEPROM_PAGESIZE)){return EEPROM_ERROR;}
 608:	89fb      	ldrh	r3, [r7, #14]
 60a:	6838      	ldr	r0, [r7, #0]
 60c:	490e      	ldr	r1, [pc, #56]	; (648 <eeprom_read_firmware_version+0x50>)
 60e:	461a      	mov	r2, r3
 610:	f04f 0340 	mov.w	r3, #64	; 0x40
 614:	f7ff fffe 	bl	148 <eeprom_read_page>
			614: R_ARM_THM_CALL	eeprom_read_page
 618:	4603      	mov	r3, r0
 61a:	2b00      	cmp	r3, #0
 61c:	d002      	beq.n	624 <eeprom_read_firmware_version+0x2c>
 61e:	f04f 0301 	mov.w	r3, #1
 622:	e00b      	b.n	63c <eeprom_read_firmware_version+0x44>

	// Copy the calibration data into the channel array.
	memcpy(firmware_version, buffer, sizeof(uint8_t));
 624:	6878      	ldr	r0, [r7, #4]
 626:	4908      	ldr	r1, [pc, #32]	; (648 <eeprom_read_firmware_version+0x50>)
 628:	f04f 0201 	mov.w	r2, #1
 62c:	f7ff fffe 	bl	0 <memcpy>
			62c: R_ARM_THM_CALL	memcpy
	(*firmware_version) = (uint8_t) buffer[0];
 630:	4b05      	ldr	r3, [pc, #20]	; (648 <eeprom_read_firmware_version+0x50>)
 632:	781a      	ldrb	r2, [r3, #0]
 634:	687b      	ldr	r3, [r7, #4]
 636:	701a      	strb	r2, [r3, #0]

	return EEPROM_STATUS_SUCCESS;
 638:	f04f 0300 	mov.w	r3, #0
}
 63c:	4618      	mov	r0, r3
 63e:	f107 0710 	add.w	r7, r7, #16
 642:	46bd      	mov	sp, r7
 644:	bd80      	pop	{r7, pc}
 646:	bf00      	nop
 648:	00000000 	.word	0x00000000
			648: R_ARM_ABS32	buffer

0000064c <eeprom_firmware_version_padding>:

void eeprom_firmware_version_padding(uint8_t firmware_version, char *padded_string)
{
 64c:	b580      	push	{r7, lr}
 64e:	b082      	sub	sp, #8
 650:	af00      	add	r7, sp, #0
 652:	4603      	mov	r3, r0
 654:	6039      	str	r1, [r7, #0]
 656:	71fb      	strb	r3, [r7, #7]
	// Fill the  padding string with zeros.
	memset(padded_string, 0, EEPROM_PAGESIZE);
 658:	6838      	ldr	r0, [r7, #0]
 65a:	f04f 0100 	mov.w	r1, #0
 65e:	f04f 0240 	mov.w	r2, #64	; 0x40
 662:	f7ff fffe 	bl	0 <memset>
			662: R_ARM_THM_CALL	memset

	// Copy the 10 calibration values for gain and offset of the channel.
	memcpy(padded_string, &firmware_version, sizeof(uint8_t));
 666:	f107 0307 	add.w	r3, r7, #7
 66a:	6838      	ldr	r0, [r7, #0]
 66c:	4619      	mov	r1, r3
 66e:	f04f 0201 	mov.w	r2, #1
 672:	f7ff fffe 	bl	0 <memcpy>
			672: R_ARM_THM_CALL	memcpy
}
 676:	f107 0708 	add.w	r7, r7, #8
 67a:	46bd      	mov	sp, r7
 67c:	bd80      	pop	{r7, pc}
 67e:	bf00      	nop

00000680 <eeprom_write_firmware_version>:

eeprom_status_t eeprom_write_firmware_version(uint8_t firmware_version, eeprom_descr_t *eeprom)
{
 680:	b580      	push	{r7, lr}
 682:	b084      	sub	sp, #16
 684:	af00      	add	r7, sp, #0
 686:	4603      	mov	r3, r0
 688:	6039      	str	r1, [r7, #0]
 68a:	71fb      	strb	r3, [r7, #7]
	uint8_t crc_check;
	// The firmware version number is placed on the first page of the eeprom.
	uint16_t address = 0;
 68c:	f04f 0300 	mov.w	r3, #0
 690:	81fb      	strh	r3, [r7, #14]

	// Pad calibration structure to 64 bytes
	eeprom_firmware_version_padding(firmware_version, buffer);
 692:	79fb      	ldrb	r3, [r7, #7]
 694:	4618      	mov	r0, r3
 696:	4911      	ldr	r1, [pc, #68]	; (6dc <eeprom_write_firmware_version+0x5c>)
 698:	f7ff fffe 	bl	64c <eeprom_firmware_version_padding>
			698: R_ARM_THM_CALL	eeprom_firmware_version_padding

	// Last byte = CRC8
	buffer[EEPROM_PAGESIZE-1] = eeprom_crc8 (buffer, (EEPROM_PAGESIZE-1));
 69c:	480f      	ldr	r0, [pc, #60]	; (6dc <eeprom_write_firmware_version+0x5c>)
 69e:	f04f 013f 	mov.w	r1, #63	; 0x3f
 6a2:	f7ff fffe 	bl	388 <eeprom_crc8>
			6a2: R_ARM_THM_CALL	eeprom_crc8
 6a6:	4603      	mov	r3, r0
 6a8:	461a      	mov	r2, r3
 6aa:	4b0c      	ldr	r3, [pc, #48]	; (6dc <eeprom_write_firmware_version+0x5c>)
 6ac:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

	// Write page
	if (EEPROM_STATUS_SUCCESS !=  eeprom_write_page(eeprom, buffer, address, EEPROM_PAGESIZE)){return EEPROM_ERROR;}
 6b0:	89fb      	ldrh	r3, [r7, #14]
 6b2:	6838      	ldr	r0, [r7, #0]
 6b4:	4909      	ldr	r1, [pc, #36]	; (6dc <eeprom_write_firmware_version+0x5c>)
 6b6:	461a      	mov	r2, r3
 6b8:	f04f 0340 	mov.w	r3, #64	; 0x40
 6bc:	f7ff fffe 	bl	0 <eeprom_write_page>
			6bc: R_ARM_THM_CALL	eeprom_write_page
 6c0:	4603      	mov	r3, r0
 6c2:	2b00      	cmp	r3, #0
 6c4:	d002      	beq.n	6cc <eeprom_write_firmware_version+0x4c>
 6c6:	f04f 0301 	mov.w	r3, #1
 6ca:	e001      	b.n	6d0 <eeprom_write_firmware_version+0x50>

	return EEPROM_STATUS_SUCCESS;
 6cc:	f04f 0300 	mov.w	r3, #0

}
 6d0:	4618      	mov	r0, r3
 6d2:	f107 0710 	add.w	r7, r7, #16
 6d6:	46bd      	mov	sp, r7
 6d8:	bd80      	pop	{r7, pc}
 6da:	bf00      	nop
 6dc:	00000000 	.word	0x00000000
			6dc: R_ARM_ABS32	buffer

eeprom_inst.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 329100 Jul 30 19:07 2021 eeprom_inst.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000002  00000000  00000000  00000064  2**1
                  ALLOC
  3 .debug_abbrev 00000105  00000000  00000000  00000064  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000444  00000000  00000000  00000169  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000062c  00000000  00000000  000005ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_macinfo 0004ed41  00000000  00000000  00000bd9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_pubnames 0000007c  00000000  00000000  0004f91a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_pubtypes 000000e9  00000000  00000000  0004f996  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000002b9  00000000  00000000  0004fa7f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002b  00000000  00000000  0004fd38  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 00000031  00000000  00000000  0004fd63  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 eeprom_inst.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000040       O *COM*	00000004 buffer
00000040       O *COM*	00000004 buffer2
00000000 g     O .bss	00000002 eeprom_Address
00000000 g     O .data	00000004 eeprom_Timeout
00000004 g     O .data	00000004 belle_eeprom
00000000         *UND*	00000000 i2c_eeprom
00000008 g     O .data	00000028 calibration_page_values


