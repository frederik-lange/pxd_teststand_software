In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libxme_lwip_netif_arp.a:

etharp.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  63204 Jul 30 19:07 2021 etharp.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001110  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00001144  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000cc  00000000  00000000  00001144  2**2
                  ALLOC
  3 .debug_abbrev 00000205  00000000  00000000  00001144  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000117a  00000000  00000000  00001349  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000007b0  00000000  00000000  000024c3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000a065  00000000  00000000  00002c73  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000010  00000000  00000000  0000ccd8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    00000380  00000000  00000000  0000cce8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 000000b5  00000000  00000000  0000d068  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 000001bc  00000000  00000000  0000d11d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  0000d2d9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    000008af  00000000  00000000  0000d2f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0000dba8  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  0000dbd3  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00000210  00000000  00000000  0000dc04  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 etharp.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .rodata	00000000 .rodata
00000000 l       .bss	00000000 arp_table
000000c8 l       .bss	00000000 etharp_cached_entry
00000000 l     F .text	00000036 free_etharp_q
00000038 l     F .text	0000007c etharp_free_entry
000001d8 l     F .text	00000264 etharp_find_entry
0000043c l     F .text	0000005c etharp_send_ip
00000498 l     F .text	00000164 etharp_update_arp_entry
00000704 l     F .text	0000005c etharp_ip_input
00000760 l     F .text	000001ba etharp_arp_input
0000091c l     F .text	000000d0 etharp_output_to_arp_index
00000e7c l     F .text	0000012a etharp_raw
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .rodata	00000006 ethbroadcast
00000008 g     O .rodata	00000006 ethzero
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 memp_free
000000b4 g     F .text	00000124 etharp_tmr
00000000         *UND*	00000000 memcpy
00000000         *UND*	00000000 ip4_addr_isbroadcast
000005fc g     F .text	00000070 etharp_cleanup_netif
0000066c g     F .text	00000098 etharp_find_addr
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 dhcp_arp_reply
00000fa8 g     F .text	0000004c etharp_request
000009ec g     F .text	000001d4 etharp_output
00000000         *UND*	00000000 pbuf_header
00000bc0 g     F .text	000002bc etharp_query
00000000         *UND*	00000000 pbuf_alloc
00000000         *UND*	00000000 pbuf_copy
00000000         *UND*	00000000 pbuf_ref
00000000         *UND*	00000000 memp_malloc
00000ff4 g     F .text	0000011c ethernet_input
00000000         *UND*	00000000 memcmp
00000000         *UND*	00000000 ip_input



Disassembly of section .text:

00000000 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
       0:	b580      	push	{r7, lr}
       2:	b084      	sub	sp, #16
       4:	af00      	add	r7, sp, #0
       6:	6078      	str	r0, [r7, #4]
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
       8:	e00e      	b.n	28 <free_etharp_q+0x28>
    r = q;
       a:	687b      	ldr	r3, [r7, #4]
       c:	60fb      	str	r3, [r7, #12]
    q = q->next;
       e:	687b      	ldr	r3, [r7, #4]
      10:	681b      	ldr	r3, [r3, #0]
      12:	607b      	str	r3, [r7, #4]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
      14:	68fb      	ldr	r3, [r7, #12]
      16:	685b      	ldr	r3, [r3, #4]
      18:	4618      	mov	r0, r3
      1a:	f7ff fffe 	bl	0 <pbuf_free>
			1a: R_ARM_THM_CALL	pbuf_free
    memp_free(MEMP_ARP_QUEUE, r);
      1e:	f04f 000a 	mov.w	r0, #10
      22:	68f9      	ldr	r1, [r7, #12]
      24:	f7ff fffe 	bl	0 <memp_free>
			24: R_ARM_THM_CALL	memp_free
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
      28:	687b      	ldr	r3, [r7, #4]
      2a:	2b00      	cmp	r3, #0
      2c:	d1ed      	bne.n	a <free_etharp_q+0xa>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
      2e:	f107 0710 	add.w	r7, r7, #16
      32:	46bd      	mov	sp, r7
      34:	bd80      	pop	{r7, pc}
      36:	bf00      	nop

00000038 <etharp_free_entry>:
#endif /* ARP_QUEUEING */

/** Clean up ARP table entries */
static void
etharp_free_entry(int i)
{
      38:	b580      	push	{r7, lr}
      3a:	b082      	sub	sp, #8
      3c:	af00      	add	r7, sp, #0
      3e:	6078      	str	r0, [r7, #4]
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
      40:	491b      	ldr	r1, [pc, #108]	; (b0 <etharp_free_entry+0x78>)
      42:	687a      	ldr	r2, [r7, #4]
      44:	4613      	mov	r3, r2
      46:	ea4f 0383 	mov.w	r3, r3, lsl #2
      4a:	189b      	adds	r3, r3, r2
      4c:	ea4f 0383 	mov.w	r3, r3, lsl #2
      50:	18cb      	adds	r3, r1, r3
      52:	681b      	ldr	r3, [r3, #0]
      54:	2b00      	cmp	r3, #0
      56:	d018      	beq.n	8a <etharp_free_entry+0x52>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
      58:	4915      	ldr	r1, [pc, #84]	; (b0 <etharp_free_entry+0x78>)
      5a:	687a      	ldr	r2, [r7, #4]
      5c:	4613      	mov	r3, r2
      5e:	ea4f 0383 	mov.w	r3, r3, lsl #2
      62:	189b      	adds	r3, r3, r2
      64:	ea4f 0383 	mov.w	r3, r3, lsl #2
      68:	18cb      	adds	r3, r1, r3
      6a:	681b      	ldr	r3, [r3, #0]
      6c:	4618      	mov	r0, r3
      6e:	f7ff ffc7 	bl	0 <free_etharp_q>
    arp_table[i].q = NULL;
      72:	490f      	ldr	r1, [pc, #60]	; (b0 <etharp_free_entry+0x78>)
      74:	687a      	ldr	r2, [r7, #4]
      76:	4613      	mov	r3, r2
      78:	ea4f 0383 	mov.w	r3, r3, lsl #2
      7c:	189b      	adds	r3, r3, r2
      7e:	ea4f 0383 	mov.w	r3, r3, lsl #2
      82:	18cb      	adds	r3, r1, r3
      84:	f04f 0200 	mov.w	r2, #0
      88:	601a      	str	r2, [r3, #0]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
      8a:	4909      	ldr	r1, [pc, #36]	; (b0 <etharp_free_entry+0x78>)
      8c:	687a      	ldr	r2, [r7, #4]
      8e:	4613      	mov	r3, r2
      90:	ea4f 0383 	mov.w	r3, r3, lsl #2
      94:	189b      	adds	r3, r3, r2
      96:	ea4f 0383 	mov.w	r3, r3, lsl #2
      9a:	18cb      	adds	r3, r1, r3
      9c:	f103 0310 	add.w	r3, r3, #16
      a0:	f04f 0200 	mov.w	r2, #0
      a4:	709a      	strb	r2, [r3, #2]
  arp_table[i].ctime = 0;
  arp_table[i].netif = NULL;
  ip_addr_set_zero(&arp_table[i].ipaddr);
  arp_table[i].ethaddr = ethzero;
#endif /* LWIP_DEBUG */
}
      a6:	f107 0708 	add.w	r7, r7, #8
      aa:	46bd      	mov	sp, r7
      ac:	bd80      	pop	{r7, pc}
      ae:	bf00      	nop
      b0:	00000000 	.word	0x00000000
			b0: R_ARM_ABS32	.bss

000000b4 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
      b4:	b580      	push	{r7, lr}
      b6:	b082      	sub	sp, #8
      b8:	af00      	add	r7, sp, #0
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
      ba:	f04f 0300 	mov.w	r3, #0
      be:	71fb      	strb	r3, [r7, #7]
      c0:	e080      	b.n	1c4 <etharp_tmr+0x110>
    u8_t state = arp_table[i].state;
      c2:	79fa      	ldrb	r2, [r7, #7]
      c4:	4943      	ldr	r1, [pc, #268]	; (1d4 <etharp_tmr+0x120>)
      c6:	4613      	mov	r3, r2
      c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
      cc:	189b      	adds	r3, r3, r2
      ce:	ea4f 0383 	mov.w	r3, r3, lsl #2
      d2:	18cb      	adds	r3, r1, r3
      d4:	f103 0310 	add.w	r3, r3, #16
      d8:	789b      	ldrb	r3, [r3, #2]
      da:	71bb      	strb	r3, [r7, #6]
    if (state != ETHARP_STATE_EMPTY
      dc:	79bb      	ldrb	r3, [r7, #6]
      de:	2b00      	cmp	r3, #0
      e0:	d06c      	beq.n	1bc <etharp_tmr+0x108>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      e2:	79fa      	ldrb	r2, [r7, #7]
      e4:	493b      	ldr	r1, [pc, #236]	; (1d4 <etharp_tmr+0x120>)
      e6:	4613      	mov	r3, r2
      e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
      ec:	189b      	adds	r3, r3, r2
      ee:	ea4f 0383 	mov.w	r3, r3, lsl #2
      f2:	18cb      	adds	r3, r1, r3
      f4:	f103 0310 	add.w	r3, r3, #16
      f8:	78db      	ldrb	r3, [r3, #3]
      fa:	f103 0301 	add.w	r3, r3, #1
      fe:	b2d9      	uxtb	r1, r3
     100:	4834      	ldr	r0, [pc, #208]	; (1d4 <etharp_tmr+0x120>)
     102:	4613      	mov	r3, r2
     104:	ea4f 0383 	mov.w	r3, r3, lsl #2
     108:	189b      	adds	r3, r3, r2
     10a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     10e:	18c3      	adds	r3, r0, r3
     110:	f103 0310 	add.w	r3, r3, #16
     114:	460a      	mov	r2, r1
     116:	70da      	strb	r2, [r3, #3]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
     118:	79fa      	ldrb	r2, [r7, #7]
     11a:	492e      	ldr	r1, [pc, #184]	; (1d4 <etharp_tmr+0x120>)
     11c:	4613      	mov	r3, r2
     11e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     122:	189b      	adds	r3, r3, r2
     124:	ea4f 0383 	mov.w	r3, r3, lsl #2
     128:	18cb      	adds	r3, r1, r3
     12a:	f103 0310 	add.w	r3, r3, #16
     12e:	78db      	ldrb	r3, [r3, #3]
     130:	2bef      	cmp	r3, #239	; 0xef
     132:	d81b      	bhi.n	16c <etharp_tmr+0xb8>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
     134:	79fa      	ldrb	r2, [r7, #7]
     136:	4927      	ldr	r1, [pc, #156]	; (1d4 <etharp_tmr+0x120>)
     138:	4613      	mov	r3, r2
     13a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     13e:	189b      	adds	r3, r3, r2
     140:	ea4f 0383 	mov.w	r3, r3, lsl #2
     144:	18cb      	adds	r3, r1, r3
     146:	f103 0310 	add.w	r3, r3, #16
     14a:	789b      	ldrb	r3, [r3, #2]
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
     14c:	2b01      	cmp	r3, #1
     14e:	d112      	bne.n	176 <etharp_tmr+0xc2>
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
     150:	79fa      	ldrb	r2, [r7, #7]
     152:	4920      	ldr	r1, [pc, #128]	; (1d4 <etharp_tmr+0x120>)
     154:	4613      	mov	r3, r2
     156:	ea4f 0383 	mov.w	r3, r3, lsl #2
     15a:	189b      	adds	r3, r3, r2
     15c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     160:	18cb      	adds	r3, r1, r3
     162:	f103 0310 	add.w	r3, r3, #16
     166:	78db      	ldrb	r3, [r3, #3]
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
     168:	2b01      	cmp	r3, #1
     16a:	d904      	bls.n	176 <etharp_tmr+0xc2>
           (arp_table[i].ctime >= ARP_MAXPENDING))) {
        /* pending or stable entry has become old! */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
     16c:	79fb      	ldrb	r3, [r7, #7]
     16e:	4618      	mov	r0, r3
     170:	f7ff ff62 	bl	38 <etharp_free_entry>
     174:	e01b      	b.n	1ae <etharp_tmr+0xfa>
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
     176:	79fa      	ldrb	r2, [r7, #7]
     178:	4916      	ldr	r1, [pc, #88]	; (1d4 <etharp_tmr+0x120>)
     17a:	4613      	mov	r3, r2
     17c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     180:	189b      	adds	r3, r3, r2
     182:	ea4f 0383 	mov.w	r3, r3, lsl #2
     186:	18cb      	adds	r3, r1, r3
     188:	f103 0310 	add.w	r3, r3, #16
     18c:	789b      	ldrb	r3, [r3, #2]
     18e:	2b03      	cmp	r3, #3
     190:	d10d      	bne.n	1ae <etharp_tmr+0xfa>
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
     192:	79fa      	ldrb	r2, [r7, #7]
     194:	490f      	ldr	r1, [pc, #60]	; (1d4 <etharp_tmr+0x120>)
     196:	4613      	mov	r3, r2
     198:	ea4f 0383 	mov.w	r3, r3, lsl #2
     19c:	189b      	adds	r3, r3, r2
     19e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     1a2:	18cb      	adds	r3, r1, r3
     1a4:	f103 0310 	add.w	r3, r3, #16
     1a8:	f04f 0202 	mov.w	r2, #2
     1ac:	709a      	strb	r2, [r3, #2]
      }
#if ARP_QUEUEING
      /* still pending entry? (not expired) */
      if (arp_table[i].state == ETHARP_STATE_PENDING) {
     1ae:	79fa      	ldrb	r2, [r7, #7]
     1b0:	4613      	mov	r3, r2
     1b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
     1b6:	189b      	adds	r3, r3, r2
     1b8:	ea4f 0383 	mov.w	r3, r3, lsl #2
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
     1bc:	79fb      	ldrb	r3, [r7, #7]
     1be:	f103 0301 	add.w	r3, r3, #1
     1c2:	71fb      	strb	r3, [r7, #7]
     1c4:	79fb      	ldrb	r3, [r7, #7]
     1c6:	2b09      	cmp	r3, #9
     1c8:	f67f af7b 	bls.w	c2 <etharp_tmr+0xe>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
     1cc:	f107 0708 	add.w	r7, r7, #8
     1d0:	46bd      	mov	sp, r7
     1d2:	bd80      	pop	{r7, pc}
     1d4:	00000000 	.word	0x00000000
			1d4: R_ARM_ABS32	.bss

000001d8 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
     1d8:	b580      	push	{r7, lr}
     1da:	b086      	sub	sp, #24
     1dc:	af00      	add	r7, sp, #0
     1de:	6078      	str	r0, [r7, #4]
     1e0:	460b      	mov	r3, r1
     1e2:	70fb      	strb	r3, [r7, #3]
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
     1e4:	f04f 030a 	mov.w	r3, #10
     1e8:	75fb      	strb	r3, [r7, #23]
     1ea:	f04f 030a 	mov.w	r3, #10
     1ee:	75bb      	strb	r3, [r7, #22]
  s8_t empty = ARP_TABLE_SIZE;
     1f0:	f04f 030a 	mov.w	r3, #10
     1f4:	757b      	strb	r3, [r7, #21]
  u8_t i = 0, age_pending = 0, age_stable = 0;
     1f6:	f04f 0300 	mov.w	r3, #0
     1fa:	753b      	strb	r3, [r7, #20]
     1fc:	f04f 0300 	mov.w	r3, #0
     200:	74fb      	strb	r3, [r7, #19]
     202:	f04f 0300 	mov.w	r3, #0
     206:	74bb      	strb	r3, [r7, #18]
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
     208:	f04f 030a 	mov.w	r3, #10
     20c:	747b      	strb	r3, [r7, #17]
  /* its age */
  u8_t age_queue = 0;
     20e:	f04f 0300 	mov.w	r3, #0
     212:	743b      	strb	r3, [r7, #16]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
     214:	f04f 0300 	mov.w	r3, #0
     218:	753b      	strb	r3, [r7, #20]
     21a:	e0a1      	b.n	360 <etharp_find_entry+0x188>
    u8_t state = arp_table[i].state;
     21c:	7d3a      	ldrb	r2, [r7, #20]
     21e:	4986      	ldr	r1, [pc, #536]	; (438 <etharp_find_entry+0x260>)
     220:	4613      	mov	r3, r2
     222:	ea4f 0383 	mov.w	r3, r3, lsl #2
     226:	189b      	adds	r3, r3, r2
     228:	ea4f 0383 	mov.w	r3, r3, lsl #2
     22c:	18cb      	adds	r3, r1, r3
     22e:	f103 0310 	add.w	r3, r3, #16
     232:	789b      	ldrb	r3, [r3, #2]
     234:	73fb      	strb	r3, [r7, #15]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
     236:	f997 3015 	ldrsb.w	r3, [r7, #21]
     23a:	2b0a      	cmp	r3, #10
     23c:	d105      	bne.n	24a <etharp_find_entry+0x72>
     23e:	7bfb      	ldrb	r3, [r7, #15]
     240:	2b00      	cmp	r3, #0
     242:	d102      	bne.n	24a <etharp_find_entry+0x72>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
     244:	7d3b      	ldrb	r3, [r7, #20]
     246:	757b      	strb	r3, [r7, #21]
     248:	e086      	b.n	358 <etharp_find_entry+0x180>
    } else if (state != ETHARP_STATE_EMPTY) {
     24a:	7bfb      	ldrb	r3, [r7, #15]
     24c:	2b00      	cmp	r3, #0
     24e:	f000 8083 	beq.w	358 <etharp_find_entry+0x180>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
     252:	687b      	ldr	r3, [r7, #4]
     254:	2b00      	cmp	r3, #0
     256:	d011      	beq.n	27c <etharp_find_entry+0xa4>
     258:	687b      	ldr	r3, [r7, #4]
     25a:	6819      	ldr	r1, [r3, #0]
     25c:	7d3a      	ldrb	r2, [r7, #20]
     25e:	4876      	ldr	r0, [pc, #472]	; (438 <etharp_find_entry+0x260>)
     260:	4613      	mov	r3, r2
     262:	ea4f 0383 	mov.w	r3, r3, lsl #2
     266:	189b      	adds	r3, r3, r2
     268:	ea4f 0383 	mov.w	r3, r3, lsl #2
     26c:	18c3      	adds	r3, r0, r3
     26e:	f103 0304 	add.w	r3, r3, #4
     272:	681b      	ldr	r3, [r3, #0]
     274:	4299      	cmp	r1, r3
     276:	d101      	bne.n	27c <etharp_find_entry+0xa4>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
     278:	7d3b      	ldrb	r3, [r7, #20]
     27a:	e0d7      	b.n	42c <etharp_find_entry+0x254>
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
     27c:	7bfb      	ldrb	r3, [r7, #15]
     27e:	2b01      	cmp	r3, #1
     280:	d149      	bne.n	316 <etharp_find_entry+0x13e>
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
     282:	7d3a      	ldrb	r2, [r7, #20]
     284:	496c      	ldr	r1, [pc, #432]	; (438 <etharp_find_entry+0x260>)
     286:	4613      	mov	r3, r2
     288:	ea4f 0383 	mov.w	r3, r3, lsl #2
     28c:	189b      	adds	r3, r3, r2
     28e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     292:	18cb      	adds	r3, r1, r3
     294:	681b      	ldr	r3, [r3, #0]
     296:	2b00      	cmp	r3, #0
     298:	d01e      	beq.n	2d8 <etharp_find_entry+0x100>
          if (arp_table[i].ctime >= age_queue) {
     29a:	7d3a      	ldrb	r2, [r7, #20]
     29c:	4966      	ldr	r1, [pc, #408]	; (438 <etharp_find_entry+0x260>)
     29e:	4613      	mov	r3, r2
     2a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
     2a4:	189b      	adds	r3, r3, r2
     2a6:	ea4f 0383 	mov.w	r3, r3, lsl #2
     2aa:	18cb      	adds	r3, r1, r3
     2ac:	f103 0310 	add.w	r3, r3, #16
     2b0:	78db      	ldrb	r3, [r3, #3]
     2b2:	7c3a      	ldrb	r2, [r7, #16]
     2b4:	429a      	cmp	r2, r3
     2b6:	d84f      	bhi.n	358 <etharp_find_entry+0x180>
            old_queue = i;
     2b8:	7d3b      	ldrb	r3, [r7, #20]
     2ba:	747b      	strb	r3, [r7, #17]
            age_queue = arp_table[i].ctime;
     2bc:	7d3a      	ldrb	r2, [r7, #20]
     2be:	495e      	ldr	r1, [pc, #376]	; (438 <etharp_find_entry+0x260>)
     2c0:	4613      	mov	r3, r2
     2c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
     2c6:	189b      	adds	r3, r3, r2
     2c8:	ea4f 0383 	mov.w	r3, r3, lsl #2
     2cc:	18cb      	adds	r3, r1, r3
     2ce:	f103 0310 	add.w	r3, r3, #16
     2d2:	78db      	ldrb	r3, [r3, #3]
     2d4:	743b      	strb	r3, [r7, #16]
     2d6:	e03f      	b.n	358 <etharp_find_entry+0x180>
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
     2d8:	7d3a      	ldrb	r2, [r7, #20]
     2da:	4957      	ldr	r1, [pc, #348]	; (438 <etharp_find_entry+0x260>)
     2dc:	4613      	mov	r3, r2
     2de:	ea4f 0383 	mov.w	r3, r3, lsl #2
     2e2:	189b      	adds	r3, r3, r2
     2e4:	ea4f 0383 	mov.w	r3, r3, lsl #2
     2e8:	18cb      	adds	r3, r1, r3
     2ea:	f103 0310 	add.w	r3, r3, #16
     2ee:	78db      	ldrb	r3, [r3, #3]
     2f0:	7cfa      	ldrb	r2, [r7, #19]
     2f2:	429a      	cmp	r2, r3
     2f4:	d830      	bhi.n	358 <etharp_find_entry+0x180>
            old_pending = i;
     2f6:	7d3b      	ldrb	r3, [r7, #20]
     2f8:	75fb      	strb	r3, [r7, #23]
            age_pending = arp_table[i].ctime;
     2fa:	7d3a      	ldrb	r2, [r7, #20]
     2fc:	494e      	ldr	r1, [pc, #312]	; (438 <etharp_find_entry+0x260>)
     2fe:	4613      	mov	r3, r2
     300:	ea4f 0383 	mov.w	r3, r3, lsl #2
     304:	189b      	adds	r3, r3, r2
     306:	ea4f 0383 	mov.w	r3, r3, lsl #2
     30a:	18cb      	adds	r3, r1, r3
     30c:	f103 0310 	add.w	r3, r3, #16
     310:	78db      	ldrb	r3, [r3, #3]
     312:	74fb      	strb	r3, [r7, #19]
     314:	e020      	b.n	358 <etharp_find_entry+0x180>
          }
        }
      /* stable entry? */
      } else if (state >= ETHARP_STATE_STABLE) {
     316:	7bfb      	ldrb	r3, [r7, #15]
     318:	2b01      	cmp	r3, #1
     31a:	d91d      	bls.n	358 <etharp_find_entry+0x180>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
     31c:	7d3a      	ldrb	r2, [r7, #20]
     31e:	4946      	ldr	r1, [pc, #280]	; (438 <etharp_find_entry+0x260>)
     320:	4613      	mov	r3, r2
     322:	ea4f 0383 	mov.w	r3, r3, lsl #2
     326:	189b      	adds	r3, r3, r2
     328:	ea4f 0383 	mov.w	r3, r3, lsl #2
     32c:	18cb      	adds	r3, r1, r3
     32e:	f103 0310 	add.w	r3, r3, #16
     332:	78db      	ldrb	r3, [r3, #3]
     334:	7cba      	ldrb	r2, [r7, #18]
     336:	429a      	cmp	r2, r3
     338:	d80e      	bhi.n	358 <etharp_find_entry+0x180>
            old_stable = i;
     33a:	7d3b      	ldrb	r3, [r7, #20]
     33c:	75bb      	strb	r3, [r7, #22]
            age_stable = arp_table[i].ctime;
     33e:	7d3a      	ldrb	r2, [r7, #20]
     340:	493d      	ldr	r1, [pc, #244]	; (438 <etharp_find_entry+0x260>)
     342:	4613      	mov	r3, r2
     344:	ea4f 0383 	mov.w	r3, r3, lsl #2
     348:	189b      	adds	r3, r3, r2
     34a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     34e:	18cb      	adds	r3, r1, r3
     350:	f103 0310 	add.w	r3, r3, #16
     354:	78db      	ldrb	r3, [r3, #3]
     356:	74bb      	strb	r3, [r7, #18]
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
     358:	7d3b      	ldrb	r3, [r7, #20]
     35a:	f103 0301 	add.w	r3, r3, #1
     35e:	753b      	strb	r3, [r7, #20]
     360:	7d3b      	ldrb	r3, [r7, #20]
     362:	2b09      	cmp	r3, #9
     364:	f67f af5a 	bls.w	21c <etharp_find_entry+0x44>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
     368:	78fb      	ldrb	r3, [r7, #3]
     36a:	f003 0302 	and.w	r3, r3, #2
     36e:	2b00      	cmp	r3, #0
     370:	d108      	bne.n	384 <etharp_find_entry+0x1ac>
     372:	f997 3015 	ldrsb.w	r3, [r7, #21]
     376:	2b0a      	cmp	r3, #10
     378:	d107      	bne.n	38a <etharp_find_entry+0x1b2>
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
     37a:	78fb      	ldrb	r3, [r7, #3]
     37c:	f003 0301 	and.w	r3, r3, #1
     380:	2b00      	cmp	r3, #0
     382:	d102      	bne.n	38a <etharp_find_entry+0x1b2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
     384:	f04f 03ff 	mov.w	r3, #255	; 0xff
     388:	e050      	b.n	42c <etharp_find_entry+0x254>
   * 
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
     38a:	f997 3015 	ldrsb.w	r3, [r7, #21]
     38e:	2b09      	cmp	r3, #9
     390:	dc02      	bgt.n	398 <etharp_find_entry+0x1c0>
    i = empty;
     392:	7d7b      	ldrb	r3, [r7, #21]
     394:	753b      	strb	r3, [r7, #20]
     396:	e022      	b.n	3de <etharp_find_entry+0x206>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
     398:	f997 3016 	ldrsb.w	r3, [r7, #22]
     39c:	2b09      	cmp	r3, #9
     39e:	dc09      	bgt.n	3b4 <etharp_find_entry+0x1dc>
      /* recycle oldest stable*/
      i = old_stable;
     3a0:	7dbb      	ldrb	r3, [r7, #22]
     3a2:	753b      	strb	r3, [r7, #20]
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
     3a4:	7d3a      	ldrb	r2, [r7, #20]
     3a6:	4613      	mov	r3, r2
     3a8:	ea4f 0383 	mov.w	r3, r3, lsl #2
     3ac:	189b      	adds	r3, r3, r2
     3ae:	ea4f 0383 	mov.w	r3, r3, lsl #2
     3b2:	e010      	b.n	3d6 <etharp_find_entry+0x1fe>
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
     3b4:	f997 3017 	ldrsb.w	r3, [r7, #23]
     3b8:	2b09      	cmp	r3, #9
     3ba:	dc02      	bgt.n	3c2 <etharp_find_entry+0x1ea>
      /* recycle oldest pending */
      i = old_pending;
     3bc:	7dfb      	ldrb	r3, [r7, #23]
     3be:	753b      	strb	r3, [r7, #20]
     3c0:	e009      	b.n	3d6 <etharp_find_entry+0x1fe>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
     3c2:	f997 3011 	ldrsb.w	r3, [r7, #17]
     3c6:	2b09      	cmp	r3, #9
     3c8:	dc02      	bgt.n	3d0 <etharp_find_entry+0x1f8>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
     3ca:	7c7b      	ldrb	r3, [r7, #17]
     3cc:	753b      	strb	r3, [r7, #20]
     3ce:	e002      	b.n	3d6 <etharp_find_entry+0x1fe>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
      /* no empty or recyclable entries found */
    } else {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
     3d0:	f04f 03ff 	mov.w	r3, #255	; 0xff
     3d4:	e02a      	b.n	42c <etharp_find_entry+0x254>
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
     3d6:	7d3b      	ldrb	r3, [r7, #20]
     3d8:	4618      	mov	r0, r3
     3da:	f7ff fe2d 	bl	38 <etharp_free_entry>
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
     3de:	7d3a      	ldrb	r2, [r7, #20]
     3e0:	4613      	mov	r3, r2
     3e2:	ea4f 0383 	mov.w	r3, r3, lsl #2
     3e6:	189b      	adds	r3, r3, r2
     3e8:	ea4f 0383 	mov.w	r3, r3, lsl #2
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
     3ec:	687b      	ldr	r3, [r7, #4]
     3ee:	2b00      	cmp	r3, #0
     3f0:	d00d      	beq.n	40e <etharp_find_entry+0x236>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
     3f2:	7d3a      	ldrb	r2, [r7, #20]
     3f4:	687b      	ldr	r3, [r7, #4]
     3f6:	6819      	ldr	r1, [r3, #0]
     3f8:	480f      	ldr	r0, [pc, #60]	; (438 <etharp_find_entry+0x260>)
     3fa:	4613      	mov	r3, r2
     3fc:	ea4f 0383 	mov.w	r3, r3, lsl #2
     400:	189b      	adds	r3, r3, r2
     402:	ea4f 0383 	mov.w	r3, r3, lsl #2
     406:	18c3      	adds	r3, r0, r3
     408:	f103 0304 	add.w	r3, r3, #4
     40c:	6019      	str	r1, [r3, #0]
  }
  arp_table[i].ctime = 0;
     40e:	7d3a      	ldrb	r2, [r7, #20]
     410:	4909      	ldr	r1, [pc, #36]	; (438 <etharp_find_entry+0x260>)
     412:	4613      	mov	r3, r2
     414:	ea4f 0383 	mov.w	r3, r3, lsl #2
     418:	189b      	adds	r3, r3, r2
     41a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     41e:	18cb      	adds	r3, r1, r3
     420:	f103 0310 	add.w	r3, r3, #16
     424:	f04f 0200 	mov.w	r2, #0
     428:	70da      	strb	r2, [r3, #3]
  return (err_t)i;
     42a:	7d3b      	ldrb	r3, [r7, #20]
     42c:	b25b      	sxtb	r3, r3
}
     42e:	4618      	mov	r0, r3
     430:	f107 0718 	add.w	r7, r7, #24
     434:	46bd      	mov	sp, r7
     436:	bd80      	pop	{r7, pc}
     438:	00000000 	.word	0x00000000
			438: R_ARM_ABS32	.bss

0000043c <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
     43c:	b580      	push	{r7, lr}
     43e:	b086      	sub	sp, #24
     440:	af00      	add	r7, sp, #0
     442:	60f8      	str	r0, [r7, #12]
     444:	60b9      	str	r1, [r7, #8]
     446:	607a      	str	r2, [r7, #4]
     448:	603b      	str	r3, [r7, #0]
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
     44a:	68bb      	ldr	r3, [r7, #8]
     44c:	685b      	ldr	r3, [r3, #4]
     44e:	617b      	str	r3, [r7, #20]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
     450:	697b      	ldr	r3, [r7, #20]
     452:	4618      	mov	r0, r3
     454:	6839      	ldr	r1, [r7, #0]
     456:	f04f 0206 	mov.w	r2, #6
     45a:	f7ff fffe 	bl	0 <memcpy>
			45a: R_ARM_THM_CALL	memcpy
  ETHADDR16_COPY(&ethhdr->src, src);
     45e:	697b      	ldr	r3, [r7, #20]
     460:	f103 0306 	add.w	r3, r3, #6
     464:	4618      	mov	r0, r3
     466:	6879      	ldr	r1, [r7, #4]
     468:	f04f 0206 	mov.w	r2, #6
     46c:	f7ff fffe 	bl	0 <memcpy>
			46c: R_ARM_THM_CALL	memcpy
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
     470:	697b      	ldr	r3, [r7, #20]
     472:	f04f 0200 	mov.w	r2, #0
     476:	f042 0208 	orr.w	r2, r2, #8
     47a:	731a      	strb	r2, [r3, #12]
     47c:	f04f 0200 	mov.w	r2, #0
     480:	735a      	strb	r2, [r3, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
     482:	68fb      	ldr	r3, [r7, #12]
     484:	699b      	ldr	r3, [r3, #24]
     486:	68f8      	ldr	r0, [r7, #12]
     488:	68b9      	ldr	r1, [r7, #8]
     48a:	4798      	blx	r3
     48c:	4603      	mov	r3, r0
}
     48e:	4618      	mov	r0, r3
     490:	f107 0718 	add.w	r7, r7, #24
     494:	46bd      	mov	sp, r7
     496:	bd80      	pop	{r7, pc}

00000498 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
     498:	b580      	push	{r7, lr}
     49a:	b088      	sub	sp, #32
     49c:	af00      	add	r7, sp, #0
     49e:	60f8      	str	r0, [r7, #12]
     4a0:	60b9      	str	r1, [r7, #8]
     4a2:	607a      	str	r2, [r7, #4]
     4a4:	70fb      	strb	r3, [r7, #3]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
     4a6:	68bb      	ldr	r3, [r7, #8]
     4a8:	2b00      	cmp	r3, #0
     4aa:	d012      	beq.n	4d2 <etharp_update_arp_entry+0x3a>
     4ac:	68bb      	ldr	r3, [r7, #8]
     4ae:	681b      	ldr	r3, [r3, #0]
     4b0:	2b00      	cmp	r3, #0
     4b2:	d00e      	beq.n	4d2 <etharp_update_arp_entry+0x3a>
      ip_addr_isbroadcast(ipaddr, netif) ||
     4b4:	68bb      	ldr	r3, [r7, #8]
     4b6:	681b      	ldr	r3, [r3, #0]
     4b8:	4618      	mov	r0, r3
     4ba:	68f9      	ldr	r1, [r7, #12]
     4bc:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			4bc: R_ARM_THM_CALL	ip4_addr_isbroadcast
     4c0:	4603      	mov	r3, r0
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
     4c2:	2b00      	cmp	r3, #0
     4c4:	d105      	bne.n	4d2 <etharp_update_arp_entry+0x3a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
     4c6:	68bb      	ldr	r3, [r7, #8]
     4c8:	681b      	ldr	r3, [r3, #0]
     4ca:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
     4ce:	2be0      	cmp	r3, #224	; 0xe0
     4d0:	d102      	bne.n	4d8 <etharp_update_arp_entry+0x40>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
     4d2:	f04f 03f2 	mov.w	r3, #242	; 0xf2
     4d6:	e089      	b.n	5ec <etharp_update_arp_entry+0x154>
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
     4d8:	78fb      	ldrb	r3, [r7, #3]
     4da:	68b8      	ldr	r0, [r7, #8]
     4dc:	4619      	mov	r1, r3
     4de:	f7ff fe7b 	bl	1d8 <etharp_find_entry>
     4e2:	4603      	mov	r3, r0
     4e4:	77fb      	strb	r3, [r7, #31]
  /* bail out if no entry could be found */
  if (i < 0) {
     4e6:	f997 301f 	ldrsb.w	r3, [r7, #31]
     4ea:	2b00      	cmp	r3, #0
     4ec:	da01      	bge.n	4f2 <etharp_update_arp_entry+0x5a>
    return (err_t)i;
     4ee:	7ffb      	ldrb	r3, [r7, #31]
     4f0:	e07c      	b.n	5ec <etharp_update_arp_entry+0x154>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
     4f2:	f997 201f 	ldrsb.w	r2, [r7, #31]
     4f6:	4940      	ldr	r1, [pc, #256]	; (5f8 <etharp_update_arp_entry+0x160>)
     4f8:	4613      	mov	r3, r2
     4fa:	ea4f 0383 	mov.w	r3, r3, lsl #2
     4fe:	189b      	adds	r3, r3, r2
     500:	ea4f 0383 	mov.w	r3, r3, lsl #2
     504:	18cb      	adds	r3, r1, r3
     506:	f103 0310 	add.w	r3, r3, #16
     50a:	f04f 0202 	mov.w	r2, #2
     50e:	709a      	strb	r2, [r3, #2]
  }

  /* record network interface */
  arp_table[i].netif = netif;
     510:	f997 201f 	ldrsb.w	r2, [r7, #31]
     514:	4938      	ldr	r1, [pc, #224]	; (5f8 <etharp_update_arp_entry+0x160>)
     516:	4613      	mov	r3, r2
     518:	ea4f 0383 	mov.w	r3, r3, lsl #2
     51c:	189b      	adds	r3, r3, r2
     51e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     522:	18cb      	adds	r3, r1, r3
     524:	f103 0308 	add.w	r3, r3, #8
     528:	68fa      	ldr	r2, [r7, #12]
     52a:	601a      	str	r2, [r3, #0]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
     52c:	f997 201f 	ldrsb.w	r2, [r7, #31]
     530:	4613      	mov	r3, r2
     532:	ea4f 0383 	mov.w	r3, r3, lsl #2
     536:	189b      	adds	r3, r3, r2
     538:	ea4f 0383 	mov.w	r3, r3, lsl #2
     53c:	f103 0208 	add.w	r2, r3, #8
     540:	4b2d      	ldr	r3, [pc, #180]	; (5f8 <etharp_update_arp_entry+0x160>)
     542:	18d3      	adds	r3, r2, r3
     544:	f103 0304 	add.w	r3, r3, #4
     548:	4618      	mov	r0, r3
     54a:	6879      	ldr	r1, [r7, #4]
     54c:	f04f 0206 	mov.w	r2, #6
     550:	f7ff fffe 	bl	0 <memcpy>
			550: R_ARM_THM_CALL	memcpy
  /* reset time stamp */
  arp_table[i].ctime = 0;
     554:	f997 201f 	ldrsb.w	r2, [r7, #31]
     558:	4927      	ldr	r1, [pc, #156]	; (5f8 <etharp_update_arp_entry+0x160>)
     55a:	4613      	mov	r3, r2
     55c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     560:	189b      	adds	r3, r3, r2
     562:	ea4f 0383 	mov.w	r3, r3, lsl #2
     566:	18cb      	adds	r3, r1, r3
     568:	f103 0310 	add.w	r3, r3, #16
     56c:	f04f 0200 	mov.w	r2, #0
     570:	70da      	strb	r2, [r3, #3]
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
     572:	e02c      	b.n	5ce <etharp_update_arp_entry+0x136>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
     574:	f997 201f 	ldrsb.w	r2, [r7, #31]
     578:	491f      	ldr	r1, [pc, #124]	; (5f8 <etharp_update_arp_entry+0x160>)
     57a:	4613      	mov	r3, r2
     57c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     580:	189b      	adds	r3, r3, r2
     582:	ea4f 0383 	mov.w	r3, r3, lsl #2
     586:	18cb      	adds	r3, r1, r3
     588:	681b      	ldr	r3, [r3, #0]
     58a:	61bb      	str	r3, [r7, #24]
    /* pop first item off the queue */
    arp_table[i].q = q->next;
     58c:	f997 201f 	ldrsb.w	r2, [r7, #31]
     590:	69bb      	ldr	r3, [r7, #24]
     592:	6819      	ldr	r1, [r3, #0]
     594:	4818      	ldr	r0, [pc, #96]	; (5f8 <etharp_update_arp_entry+0x160>)
     596:	4613      	mov	r3, r2
     598:	ea4f 0383 	mov.w	r3, r3, lsl #2
     59c:	189b      	adds	r3, r3, r2
     59e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     5a2:	18c3      	adds	r3, r0, r3
     5a4:	6019      	str	r1, [r3, #0]
    /* get the packet pointer */
    p = q->p;
     5a6:	69bb      	ldr	r3, [r7, #24]
     5a8:	685b      	ldr	r3, [r3, #4]
     5aa:	617b      	str	r3, [r7, #20]
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
     5ac:	f04f 000a 	mov.w	r0, #10
     5b0:	69b9      	ldr	r1, [r7, #24]
     5b2:	f7ff fffe 	bl	0 <memp_free>
			5b2: R_ARM_THM_CALL	memp_free
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
     5b6:	68fb      	ldr	r3, [r7, #12]
     5b8:	f103 032f 	add.w	r3, r3, #47	; 0x2f
     5bc:	68f8      	ldr	r0, [r7, #12]
     5be:	6979      	ldr	r1, [r7, #20]
     5c0:	461a      	mov	r2, r3
     5c2:	687b      	ldr	r3, [r7, #4]
     5c4:	f7ff ff3a 	bl	43c <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
     5c8:	6978      	ldr	r0, [r7, #20]
     5ca:	f7ff fffe 	bl	0 <pbuf_free>
			5ca: R_ARM_THM_CALL	pbuf_free
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
     5ce:	f997 201f 	ldrsb.w	r2, [r7, #31]
     5d2:	4909      	ldr	r1, [pc, #36]	; (5f8 <etharp_update_arp_entry+0x160>)
     5d4:	4613      	mov	r3, r2
     5d6:	ea4f 0383 	mov.w	r3, r3, lsl #2
     5da:	189b      	adds	r3, r3, r2
     5dc:	ea4f 0383 	mov.w	r3, r3, lsl #2
     5e0:	18cb      	adds	r3, r1, r3
     5e2:	681b      	ldr	r3, [r3, #0]
     5e4:	2b00      	cmp	r3, #0
     5e6:	d1c5      	bne.n	574 <etharp_update_arp_entry+0xdc>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
     5e8:	f04f 0300 	mov.w	r3, #0
     5ec:	b25b      	sxtb	r3, r3
}
     5ee:	4618      	mov	r0, r3
     5f0:	f107 0720 	add.w	r7, r7, #32
     5f4:	46bd      	mov	sp, r7
     5f6:	bd80      	pop	{r7, pc}
     5f8:	00000000 	.word	0x00000000
			5f8: R_ARM_ABS32	.bss

000005fc <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
     5fc:	b580      	push	{r7, lr}
     5fe:	b084      	sub	sp, #16
     600:	af00      	add	r7, sp, #0
     602:	6078      	str	r0, [r7, #4]
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
     604:	f04f 0300 	mov.w	r3, #0
     608:	73fb      	strb	r3, [r7, #15]
     60a:	e026      	b.n	65a <etharp_cleanup_netif+0x5e>
    u8_t state = arp_table[i].state;
     60c:	7bfa      	ldrb	r2, [r7, #15]
     60e:	4916      	ldr	r1, [pc, #88]	; (668 <etharp_cleanup_netif+0x6c>)
     610:	4613      	mov	r3, r2
     612:	ea4f 0383 	mov.w	r3, r3, lsl #2
     616:	189b      	adds	r3, r3, r2
     618:	ea4f 0383 	mov.w	r3, r3, lsl #2
     61c:	18cb      	adds	r3, r1, r3
     61e:	f103 0310 	add.w	r3, r3, #16
     622:	789b      	ldrb	r3, [r3, #2]
     624:	73bb      	strb	r3, [r7, #14]
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
     626:	7bbb      	ldrb	r3, [r7, #14]
     628:	2b00      	cmp	r3, #0
     62a:	d012      	beq.n	652 <etharp_cleanup_netif+0x56>
     62c:	7bfa      	ldrb	r2, [r7, #15]
     62e:	490e      	ldr	r1, [pc, #56]	; (668 <etharp_cleanup_netif+0x6c>)
     630:	4613      	mov	r3, r2
     632:	ea4f 0383 	mov.w	r3, r3, lsl #2
     636:	189b      	adds	r3, r3, r2
     638:	ea4f 0383 	mov.w	r3, r3, lsl #2
     63c:	18cb      	adds	r3, r1, r3
     63e:	f103 0308 	add.w	r3, r3, #8
     642:	681a      	ldr	r2, [r3, #0]
     644:	687b      	ldr	r3, [r7, #4]
     646:	429a      	cmp	r2, r3
     648:	d103      	bne.n	652 <etharp_cleanup_netif+0x56>
      etharp_free_entry(i);
     64a:	7bfb      	ldrb	r3, [r7, #15]
     64c:	4618      	mov	r0, r3
     64e:	f7ff fcf3 	bl	38 <etharp_free_entry>
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
     652:	7bfb      	ldrb	r3, [r7, #15]
     654:	f103 0301 	add.w	r3, r3, #1
     658:	73fb      	strb	r3, [r7, #15]
     65a:	7bfb      	ldrb	r3, [r7, #15]
     65c:	2b09      	cmp	r3, #9
     65e:	d9d5      	bls.n	60c <etharp_cleanup_netif+0x10>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
     660:	f107 0710 	add.w	r7, r7, #16
     664:	46bd      	mov	sp, r7
     666:	bd80      	pop	{r7, pc}
     668:	00000000 	.word	0x00000000
			668: R_ARM_ABS32	.bss

0000066c <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
     66c:	b580      	push	{r7, lr}
     66e:	b086      	sub	sp, #24
     670:	af00      	add	r7, sp, #0
     672:	60f8      	str	r0, [r7, #12]
     674:	60b9      	str	r1, [r7, #8]
     676:	607a      	str	r2, [r7, #4]
     678:	603b      	str	r3, [r7, #0]
  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
     67a:	68b8      	ldr	r0, [r7, #8]
     67c:	f04f 0102 	mov.w	r1, #2
     680:	f7ff fdaa 	bl	1d8 <etharp_find_entry>
     684:	4603      	mov	r3, r0
     686:	75fb      	strb	r3, [r7, #23]
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
     688:	f997 3017 	ldrsb.w	r3, [r7, #23]
     68c:	2b00      	cmp	r3, #0
     68e:	db2e      	blt.n	6ee <etharp_find_addr+0x82>
     690:	f997 2017 	ldrsb.w	r2, [r7, #23]
     694:	491a      	ldr	r1, [pc, #104]	; (700 <etharp_find_addr+0x94>)
     696:	4613      	mov	r3, r2
     698:	ea4f 0383 	mov.w	r3, r3, lsl #2
     69c:	189b      	adds	r3, r3, r2
     69e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     6a2:	18cb      	adds	r3, r1, r3
     6a4:	f103 0310 	add.w	r3, r3, #16
     6a8:	789b      	ldrb	r3, [r3, #2]
     6aa:	2b01      	cmp	r3, #1
     6ac:	d91f      	bls.n	6ee <etharp_find_addr+0x82>
      *eth_ret = &arp_table[i].ethaddr;
     6ae:	f997 2017 	ldrsb.w	r2, [r7, #23]
     6b2:	4613      	mov	r3, r2
     6b4:	ea4f 0383 	mov.w	r3, r3, lsl #2
     6b8:	189b      	adds	r3, r3, r2
     6ba:	ea4f 0383 	mov.w	r3, r3, lsl #2
     6be:	f103 0208 	add.w	r2, r3, #8
     6c2:	4b0f      	ldr	r3, [pc, #60]	; (700 <etharp_find_addr+0x94>)
     6c4:	18d3      	adds	r3, r2, r3
     6c6:	f103 0204 	add.w	r2, r3, #4
     6ca:	687b      	ldr	r3, [r7, #4]
     6cc:	601a      	str	r2, [r3, #0]
      *ip_ret = &arp_table[i].ipaddr;
     6ce:	f997 2017 	ldrsb.w	r2, [r7, #23]
     6d2:	4613      	mov	r3, r2
     6d4:	ea4f 0383 	mov.w	r3, r3, lsl #2
     6d8:	189b      	adds	r3, r3, r2
     6da:	ea4f 0383 	mov.w	r3, r3, lsl #2
     6de:	4a08      	ldr	r2, [pc, #32]	; (700 <etharp_find_addr+0x94>)
     6e0:	189b      	adds	r3, r3, r2
     6e2:	f103 0204 	add.w	r2, r3, #4
     6e6:	683b      	ldr	r3, [r7, #0]
     6e8:	601a      	str	r2, [r3, #0]
      return i;
     6ea:	7dfb      	ldrb	r3, [r7, #23]
     6ec:	e001      	b.n	6f2 <etharp_find_addr+0x86>
  }
  return -1;
     6ee:	f04f 03ff 	mov.w	r3, #255	; 0xff
     6f2:	b25b      	sxtb	r3, r3
}
     6f4:	4618      	mov	r0, r3
     6f6:	f107 0718 	add.w	r7, r7, #24
     6fa:	46bd      	mov	sp, r7
     6fc:	bd80      	pop	{r7, pc}
     6fe:	bf00      	nop
     700:	00000000 	.word	0x00000000
			700: R_ARM_ABS32	.bss

00000704 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
     704:	b580      	push	{r7, lr}
     706:	b086      	sub	sp, #24
     708:	af00      	add	r7, sp, #0
     70a:	6078      	str	r0, [r7, #4]
     70c:	6039      	str	r1, [r7, #0]
  struct eth_hdr *ethhdr;
  struct ip_hdr *iphdr;
  ip_addr_t iphdr_src;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
     70e:	687b      	ldr	r3, [r7, #4]
     710:	2b00      	cmp	r3, #0
     712:	d021      	beq.n	758 <etharp_ip_input+0x54>

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = (struct eth_hdr *)p->payload;
     714:	683b      	ldr	r3, [r7, #0]
     716:	685b      	ldr	r3, [r3, #4]
     718:	617b      	str	r3, [r7, #20]
  iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
     71a:	697b      	ldr	r3, [r7, #20]
     71c:	f103 030e 	add.w	r3, r3, #14
     720:	613b      	str	r3, [r7, #16]
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
     722:	693b      	ldr	r3, [r7, #16]
     724:	68db      	ldr	r3, [r3, #12]
     726:	60fb      	str	r3, [r7, #12]

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
     728:	68fa      	ldr	r2, [r7, #12]
     72a:	687b      	ldr	r3, [r7, #4]
     72c:	685b      	ldr	r3, [r3, #4]
     72e:	405a      	eors	r2, r3
     730:	687b      	ldr	r3, [r7, #4]
     732:	689b      	ldr	r3, [r3, #8]
     734:	ea02 0303 	and.w	r3, r2, r3
     738:	2b00      	cmp	r3, #0
     73a:	d10c      	bne.n	756 <etharp_ip_input+0x52>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
     73c:	697b      	ldr	r3, [r7, #20]
     73e:	f103 0306 	add.w	r3, r3, #6
     742:	f107 020c 	add.w	r2, r7, #12
     746:	6878      	ldr	r0, [r7, #4]
     748:	4611      	mov	r1, r2
     74a:	461a      	mov	r2, r3
     74c:	f04f 0302 	mov.w	r3, #2
     750:	f7ff fea2 	bl	498 <etharp_update_arp_entry>
     754:	e000      	b.n	758 <etharp_ip_input+0x54>
  ip_addr_copy(iphdr_src, iphdr->src);

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
     756:	bf00      	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
}
     758:	f107 0718 	add.w	r7, r7, #24
     75c:	46bd      	mov	sp, r7
     75e:	bd80      	pop	{r7, pc}

00000760 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
static void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
     760:	b580      	push	{r7, lr}
     762:	b08a      	sub	sp, #40	; 0x28
     764:	af00      	add	r7, sp, #0
     766:	60f8      	str	r0, [r7, #12]
     768:	60b9      	str	r1, [r7, #8]
     76a:	607a      	str	r2, [r7, #4]
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
     76c:	68fb      	ldr	r3, [r7, #12]
     76e:	2b00      	cmp	r3, #0
     770:	f000 80cf 	beq.w	912 <etharp_arp_input+0x1b2>

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
     774:	687b      	ldr	r3, [r7, #4]
     776:	895b      	ldrh	r3, [r3, #10]
     778:	2b29      	cmp	r3, #41	; 0x29
     77a:	d803      	bhi.n	784 <etharp_arp_input+0x24>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len,
      (s16_t)SIZEOF_ETHARP_PACKET));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
     77c:	6878      	ldr	r0, [r7, #4]
     77e:	f7ff fffe 	bl	0 <pbuf_free>
			77e: R_ARM_THM_CALL	pbuf_free
    return;
     782:	e0c6      	b.n	912 <etharp_arp_input+0x1b2>
  }

  ethhdr = (struct eth_hdr *)p->payload;
     784:	687b      	ldr	r3, [r7, #4]
     786:	685b      	ldr	r3, [r3, #4]
     788:	623b      	str	r3, [r7, #32]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
     78a:	6a3b      	ldr	r3, [r7, #32]
     78c:	f103 030e 	add.w	r3, r3, #14
     790:	61fb      	str	r3, [r7, #28]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
     792:	69fb      	ldr	r3, [r7, #28]
     794:	881b      	ldrh	r3, [r3, #0]
     796:	b29b      	uxth	r3, r3
     798:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
     79c:	d10c      	bne.n	7b8 <etharp_arp_input+0x58>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
     79e:	69fb      	ldr	r3, [r7, #28]
     7a0:	791b      	ldrb	r3, [r3, #4]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
     7a2:	2b06      	cmp	r3, #6
     7a4:	d108      	bne.n	7b8 <etharp_arp_input+0x58>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
     7a6:	69fb      	ldr	r3, [r7, #28]
     7a8:	795b      	ldrb	r3, [r3, #5]
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
     7aa:	2b04      	cmp	r3, #4
     7ac:	d104      	bne.n	7b8 <etharp_arp_input+0x58>
      (hdr->protolen != sizeof(ip_addr_t)) ||
      (hdr->proto != PP_HTONS(ETHTYPE_IP)))  {
     7ae:	69fb      	ldr	r3, [r7, #28]
     7b0:	885b      	ldrh	r3, [r3, #2]
     7b2:	b29b      	uxth	r3, r3
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
      (hdr->protolen != sizeof(ip_addr_t)) ||
     7b4:	2b08      	cmp	r3, #8
     7b6:	d003      	beq.n	7c0 <etharp_arp_input+0x60>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, hdr->hwlen, hdr->proto, hdr->protolen));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
     7b8:	6878      	ldr	r0, [r7, #4]
     7ba:	f7ff fffe 	bl	0 <pbuf_free>
			7ba: R_ARM_THM_CALL	pbuf_free
    return;
     7be:	e0a8      	b.n	912 <etharp_arp_input+0x1b2>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
     7c0:	69fb      	ldr	r3, [r7, #28]
     7c2:	f103 030e 	add.w	r3, r3, #14
     7c6:	f107 0218 	add.w	r2, r7, #24
     7ca:	4610      	mov	r0, r2
     7cc:	4619      	mov	r1, r3
     7ce:	f04f 0204 	mov.w	r2, #4
     7d2:	f7ff fffe 	bl	0 <memcpy>
			7d2: R_ARM_THM_CALL	memcpy
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
     7d6:	69fb      	ldr	r3, [r7, #28]
     7d8:	f103 0318 	add.w	r3, r3, #24
     7dc:	f107 0214 	add.w	r2, r7, #20
     7e0:	4610      	mov	r0, r2
     7e2:	4619      	mov	r1, r3
     7e4:	f04f 0204 	mov.w	r2, #4
     7e8:	f7ff fffe 	bl	0 <memcpy>
			7e8: R_ARM_THM_CALL	memcpy

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
     7ec:	68fb      	ldr	r3, [r7, #12]
     7ee:	f103 0304 	add.w	r3, r3, #4
     7f2:	2b00      	cmp	r3, #0
     7f4:	d003      	beq.n	7fe <etharp_arp_input+0x9e>
     7f6:	68fb      	ldr	r3, [r7, #12]
     7f8:	685b      	ldr	r3, [r3, #4]
     7fa:	2b00      	cmp	r3, #0
     7fc:	d104      	bne.n	808 <etharp_arp_input+0xa8>
    for_us = 0;
     7fe:	f04f 0300 	mov.w	r3, #0
     802:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
     806:	e008      	b.n	81a <etharp_arp_input+0xba>
  } else {
    /* ARP packet directed to us? */
    for_us = (u8_t)ip_addr_cmp(&dipaddr, &(netif->ip_addr));
     808:	697a      	ldr	r2, [r7, #20]
     80a:	68fb      	ldr	r3, [r7, #12]
     80c:	685b      	ldr	r3, [r3, #4]
     80e:	429a      	cmp	r2, r3
     810:	bf14      	ite	ne
     812:	2300      	movne	r3, #0
     814:	2301      	moveq	r3, #1
     816:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
     81a:	69fb      	ldr	r3, [r7, #28]
     81c:	f103 0208 	add.w	r2, r3, #8
     820:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
     824:	2b00      	cmp	r3, #0
     826:	d002      	beq.n	82e <etharp_arp_input+0xce>
     828:	f04f 0301 	mov.w	r3, #1
     82c:	e001      	b.n	832 <etharp_arp_input+0xd2>
     82e:	f04f 0302 	mov.w	r3, #2
     832:	f107 0118 	add.w	r1, r7, #24
     836:	68f8      	ldr	r0, [r7, #12]
     838:	f7ff fe2e 	bl	498 <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
     83c:	69fb      	ldr	r3, [r7, #28]
     83e:	88db      	ldrh	r3, [r3, #6]
     840:	b29b      	uxth	r3, r3
     842:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
     846:	d003      	beq.n	850 <etharp_arp_input+0xf0>
     848:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
     84c:	d057      	beq.n	8fe <etharp_arp_input+0x19e>
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
     84e:	e05d      	b.n	90c <etharp_arp_input+0x1ac>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
     850:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
     854:	2b00      	cmp	r3, #0
     856:	d04d      	beq.n	8f4 <etharp_arp_input+0x194>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
     858:	f04f 0002 	mov.w	r0, #2
     85c:	f7ff fffe 	bl	0 <lwip_htons>
			85c: R_ARM_THM_CALL	lwip_htons
     860:	4603      	mov	r3, r0
     862:	461a      	mov	r2, r3
     864:	69fb      	ldr	r3, [r7, #28]
     866:	80da      	strh	r2, [r3, #6]

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
     868:	69fb      	ldr	r3, [r7, #28]
     86a:	f103 0218 	add.w	r2, r3, #24
     86e:	69fb      	ldr	r3, [r7, #28]
     870:	f103 030e 	add.w	r3, r3, #14
     874:	4610      	mov	r0, r2
     876:	4619      	mov	r1, r3
     878:	f04f 0204 	mov.w	r2, #4
     87c:	f7ff fffe 	bl	0 <memcpy>
			87c: R_ARM_THM_CALL	memcpy
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
     880:	69fb      	ldr	r3, [r7, #28]
     882:	f103 020e 	add.w	r2, r3, #14
     886:	68fb      	ldr	r3, [r7, #12]
     888:	f103 0304 	add.w	r3, r3, #4
     88c:	4610      	mov	r0, r2
     88e:	4619      	mov	r1, r3
     890:	f04f 0204 	mov.w	r2, #4
     894:	f7ff fffe 	bl	0 <memcpy>
			894: R_ARM_THM_CALL	memcpy
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
     898:	69fb      	ldr	r3, [r7, #28]
     89a:	f103 0212 	add.w	r2, r3, #18
     89e:	69fb      	ldr	r3, [r7, #28]
     8a0:	f103 0308 	add.w	r3, r3, #8
     8a4:	4610      	mov	r0, r2
     8a6:	4619      	mov	r1, r3
     8a8:	f04f 0206 	mov.w	r2, #6
     8ac:	f7ff fffe 	bl	0 <memcpy>
			8ac: R_ARM_THM_CALL	memcpy
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
     8b0:	6a3a      	ldr	r2, [r7, #32]
     8b2:	69fb      	ldr	r3, [r7, #28]
     8b4:	f103 0308 	add.w	r3, r3, #8
     8b8:	4610      	mov	r0, r2
     8ba:	4619      	mov	r1, r3
     8bc:	f04f 0206 	mov.w	r2, #6
     8c0:	f7ff fffe 	bl	0 <memcpy>
			8c0: R_ARM_THM_CALL	memcpy
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
     8c4:	69fb      	ldr	r3, [r7, #28]
     8c6:	f103 0308 	add.w	r3, r3, #8
     8ca:	4618      	mov	r0, r3
     8cc:	68b9      	ldr	r1, [r7, #8]
     8ce:	f04f 0206 	mov.w	r2, #6
     8d2:	f7ff fffe 	bl	0 <memcpy>
			8d2: R_ARM_THM_CALL	memcpy
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
     8d6:	6a3b      	ldr	r3, [r7, #32]
     8d8:	f103 0306 	add.w	r3, r3, #6
     8dc:	4618      	mov	r0, r3
     8de:	68b9      	ldr	r1, [r7, #8]
     8e0:	f04f 0206 	mov.w	r2, #6
     8e4:	f7ff fffe 	bl	0 <memcpy>
			8e4: R_ARM_THM_CALL	memcpy

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
     8e8:	68fb      	ldr	r3, [r7, #12]
     8ea:	699b      	ldr	r3, [r3, #24]
     8ec:	68f8      	ldr	r0, [r7, #12]
     8ee:	6879      	ldr	r1, [r7, #4]
     8f0:	4798      	blx	r3
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
     8f2:	e00b      	b.n	90c <etharp_arp_input+0x1ac>
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
    /* we are not configured? */
    } else if (ip_addr_isany(&netif->ip_addr)) {
     8f4:	68fb      	ldr	r3, [r7, #12]
     8f6:	f103 0304 	add.w	r3, r3, #4
     8fa:	2b00      	cmp	r3, #0
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
     8fc:	e006      	b.n	90c <etharp_arp_input+0x1ac>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
     8fe:	f107 0318 	add.w	r3, r7, #24
     902:	68f8      	ldr	r0, [r7, #12]
     904:	4619      	mov	r1, r3
     906:	f7ff fffe 	bl	0 <dhcp_arp_reply>
			906: R_ARM_THM_CALL	dhcp_arp_reply
#endif /* (LWIP_DHCP && DHCP_DOES_ARP_CHECK) */
    break;
     90a:	bf00      	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
     90c:	6878      	ldr	r0, [r7, #4]
     90e:	f7ff fffe 	bl	0 <pbuf_free>
			90e: R_ARM_THM_CALL	pbuf_free
}
     912:	f107 0728 	add.w	r7, r7, #40	; 0x28
     916:	46bd      	mov	sp, r7
     918:	bd80      	pop	{r7, pc}
     91a:	bf00      	nop

0000091c <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
     91c:	b590      	push	{r4, r7, lr}
     91e:	b085      	sub	sp, #20
     920:	af00      	add	r7, sp, #0
     922:	60f8      	str	r0, [r7, #12]
     924:	60b9      	str	r1, [r7, #8]
     926:	4613      	mov	r3, r2
     928:	71fb      	strb	r3, [r7, #7]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
     92a:	79fa      	ldrb	r2, [r7, #7]
     92c:	4613      	mov	r3, r2
     92e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     932:	189b      	adds	r3, r3, r2
     934:	ea4f 0383 	mov.w	r3, r3, lsl #2
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
     938:	79fa      	ldrb	r2, [r7, #7]
     93a:	492b      	ldr	r1, [pc, #172]	; (9e8 <etharp_output_to_arp_index+0xcc>)
     93c:	4613      	mov	r3, r2
     93e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     942:	189b      	adds	r3, r3, r2
     944:	ea4f 0383 	mov.w	r3, r3, lsl #2
     948:	18cb      	adds	r3, r1, r3
     94a:	f103 0310 	add.w	r3, r3, #16
     94e:	789b      	ldrb	r3, [r3, #2]
     950:	2b02      	cmp	r3, #2
     952:	d12d      	bne.n	9b0 <etharp_output_to_arp_index+0x94>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
     954:	79fa      	ldrb	r2, [r7, #7]
     956:	4924      	ldr	r1, [pc, #144]	; (9e8 <etharp_output_to_arp_index+0xcc>)
     958:	4613      	mov	r3, r2
     95a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     95e:	189b      	adds	r3, r3, r2
     960:	ea4f 0383 	mov.w	r3, r3, lsl #2
     964:	18cb      	adds	r3, r1, r3
     966:	f103 0310 	add.w	r3, r3, #16
     96a:	78db      	ldrb	r3, [r3, #3]
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
     96c:	2be3      	cmp	r3, #227	; 0xe3
     96e:	d91f      	bls.n	9b0 <etharp_output_to_arp_index+0x94>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
     970:	79fa      	ldrb	r2, [r7, #7]
     972:	4613      	mov	r3, r2
     974:	ea4f 0383 	mov.w	r3, r3, lsl #2
     978:	189b      	adds	r3, r3, r2
     97a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     97e:	4a1a      	ldr	r2, [pc, #104]	; (9e8 <etharp_output_to_arp_index+0xcc>)
     980:	189b      	adds	r3, r3, r2
     982:	f103 0304 	add.w	r3, r3, #4
     986:	68f8      	ldr	r0, [r7, #12]
     988:	4619      	mov	r1, r3
     98a:	f7ff fffe 	bl	fa8 <etharp_request>
			98a: R_ARM_THM_CALL	etharp_request
     98e:	4603      	mov	r3, r0
     990:	2b00      	cmp	r3, #0
     992:	d10d      	bne.n	9b0 <etharp_output_to_arp_index+0x94>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
     994:	79fa      	ldrb	r2, [r7, #7]
     996:	4914      	ldr	r1, [pc, #80]	; (9e8 <etharp_output_to_arp_index+0xcc>)
     998:	4613      	mov	r3, r2
     99a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     99e:	189b      	adds	r3, r3, r2
     9a0:	ea4f 0383 	mov.w	r3, r3, lsl #2
     9a4:	18cb      	adds	r3, r1, r3
     9a6:	f103 0310 	add.w	r3, r3, #16
     9aa:	f04f 0203 	mov.w	r2, #3
     9ae:	709a      	strb	r2, [r3, #2]
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
     9b0:	68fb      	ldr	r3, [r7, #12]
     9b2:	f103 032f 	add.w	r3, r3, #47	; 0x2f
     9b6:	461c      	mov	r4, r3
    &arp_table[arp_idx].ethaddr);
     9b8:	79fa      	ldrb	r2, [r7, #7]
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
     9ba:	4613      	mov	r3, r2
     9bc:	ea4f 0383 	mov.w	r3, r3, lsl #2
     9c0:	189b      	adds	r3, r3, r2
     9c2:	ea4f 0383 	mov.w	r3, r3, lsl #2
     9c6:	f103 0208 	add.w	r2, r3, #8
     9ca:	4b07      	ldr	r3, [pc, #28]	; (9e8 <etharp_output_to_arp_index+0xcc>)
     9cc:	18d3      	adds	r3, r2, r3
     9ce:	f103 0304 	add.w	r3, r3, #4
     9d2:	68f8      	ldr	r0, [r7, #12]
     9d4:	68b9      	ldr	r1, [r7, #8]
     9d6:	4622      	mov	r2, r4
     9d8:	f7ff fd30 	bl	43c <etharp_send_ip>
     9dc:	4603      	mov	r3, r0
    &arp_table[arp_idx].ethaddr);
}
     9de:	4618      	mov	r0, r3
     9e0:	f107 0714 	add.w	r7, r7, #20
     9e4:	46bd      	mov	sp, r7
     9e6:	bd90      	pop	{r4, r7, pc}
     9e8:	00000000 	.word	0x00000000
			9e8: R_ARM_ABS32	.bss

000009ec <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
     9ec:	b580      	push	{r7, lr}
     9ee:	b088      	sub	sp, #32
     9f0:	af00      	add	r7, sp, #0
     9f2:	60f8      	str	r0, [r7, #12]
     9f4:	60b9      	str	r1, [r7, #8]
     9f6:	607a      	str	r2, [r7, #4]
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;
     9f8:	687b      	ldr	r3, [r7, #4]
     9fa:	61bb      	str	r3, [r7, #24]
  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
     9fc:	68b8      	ldr	r0, [r7, #8]
     9fe:	f04f 010e 	mov.w	r1, #14
     a02:	f7ff fffe 	bl	0 <pbuf_header>
			a02: R_ARM_THM_CALL	pbuf_header
     a06:	4603      	mov	r3, r0
     a08:	2b00      	cmp	r3, #0
     a0a:	d002      	beq.n	a12 <etharp_output+0x26>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
     a0c:	f04f 03fe 	mov.w	r3, #254	; 0xfe
     a10:	e0c9      	b.n	ba6 <etharp_output+0x1ba>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
     a12:	687b      	ldr	r3, [r7, #4]
     a14:	681b      	ldr	r3, [r3, #0]
     a16:	4618      	mov	r0, r3
     a18:	68f9      	ldr	r1, [r7, #12]
     a1a:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			a1a: R_ARM_THM_CALL	ip4_addr_isbroadcast
     a1e:	4603      	mov	r3, r0
     a20:	2b00      	cmp	r3, #0
     a22:	d002      	beq.n	a2a <etharp_output+0x3e>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
     a24:	4b63      	ldr	r3, [pc, #396]	; (bb4 <etharp_output+0x1c8>)
     a26:	61fb      	str	r3, [r7, #28]
     a28:	e0b3      	b.n	b92 <etharp_output+0x1a6>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
     a2a:	687b      	ldr	r3, [r7, #4]
     a2c:	681b      	ldr	r3, [r3, #0]
     a2e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
     a32:	2be0      	cmp	r3, #224	; 0xe0
     a34:	d11e      	bne.n	a74 <etharp_output+0x88>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
     a36:	f04f 0301 	mov.w	r3, #1
     a3a:	743b      	strb	r3, [r7, #16]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
     a3c:	f04f 0300 	mov.w	r3, #0
     a40:	747b      	strb	r3, [r7, #17]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
     a42:	f04f 035e 	mov.w	r3, #94	; 0x5e
     a46:	74bb      	strb	r3, [r7, #18]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
     a48:	687b      	ldr	r3, [r7, #4]
     a4a:	f103 0301 	add.w	r3, r3, #1
     a4e:	781b      	ldrb	r3, [r3, #0]
     a50:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     a54:	b2db      	uxtb	r3, r3
     a56:	74fb      	strb	r3, [r7, #19]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
     a58:	687b      	ldr	r3, [r7, #4]
     a5a:	f103 0302 	add.w	r3, r3, #2
     a5e:	781b      	ldrb	r3, [r3, #0]
     a60:	753b      	strb	r3, [r7, #20]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
     a62:	687b      	ldr	r3, [r7, #4]
     a64:	f103 0303 	add.w	r3, r3, #3
     a68:	781b      	ldrb	r3, [r3, #0]
     a6a:	757b      	strb	r3, [r7, #21]
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
     a6c:	f107 0310 	add.w	r3, r7, #16
     a70:	61fb      	str	r3, [r7, #28]
     a72:	e08e      	b.n	b92 <etharp_output+0x1a6>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
     a74:	687b      	ldr	r3, [r7, #4]
     a76:	681a      	ldr	r2, [r3, #0]
     a78:	68fb      	ldr	r3, [r7, #12]
     a7a:	685b      	ldr	r3, [r3, #4]
     a7c:	405a      	eors	r2, r3
     a7e:	68fb      	ldr	r3, [r7, #12]
     a80:	689b      	ldr	r3, [r3, #8]
     a82:	ea02 0303 	and.w	r3, r2, r3
     a86:	2b00      	cmp	r3, #0
     a88:	d01a      	beq.n	ac0 <etharp_output+0xd4>
        !ip_addr_islinklocal(ipaddr)) {
     a8a:	687b      	ldr	r3, [r7, #4]
     a8c:	681b      	ldr	r3, [r3, #0]
     a8e:	ea4f 4303 	mov.w	r3, r3, lsl #16
     a92:	ea4f 4313 	mov.w	r3, r3, lsr #16
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
     a96:	f64f 62a9 	movw	r2, #65193	; 0xfea9
     a9a:	4293      	cmp	r3, r2
     a9c:	d010      	beq.n	ac0 <etharp_output+0xd4>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
     a9e:	68fb      	ldr	r3, [r7, #12]
     aa0:	f103 030c 	add.w	r3, r3, #12
     aa4:	2b00      	cmp	r3, #0
     aa6:	d008      	beq.n	aba <etharp_output+0xce>
     aa8:	68fb      	ldr	r3, [r7, #12]
     aaa:	68db      	ldr	r3, [r3, #12]
     aac:	2b00      	cmp	r3, #0
     aae:	d004      	beq.n	aba <etharp_output+0xce>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
     ab0:	68fb      	ldr	r3, [r7, #12]
     ab2:	f103 030c 	add.w	r3, r3, #12
     ab6:	61bb      	str	r3, [r7, #24]
     ab8:	e002      	b.n	ac0 <etharp_output+0xd4>
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
     aba:	f04f 03fc 	mov.w	r3, #252	; 0xfc
     abe:	e072      	b.n	ba6 <etharp_output+0x1ba>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
     ac0:	4b3d      	ldr	r3, [pc, #244]	; (bb8 <etharp_output+0x1cc>)
     ac2:	781b      	ldrb	r3, [r3, #0]
     ac4:	461a      	mov	r2, r3
     ac6:	493d      	ldr	r1, [pc, #244]	; (bbc <etharp_output+0x1d0>)
     ac8:	4613      	mov	r3, r2
     aca:	ea4f 0383 	mov.w	r3, r3, lsl #2
     ace:	189b      	adds	r3, r3, r2
     ad0:	ea4f 0383 	mov.w	r3, r3, lsl #2
     ad4:	18cb      	adds	r3, r1, r3
     ad6:	f103 0310 	add.w	r3, r3, #16
     ada:	789b      	ldrb	r3, [r3, #2]
     adc:	2b01      	cmp	r3, #1
     ade:	d91a      	bls.n	b16 <etharp_output+0x12a>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
     ae0:	69bb      	ldr	r3, [r7, #24]
     ae2:	6819      	ldr	r1, [r3, #0]
     ae4:	4b34      	ldr	r3, [pc, #208]	; (bb8 <etharp_output+0x1cc>)
     ae6:	781b      	ldrb	r3, [r3, #0]
     ae8:	461a      	mov	r2, r3
     aea:	4834      	ldr	r0, [pc, #208]	; (bbc <etharp_output+0x1d0>)
     aec:	4613      	mov	r3, r2
     aee:	ea4f 0383 	mov.w	r3, r3, lsl #2
     af2:	189b      	adds	r3, r3, r2
     af4:	ea4f 0383 	mov.w	r3, r3, lsl #2
     af8:	18c3      	adds	r3, r0, r3
     afa:	f103 0304 	add.w	r3, r3, #4
     afe:	681b      	ldr	r3, [r3, #0]
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
     b00:	4299      	cmp	r1, r3
     b02:	d108      	bne.n	b16 <etharp_output+0x12a>
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
     b04:	4b2c      	ldr	r3, [pc, #176]	; (bb8 <etharp_output+0x1cc>)
     b06:	781b      	ldrb	r3, [r3, #0]
     b08:	68f8      	ldr	r0, [r7, #12]
     b0a:	68b9      	ldr	r1, [r7, #8]
     b0c:	461a      	mov	r2, r3
     b0e:	f7ff ff05 	bl	91c <etharp_output_to_arp_index>
     b12:	4603      	mov	r3, r0
     b14:	e047      	b.n	ba6 <etharp_output+0x1ba>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
     b16:	f04f 0300 	mov.w	r3, #0
     b1a:	75fb      	strb	r3, [r7, #23]
     b1c:	e02e      	b.n	b7c <etharp_output+0x190>
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
     b1e:	f997 2017 	ldrsb.w	r2, [r7, #23]
     b22:	4926      	ldr	r1, [pc, #152]	; (bbc <etharp_output+0x1d0>)
     b24:	4613      	mov	r3, r2
     b26:	ea4f 0383 	mov.w	r3, r3, lsl #2
     b2a:	189b      	adds	r3, r3, r2
     b2c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     b30:	18cb      	adds	r3, r1, r3
     b32:	f103 0310 	add.w	r3, r3, #16
     b36:	789b      	ldrb	r3, [r3, #2]
     b38:	2b01      	cmp	r3, #1
     b3a:	d91b      	bls.n	b74 <etharp_output+0x188>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
     b3c:	69bb      	ldr	r3, [r7, #24]
     b3e:	6819      	ldr	r1, [r3, #0]
     b40:	f997 2017 	ldrsb.w	r2, [r7, #23]
     b44:	481d      	ldr	r0, [pc, #116]	; (bbc <etharp_output+0x1d0>)
     b46:	4613      	mov	r3, r2
     b48:	ea4f 0383 	mov.w	r3, r3, lsl #2
     b4c:	189b      	adds	r3, r3, r2
     b4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     b52:	18c3      	adds	r3, r0, r3
     b54:	f103 0304 	add.w	r3, r3, #4
     b58:	681b      	ldr	r3, [r3, #0]
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
     b5a:	4299      	cmp	r1, r3
     b5c:	d10a      	bne.n	b74 <etharp_output+0x188>
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
     b5e:	7dfa      	ldrb	r2, [r7, #23]
     b60:	4b15      	ldr	r3, [pc, #84]	; (bb8 <etharp_output+0x1cc>)
     b62:	701a      	strb	r2, [r3, #0]
        return etharp_output_to_arp_index(netif, q, i);
     b64:	7dfb      	ldrb	r3, [r7, #23]
     b66:	68f8      	ldr	r0, [r7, #12]
     b68:	68b9      	ldr	r1, [r7, #8]
     b6a:	461a      	mov	r2, r3
     b6c:	f7ff fed6 	bl	91c <etharp_output_to_arp_index>
     b70:	4603      	mov	r3, r0
     b72:	e018      	b.n	ba6 <etharp_output+0x1ba>
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
     b74:	7dfb      	ldrb	r3, [r7, #23]
     b76:	f103 0301 	add.w	r3, r3, #1
     b7a:	75fb      	strb	r3, [r7, #23]
     b7c:	f997 3017 	ldrsb.w	r3, [r7, #23]
     b80:	2b09      	cmp	r3, #9
     b82:	ddcc      	ble.n	b1e <etharp_output+0x132>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
     b84:	68f8      	ldr	r0, [r7, #12]
     b86:	69b9      	ldr	r1, [r7, #24]
     b88:	68ba      	ldr	r2, [r7, #8]
     b8a:	f7ff fffe 	bl	bc0 <etharp_query>
			b8a: R_ARM_THM_CALL	etharp_query
     b8e:	4603      	mov	r3, r0
     b90:	e009      	b.n	ba6 <etharp_output+0x1ba>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
     b92:	68fb      	ldr	r3, [r7, #12]
     b94:	f103 032f 	add.w	r3, r3, #47	; 0x2f
     b98:	68f8      	ldr	r0, [r7, #12]
     b9a:	68b9      	ldr	r1, [r7, #8]
     b9c:	461a      	mov	r2, r3
     b9e:	69fb      	ldr	r3, [r7, #28]
     ba0:	f7ff fc4c 	bl	43c <etharp_send_ip>
     ba4:	4603      	mov	r3, r0
     ba6:	b25b      	sxtb	r3, r3
}
     ba8:	4618      	mov	r0, r3
     baa:	f107 0720 	add.w	r7, r7, #32
     bae:	46bd      	mov	sp, r7
     bb0:	bd80      	pop	{r7, pc}
     bb2:	bf00      	nop
     bb4:	00000000 	.word	0x00000000
			bb4: R_ARM_ABS32	ethbroadcast
     bb8:	000000c8 	.word	0x000000c8
			bb8: R_ARM_ABS32	.bss
     bbc:	00000000 	.word	0x00000000
			bbc: R_ARM_ABS32	.bss

00000bc0 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
     bc0:	b580      	push	{r7, lr}
     bc2:	b08c      	sub	sp, #48	; 0x30
     bc4:	af00      	add	r7, sp, #0
     bc6:	60f8      	str	r0, [r7, #12]
     bc8:	60b9      	str	r1, [r7, #8]
     bca:	607a      	str	r2, [r7, #4]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
     bcc:	68fb      	ldr	r3, [r7, #12]
     bce:	f103 032f 	add.w	r3, r3, #47	; 0x2f
     bd2:	61fb      	str	r3, [r7, #28]
  err_t result = ERR_MEM;
     bd4:	f04f 03ff 	mov.w	r3, #255	; 0xff
     bd8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
     bdc:	68bb      	ldr	r3, [r7, #8]
     bde:	681b      	ldr	r3, [r3, #0]
     be0:	4618      	mov	r0, r3
     be2:	68f9      	ldr	r1, [r7, #12]
     be4:	f7ff fffe 	bl	0 <ip4_addr_isbroadcast>
			be4: R_ARM_THM_CALL	ip4_addr_isbroadcast
     be8:	4603      	mov	r3, r0
     bea:	2b00      	cmp	r3, #0
     bec:	d10c      	bne.n	c08 <etharp_query+0x48>
      ip_addr_ismulticast(ipaddr) ||
     bee:	68bb      	ldr	r3, [r7, #8]
     bf0:	681b      	ldr	r3, [r3, #0]
     bf2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
     bf6:	2be0      	cmp	r3, #224	; 0xe0
     bf8:	d006      	beq.n	c08 <etharp_query+0x48>
      ip_addr_ismulticast(ipaddr) ||
     bfa:	68bb      	ldr	r3, [r7, #8]
     bfc:	2b00      	cmp	r3, #0
     bfe:	d003      	beq.n	c08 <etharp_query+0x48>
      ip_addr_isany(ipaddr)) {
     c00:	68bb      	ldr	r3, [r7, #8]
     c02:	681b      	ldr	r3, [r3, #0]
     c04:	2b00      	cmp	r3, #0
     c06:	d102      	bne.n	c0e <etharp_query+0x4e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
     c08:	f04f 03f2 	mov.w	r3, #242	; 0xf2
     c0c:	e12c      	b.n	e68 <etharp_query+0x2a8>
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
     c0e:	68b8      	ldr	r0, [r7, #8]
     c10:	f04f 0101 	mov.w	r1, #1
     c14:	f7ff fae0 	bl	1d8 <etharp_find_entry>
     c18:	4603      	mov	r3, r0
     c1a:	76fb      	strb	r3, [r7, #27]

  /* could not find or create entry? */
  if (i < 0) {
     c1c:	f997 301b 	ldrsb.w	r3, [r7, #27]
     c20:	2b00      	cmp	r3, #0
     c22:	da01      	bge.n	c28 <etharp_query+0x68>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
     c24:	7efb      	ldrb	r3, [r7, #27]
     c26:	e11f      	b.n	e68 <etharp_query+0x2a8>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
     c28:	f997 201b 	ldrsb.w	r2, [r7, #27]
     c2c:	4991      	ldr	r1, [pc, #580]	; (e74 <etharp_query+0x2b4>)
     c2e:	4613      	mov	r3, r2
     c30:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c34:	189b      	adds	r3, r3, r2
     c36:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c3a:	18cb      	adds	r3, r1, r3
     c3c:	f103 0310 	add.w	r3, r3, #16
     c40:	789b      	ldrb	r3, [r3, #2]
     c42:	2b00      	cmp	r3, #0
     c44:	d10e      	bne.n	c64 <etharp_query+0xa4>
    arp_table[i].state = ETHARP_STATE_PENDING;
     c46:	f997 201b 	ldrsb.w	r2, [r7, #27]
     c4a:	498a      	ldr	r1, [pc, #552]	; (e74 <etharp_query+0x2b4>)
     c4c:	4613      	mov	r3, r2
     c4e:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c52:	189b      	adds	r3, r3, r2
     c54:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c58:	18cb      	adds	r3, r1, r3
     c5a:	f103 0310 	add.w	r3, r3, #16
     c5e:	f04f 0201 	mov.w	r2, #1
     c62:	709a      	strb	r2, [r3, #2]
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
     c64:	f997 201b 	ldrsb.w	r2, [r7, #27]
     c68:	4982      	ldr	r1, [pc, #520]	; (e74 <etharp_query+0x2b4>)
     c6a:	4613      	mov	r3, r2
     c6c:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c70:	189b      	adds	r3, r3, r2
     c72:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c76:	18cb      	adds	r3, r1, r3
     c78:	f103 0310 	add.w	r3, r3, #16
     c7c:	789b      	ldrb	r3, [r3, #2]
     c7e:	2b01      	cmp	r3, #1
     c80:	d007      	beq.n	c92 <etharp_query+0xd2>
     c82:	f997 201b 	ldrsb.w	r2, [r7, #27]
     c86:	4613      	mov	r3, r2
     c88:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c8c:	189b      	adds	r3, r3, r2
     c8e:	ea4f 0383 	mov.w	r3, r3, lsl #2
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
     c92:	f997 201b 	ldrsb.w	r2, [r7, #27]
     c96:	4977      	ldr	r1, [pc, #476]	; (e74 <etharp_query+0x2b4>)
     c98:	4613      	mov	r3, r2
     c9a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     c9e:	189b      	adds	r3, r3, r2
     ca0:	ea4f 0383 	mov.w	r3, r3, lsl #2
     ca4:	18cb      	adds	r3, r1, r3
     ca6:	f103 0310 	add.w	r3, r3, #16
     caa:	789b      	ldrb	r3, [r3, #2]
     cac:	2b01      	cmp	r3, #1
     cae:	d002      	beq.n	cb6 <etharp_query+0xf6>
     cb0:	687b      	ldr	r3, [r7, #4]
     cb2:	2b00      	cmp	r3, #0
     cb4:	d10c      	bne.n	cd0 <etharp_query+0x110>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
     cb6:	68f8      	ldr	r0, [r7, #12]
     cb8:	68b9      	ldr	r1, [r7, #8]
     cba:	f7ff fffe 	bl	fa8 <etharp_request>
			cba: R_ARM_THM_CALL	etharp_request
     cbe:	4603      	mov	r3, r0
     cc0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
     cc4:	687b      	ldr	r3, [r7, #4]
     cc6:	2b00      	cmp	r3, #0
     cc8:	d102      	bne.n	cd0 <etharp_query+0x110>
      return result;
     cca:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
     cce:	e0cb      	b.n	e68 <etharp_query+0x2a8>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
     cd0:	f997 201b 	ldrsb.w	r2, [r7, #27]
     cd4:	4967      	ldr	r1, [pc, #412]	; (e74 <etharp_query+0x2b4>)
     cd6:	4613      	mov	r3, r2
     cd8:	ea4f 0383 	mov.w	r3, r3, lsl #2
     cdc:	189b      	adds	r3, r3, r2
     cde:	ea4f 0383 	mov.w	r3, r3, lsl #2
     ce2:	18cb      	adds	r3, r1, r3
     ce4:	f103 0310 	add.w	r3, r3, #16
     ce8:	789b      	ldrb	r3, [r3, #2]
     cea:	2b01      	cmp	r3, #1
     cec:	d919      	bls.n	d22 <etharp_query+0x162>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
     cee:	7efa      	ldrb	r2, [r7, #27]
     cf0:	4b61      	ldr	r3, [pc, #388]	; (e78 <etharp_query+0x2b8>)
     cf2:	701a      	strb	r2, [r3, #0]
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
     cf4:	f997 201b 	ldrsb.w	r2, [r7, #27]
     cf8:	4613      	mov	r3, r2
     cfa:	ea4f 0383 	mov.w	r3, r3, lsl #2
     cfe:	189b      	adds	r3, r3, r2
     d00:	ea4f 0383 	mov.w	r3, r3, lsl #2
     d04:	f103 0208 	add.w	r2, r3, #8
     d08:	4b5a      	ldr	r3, [pc, #360]	; (e74 <etharp_query+0x2b4>)
     d0a:	18d3      	adds	r3, r2, r3
     d0c:	f103 0304 	add.w	r3, r3, #4
     d10:	68f8      	ldr	r0, [r7, #12]
     d12:	6879      	ldr	r1, [r7, #4]
     d14:	69fa      	ldr	r2, [r7, #28]
     d16:	f7ff fb91 	bl	43c <etharp_send_ip>
     d1a:	4603      	mov	r3, r0
     d1c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
     d20:	e0a0      	b.n	e64 <etharp_query+0x2a4>
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
     d22:	f997 201b 	ldrsb.w	r2, [r7, #27]
     d26:	4953      	ldr	r1, [pc, #332]	; (e74 <etharp_query+0x2b4>)
     d28:	4613      	mov	r3, r2
     d2a:	ea4f 0383 	mov.w	r3, r3, lsl #2
     d2e:	189b      	adds	r3, r3, r2
     d30:	ea4f 0383 	mov.w	r3, r3, lsl #2
     d34:	18cb      	adds	r3, r1, r3
     d36:	f103 0310 	add.w	r3, r3, #16
     d3a:	789b      	ldrb	r3, [r3, #2]
     d3c:	2b01      	cmp	r3, #1
     d3e:	f040 8091 	bne.w	e64 <etharp_query+0x2a4>
    /* entry is still pending, queue the given packet 'q' */
    struct pbuf *p;
    int copy_needed = 0;
     d42:	f04f 0300 	mov.w	r3, #0
     d46:	627b      	str	r3, [r7, #36]	; 0x24
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
     d48:	687b      	ldr	r3, [r7, #4]
     d4a:	62bb      	str	r3, [r7, #40]	; 0x28
    while (p) {
     d4c:	e00f      	b.n	d6e <etharp_query+0x1ae>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
     d4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d50:	895a      	ldrh	r2, [r3, #10]
     d52:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d54:	891b      	ldrh	r3, [r3, #8]
     d56:	429a      	cmp	r2, r3
      if(p->type != PBUF_ROM) {
     d58:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d5a:	7b1b      	ldrb	r3, [r3, #12]
     d5c:	2b01      	cmp	r3, #1
     d5e:	d003      	beq.n	d68 <etharp_query+0x1a8>
        copy_needed = 1;
     d60:	f04f 0301 	mov.w	r3, #1
     d64:	627b      	str	r3, [r7, #36]	; 0x24
        break;
     d66:	e005      	b.n	d74 <etharp_query+0x1b4>
      }
      p = p->next;
     d68:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d6a:	681b      	ldr	r3, [r3, #0]
     d6c:	62bb      	str	r3, [r7, #40]	; 0x28
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
     d6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d70:	2b00      	cmp	r3, #0
     d72:	d1ec      	bne.n	d4e <etharp_query+0x18e>
        copy_needed = 1;
        break;
      }
      p = p->next;
    }
    if(copy_needed) {
     d74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     d76:	2b00      	cmp	r3, #0
     d78:	d01a      	beq.n	db0 <etharp_query+0x1f0>
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
     d7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d7c:	891b      	ldrh	r3, [r3, #8]
     d7e:	f04f 0003 	mov.w	r0, #3
     d82:	4619      	mov	r1, r3
     d84:	f04f 0200 	mov.w	r2, #0
     d88:	f7ff fffe 	bl	0 <pbuf_alloc>
			d88: R_ARM_THM_CALL	pbuf_alloc
     d8c:	62b8      	str	r0, [r7, #40]	; 0x28
      if(p != NULL) {
     d8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
     d90:	2b00      	cmp	r3, #0
     d92:	d012      	beq.n	dba <etharp_query+0x1fa>
        if (pbuf_copy(p, q) != ERR_OK) {
     d94:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     d96:	6879      	ldr	r1, [r7, #4]
     d98:	f7ff fffe 	bl	0 <pbuf_copy>
			d98: R_ARM_THM_CALL	pbuf_copy
     d9c:	4603      	mov	r3, r0
     d9e:	2b00      	cmp	r3, #0
     da0:	d00b      	beq.n	dba <etharp_query+0x1fa>
          pbuf_free(p);
     da2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     da4:	f7ff fffe 	bl	0 <pbuf_free>
			da4: R_ARM_THM_CALL	pbuf_free
          p = NULL;
     da8:	f04f 0300 	mov.w	r3, #0
     dac:	62bb      	str	r3, [r7, #40]	; 0x28
     dae:	e004      	b.n	dba <etharp_query+0x1fa>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
     db0:	687b      	ldr	r3, [r7, #4]
     db2:	62bb      	str	r3, [r7, #40]	; 0x28
      pbuf_ref(p);
     db4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     db6:	f7ff fffe 	bl	0 <pbuf_ref>
			db6: R_ARM_THM_CALL	pbuf_ref
    }
    /* packet could be taken over? */
    if (p != NULL) {
     dba:	6abb      	ldr	r3, [r7, #40]	; 0x28
     dbc:	2b00      	cmp	r3, #0
     dbe:	d04d      	beq.n	e5c <etharp_query+0x29c>
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
     dc0:	f04f 000a 	mov.w	r0, #10
     dc4:	f7ff fffe 	bl	0 <memp_malloc>
			dc4: R_ARM_THM_CALL	memp_malloc
     dc8:	4603      	mov	r3, r0
     dca:	617b      	str	r3, [r7, #20]
      if (new_entry != NULL) {
     dcc:	697b      	ldr	r3, [r7, #20]
     dce:	2b00      	cmp	r3, #0
     dd0:	d03c      	beq.n	e4c <etharp_query+0x28c>
        new_entry->next = 0;
     dd2:	697b      	ldr	r3, [r7, #20]
     dd4:	f04f 0200 	mov.w	r2, #0
     dd8:	601a      	str	r2, [r3, #0]
        new_entry->p = p;
     dda:	697b      	ldr	r3, [r7, #20]
     ddc:	6aba      	ldr	r2, [r7, #40]	; 0x28
     dde:	605a      	str	r2, [r3, #4]
        if(arp_table[i].q != NULL) {
     de0:	f997 201b 	ldrsb.w	r2, [r7, #27]
     de4:	4923      	ldr	r1, [pc, #140]	; (e74 <etharp_query+0x2b4>)
     de6:	4613      	mov	r3, r2
     de8:	ea4f 0383 	mov.w	r3, r3, lsl #2
     dec:	189b      	adds	r3, r3, r2
     dee:	ea4f 0383 	mov.w	r3, r3, lsl #2
     df2:	18cb      	adds	r3, r1, r3
     df4:	681b      	ldr	r3, [r3, #0]
     df6:	2b00      	cmp	r3, #0
     df8:	d017      	beq.n	e2a <etharp_query+0x26a>
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
     dfa:	f997 201b 	ldrsb.w	r2, [r7, #27]
     dfe:	491d      	ldr	r1, [pc, #116]	; (e74 <etharp_query+0x2b4>)
     e00:	4613      	mov	r3, r2
     e02:	ea4f 0383 	mov.w	r3, r3, lsl #2
     e06:	189b      	adds	r3, r3, r2
     e08:	ea4f 0383 	mov.w	r3, r3, lsl #2
     e0c:	18cb      	adds	r3, r1, r3
     e0e:	681b      	ldr	r3, [r3, #0]
     e10:	623b      	str	r3, [r7, #32]
          while (r->next != NULL) {
     e12:	e002      	b.n	e1a <etharp_query+0x25a>
            r = r->next;
     e14:	6a3b      	ldr	r3, [r7, #32]
     e16:	681b      	ldr	r3, [r3, #0]
     e18:	623b      	str	r3, [r7, #32]
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
     e1a:	6a3b      	ldr	r3, [r7, #32]
     e1c:	681b      	ldr	r3, [r3, #0]
     e1e:	2b00      	cmp	r3, #0
     e20:	d1f8      	bne.n	e14 <etharp_query+0x254>
            r = r->next;
          }
          r->next = new_entry;
     e22:	6a3b      	ldr	r3, [r7, #32]
     e24:	697a      	ldr	r2, [r7, #20]
     e26:	601a      	str	r2, [r3, #0]
     e28:	e00b      	b.n	e42 <etharp_query+0x282>
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
     e2a:	f997 201b 	ldrsb.w	r2, [r7, #27]
     e2e:	4911      	ldr	r1, [pc, #68]	; (e74 <etharp_query+0x2b4>)
     e30:	4613      	mov	r3, r2
     e32:	ea4f 0383 	mov.w	r3, r3, lsl #2
     e36:	189b      	adds	r3, r3, r2
     e38:	ea4f 0383 	mov.w	r3, r3, lsl #2
     e3c:	18cb      	adds	r3, r1, r3
     e3e:	697a      	ldr	r2, [r7, #20]
     e40:	601a      	str	r2, [r3, #0]
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
     e42:	f04f 0300 	mov.w	r3, #0
     e46:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
     e4a:	e00b      	b.n	e64 <etharp_query+0x2a4>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
     e4c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
     e4e:	f7ff fffe 	bl	0 <pbuf_free>
			e4e: R_ARM_THM_CALL	pbuf_free
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
     e52:	f04f 03ff 	mov.w	r3, #255	; 0xff
     e56:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
     e5a:	e003      	b.n	e64 <etharp_query+0x2a4>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
     e5c:	f04f 03ff 	mov.w	r3, #255	; 0xff
     e60:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    }
  }
  return result;
     e64:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
     e68:	b25b      	sxtb	r3, r3
}
     e6a:	4618      	mov	r0, r3
     e6c:	f107 0730 	add.w	r7, r7, #48	; 0x30
     e70:	46bd      	mov	sp, r7
     e72:	bd80      	pop	{r7, pc}
     e74:	00000000 	.word	0x00000000
			e74: R_ARM_ABS32	.bss
     e78:	000000c8 	.word	0x000000c8
			e78: R_ARM_ABS32	.bss

00000e7c <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const ip_addr_t *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const ip_addr_t *ipdst_addr,
           const u16_t opcode)
{
     e7c:	b580      	push	{r7, lr}
     e7e:	b088      	sub	sp, #32
     e80:	af00      	add	r7, sp, #0
     e82:	60f8      	str	r0, [r7, #12]
     e84:	60b9      	str	r1, [r7, #8]
     e86:	607a      	str	r2, [r7, #4]
     e88:	603b      	str	r3, [r7, #0]
  struct pbuf *p;
  err_t result = ERR_OK;
     e8a:	f04f 0300 	mov.w	r3, #0
     e8e:	77fb      	strb	r3, [r7, #31]
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
     e90:	f04f 0003 	mov.w	r0, #3
     e94:	f04f 012a 	mov.w	r1, #42	; 0x2a
     e98:	f04f 0200 	mov.w	r2, #0
     e9c:	f7ff fffe 	bl	0 <pbuf_alloc>
			e9c: R_ARM_THM_CALL	pbuf_alloc
     ea0:	61b8      	str	r0, [r7, #24]
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
     ea2:	69bb      	ldr	r3, [r7, #24]
     ea4:	2b00      	cmp	r3, #0
     ea6:	d102      	bne.n	eae <etharp_raw+0x32>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
     ea8:	f04f 03ff 	mov.w	r3, #255	; 0xff
     eac:	e075      	b.n	f9a <etharp_raw+0x11e>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
     eae:	69bb      	ldr	r3, [r7, #24]
     eb0:	685b      	ldr	r3, [r3, #4]
     eb2:	617b      	str	r3, [r7, #20]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
     eb4:	697b      	ldr	r3, [r7, #20]
     eb6:	f103 030e 	add.w	r3, r3, #14
     eba:	613b      	str	r3, [r7, #16]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
     ebc:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
     ebe:	4618      	mov	r0, r3
     ec0:	f7ff fffe 	bl	0 <lwip_htons>
			ec0: R_ARM_THM_CALL	lwip_htons
     ec4:	4603      	mov	r3, r0
     ec6:	461a      	mov	r2, r3
     ec8:	693b      	ldr	r3, [r7, #16]
     eca:	80da      	strh	r2, [r3, #6]
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
     ecc:	693b      	ldr	r3, [r7, #16]
     ece:	f103 0308 	add.w	r3, r3, #8
     ed2:	4618      	mov	r0, r3
     ed4:	6839      	ldr	r1, [r7, #0]
     ed6:	f04f 0206 	mov.w	r2, #6
     eda:	f7ff fffe 	bl	0 <memcpy>
			eda: R_ARM_THM_CALL	memcpy
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
     ede:	693b      	ldr	r3, [r7, #16]
     ee0:	f103 0312 	add.w	r3, r3, #18
     ee4:	4618      	mov	r0, r3
     ee6:	6af9      	ldr	r1, [r7, #44]	; 0x2c
     ee8:	f04f 0206 	mov.w	r2, #6
     eec:	f7ff fffe 	bl	0 <memcpy>
			eec: R_ARM_THM_CALL	memcpy
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
     ef0:	697b      	ldr	r3, [r7, #20]
     ef2:	4618      	mov	r0, r3
     ef4:	6879      	ldr	r1, [r7, #4]
     ef6:	f04f 0206 	mov.w	r2, #6
     efa:	f7ff fffe 	bl	0 <memcpy>
			efa: R_ARM_THM_CALL	memcpy
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
     efe:	697b      	ldr	r3, [r7, #20]
     f00:	f103 0306 	add.w	r3, r3, #6
     f04:	4618      	mov	r0, r3
     f06:	68b9      	ldr	r1, [r7, #8]
     f08:	f04f 0206 	mov.w	r2, #6
     f0c:	f7ff fffe 	bl	0 <memcpy>
			f0c: R_ARM_THM_CALL	memcpy
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
     f10:	693b      	ldr	r3, [r7, #16]
     f12:	f103 030e 	add.w	r3, r3, #14
     f16:	4618      	mov	r0, r3
     f18:	6ab9      	ldr	r1, [r7, #40]	; 0x28
     f1a:	f04f 0204 	mov.w	r2, #4
     f1e:	f7ff fffe 	bl	0 <memcpy>
			f1e: R_ARM_THM_CALL	memcpy
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
     f22:	693b      	ldr	r3, [r7, #16]
     f24:	f103 0318 	add.w	r3, r3, #24
     f28:	4618      	mov	r0, r3
     f2a:	6b39      	ldr	r1, [r7, #48]	; 0x30
     f2c:	f04f 0204 	mov.w	r2, #4
     f30:	f7ff fffe 	bl	0 <memcpy>
			f30: R_ARM_THM_CALL	memcpy

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
     f34:	693b      	ldr	r3, [r7, #16]
     f36:	f04f 0200 	mov.w	r2, #0
     f3a:	701a      	strb	r2, [r3, #0]
     f3c:	f04f 0200 	mov.w	r2, #0
     f40:	f042 0201 	orr.w	r2, r2, #1
     f44:	705a      	strb	r2, [r3, #1]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
     f46:	693b      	ldr	r3, [r7, #16]
     f48:	f04f 0200 	mov.w	r2, #0
     f4c:	f042 0208 	orr.w	r2, r2, #8
     f50:	709a      	strb	r2, [r3, #2]
     f52:	f04f 0200 	mov.w	r2, #0
     f56:	70da      	strb	r2, [r3, #3]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
     f58:	693b      	ldr	r3, [r7, #16]
     f5a:	f04f 0206 	mov.w	r2, #6
     f5e:	711a      	strb	r2, [r3, #4]
  hdr->protolen = sizeof(ip_addr_t);
     f60:	693b      	ldr	r3, [r7, #16]
     f62:	f04f 0204 	mov.w	r2, #4
     f66:	715a      	strb	r2, [r3, #5]

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
     f68:	697b      	ldr	r3, [r7, #20]
     f6a:	f04f 0200 	mov.w	r2, #0
     f6e:	f042 0208 	orr.w	r2, r2, #8
     f72:	731a      	strb	r2, [r3, #12]
     f74:	f04f 0200 	mov.w	r2, #0
     f78:	f042 0206 	orr.w	r2, r2, #6
     f7c:	735a      	strb	r2, [r3, #13]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
     f7e:	68fb      	ldr	r3, [r7, #12]
     f80:	699b      	ldr	r3, [r3, #24]
     f82:	68f8      	ldr	r0, [r7, #12]
     f84:	69b9      	ldr	r1, [r7, #24]
     f86:	4798      	blx	r3
     f88:	4603      	mov	r3, r0
     f8a:	77fb      	strb	r3, [r7, #31]
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
     f8c:	69b8      	ldr	r0, [r7, #24]
     f8e:	f7ff fffe 	bl	0 <pbuf_free>
			f8e: R_ARM_THM_CALL	pbuf_free
  p = NULL;
     f92:	f04f 0300 	mov.w	r3, #0
     f96:	61bb      	str	r3, [r7, #24]
  /* could not allocate pbuf for ARP request */

  return result;
     f98:	7ffb      	ldrb	r3, [r7, #31]
     f9a:	b25b      	sxtb	r3, r3
}
     f9c:	4618      	mov	r0, r3
     f9e:	f107 0720 	add.w	r7, r7, #32
     fa2:	46bd      	mov	sp, r7
     fa4:	bd80      	pop	{r7, pc}
     fa6:	bf00      	nop

00000fa8 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
     fa8:	b580      	push	{r7, lr}
     faa:	b086      	sub	sp, #24
     fac:	af04      	add	r7, sp, #16
     fae:	6078      	str	r0, [r7, #4]
     fb0:	6039      	str	r1, [r7, #0]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
     fb2:	687b      	ldr	r3, [r7, #4]
     fb4:	f103 032f 	add.w	r3, r3, #47	; 0x2f
     fb8:	461a      	mov	r2, r3
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
     fba:	687b      	ldr	r3, [r7, #4]
     fbc:	f103 032f 	add.w	r3, r3, #47	; 0x2f
     fc0:	6879      	ldr	r1, [r7, #4]
     fc2:	f101 0104 	add.w	r1, r1, #4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
     fc6:	9100      	str	r1, [sp, #0]
     fc8:	4908      	ldr	r1, [pc, #32]	; (fec <etharp_request+0x44>)
     fca:	9101      	str	r1, [sp, #4]
     fcc:	6839      	ldr	r1, [r7, #0]
     fce:	9102      	str	r1, [sp, #8]
     fd0:	f04f 0101 	mov.w	r1, #1
     fd4:	9103      	str	r1, [sp, #12]
     fd6:	6878      	ldr	r0, [r7, #4]
     fd8:	4611      	mov	r1, r2
     fda:	4a05      	ldr	r2, [pc, #20]	; (ff0 <etharp_request+0x48>)
     fdc:	f7ff ff4e 	bl	e7c <etharp_raw>
     fe0:	4603      	mov	r3, r0
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
     fe2:	4618      	mov	r0, r3
     fe4:	f107 0708 	add.w	r7, r7, #8
     fe8:	46bd      	mov	sp, r7
     fea:	bd80      	pop	{r7, pc}
	...
			fec: R_ARM_ABS32	ethzero
			ff0: R_ARM_ABS32	ethbroadcast

00000ff4 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
     ff4:	b580      	push	{r7, lr}
     ff6:	b086      	sub	sp, #24
     ff8:	af00      	add	r7, sp, #0
     ffa:	6078      	str	r0, [r7, #4]
     ffc:	6039      	str	r1, [r7, #0]
  struct eth_hdr* ethhdr;
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
     ffe:	f04f 030e 	mov.w	r3, #14
    1002:	82fb      	strh	r3, [r7, #22]
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
    1004:	687b      	ldr	r3, [r7, #4]
    1006:	895b      	ldrh	r3, [r3, #10]
    1008:	2b0e      	cmp	r3, #14
    100a:	d96c      	bls.n	10e6 <ethernet_input+0xf2>
    ETHARP_STATS_INC(etharp.drop);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
    100c:	687b      	ldr	r3, [r7, #4]
    100e:	685b      	ldr	r3, [r3, #4]
    1010:	613b      	str	r3, [r7, #16]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
    1012:	693b      	ldr	r3, [r7, #16]
    1014:	7b1a      	ldrb	r2, [r3, #12]
    1016:	7b5b      	ldrb	r3, [r3, #13]
    1018:	ea4f 2303 	mov.w	r3, r3, lsl #8
    101c:	4313      	orrs	r3, r2
    101e:	81fb      	strh	r3, [r7, #14]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    1020:	693b      	ldr	r3, [r7, #16]
    1022:	781b      	ldrb	r3, [r3, #0]
    1024:	f003 0301 	and.w	r3, r3, #1
    1028:	b2db      	uxtb	r3, r3
    102a:	2b00      	cmp	r3, #0
    102c:	d024      	beq.n	1078 <ethernet_input+0x84>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
    102e:	693b      	ldr	r3, [r7, #16]
    1030:	781b      	ldrb	r3, [r3, #0]
    1032:	2b01      	cmp	r3, #1
    1034:	d10f      	bne.n	1056 <ethernet_input+0x62>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
    1036:	693b      	ldr	r3, [r7, #16]
    1038:	785b      	ldrb	r3, [r3, #1]
    103a:	2b00      	cmp	r3, #0
    103c:	d11c      	bne.n	1078 <ethernet_input+0x84>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
    103e:	693b      	ldr	r3, [r7, #16]
    1040:	789b      	ldrb	r3, [r3, #2]
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
    1042:	2b5e      	cmp	r3, #94	; 0x5e
    1044:	d118      	bne.n	1078 <ethernet_input+0x84>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
    1046:	687b      	ldr	r3, [r7, #4]
    1048:	7b5b      	ldrb	r3, [r3, #13]
    104a:	f043 0310 	orr.w	r3, r3, #16
    104e:	b2da      	uxtb	r2, r3
    1050:	687b      	ldr	r3, [r7, #4]
    1052:	735a      	strb	r2, [r3, #13]
    1054:	e010      	b.n	1078 <ethernet_input+0x84>
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
    1056:	693b      	ldr	r3, [r7, #16]
    1058:	4618      	mov	r0, r3
    105a:	492c      	ldr	r1, [pc, #176]	; (110c <ethernet_input+0x118>)
    105c:	f04f 0206 	mov.w	r2, #6
    1060:	f7ff fffe 	bl	0 <memcmp>
			1060: R_ARM_THM_CALL	memcmp
    1064:	4603      	mov	r3, r0
    1066:	2b00      	cmp	r3, #0
    1068:	d106      	bne.n	1078 <ethernet_input+0x84>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
    106a:	687b      	ldr	r3, [r7, #4]
    106c:	7b5b      	ldrb	r3, [r3, #13]
    106e:	f043 0308 	orr.w	r3, r3, #8
    1072:	b2da      	uxtb	r2, r3
    1074:	687b      	ldr	r3, [r7, #4]
    1076:	735a      	strb	r2, [r3, #13]
    }
  }

  switch (type) {
    1078:	89fb      	ldrh	r3, [r7, #14]
    107a:	2b08      	cmp	r3, #8
    107c:	d003      	beq.n	1086 <ethernet_input+0x92>
    107e:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
    1082:	d01d      	beq.n	10c0 <ethernet_input+0xcc>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      goto free_and_return;
    1084:	e036      	b.n	10f4 <ethernet_input+0x100>

  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    1086:	683b      	ldr	r3, [r7, #0]
    1088:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
    108c:	f003 0320 	and.w	r3, r3, #32
    1090:	2b00      	cmp	r3, #0
    1092:	d02a      	beq.n	10ea <ethernet_input+0xf6>
        goto free_and_return;
      }
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
    1094:	6838      	ldr	r0, [r7, #0]
    1096:	6879      	ldr	r1, [r7, #4]
    1098:	f7ff fb34 	bl	704 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
    109c:	8afb      	ldrh	r3, [r7, #22]
    109e:	f1c3 0300 	rsb	r3, r3, #0
    10a2:	b29b      	uxth	r3, r3
    10a4:	b29b      	uxth	r3, r3
    10a6:	b21b      	sxth	r3, r3
    10a8:	6878      	ldr	r0, [r7, #4]
    10aa:	4619      	mov	r1, r3
    10ac:	f7ff fffe 	bl	0 <pbuf_header>
			10ac: R_ARM_THM_CALL	pbuf_header
    10b0:	4603      	mov	r3, r0
    10b2:	2b00      	cmp	r3, #0
    10b4:	d11b      	bne.n	10ee <ethernet_input+0xfa>
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
    10b6:	6878      	ldr	r0, [r7, #4]
    10b8:	6839      	ldr	r1, [r7, #0]
    10ba:	f7ff fffe 	bl	0 <ip_input>
			10ba: R_ARM_THM_CALL	ip_input
      }
      break;
    10be:	e00f      	b.n	10e0 <ethernet_input+0xec>
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
    10c0:	683b      	ldr	r3, [r7, #0]
    10c2:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
    10c6:	f003 0320 	and.w	r3, r3, #32
    10ca:	2b00      	cmp	r3, #0
    10cc:	d011      	beq.n	10f2 <ethernet_input+0xfe>
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
    10ce:	683b      	ldr	r3, [r7, #0]
    10d0:	f103 032f 	add.w	r3, r3, #47	; 0x2f
    10d4:	6838      	ldr	r0, [r7, #0]
    10d6:	4619      	mov	r1, r3
    10d8:	687a      	ldr	r2, [r7, #4]
    10da:	f7ff fb41 	bl	760 <etharp_arp_input>
      break;
    10de:	bf00      	nop
      goto free_and_return;
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
    10e0:	f04f 0300 	mov.w	r3, #0
    10e4:	e00b      	b.n	10fe <ethernet_input+0x10a>

  if (p->len <= SIZEOF_ETH_HDR) {
    /* a packet with only an ethernet header (or less) is not valid for us */
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    goto free_and_return;
    10e6:	bf00      	nop
    10e8:	e004      	b.n	10f4 <ethernet_input+0x100>
  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
    10ea:	bf00      	nop
    10ec:	e002      	b.n	10f4 <ethernet_input+0x100>
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
    10ee:	bf00      	nop
    10f0:	e000      	b.n	10f4 <ethernet_input+0x100>
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
    10f2:	bf00      	nop
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
    10f4:	6878      	ldr	r0, [r7, #4]
    10f6:	f7ff fffe 	bl	0 <pbuf_free>
			10f6: R_ARM_THM_CALL	pbuf_free
  return ERR_OK;
    10fa:	f04f 0300 	mov.w	r3, #0
    10fe:	b25b      	sxtb	r3, r3
}
    1100:	4618      	mov	r0, r3
    1102:	f107 0718 	add.w	r7, r7, #24
    1106:	46bd      	mov	sp, r7
    1108:	bd80      	pop	{r7, pc}
    110a:	bf00      	nop
    110c:	00000000 	.word	0x00000000
			110c: R_ARM_ABS32	ethbroadcast
