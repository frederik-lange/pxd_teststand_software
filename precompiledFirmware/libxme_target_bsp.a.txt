In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libxme_target_bsp.a:

enet_arch.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 364812 Jul 30 19:07 2021 enet_arch.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000434  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000468  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000468  2**0
                  ALLOC
  3 .debug_abbrev 0000017b  00000000  00000000  00000468  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000880  00000000  00000000  000005e3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000704  00000000  00000000  00000e63  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 000557f1  00000000  00000000  00001567  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000172  00000000  00000000  00056d58  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 000000bd  00000000  00000000  00056eca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000119  00000000  00000000  00056f87  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  000570a0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000c2b  00000000  00000000  000570c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00057ceb  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00057d16  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000e4  00000000  00000000  00057d48  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 enet_arch.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000170 bsp_eth_gpio_init
00000000         *UND*	00000000 GPIO_PinRemapConfig
00000000         *UND*	00000000 RCC_APB2PeriphClockCmd
00000000         *UND*	00000000 GPIO_Init
00000170 g     F .text	0000001a Set_MAC_Address
00000000         *UND*	00000000 ETH_MACAddressConfig
0000018c g     F .text	0000001e ETH_driver_init
00000000         *UND*	00000000 RCC_AHBPeriphClockCmd
000002f0 g     F .text	00000044 NVIC_Configuration
000001bc g     F .text	00000134 Ethernet_Configuration
000001ac g     F .text	00000010 bsp_eth_phy_addr
00000000         *UND*	00000000 GPIO_ETH_MediaInterfaceConfig
00000000         *UND*	00000000 RCC_PLL3Config
00000000         *UND*	00000000 RCC_PLL3Cmd
00000000         *UND*	00000000 RCC_GetFlagStatus
00000000         *UND*	00000000 RCC_MCOConfig
00000000         *UND*	00000000 ETH_DeInit
00000000         *UND*	00000000 ETH_SoftwareReset
00000000         *UND*	00000000 ETH_GetSoftwareResetStatus
00000000         *UND*	00000000 ETH_StructInit
00000000         *UND*	00000000 ETH_Init
00000000         *UND*	00000000 ETH_DMAITConfig
00000000         *UND*	00000000 NVIC_SetVectorTable
00000000         *UND*	00000000 NVIC_PriorityGroupConfig
00000000         *UND*	00000000 NVIC_Init
00000334 g     F .text	000000fe NVIC_Configuration_Emergency_Bits
00000000         *UND*	00000000 GPIO_EXTILineConfig
00000000         *UND*	00000000 EXTI_Init



Disassembly of section .text:

00000000 <bsp_eth_gpio_init>:
/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
#if XME_BSP_STM32_ETHERNET_RMII
void bsp_eth_gpio_init (void)
{
   0:	b580      	push	{r7, lr}
   2:	b082      	sub	sp, #8
   4:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

#if XME_BSP_STM32_ETHERNET_AF_REMAPPED
	GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE);
   6:	f04f 1020 	mov.w	r0, #2097184	; 0x200020
   a:	f04f 0101 	mov.w	r1, #1
   e:	f7ff fffe 	bl	0 <GPIO_PinRemapConfig>
			e: R_ARM_THM_CALL	GPIO_PinRemapConfig

#if XME_BSP_STM32_ETHERNET_AF_DEFAULT
	GPIO_PinRemapConfig(GPIO_Remap_ETH, DISABLE);
#endif // #if XME_BSP_STM32_ETHERNET_AF_DEFAULT

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC |
  12:	f04f 003d 	mov.w	r0, #61	; 0x3d
  16:	f04f 0101 	mov.w	r1, #1
  1a:	f7ff fffe 	bl	0 <RCC_APB2PeriphClockCmd>
			1a: R_ARM_THM_CALL	RCC_APB2PeriphClockCmd
	                       RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);

	// ETH_MDC
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_MDC_PIN;
  1e:	f04f 0302 	mov.w	r3, #2
  22:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  24:	f04f 0303 	mov.w	r3, #3
  28:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  2a:	f04f 0318 	mov.w	r3, #24
  2e:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_MDC_PORT, &GPIO_InitStructure);
  30:	f107 0304 	add.w	r3, r7, #4
  34:	484a      	ldr	r0, [pc, #296]	; (160 <bsp_eth_gpio_init+0x160>)
  36:	4619      	mov	r1, r3
  38:	f7ff fffe 	bl	0 <GPIO_Init>
			38: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_REF_CLK
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_REFCLK_PIN;
  3c:	f04f 0302 	mov.w	r3, #2
  40:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  42:	f04f 0303 	mov.w	r3, #3
  46:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  48:	f04f 0304 	mov.w	r3, #4
  4c:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_REFCLK_PORT, &GPIO_InitStructure);
  4e:	f107 0304 	add.w	r3, r7, #4
  52:	4844      	ldr	r0, [pc, #272]	; (164 <bsp_eth_gpio_init+0x164>)
  54:	4619      	mov	r1, r3
  56:	f7ff fffe 	bl	0 <GPIO_Init>
			56: R_ARM_THM_CALL	GPIO_Init

	// ETH_MDIO
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_MDIO_PIN;
  5a:	f04f 0304 	mov.w	r3, #4
  5e:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  60:	f04f 0303 	mov.w	r3, #3
  64:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  66:	f04f 0318 	mov.w	r3, #24
  6a:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_MDIO_PORT, &GPIO_InitStructure);
  6c:	f107 0304 	add.w	r3, r7, #4
  70:	483c      	ldr	r0, [pc, #240]	; (164 <bsp_eth_gpio_init+0x164>)
  72:	4619      	mov	r1, r3
  74:	f7ff fffe 	bl	0 <GPIO_Init>
			74: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_CRS_DV
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_CRSDV_PIN;
  78:	f44f 7380 	mov.w	r3, #256	; 0x100
  7c:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  7e:	f04f 0303 	mov.w	r3, #3
  82:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  84:	f04f 0304 	mov.w	r3, #4
  88:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_CRSDV_PORT, &GPIO_InitStructure);
  8a:	f107 0304 	add.w	r3, r7, #4
  8e:	4836      	ldr	r0, [pc, #216]	; (168 <bsp_eth_gpio_init+0x168>)
  90:	4619      	mov	r1, r3
  92:	f7ff fffe 	bl	0 <GPIO_Init>
			92: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_RXDO
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_RXD0_PIN;
  96:	f44f 7300 	mov.w	r3, #512	; 0x200
  9a:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  9c:	f04f 0303 	mov.w	r3, #3
  a0:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  a2:	f04f 0304 	mov.w	r3, #4
  a6:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_RXD0_PORT, &GPIO_InitStructure);
  a8:	f107 0304 	add.w	r3, r7, #4
  ac:	482e      	ldr	r0, [pc, #184]	; (168 <bsp_eth_gpio_init+0x168>)
  ae:	4619      	mov	r1, r3
  b0:	f7ff fffe 	bl	0 <GPIO_Init>
			b0: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_RXD1
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_RXD1_PIN;
  b4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  b8:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  ba:	f04f 0303 	mov.w	r3, #3
  be:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  c0:	f04f 0304 	mov.w	r3, #4
  c4:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_RXD1_PORT, &GPIO_InitStructure);
  c6:	f107 0304 	add.w	r3, r7, #4
  ca:	4827      	ldr	r0, [pc, #156]	; (168 <bsp_eth_gpio_init+0x168>)
  cc:	4619      	mov	r1, r3
  ce:	f7ff fffe 	bl	0 <GPIO_Init>
			ce: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_TXEN
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_TXEN_PIN;
  d2:	f44f 6300 	mov.w	r3, #2048	; 0x800
  d6:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  d8:	f04f 0303 	mov.w	r3, #3
  dc:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  de:	f04f 0318 	mov.w	r3, #24
  e2:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_TXEN_PORT, &GPIO_InitStructure);
  e4:	f107 0304 	add.w	r3, r7, #4
  e8:	4820      	ldr	r0, [pc, #128]	; (16c <bsp_eth_gpio_init+0x16c>)
  ea:	4619      	mov	r1, r3
  ec:	f7ff fffe 	bl	0 <GPIO_Init>
			ec: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_TXD0
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_TXD0_PIN;
  f0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  f4:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  f6:	f04f 0303 	mov.w	r3, #3
  fa:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  fc:	f04f 0318 	mov.w	r3, #24
 100:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_TXD0_PORT, &GPIO_InitStructure);
 102:	f107 0304 	add.w	r3, r7, #4
 106:	4819      	ldr	r0, [pc, #100]	; (16c <bsp_eth_gpio_init+0x16c>)
 108:	4619      	mov	r1, r3
 10a:	f7ff fffe 	bl	0 <GPIO_Init>
			10a: R_ARM_THM_CALL	GPIO_Init

	// ETH_RMII_TXD1
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_RMII_TXD1_PIN;
 10e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 112:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 114:	f04f 0303 	mov.w	r3, #3
 118:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 11a:	f04f 0318 	mov.w	r3, #24
 11e:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_RMII_TXD1_PORT, &GPIO_InitStructure);
 120:	f107 0304 	add.w	r3, r7, #4
 124:	4811      	ldr	r0, [pc, #68]	; (16c <bsp_eth_gpio_init+0x16c>)
 126:	4619      	mov	r1, r3
 128:	f7ff fffe 	bl	0 <GPIO_Init>
			128: R_ARM_THM_CALL	GPIO_Init

	// ETH_PPSOUT
	GPIO_InitStructure.GPIO_Pin = XME_BSP_STM32_ETHERNET_PPSOUT_PIN;
 12c:	f04f 0320 	mov.w	r3, #32
 130:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 132:	f04f 0303 	mov.w	r3, #3
 136:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 138:	f04f 0318 	mov.w	r3, #24
 13c:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(XME_BSP_STM32_ETHERNET_PPSOUT_PORT, &GPIO_InitStructure);
 13e:	f107 0304 	add.w	r3, r7, #4
 142:	480a      	ldr	r0, [pc, #40]	; (16c <bsp_eth_gpio_init+0x16c>)
 144:	4619      	mov	r1, r3
 146:	f7ff fffe 	bl	0 <GPIO_Init>
			146: R_ARM_THM_CALL	GPIO_Init

	// Selected alternate pin function mapping for Ethernet peripheral
	// Needs to be performed after the actual pin configuration!
#if XME_BSP_STM32_ETHERNET_AF_REMAPPED
	GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE);
 14a:	f04f 1020 	mov.w	r0, #2097184	; 0x200020
 14e:	f04f 0101 	mov.w	r1, #1
 152:	f7ff fffe 	bl	0 <GPIO_PinRemapConfig>
			152: R_ARM_THM_CALL	GPIO_PinRemapConfig
#endif // #if XME_BSP_STM32_ETHERNET_AF_REMAPPED

#if XME_BSP_STM32_ETHERNET_AF_DEFAULT
	GPIO_PinRemapConfig(GPIO_Remap_ETH, DISABLE);
#endif // #if XME_BSP_STM32_ETHERNET_AF_DEFAULT
}
 156:	f107 0708 	add.w	r7, r7, #8
 15a:	46bd      	mov	sp, r7
 15c:	bd80      	pop	{r7, pc}
 15e:	bf00      	nop
 160:	40011000 	.word	0x40011000
 164:	40010800 	.word	0x40010800
 168:	40011400 	.word	0x40011400
 16c:	40010c00 	.word	0x40010c00

00000170 <Set_MAC_Address>:
 *
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
void Set_MAC_Address(eth_mac_addr_t macadd)
{
 170:	b580      	push	{r7, lr}
 172:	b082      	sub	sp, #8
 174:	af00      	add	r7, sp, #0
 176:	6078      	str	r0, [r7, #4]
	ETH_MACAddressConfig(ETH_MAC_Address0, macadd);
 178:	f04f 0000 	mov.w	r0, #0
 17c:	6879      	ldr	r1, [r7, #4]
 17e:	f7ff fffe 	bl	0 <ETH_MACAddressConfig>
			17e: R_ARM_THM_CALL	ETH_MACAddressConfig
}
 182:	f107 0708 	add.w	r7, r7, #8
 186:	46bd      	mov	sp, r7
 188:	bd80      	pop	{r7, pc}
 18a:	bf00      	nop

0000018c <ETH_driver_init>:
  * @brief  Setup ethernet peripheral
  * @param  None
  * @retval None
  */
void ETH_driver_init(void)
{
 18c:	b580      	push	{r7, lr}
 18e:	af00      	add	r7, sp, #0
	*  To reconfigure the default setting of SystemInit() function, refer to
	*  system_stm32f10x.c file
	*/

  	/* Enable ETHERNET clock  */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ETH_MAC | RCC_AHBPeriph_ETH_MAC_Tx | RCC_AHBPeriph_ETH_MAC_Rx, ENABLE);
 190:	f44f 30e0 	mov.w	r0, #114688	; 0x1c000
 194:	f04f 0101 	mov.w	r1, #1
 198:	f7ff fffe 	bl	0 <RCC_AHBPeriphClockCmd>
			198: R_ARM_THM_CALL	RCC_AHBPeriphClockCmd

	/* Configure the GPIO ports */
	bsp_eth_gpio_init();
 19c:	f7ff fffe 	bl	0 <bsp_eth_gpio_init>
			19c: R_ARM_THM_CALL	bsp_eth_gpio_init

	/* NVIC configuration */
	NVIC_Configuration();
 1a0:	f7ff fffe 	bl	2f0 <NVIC_Configuration>
			1a0: R_ARM_THM_CALL	NVIC_Configuration

	/* Configure the Ethernet peripheral */
	Ethernet_Configuration();
 1a4:	f7ff fffe 	bl	1bc <Ethernet_Configuration>
			1a4: R_ARM_THM_CALL	Ethernet_Configuration
}
 1a8:	bd80      	pop	{r7, pc}
 1aa:	bf00      	nop

000001ac <bsp_eth_phy_addr>:
}
#endif // #if XME_BSP_STM32_ETHERNET_PHY_STE101P

#if XME_BSP_STM32_ETHERNET_PHY_DP83848J
int bsp_eth_phy_addr (void)
{
 1ac:	b480      	push	{r7}
 1ae:	af00      	add	r7, sp, #0
	return 1;
 1b0:	f04f 0301 	mov.w	r3, #1
}
 1b4:	4618      	mov	r0, r3
 1b6:	46bd      	mov	sp, r7
 1b8:	bc80      	pop	{r7}
 1ba:	4770      	bx	lr

000001bc <Ethernet_Configuration>:
  * @brief  Configures the Ethernet Interface
  * @param  None
  * @retval None
  */
void Ethernet_Configuration(void)
{
 1bc:	b580      	push	{r7, lr}
 1be:	b0b0      	sub	sp, #192	; 0xc0
 1c0:	af00      	add	r7, sp, #0
	RCC_MCOConfig(RCC_MCO_HSE);

#endif // #if XME_BSP_STM32_ETHERNET_MII

#if XME_BSP_STM32_ETHERNET_RMII
	GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_RMII);
 1c2:	f04f 0001 	mov.w	r0, #1
 1c6:	f7ff fffe 	bl	0 <GPIO_ETH_MediaInterfaceConfig>
			1c6: R_ARM_THM_CALL	GPIO_ETH_MediaInterfaceConfig

#if XME_BSP_STM32_ETHERNET_RMII_PLL3
	/* Configure MCO (PA8) as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 1ca:	f44f 7380 	mov.w	r3, #256	; 0x100
 1ce:	803b      	strh	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 1d0:	f04f 0303 	mov.w	r3, #3
 1d4:	70bb      	strb	r3, [r7, #2]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 1d6:	f04f 0318 	mov.w	r3, #24
 1da:	70fb      	strb	r3, [r7, #3]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 1dc:	463b      	mov	r3, r7
 1de:	4842      	ldr	r0, [pc, #264]	; (2e8 <Ethernet_Configuration+0x12c>)
 1e0:	4619      	mov	r1, r3
 1e2:	f7ff fffe 	bl	0 <GPIO_Init>
			1e2: R_ARM_THM_CALL	GPIO_Init

	/* Set PLL3 clock output to 50MHz (25MHz /5 *10 =50MHz) */
	RCC_PLL3Config(RCC_PLL3Mul_10);
 1e6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 1ea:	f7ff fffe 	bl	0 <RCC_PLL3Config>
			1ea: R_ARM_THM_CALL	RCC_PLL3Config
	/* Enable PLL3 */
	RCC_PLL3Cmd(ENABLE);
 1ee:	f04f 0001 	mov.w	r0, #1
 1f2:	f7ff fffe 	bl	0 <RCC_PLL3Cmd>
			1f2: R_ARM_THM_CALL	RCC_PLL3Cmd
	/* Wait till PLL3 is ready */
	while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET)
 1f6:	bf00      	nop
 1f8:	f04f 003d 	mov.w	r0, #61	; 0x3d
 1fc:	f7ff fffe 	bl	0 <RCC_GetFlagStatus>
			1fc: R_ARM_THM_CALL	RCC_GetFlagStatus
 200:	4603      	mov	r3, r0
 202:	2b00      	cmp	r3, #0
 204:	d0f8      	beq.n	1f8 <Ethernet_Configuration+0x3c>
	{}

	/* Get PLL3 clock on PA8 pin (MCO) */
	RCC_MCOConfig(RCC_MCO_PLL3CLK);
 206:	f04f 000b 	mov.w	r0, #11
 20a:	f7ff fffe 	bl	0 <RCC_MCOConfig>
			20a: R_ARM_THM_CALL	RCC_MCOConfig
#endif // #if XME_BSP_STM32_ETHERNET_RMII_PLL3
#endif // #if XME_BSP_STM32_ETHERNET_RMII

	/* Reset ETHERNET on AHB Bus */
	ETH_DeInit();
 20e:	f7ff fffe 	bl	0 <ETH_DeInit>
			20e: R_ARM_THM_CALL	ETH_DeInit

	/* Software reset */
	ETH_SoftwareReset();
 212:	f7ff fffe 	bl	0 <ETH_SoftwareReset>
			212: R_ARM_THM_CALL	ETH_SoftwareReset

	/* Wait for software reset */
	while (ETH_GetSoftwareResetStatus() == SET);
 216:	bf00      	nop
 218:	f7ff fffe 	bl	0 <ETH_GetSoftwareResetStatus>
			218: R_ARM_THM_CALL	ETH_GetSoftwareResetStatus
 21c:	4603      	mov	r3, r0
 21e:	2b01      	cmp	r3, #1
 220:	d0fa      	beq.n	218 <Ethernet_Configuration+0x5c>

	/* ETHERNET Configuration ------------------------------------------------------*/
	/* Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter */
	ETH_StructInit(&ETH_InitStructure);
 222:	f107 0304 	add.w	r3, r7, #4
 226:	4618      	mov	r0, r3
 228:	f7ff fffe 	bl	0 <ETH_StructInit>
			228: R_ARM_THM_CALL	ETH_StructInit

	/* Fill ETH_InitStructure parametrs */
	/*------------------------   MAC   -----------------------------------*/
	ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable  ;
 22c:	f04f 0301 	mov.w	r3, #1
 230:	607b      	str	r3, [r7, #4]
	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 232:	f04f 0300 	mov.w	r3, #0
 236:	623b      	str	r3, [r7, #32]
	ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
 238:	f44f 7300 	mov.w	r3, #512	; 0x200
 23c:	62fb      	str	r3, [r7, #44]	; 0x2c
	ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
 23e:	f04f 0300 	mov.w	r3, #0
 242:	633b      	str	r3, [r7, #48]	; 0x30
	ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Enable;
 244:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 248:	63fb      	str	r3, [r7, #60]	; 0x3c
	ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
 24a:	f04f 0300 	mov.w	r3, #0
 24e:	64bb      	str	r3, [r7, #72]	; 0x48
	ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
 250:	f04f 0300 	mov.w	r3, #0
 254:	653b      	str	r3, [r7, #80]	; 0x50
	ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_None;
 256:	f04f 0310 	mov.w	r3, #16
 25a:	657b      	str	r3, [r7, #84]	; 0x54
	ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
 25c:	f04f 0300 	mov.w	r3, #0
 260:	65bb      	str	r3, [r7, #88]	; 0x58

	// TODO: Manage with xme_build_option. See ticket #848
	#ifdef CHECKSUM_BY_HARDWARE
	ETH_InitStructure.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable;
 262:	f44f 6380 	mov.w	r3, #1024	; 0x400
 266:	62bb      	str	r3, [r7, #40]	; 0x28
	/*------------------------   DMA   -----------------------------------*/

	/* When we use the Checksum offload feature, we need to enable the Store and Forward mode:
	the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum,
	if the checksum is OK the DMA can handle the frame otherwise the frame is dropped */
	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable;
 268:	f04f 0300 	mov.w	r3, #0
 26c:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
 270:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 274:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;
 278:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 27c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
 280:	f04f 0300 	mov.w	r3, #0
 284:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
 288:	f04f 0300 	mov.w	r3, #0
 28c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
 290:	f04f 0304 	mov.w	r3, #4
 294:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
 298:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 29c:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;
 2a0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 2a4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 2a8:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 2ac:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 2b0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 2b4:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
 2b8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 2bc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

	/* Configure Ethernet */
	ETH_Init(&ETH_InitStructure, bsp_eth_phy_addr());
 2c0:	f7ff fffe 	bl	1ac <bsp_eth_phy_addr>
			2c0: R_ARM_THM_CALL	bsp_eth_phy_addr
 2c4:	4603      	mov	r3, r0
 2c6:	b29b      	uxth	r3, r3
 2c8:	f107 0204 	add.w	r2, r7, #4
 2cc:	4610      	mov	r0, r2
 2ce:	4619      	mov	r1, r3
 2d0:	f7ff fffe 	bl	0 <ETH_Init>
			2d0: R_ARM_THM_CALL	ETH_Init

	/* Enable the Ethernet Rx Interrupt */
	ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R, ENABLE);
 2d4:	4805      	ldr	r0, [pc, #20]	; (2ec <Ethernet_Configuration+0x130>)
 2d6:	f04f 0101 	mov.w	r1, #1
 2da:	f7ff fffe 	bl	0 <ETH_DMAITConfig>
			2da: R_ARM_THM_CALL	ETH_DMAITConfig
}
 2de:	f107 07c0 	add.w	r7, r7, #192	; 0xc0
 2e2:	46bd      	mov	sp, r7
 2e4:	bd80      	pop	{r7, pc}
 2e6:	bf00      	nop
 2e8:	40010800 	.word	0x40010800
 2ec:	00010040 	.word	0x00010040

000002f0 <NVIC_Configuration>:
  * @brief  Configures the nested vectored interrupt controller.
  * @param  None
  * @retval None
  */
void NVIC_Configuration(void)
{
 2f0:	b580      	push	{r7, lr}
 2f2:	b082      	sub	sp, #8
 2f4:	af00      	add	r7, sp, #0
	NVIC_InitTypeDef   NVIC_InitStructure;

	/* Set the Vector Table base location at 0x08000000 */
	/*	NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0); */
	NVIC_SetVectorTable(XME_HAL_INTERNAL_FLASH_IMAGE_FIRST_PAGE_ADDRESS, 0x0);
 2f6:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 2fa:	f04f 0100 	mov.w	r1, #0
 2fe:	f7ff fffe 	bl	0 <NVIC_SetVectorTable>
			2fe: R_ARM_THM_CALL	NVIC_SetVectorTable

	/* 2 bit for pre-emption priority, 2 bits for subpriority */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
 302:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 306:	f7ff fffe 	bl	0 <NVIC_PriorityGroupConfig>
			306: R_ARM_THM_CALL	NVIC_PriorityGroupConfig

	/* Enable the Ethernet global Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn;
 30a:	f04f 033d 	mov.w	r3, #61	; 0x3d
 30e:	713b      	strb	r3, [r7, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
 310:	f04f 0302 	mov.w	r3, #2
 314:	717b      	strb	r3, [r7, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 316:	f04f 0300 	mov.w	r3, #0
 31a:	71bb      	strb	r3, [r7, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 31c:	f04f 0301 	mov.w	r3, #1
 320:	71fb      	strb	r3, [r7, #7]
	NVIC_Init(&NVIC_InitStructure);
 322:	f107 0304 	add.w	r3, r7, #4
 326:	4618      	mov	r0, r3
 328:	f7ff fffe 	bl	0 <NVIC_Init>
			328: R_ARM_THM_CALL	NVIC_Init
}
 32c:	f107 0708 	add.w	r7, r7, #8
 330:	46bd      	mov	sp, r7
 332:	bd80      	pop	{r7, pc}

00000334 <NVIC_Configuration_Emergency_Bits>:

void NVIC_Configuration_Emergency_Bits(void)
{
 334:	b580      	push	{r7, lr}
 336:	b084      	sub	sp, #16
 338:	af00      	add	r7, sp, #0
	NVIC_InitTypeDef NVIC_InitStructure_EXTI;
	EXTI_InitTypeDef EXTI_InitStructure;

	//Connect EXTI0 Line to PC0 OVP Fast pin
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource0);
 33a:	f04f 0002 	mov.w	r0, #2
 33e:	f04f 0100 	mov.w	r1, #0
 342:	f7ff fffe 	bl	0 <GPIO_EXTILineConfig>
			342: R_ARM_THM_CALL	GPIO_EXTILineConfig

	// Configure EXTI0 line
	EXTI_InitStructure.EXTI_Line = EXTI_Line0;
 346:	f04f 0301 	mov.w	r3, #1
 34a:	607b      	str	r3, [r7, #4]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 34c:	f04f 0300 	mov.w	r3, #0
 350:	723b      	strb	r3, [r7, #8]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 352:	f04f 030c 	mov.w	r3, #12
 356:	727b      	strb	r3, [r7, #9]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 358:	f04f 0301 	mov.w	r3, #1
 35c:	72bb      	strb	r3, [r7, #10]
	EXTI_Init(&EXTI_InitStructure);
 35e:	f107 0304 	add.w	r3, r7, #4
 362:	4618      	mov	r0, r3
 364:	f7ff fffe 	bl	0 <EXTI_Init>
			364: R_ARM_THM_CALL	EXTI_Init

	// Enable and set EXTI0 Interrupt to the lowest priority
	NVIC_InitStructure_EXTI.NVIC_IRQChannel = EXTI0_IRQn;
 368:	f04f 0306 	mov.w	r3, #6
 36c:	733b      	strb	r3, [r7, #12]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelPreemptionPriority = 0;
 36e:	f04f 0300 	mov.w	r3, #0
 372:	737b      	strb	r3, [r7, #13]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelSubPriority = 0;
 374:	f04f 0300 	mov.w	r3, #0
 378:	73bb      	strb	r3, [r7, #14]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelCmd = ENABLE;
 37a:	f04f 0301 	mov.w	r3, #1
 37e:	73fb      	strb	r3, [r7, #15]
	NVIC_Init(&NVIC_InitStructure_EXTI);
 380:	f107 030c 	add.w	r3, r7, #12
 384:	4618      	mov	r0, r3
 386:	f7ff fffe 	bl	0 <NVIC_Init>
			386: R_ARM_THM_CALL	NVIC_Init

	// Connect EXTI0 Line to PC2 UPS pin
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource2);
 38a:	f04f 0002 	mov.w	r0, #2
 38e:	f04f 0102 	mov.w	r1, #2
 392:	f7ff fffe 	bl	0 <GPIO_EXTILineConfig>
			392: R_ARM_THM_CALL	GPIO_EXTILineConfig

	// Configure EXTI0 line
	EXTI_InitStructure.EXTI_Line = EXTI_Line2;
 396:	f04f 0304 	mov.w	r3, #4
 39a:	607b      	str	r3, [r7, #4]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 39c:	f04f 0300 	mov.w	r3, #0
 3a0:	723b      	strb	r3, [r7, #8]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 3a2:	f04f 030c 	mov.w	r3, #12
 3a6:	727b      	strb	r3, [r7, #9]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 3a8:	f04f 0301 	mov.w	r3, #1
 3ac:	72bb      	strb	r3, [r7, #10]
	EXTI_Init(&EXTI_InitStructure);
 3ae:	f107 0304 	add.w	r3, r7, #4
 3b2:	4618      	mov	r0, r3
 3b4:	f7ff fffe 	bl	0 <EXTI_Init>
			3b4: R_ARM_THM_CALL	EXTI_Init

	// Enable and set EXTI0 Interrupt to the lowest priority
	NVIC_InitStructure_EXTI.NVIC_IRQChannel = EXTI2_IRQn;
 3b8:	f04f 0308 	mov.w	r3, #8
 3bc:	733b      	strb	r3, [r7, #12]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelPreemptionPriority = 0;
 3be:	f04f 0300 	mov.w	r3, #0
 3c2:	737b      	strb	r3, [r7, #13]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelSubPriority = 0;
 3c4:	f04f 0300 	mov.w	r3, #0
 3c8:	73bb      	strb	r3, [r7, #14]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelCmd = ENABLE;
 3ca:	f04f 0301 	mov.w	r3, #1
 3ce:	73fb      	strb	r3, [r7, #15]
	NVIC_Init(&NVIC_InitStructure_EXTI);
 3d0:	f107 030c 	add.w	r3, r7, #12
 3d4:	4618      	mov	r0, r3
 3d6:	f7ff fffe 	bl	0 <NVIC_Init>
			3d6: R_ARM_THM_CALL	NVIC_Init

	// Connect EXTI13 Line to PC13 pin Therma status
	GPIO_EXTILineConfig(GPIO_PortSourceGPIOD, GPIO_PinSource13);
 3da:	f04f 0003 	mov.w	r0, #3
 3de:	f04f 010d 	mov.w	r1, #13
 3e2:	f7ff fffe 	bl	0 <GPIO_EXTILineConfig>
			3e2: R_ARM_THM_CALL	GPIO_EXTILineConfig

	// Configure EXT13 line
	EXTI_InitStructure.EXTI_Line = EXTI_Line13;
 3e6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 3ea:	607b      	str	r3, [r7, #4]
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 3ec:	f04f 0300 	mov.w	r3, #0
 3f0:	723b      	strb	r3, [r7, #8]
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
 3f2:	f04f 030c 	mov.w	r3, #12
 3f6:	727b      	strb	r3, [r7, #9]
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 3f8:	f04f 0301 	mov.w	r3, #1
 3fc:	72bb      	strb	r3, [r7, #10]
	EXTI_Init(&EXTI_InitStructure);
 3fe:	f107 0304 	add.w	r3, r7, #4
 402:	4618      	mov	r0, r3
 404:	f7ff fffe 	bl	0 <EXTI_Init>
			404: R_ARM_THM_CALL	EXTI_Init

	// Enable and set EXT13 Interrupt to the lowest priority
	NVIC_InitStructure_EXTI.NVIC_IRQChannel = EXTI15_10_IRQn;
 408:	f04f 0328 	mov.w	r3, #40	; 0x28
 40c:	733b      	strb	r3, [r7, #12]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelPreemptionPriority = 0;
 40e:	f04f 0300 	mov.w	r3, #0
 412:	737b      	strb	r3, [r7, #13]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelSubPriority = 0;
 414:	f04f 0300 	mov.w	r3, #0
 418:	73bb      	strb	r3, [r7, #14]
	NVIC_InitStructure_EXTI.NVIC_IRQChannelCmd = ENABLE;
 41a:	f04f 0301 	mov.w	r3, #1
 41e:	73fb      	strb	r3, [r7, #15]
	NVIC_Init(&NVIC_InitStructure_EXTI);
 420:	f107 030c 	add.w	r3, r7, #12
 424:	4618      	mov	r0, r3
 426:	f7ff fffe 	bl	0 <NVIC_Init>
			426: R_ARM_THM_CALL	NVIC_Init
}
 42a:	f107 0710 	add.w	r7, r7, #16
 42e:	46bd      	mov	sp, r7
 430:	bd80      	pop	{r7, pc}
 432:	bf00      	nop

core_cm3.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  20852 Jul 30 19:07 2021 core_cm3.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000028c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002c0  2**0
                  ALLOC
  3 .debug_abbrev 000000d5  00000000  00000000  000002c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000548  00000000  00000000  00000395  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000001ec  00000000  00000000  000008dd  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00002d78  00000000  00000000  00000ac9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000003f0  00000000  00000000  00003841  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000159  00000000  00000000  00003c31  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000050  00000000  00000000  00003d8a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00003dda  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000254  00000000  00000000  00003dfa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000404e  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00004079  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000280  00000000  00000000  000040ac  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 core_cm3.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000010 __get_PSP
00000010 g     F .text	00000008 __set_PSP
00000018 g     F .text	00000010 __get_MSP
00000028 g     F .text	00000008 __set_MSP
00000030 g     F .text	00000020 __get_BASEPRI
00000050 g     F .text	00000018 __set_BASEPRI
00000068 g     F .text	00000020 __get_PRIMASK
00000088 g     F .text	00000018 __set_PRIMASK
000000a0 g     F .text	00000020 __get_FAULTMASK
000000c0 g     F .text	00000018 __set_FAULTMASK
000000d8 g     F .text	00000020 __get_CONTROL
000000f8 g     F .text	00000018 __set_CONTROL
00000110 g     F .text	00000022 __REV
00000134 g     F .text	00000024 __REV16
00000158 g     F .text	00000024 __REVSH
0000017c g     F .text	00000024 __RBIT
000001a0 g     F .text	00000024 __LDREXB
000001c4 g     F .text	00000024 __LDREXH
000001e8 g     F .text	00000024 __LDREXW
0000020c g     F .text	0000002a __STREXB
00000238 g     F .text	0000002a __STREXH
00000264 g     F .text	00000028 __STREXW



Disassembly of section .text:

00000000 <__get_PSP>:
 * Return the actual process stack pointer
 */
uint32_t __get_PSP(void) __attribute__( ( naked ) );
uint32_t __get_PSP(void)
{
  uint32_t result=0;
   0:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, psp\n\t" 
   4:	f3ef 8409 	mrs	r4, PSP
   8:	4620      	mov	r0, r4
   a:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
   c:	4623      	mov	r3, r4
}
   e:	4618      	mov	r0, r3

00000010 <__set_PSP>:
 * Assign the value ProcessStackPointer to the MSP 
 * (process stack pointer) Cortex processor register
 */
void __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );
void __set_PSP(uint32_t topOfProcStack)
{
  10:	4603      	mov	r3, r0
  __ASM volatile ("MSR psp, %0\n\t"
  12:	f383 8809 	msr	PSP, r3
  16:	4770      	bx	lr

00000018 <__get_MSP>:
 * Cortex processor register
 */
uint32_t __get_MSP(void) __attribute__( ( naked ) );
uint32_t __get_MSP(void)
{
  uint32_t result=0;
  18:	f04f 0400 	mov.w	r4, #0

  __ASM volatile ("MRS %0, msp\n\t" 
  1c:	f3ef 8408 	mrs	r4, MSP
  20:	4620      	mov	r0, r4
  22:	4770      	bx	lr
                  "MOV r0, %0 \n\t"
                  "BX  lr     \n\t"  : "=r" (result) );
  return(result);
  24:	4623      	mov	r3, r4
}
  26:	4618      	mov	r0, r3

00000028 <__set_MSP>:
 * Assign the value mainStackPointer to the MSP 
 * (main stack pointer) Cortex processor register
 */
void __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );
void __set_MSP(uint32_t topOfMainStack)
{
  28:	4603      	mov	r3, r0
  __ASM volatile ("MSR msp, %0\n\t"
  2a:	f383 8808 	msr	MSP, r3
  2e:	4770      	bx	lr

00000030 <__get_BASEPRI>:
 * @return BasePriority
 *
 * Return the content of the base priority register
 */
uint32_t __get_BASEPRI(void)
{
  30:	b490      	push	{r4, r7}
  32:	b082      	sub	sp, #8
  34:	af00      	add	r7, sp, #0
  uint32_t result=0;
  36:	f04f 0300 	mov.w	r3, #0
  3a:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
  3c:	f3ef 8412 	mrs	r4, BASEPRI_MAX
  40:	607c      	str	r4, [r7, #4]
  return(result);
  42:	687b      	ldr	r3, [r7, #4]
}
  44:	4618      	mov	r0, r3
  46:	f107 0708 	add.w	r7, r7, #8
  4a:	46bd      	mov	sp, r7
  4c:	bc90      	pop	{r4, r7}
  4e:	4770      	bx	lr

00000050 <__set_BASEPRI>:
 * @param  basePri  BasePriority
 *
 * Set the base priority register
 */
void __set_BASEPRI(uint32_t value)
{
  50:	b480      	push	{r7}
  52:	b083      	sub	sp, #12
  54:	af00      	add	r7, sp, #0
  56:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
  58:	687b      	ldr	r3, [r7, #4]
  5a:	f383 8811 	msr	BASEPRI, r3
}
  5e:	f107 070c 	add.w	r7, r7, #12
  62:	46bd      	mov	sp, r7
  64:	bc80      	pop	{r7}
  66:	4770      	bx	lr

00000068 <__get_PRIMASK>:
 * @return PriMask
 *
 * Return state of the priority mask bit from the priority mask register
 */
uint32_t __get_PRIMASK(void)
{
  68:	b490      	push	{r4, r7}
  6a:	b082      	sub	sp, #8
  6c:	af00      	add	r7, sp, #0
  uint32_t result=0;
  6e:	f04f 0300 	mov.w	r3, #0
  72:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
  74:	f3ef 8410 	mrs	r4, PRIMASK
  78:	607c      	str	r4, [r7, #4]
  return(result);
  7a:	687b      	ldr	r3, [r7, #4]
}
  7c:	4618      	mov	r0, r3
  7e:	f107 0708 	add.w	r7, r7, #8
  82:	46bd      	mov	sp, r7
  84:	bc90      	pop	{r4, r7}
  86:	4770      	bx	lr

00000088 <__set_PRIMASK>:
 * @param  priMask  PriMask
 *
 * Set the priority mask bit in the priority mask register
 */
void __set_PRIMASK(uint32_t priMask)
{
  88:	b480      	push	{r7}
  8a:	b083      	sub	sp, #12
  8c:	af00      	add	r7, sp, #0
  8e:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
  90:	687b      	ldr	r3, [r7, #4]
  92:	f383 8810 	msr	PRIMASK, r3
}
  96:	f107 070c 	add.w	r7, r7, #12
  9a:	46bd      	mov	sp, r7
  9c:	bc80      	pop	{r7}
  9e:	4770      	bx	lr

000000a0 <__get_FAULTMASK>:
 * @return FaultMask
 *
 * Return the content of the fault mask register
 */
uint32_t __get_FAULTMASK(void)
{
  a0:	b490      	push	{r4, r7}
  a2:	b082      	sub	sp, #8
  a4:	af00      	add	r7, sp, #0
  uint32_t result=0;
  a6:	f04f 0300 	mov.w	r3, #0
  aa:	607b      	str	r3, [r7, #4]
  
  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
  ac:	f3ef 8413 	mrs	r4, FAULTMASK
  b0:	607c      	str	r4, [r7, #4]
  return(result);
  b2:	687b      	ldr	r3, [r7, #4]
}
  b4:	4618      	mov	r0, r3
  b6:	f107 0708 	add.w	r7, r7, #8
  ba:	46bd      	mov	sp, r7
  bc:	bc90      	pop	{r4, r7}
  be:	4770      	bx	lr

000000c0 <__set_FAULTMASK>:
 * @param  faultMask  faultMask value
 *
 * Set the fault mask register
 */
void __set_FAULTMASK(uint32_t faultMask)
{
  c0:	b480      	push	{r7}
  c2:	b083      	sub	sp, #12
  c4:	af00      	add	r7, sp, #0
  c6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
  c8:	687b      	ldr	r3, [r7, #4]
  ca:	f383 8813 	msr	FAULTMASK, r3
}
  ce:	f107 070c 	add.w	r7, r7, #12
  d2:	46bd      	mov	sp, r7
  d4:	bc80      	pop	{r7}
  d6:	4770      	bx	lr

000000d8 <__get_CONTROL>:
*  @return Control value
 *
 * Return the content of the control register
 */
uint32_t __get_CONTROL(void)
{
  d8:	b490      	push	{r4, r7}
  da:	b082      	sub	sp, #8
  dc:	af00      	add	r7, sp, #0
  uint32_t result=0;
  de:	f04f 0300 	mov.w	r3, #0
  e2:	607b      	str	r3, [r7, #4]

  __ASM volatile ("MRS %0, control" : "=r" (result) );
  e4:	f3ef 8414 	mrs	r4, CONTROL
  e8:	607c      	str	r4, [r7, #4]
  return(result);
  ea:	687b      	ldr	r3, [r7, #4]
}
  ec:	4618      	mov	r0, r3
  ee:	f107 0708 	add.w	r7, r7, #8
  f2:	46bd      	mov	sp, r7
  f4:	bc90      	pop	{r4, r7}
  f6:	4770      	bx	lr

000000f8 <__set_CONTROL>:
 * @param  control  Control value
 *
 * Set the control register
 */
void __set_CONTROL(uint32_t control)
{
  f8:	b480      	push	{r7}
  fa:	b083      	sub	sp, #12
  fc:	af00      	add	r7, sp, #0
  fe:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MSR control, %0" : : "r" (control) );
 100:	687b      	ldr	r3, [r7, #4]
 102:	f383 8814 	msr	CONTROL, r3
}
 106:	f107 070c 	add.w	r7, r7, #12
 10a:	46bd      	mov	sp, r7
 10c:	bc80      	pop	{r7}
 10e:	4770      	bx	lr

00000110 <__REV>:
 * @return        reversed value
 *
 * Reverse byte order in integer value
 */
uint32_t __REV(uint32_t value)
{
 110:	b490      	push	{r4, r7}
 112:	b084      	sub	sp, #16
 114:	af00      	add	r7, sp, #0
 116:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
 118:	f04f 0300 	mov.w	r3, #0
 11c:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 11e:	687b      	ldr	r3, [r7, #4]
 120:	ba1c      	rev	r4, r3
 122:	60fc      	str	r4, [r7, #12]
  return(result);
 124:	68fb      	ldr	r3, [r7, #12]
}
 126:	4618      	mov	r0, r3
 128:	f107 0710 	add.w	r7, r7, #16
 12c:	46bd      	mov	sp, r7
 12e:	bc90      	pop	{r4, r7}
 130:	4770      	bx	lr
 132:	bf00      	nop

00000134 <__REV16>:
 * @return        reversed value
 *
 * Reverse byte order in unsigned short value
 */
uint32_t __REV16(uint16_t value)
{
 134:	b490      	push	{r4, r7}
 136:	b084      	sub	sp, #16
 138:	af00      	add	r7, sp, #0
 13a:	4603      	mov	r3, r0
 13c:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
 13e:	f04f 0300 	mov.w	r3, #0
 142:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
 144:	88fb      	ldrh	r3, [r7, #6]
 146:	ba5c      	rev16	r4, r3
 148:	60fc      	str	r4, [r7, #12]
  return(result);
 14a:	68fb      	ldr	r3, [r7, #12]
}
 14c:	4618      	mov	r0, r3
 14e:	f107 0710 	add.w	r7, r7, #16
 152:	46bd      	mov	sp, r7
 154:	bc90      	pop	{r4, r7}
 156:	4770      	bx	lr

00000158 <__REVSH>:
 * @return        reversed value
 *
 * Reverse byte order in signed short value with sign extension to integer
 */
int32_t __REVSH(int16_t value)
{
 158:	b490      	push	{r4, r7}
 15a:	b084      	sub	sp, #16
 15c:	af00      	add	r7, sp, #0
 15e:	4603      	mov	r3, r0
 160:	80fb      	strh	r3, [r7, #6]
  uint32_t result=0;
 162:	f04f 0300 	mov.w	r3, #0
 166:	60fb      	str	r3, [r7, #12]
  
  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
 168:	88fb      	ldrh	r3, [r7, #6]
 16a:	badc      	revsh	r4, r3
 16c:	60fc      	str	r4, [r7, #12]
  return(result);
 16e:	68fb      	ldr	r3, [r7, #12]
}
 170:	4618      	mov	r0, r3
 172:	f107 0710 	add.w	r7, r7, #16
 176:	46bd      	mov	sp, r7
 178:	bc90      	pop	{r4, r7}
 17a:	4770      	bx	lr

0000017c <__RBIT>:
 * @return        reversed value
 *
 * Reverse bit order of value
 */
uint32_t __RBIT(uint32_t value)
{
 17c:	b490      	push	{r4, r7}
 17e:	b084      	sub	sp, #16
 180:	af00      	add	r7, sp, #0
 182:	6078      	str	r0, [r7, #4]
  uint32_t result=0;
 184:	f04f 0300 	mov.w	r3, #0
 188:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 18a:	687b      	ldr	r3, [r7, #4]
 18c:	fa93 f4a3 	rbit	r4, r3
 190:	60fc      	str	r4, [r7, #12]
   return(result);
 192:	68fb      	ldr	r3, [r7, #12]
}
 194:	4618      	mov	r0, r3
 196:	f107 0710 	add.w	r7, r7, #16
 19a:	46bd      	mov	sp, r7
 19c:	bc90      	pop	{r4, r7}
 19e:	4770      	bx	lr

000001a0 <__LDREXB>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 8 bit value
 */
uint8_t __LDREXB(uint8_t *addr)
{
 1a0:	b490      	push	{r4, r7}
 1a2:	b084      	sub	sp, #16
 1a4:	af00      	add	r7, sp, #0
 1a6:	6078      	str	r0, [r7, #4]
    uint8_t result=0;
 1a8:	f04f 0300 	mov.w	r3, #0
 1ac:	73fb      	strb	r3, [r7, #15]
  
   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
 1ae:	687b      	ldr	r3, [r7, #4]
 1b0:	e8d3 4f4f 	ldrexb	r4, [r3]
 1b4:	73fc      	strb	r4, [r7, #15]
   return(result);
 1b6:	7bfb      	ldrb	r3, [r7, #15]
}
 1b8:	4618      	mov	r0, r3
 1ba:	f107 0710 	add.w	r7, r7, #16
 1be:	46bd      	mov	sp, r7
 1c0:	bc90      	pop	{r4, r7}
 1c2:	4770      	bx	lr

000001c4 <__LDREXH>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 16 bit values
 */
uint16_t __LDREXH(uint16_t *addr)
{
 1c4:	b490      	push	{r4, r7}
 1c6:	b084      	sub	sp, #16
 1c8:	af00      	add	r7, sp, #0
 1ca:	6078      	str	r0, [r7, #4]
    uint16_t result=0;
 1cc:	f04f 0300 	mov.w	r3, #0
 1d0:	81fb      	strh	r3, [r7, #14]
  
   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
 1d2:	687b      	ldr	r3, [r7, #4]
 1d4:	e8d3 4f5f 	ldrexh	r4, [r3]
 1d8:	81fc      	strh	r4, [r7, #14]
   return(result);
 1da:	89fb      	ldrh	r3, [r7, #14]
}
 1dc:	4618      	mov	r0, r3
 1de:	f107 0710 	add.w	r7, r7, #16
 1e2:	46bd      	mov	sp, r7
 1e4:	bc90      	pop	{r4, r7}
 1e6:	4770      	bx	lr

000001e8 <__LDREXW>:
 * @return        value of (*address)
 *
 * Exclusive LDR command for 32 bit values
 */
uint32_t __LDREXW(uint32_t *addr)
{
 1e8:	b490      	push	{r4, r7}
 1ea:	b084      	sub	sp, #16
 1ec:	af00      	add	r7, sp, #0
 1ee:	6078      	str	r0, [r7, #4]
    uint32_t result=0;
 1f0:	f04f 0300 	mov.w	r3, #0
 1f4:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
 1f6:	687b      	ldr	r3, [r7, #4]
 1f8:	e853 4f00 	ldrex	r4, [r3]
 1fc:	60fc      	str	r4, [r7, #12]
   return(result);
 1fe:	68fb      	ldr	r3, [r7, #12]
}
 200:	4618      	mov	r0, r3
 202:	f107 0710 	add.w	r7, r7, #16
 206:	46bd      	mov	sp, r7
 208:	bc90      	pop	{r4, r7}
 20a:	4770      	bx	lr

0000020c <__STREXB>:
 * @return        successful / failed
 *
 * Exclusive STR command for 8 bit values
 */
uint32_t __STREXB(uint8_t value, uint8_t *addr)
{
 20c:	b490      	push	{r4, r7}
 20e:	b084      	sub	sp, #16
 210:	af00      	add	r7, sp, #0
 212:	4603      	mov	r3, r0
 214:	6039      	str	r1, [r7, #0]
 216:	71fb      	strb	r3, [r7, #7]
   uint32_t result=0;
 218:	f04f 0300 	mov.w	r3, #0
 21c:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
 21e:	683b      	ldr	r3, [r7, #0]
 220:	79fa      	ldrb	r2, [r7, #7]
 222:	e8c3 2f44 	strexb	r4, r2, [r3]
 226:	60fc      	str	r4, [r7, #12]
   return(result);
 228:	68fb      	ldr	r3, [r7, #12]
}
 22a:	4618      	mov	r0, r3
 22c:	f107 0710 	add.w	r7, r7, #16
 230:	46bd      	mov	sp, r7
 232:	bc90      	pop	{r4, r7}
 234:	4770      	bx	lr
 236:	bf00      	nop

00000238 <__STREXH>:
 * @return        successful / failed
 *
 * Exclusive STR command for 16 bit values
 */
uint32_t __STREXH(uint16_t value, uint16_t *addr)
{
 238:	b490      	push	{r4, r7}
 23a:	b084      	sub	sp, #16
 23c:	af00      	add	r7, sp, #0
 23e:	4603      	mov	r3, r0
 240:	6039      	str	r1, [r7, #0]
 242:	80fb      	strh	r3, [r7, #6]
   uint32_t result=0;
 244:	f04f 0300 	mov.w	r3, #0
 248:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
 24a:	683b      	ldr	r3, [r7, #0]
 24c:	88fa      	ldrh	r2, [r7, #6]
 24e:	e8c3 2f54 	strexh	r4, r2, [r3]
 252:	60fc      	str	r4, [r7, #12]
   return(result);
 254:	68fb      	ldr	r3, [r7, #12]
}
 256:	4618      	mov	r0, r3
 258:	f107 0710 	add.w	r7, r7, #16
 25c:	46bd      	mov	sp, r7
 25e:	bc90      	pop	{r4, r7}
 260:	4770      	bx	lr
 262:	bf00      	nop

00000264 <__STREXW>:
 * @return        successful / failed
 *
 * Exclusive STR command for 32 bit values
 */
uint32_t __STREXW(uint32_t value, uint32_t *addr)
{
 264:	b490      	push	{r4, r7}
 266:	b084      	sub	sp, #16
 268:	af00      	add	r7, sp, #0
 26a:	6078      	str	r0, [r7, #4]
 26c:	6039      	str	r1, [r7, #0]
   uint32_t result=0;
 26e:	f04f 0300 	mov.w	r3, #0
 272:	60fb      	str	r3, [r7, #12]
  
   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );
 274:	683b      	ldr	r3, [r7, #0]
 276:	687a      	ldr	r2, [r7, #4]
 278:	e843 2400 	strex	r4, r2, [r3]
 27c:	60fc      	str	r4, [r7, #12]
   return(result);
 27e:	68fb      	ldr	r3, [r7, #12]
}
 280:	4618      	mov	r0, r3
 282:	f107 0710 	add.w	r7, r7, #16
 286:	46bd      	mov	sp, r7
 288:	bc90      	pop	{r4, r7}
 28a:	4770      	bx	lr

system_stm32f10x.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 317292 Jul 30 19:07 2021 system_stm32f10x.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000032c  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000014  00000000  00000000  00000360  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000374  2**0
                  ALLOC
  3 .debug_abbrev 0000017e  00000000  00000000  00000374  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000004fa  00000000  00000000  000004f2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000478  00000000  00000000  000009ec  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0004b969  00000000  00000000  00000e64  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000000c8  00000000  00000000  0004c7cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000061  00000000  00000000  0004c895  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000067  00000000  00000000  0004c8f6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0004c95d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000002b2  00000000  00000000  0004c97d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0004cc2f  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0004cc5a  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000080  00000000  00000000  0004cc8c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 system_stm32f10x.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
000001dc l     F .text	0000000a SetSysClock
000001e8 l     F .text	00000144 SetSysClockTo72
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     O .data	00000004 SystemCoreClock
00000004 g     O .data	00000010 AHBPrescTable
00000000 g     F .text	0000007c SystemInit
0000007c g     F .text	00000160 SystemCoreClockUpdate



Disassembly of section .text:

00000000 <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
   0:	b580      	push	{r7, lr}
   2:	af00      	add	r7, sp, #0
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
   4:	4b1a      	ldr	r3, [pc, #104]	; (70 <SystemInit+0x70>)
   6:	4a1a      	ldr	r2, [pc, #104]	; (70 <SystemInit+0x70>)
   8:	6812      	ldr	r2, [r2, #0]
   a:	f042 0201 	orr.w	r2, r2, #1
   e:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
  10:	4a17      	ldr	r2, [pc, #92]	; (70 <SystemInit+0x70>)
  12:	4b17      	ldr	r3, [pc, #92]	; (70 <SystemInit+0x70>)
  14:	6859      	ldr	r1, [r3, #4]
  16:	4b17      	ldr	r3, [pc, #92]	; (74 <SystemInit+0x74>)
  18:	ea01 0303 	and.w	r3, r1, r3
  1c:	6053      	str	r3, [r2, #4]
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
  1e:	4a14      	ldr	r2, [pc, #80]	; (70 <SystemInit+0x70>)
  20:	4b13      	ldr	r3, [pc, #76]	; (70 <SystemInit+0x70>)
  22:	681b      	ldr	r3, [r3, #0]
  24:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
  28:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  2c:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
  2e:	4b10      	ldr	r3, [pc, #64]	; (70 <SystemInit+0x70>)
  30:	4a0f      	ldr	r2, [pc, #60]	; (70 <SystemInit+0x70>)
  32:	6812      	ldr	r2, [r2, #0]
  34:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  38:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
  3a:	4b0d      	ldr	r3, [pc, #52]	; (70 <SystemInit+0x70>)
  3c:	4a0c      	ldr	r2, [pc, #48]	; (70 <SystemInit+0x70>)
  3e:	6852      	ldr	r2, [r2, #4]
  40:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
  44:	605a      	str	r2, [r3, #4]

#ifdef STM32F10X_CL
  /* Reset PLL2ON and PLL3ON bits */
  RCC->CR &= (uint32_t)0xEBFFFFFF;
  46:	4b0a      	ldr	r3, [pc, #40]	; (70 <SystemInit+0x70>)
  48:	4a09      	ldr	r2, [pc, #36]	; (70 <SystemInit+0x70>)
  4a:	6812      	ldr	r2, [r2, #0]
  4c:	f022 52a0 	bic.w	r2, r2, #335544320	; 0x14000000
  50:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x00FF0000;
  52:	4b07      	ldr	r3, [pc, #28]	; (70 <SystemInit+0x70>)
  54:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
  58:	609a      	str	r2, [r3, #8]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
  5a:	4b05      	ldr	r3, [pc, #20]	; (70 <SystemInit+0x70>)
  5c:	f04f 0200 	mov.w	r2, #0
  60:	62da      	str	r2, [r3, #44]	; 0x2c
  #endif /* DATA_IN_ExtSRAM */
#endif 

  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
  /* Configure the Flash Latency cycles and enable prefetch buffer */
  SetSysClock();
  62:	f000 f8bb 	bl	1dc <SetSysClock>

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
  66:	4b04      	ldr	r3, [pc, #16]	; (78 <SystemInit+0x78>)
  68:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  6c:	609a      	str	r2, [r3, #8]
#endif 
}
  6e:	bd80      	pop	{r7, pc}
  70:	40021000 	.word	0x40021000
  74:	f0ff0000 	.word	0xf0ff0000
  78:	e000ed00 	.word	0xe000ed00

0000007c <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
  7c:	b480      	push	{r7}
  7e:	b089      	sub	sp, #36	; 0x24
  80:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllmull = 0, pllsource = 0;
  82:	f04f 0300 	mov.w	r3, #0
  86:	61bb      	str	r3, [r7, #24]
  88:	f04f 0300 	mov.w	r3, #0
  8c:	61fb      	str	r3, [r7, #28]
  8e:	f04f 0300 	mov.w	r3, #0
  92:	617b      	str	r3, [r7, #20]

#ifdef  STM32F10X_CL
  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
  94:	f04f 0300 	mov.w	r3, #0
  98:	613b      	str	r3, [r7, #16]
  9a:	f04f 0300 	mov.w	r3, #0
  9e:	60fb      	str	r3, [r7, #12]
  a0:	f04f 0300 	mov.w	r3, #0
  a4:	60bb      	str	r3, [r7, #8]
  a6:	f04f 0300 	mov.w	r3, #0
  aa:	607b      	str	r3, [r7, #4]
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  ac:	4b45      	ldr	r3, [pc, #276]	; (1c4 <SystemCoreClockUpdate+0x148>)
  ae:	685b      	ldr	r3, [r3, #4]
  b0:	f003 030c 	and.w	r3, r3, #12
  b4:	61bb      	str	r3, [r7, #24]
  
  switch (tmp)
  b6:	69bb      	ldr	r3, [r7, #24]
  b8:	2b04      	cmp	r3, #4
  ba:	d007      	beq.n	cc <SystemCoreClockUpdate+0x50>
  bc:	2b08      	cmp	r3, #8
  be:	d009      	beq.n	d4 <SystemCoreClockUpdate+0x58>
  c0:	2b00      	cmp	r3, #0
  c2:	d165      	bne.n	190 <SystemCoreClockUpdate+0x114>
  {
    case 0x00:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
  c4:	4b40      	ldr	r3, [pc, #256]	; (1c8 <SystemCoreClockUpdate+0x14c>)
  c6:	4a41      	ldr	r2, [pc, #260]	; (1cc <SystemCoreClockUpdate+0x150>)
  c8:	601a      	str	r2, [r3, #0]
      break;
  ca:	e065      	b.n	198 <SystemCoreClockUpdate+0x11c>
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
  cc:	4b3e      	ldr	r3, [pc, #248]	; (1c8 <SystemCoreClockUpdate+0x14c>)
  ce:	4a40      	ldr	r2, [pc, #256]	; (1d0 <SystemCoreClockUpdate+0x154>)
  d0:	601a      	str	r2, [r3, #0]
      break;
  d2:	e061      	b.n	198 <SystemCoreClockUpdate+0x11c>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
  d4:	4b3b      	ldr	r3, [pc, #236]	; (1c4 <SystemCoreClockUpdate+0x148>)
  d6:	685b      	ldr	r3, [r3, #4]
  d8:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
  dc:	61fb      	str	r3, [r7, #28]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
  de:	4b39      	ldr	r3, [pc, #228]	; (1c4 <SystemCoreClockUpdate+0x148>)
  e0:	685b      	ldr	r3, [r3, #4]
  e2:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  e6:	617b      	str	r3, [r7, #20]
          SystemCoreClock = HSE_VALUE * pllmull;
        }
 #endif
      }
#else
      pllmull = pllmull >> 18;
  e8:	69fb      	ldr	r3, [r7, #28]
  ea:	ea4f 4393 	mov.w	r3, r3, lsr #18
  ee:	61fb      	str	r3, [r7, #28]
      
      if (pllmull != 0x0D)
  f0:	69fb      	ldr	r3, [r7, #28]
  f2:	2b0d      	cmp	r3, #13
  f4:	d004      	beq.n	100 <SystemCoreClockUpdate+0x84>
      {
         pllmull += 2;
  f6:	69fb      	ldr	r3, [r7, #28]
  f8:	f103 0302 	add.w	r3, r3, #2
  fc:	61fb      	str	r3, [r7, #28]
  fe:	e002      	b.n	106 <SystemCoreClockUpdate+0x8a>
      }
      else
      { /* PLL multiplication factor = PLL input clock * 6.5 */
        pllmull = 13 / 2; 
 100:	f04f 0306 	mov.w	r3, #6
 104:	61fb      	str	r3, [r7, #28]
      }
            
      if (pllsource == 0x00)
 106:	697b      	ldr	r3, [r7, #20]
 108:	2b00      	cmp	r3, #0
 10a:	d106      	bne.n	11a <SystemCoreClockUpdate+0x9e>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
 10c:	69fb      	ldr	r3, [r7, #28]
 10e:	4a31      	ldr	r2, [pc, #196]	; (1d4 <SystemCoreClockUpdate+0x158>)
 110:	fb02 f203 	mul.w	r2, r2, r3
 114:	4b2c      	ldr	r3, [pc, #176]	; (1c8 <SystemCoreClockUpdate+0x14c>)
 116:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 118:	e03e      	b.n	198 <SystemCoreClockUpdate+0x11c>
      }
      else
      {/* PREDIV1 selected as PLL clock entry */
        
        /* Get PREDIV1 clock source and division factor */
        prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
 11a:	4b2a      	ldr	r3, [pc, #168]	; (1c4 <SystemCoreClockUpdate+0x148>)
 11c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 11e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 122:	613b      	str	r3, [r7, #16]
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 124:	4b27      	ldr	r3, [pc, #156]	; (1c4 <SystemCoreClockUpdate+0x148>)
 126:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 128:	f003 030f 	and.w	r3, r3, #15
 12c:	f103 0301 	add.w	r3, r3, #1
 130:	60fb      	str	r3, [r7, #12]
        
        if (prediv1source == 0)
 132:	693b      	ldr	r3, [r7, #16]
 134:	2b00      	cmp	r3, #0
 136:	d109      	bne.n	14c <SystemCoreClockUpdate+0xd0>
        { 
          /* HSE oscillator clock selected as PREDIV1 clock entry */
          SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
 138:	4a25      	ldr	r2, [pc, #148]	; (1d0 <SystemCoreClockUpdate+0x154>)
 13a:	68fb      	ldr	r3, [r7, #12]
 13c:	fbb2 f3f3 	udiv	r3, r2, r3
 140:	69fa      	ldr	r2, [r7, #28]
 142:	fb02 f203 	mul.w	r2, r2, r3
 146:	4b20      	ldr	r3, [pc, #128]	; (1c8 <SystemCoreClockUpdate+0x14c>)
 148:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 14a:	e025      	b.n	198 <SystemCoreClockUpdate+0x11c>
        }
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
 14c:	4b1d      	ldr	r3, [pc, #116]	; (1c4 <SystemCoreClockUpdate+0x148>)
 14e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 150:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 154:	ea4f 1313 	mov.w	r3, r3, lsr #4
 158:	f103 0301 	add.w	r3, r3, #1
 15c:	60bb      	str	r3, [r7, #8]
          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
 15e:	4b19      	ldr	r3, [pc, #100]	; (1c4 <SystemCoreClockUpdate+0x148>)
 160:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 162:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 166:	ea4f 2313 	mov.w	r3, r3, lsr #8
 16a:	f103 0302 	add.w	r3, r3, #2
 16e:	607b      	str	r3, [r7, #4]
          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 170:	4a17      	ldr	r2, [pc, #92]	; (1d0 <SystemCoreClockUpdate+0x154>)
 172:	68bb      	ldr	r3, [r7, #8]
 174:	fbb2 f3f3 	udiv	r3, r2, r3
 178:	687a      	ldr	r2, [r7, #4]
 17a:	fb02 f203 	mul.w	r2, r2, r3
 17e:	68fb      	ldr	r3, [r7, #12]
 180:	fbb2 f3f3 	udiv	r3, r2, r3
 184:	69fa      	ldr	r2, [r7, #28]
 186:	fb02 f203 	mul.w	r2, r2, r3
 18a:	4b0f      	ldr	r3, [pc, #60]	; (1c8 <SystemCoreClockUpdate+0x14c>)
 18c:	601a      	str	r2, [r3, #0]
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 18e:	e003      	b.n	198 <SystemCoreClockUpdate+0x11c>

    default:
      SystemCoreClock = HSI_VALUE;
 190:	4b0d      	ldr	r3, [pc, #52]	; (1c8 <SystemCoreClockUpdate+0x14c>)
 192:	4a0e      	ldr	r2, [pc, #56]	; (1cc <SystemCoreClockUpdate+0x150>)
 194:	601a      	str	r2, [r3, #0]
      break;
 196:	bf00      	nop
  }
  
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 198:	4b0a      	ldr	r3, [pc, #40]	; (1c4 <SystemCoreClockUpdate+0x148>)
 19a:	685b      	ldr	r3, [r3, #4]
 19c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 1a0:	ea4f 1313 	mov.w	r3, r3, lsr #4
 1a4:	4a0c      	ldr	r2, [pc, #48]	; (1d8 <SystemCoreClockUpdate+0x15c>)
 1a6:	5cd3      	ldrb	r3, [r2, r3]
 1a8:	b2db      	uxtb	r3, r3
 1aa:	61bb      	str	r3, [r7, #24]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 1ac:	4b06      	ldr	r3, [pc, #24]	; (1c8 <SystemCoreClockUpdate+0x14c>)
 1ae:	681a      	ldr	r2, [r3, #0]
 1b0:	69bb      	ldr	r3, [r7, #24]
 1b2:	fa22 f203 	lsr.w	r2, r2, r3
 1b6:	4b04      	ldr	r3, [pc, #16]	; (1c8 <SystemCoreClockUpdate+0x14c>)
 1b8:	601a      	str	r2, [r3, #0]
}
 1ba:	f107 0724 	add.w	r7, r7, #36	; 0x24
 1be:	46bd      	mov	sp, r7
 1c0:	bc80      	pop	{r7}
 1c2:	4770      	bx	lr
 1c4:	40021000 	.word	0x40021000
 1c8:	00000000 	.word	0x00000000
			1c8: R_ARM_ABS32	SystemCoreClock
 1cc:	007a1200 	.word	0x007a1200
 1d0:	017d7840 	.word	0x017d7840
 1d4:	003d0900 	.word	0x003d0900
 1d8:	00000000 	.word	0x00000000
			1d8: R_ARM_ABS32	AHBPrescTable

000001dc <SetSysClock>:
  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 1dc:	b580      	push	{r7, lr}
 1de:	af00      	add	r7, sp, #0
#elif defined SYSCLK_FREQ_48MHz
  SetSysClockTo48();
#elif defined SYSCLK_FREQ_56MHz
  SetSysClockTo56();  
#elif defined SYSCLK_FREQ_72MHz
  SetSysClockTo72();
 1e0:	f000 f802 	bl	1e8 <SetSysClockTo72>
#endif
 
 /* If none of the define above is enabled, the HSI is used as System clock
    source (default after reset) */ 
}
 1e4:	bd80      	pop	{r7, pc}
 1e6:	bf00      	nop

000001e8 <SetSysClockTo72>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
static void SetSysClockTo72(void)
{
 1e8:	b480      	push	{r7}
 1ea:	b083      	sub	sp, #12
 1ec:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 1ee:	f04f 0300 	mov.w	r3, #0
 1f2:	607b      	str	r3, [r7, #4]
 1f4:	f04f 0300 	mov.w	r3, #0
 1f8:	603b      	str	r3, [r7, #0]
  
  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
  /* Enable HSE */    
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 1fa:	4b49      	ldr	r3, [pc, #292]	; (320 <SetSysClockTo72+0x138>)
 1fc:	4a48      	ldr	r2, [pc, #288]	; (320 <SetSysClockTo72+0x138>)
 1fe:	6812      	ldr	r2, [r2, #0]
 200:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 204:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 206:	4b46      	ldr	r3, [pc, #280]	; (320 <SetSysClockTo72+0x138>)
 208:	681b      	ldr	r3, [r3, #0]
 20a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 20e:	603b      	str	r3, [r7, #0]
    StartUpCounter++;  
 210:	687b      	ldr	r3, [r7, #4]
 212:	f103 0301 	add.w	r3, r3, #1
 216:	607b      	str	r3, [r7, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 218:	683b      	ldr	r3, [r7, #0]
 21a:	2b00      	cmp	r3, #0
 21c:	d103      	bne.n	226 <SetSysClockTo72+0x3e>
 21e:	687b      	ldr	r3, [r7, #4]
 220:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 224:	d1ef      	bne.n	206 <SetSysClockTo72+0x1e>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 226:	4b3e      	ldr	r3, [pc, #248]	; (320 <SetSysClockTo72+0x138>)
 228:	681b      	ldr	r3, [r3, #0]
 22a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 22e:	2b00      	cmp	r3, #0
 230:	d003      	beq.n	23a <SetSysClockTo72+0x52>
  {
    HSEStatus = (uint32_t)0x01;
 232:	f04f 0301 	mov.w	r3, #1
 236:	603b      	str	r3, [r7, #0]
 238:	e002      	b.n	240 <SetSysClockTo72+0x58>
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 23a:	f04f 0300 	mov.w	r3, #0
 23e:	603b      	str	r3, [r7, #0]
  }  

  if (HSEStatus == (uint32_t)0x01)
 240:	683b      	ldr	r3, [r7, #0]
 242:	2b01      	cmp	r3, #1
 244:	d167      	bne.n	316 <SetSysClockTo72+0x12e>
  {
    /* Enable Prefetch Buffer */
    FLASH->ACR |= FLASH_ACR_PRFTBE;
 246:	4b37      	ldr	r3, [pc, #220]	; (324 <SetSysClockTo72+0x13c>)
 248:	4a36      	ldr	r2, [pc, #216]	; (324 <SetSysClockTo72+0x13c>)
 24a:	6812      	ldr	r2, [r2, #0]
 24c:	f042 0210 	orr.w	r2, r2, #16
 250:	601a      	str	r2, [r3, #0]

    /* Flash 2 wait state */
    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
 252:	4b34      	ldr	r3, [pc, #208]	; (324 <SetSysClockTo72+0x13c>)
 254:	4a33      	ldr	r2, [pc, #204]	; (324 <SetSysClockTo72+0x13c>)
 256:	6812      	ldr	r2, [r2, #0]
 258:	f022 0203 	bic.w	r2, r2, #3
 25c:	601a      	str	r2, [r3, #0]
    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
 25e:	4b31      	ldr	r3, [pc, #196]	; (324 <SetSysClockTo72+0x13c>)
 260:	4a30      	ldr	r2, [pc, #192]	; (324 <SetSysClockTo72+0x13c>)
 262:	6812      	ldr	r2, [r2, #0]
 264:	f042 0202 	orr.w	r2, r2, #2
 268:	601a      	str	r2, [r3, #0]

 
    /* HCLK = SYSCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 26a:	4b2d      	ldr	r3, [pc, #180]	; (320 <SetSysClockTo72+0x138>)
 26c:	4a2c      	ldr	r2, [pc, #176]	; (320 <SetSysClockTo72+0x138>)
 26e:	6852      	ldr	r2, [r2, #4]
 270:	605a      	str	r2, [r3, #4]
      
    /* PCLK2 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 272:	4b2b      	ldr	r3, [pc, #172]	; (320 <SetSysClockTo72+0x138>)
 274:	4a2a      	ldr	r2, [pc, #168]	; (320 <SetSysClockTo72+0x138>)
 276:	6852      	ldr	r2, [r2, #4]
 278:	605a      	str	r2, [r3, #4]
    
    /* PCLK1 = HCLK */
    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 27a:	4b29      	ldr	r3, [pc, #164]	; (320 <SetSysClockTo72+0x138>)
 27c:	4a28      	ldr	r2, [pc, #160]	; (320 <SetSysClockTo72+0x138>)
 27e:	6852      	ldr	r2, [r2, #4]
 280:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 284:	605a      	str	r2, [r3, #4]
#ifdef STM32F10X_CL
    /* Configure PLLs ------------------------------------------------------*/
    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
        
    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
 286:	4a26      	ldr	r2, [pc, #152]	; (320 <SetSysClockTo72+0x138>)
 288:	4b25      	ldr	r3, [pc, #148]	; (320 <SetSysClockTo72+0x138>)
 28a:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 28c:	4b26      	ldr	r3, [pc, #152]	; (328 <SetSysClockTo72+0x140>)
 28e:	ea01 0303 	and.w	r3, r1, r3
 292:	62d3      	str	r3, [r2, #44]	; 0x2c
                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
 294:	4a22      	ldr	r2, [pc, #136]	; (320 <SetSysClockTo72+0x138>)
 296:	4b22      	ldr	r3, [pc, #136]	; (320 <SetSysClockTo72+0x138>)
 298:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 29a:	f443 3382 	orr.w	r3, r3, #66560	; 0x10400
 29e:	f443 7311 	orr.w	r3, r3, #580	; 0x244
 2a2:	62d3      	str	r3, [r2, #44]	; 0x2c
                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
  
    /* Enable PLL2 */
    RCC->CR |= RCC_CR_PLL2ON;
 2a4:	4b1e      	ldr	r3, [pc, #120]	; (320 <SetSysClockTo72+0x138>)
 2a6:	4a1e      	ldr	r2, [pc, #120]	; (320 <SetSysClockTo72+0x138>)
 2a8:	6812      	ldr	r2, [r2, #0]
 2aa:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 2ae:	601a      	str	r2, [r3, #0]
    /* Wait till PLL2 is ready */
    while((RCC->CR & RCC_CR_PLL2RDY) == 0)
 2b0:	bf00      	nop
 2b2:	4b1b      	ldr	r3, [pc, #108]	; (320 <SetSysClockTo72+0x138>)
 2b4:	681b      	ldr	r3, [r3, #0]
 2b6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 2ba:	2b00      	cmp	r3, #0
 2bc:	d0f9      	beq.n	2b2 <SetSysClockTo72+0xca>
    {
    }
    
   
    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
 2be:	4b18      	ldr	r3, [pc, #96]	; (320 <SetSysClockTo72+0x138>)
 2c0:	4a17      	ldr	r2, [pc, #92]	; (320 <SetSysClockTo72+0x138>)
 2c2:	6852      	ldr	r2, [r2, #4]
 2c4:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 2c8:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
 2ca:	4b15      	ldr	r3, [pc, #84]	; (320 <SetSysClockTo72+0x138>)
 2cc:	4a14      	ldr	r2, [pc, #80]	; (320 <SetSysClockTo72+0x138>)
 2ce:	6852      	ldr	r2, [r2, #4]
 2d0:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 2d4:	605a      	str	r2, [r3, #4]
                                        RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
#endif /* STM32F10X_CL */

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 2d6:	4b12      	ldr	r3, [pc, #72]	; (320 <SetSysClockTo72+0x138>)
 2d8:	4a11      	ldr	r2, [pc, #68]	; (320 <SetSysClockTo72+0x138>)
 2da:	6812      	ldr	r2, [r2, #0]
 2dc:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 2e0:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 2e2:	bf00      	nop
 2e4:	4b0e      	ldr	r3, [pc, #56]	; (320 <SetSysClockTo72+0x138>)
 2e6:	681b      	ldr	r3, [r3, #0]
 2e8:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 2ec:	2b00      	cmp	r3, #0
 2ee:	d0f9      	beq.n	2e4 <SetSysClockTo72+0xfc>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 2f0:	4b0b      	ldr	r3, [pc, #44]	; (320 <SetSysClockTo72+0x138>)
 2f2:	4a0b      	ldr	r2, [pc, #44]	; (320 <SetSysClockTo72+0x138>)
 2f4:	6852      	ldr	r2, [r2, #4]
 2f6:	f022 0203 	bic.w	r2, r2, #3
 2fa:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
 2fc:	4b08      	ldr	r3, [pc, #32]	; (320 <SetSysClockTo72+0x138>)
 2fe:	4a08      	ldr	r2, [pc, #32]	; (320 <SetSysClockTo72+0x138>)
 300:	6852      	ldr	r2, [r2, #4]
 302:	f042 0202 	orr.w	r2, r2, #2
 306:	605a      	str	r2, [r3, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
 308:	bf00      	nop
 30a:	4b05      	ldr	r3, [pc, #20]	; (320 <SetSysClockTo72+0x138>)
 30c:	685b      	ldr	r3, [r3, #4]
 30e:	f003 030c 	and.w	r3, r3, #12
 312:	2b08      	cmp	r3, #8
 314:	d1f9      	bne.n	30a <SetSysClockTo72+0x122>
  }
  else
  { /* If HSE fails to start-up, the application will have wrong clock 
         configuration. User can add here some code to deal with this error */
  }
}
 316:	f107 070c 	add.w	r7, r7, #12
 31a:	46bd      	mov	sp, r7
 31c:	bc80      	pop	{r7}
 31e:	4770      	bx	lr
 320:	40021000 	.word	0x40021000
 324:	40022000 	.word	0x40022000
 328:	fffef000 	.word	0xfffef000
