In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libxme_stm32f0xspl_rcc.a:

stm32f10x_rcc.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 333268 Jul 30 19:07 2021 stm32f10x_rcc.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000abc  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000014  00000000  00000000  00000af0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000b04  2**0
                  ALLOC
  3 .debug_abbrev 00000191  00000000  00000000  00000b04  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000b2f  00000000  00000000  00000c95  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   0000054f  00000000  00000000  000017c4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0004c361  00000000  00000000  00001d13  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000008d4  00000000  00000000  0004e074  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000037e  00000000  00000000  0004e948  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 0000009e  00000000  00000000  0004ecc6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0004ed64  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000006df  00000000  00000000  0004ed84  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0004f463  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0004f48e  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000484  00000000  00000000  0004f4c0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 stm32f10x_rcc.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     O .data	00000010 APBAHBPrescTable
00000010 l     O .data	00000004 ADCPrescTable
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000070 RCC_DeInit
00000070 g     F .text	0000005c RCC_HSEConfig
000000cc g     F .text	00000062 RCC_WaitForHSEStartUp
000009bc g     F .text	00000084 RCC_GetFlagStatus
00000130 g     F .text	00000040 RCC_AdjustHSICalibrationValue
00000170 g     F .text	00000020 RCC_HSICmd
00000190 g     F .text	00000044 RCC_PLLConfig
000001d4 g     F .text	00000020 RCC_PLLCmd
000001f4 g     F .text	00000048 RCC_PREDIV1Config
0000023c g     F .text	0000003c RCC_PREDIV2Config
00000278 g     F .text	0000003c RCC_PLL2Config
000002b4 g     F .text	00000020 RCC_PLL2Cmd
000002d4 g     F .text	0000003c RCC_PLL3Config
00000310 g     F .text	00000020 RCC_PLL3Cmd
00000330 g     F .text	0000003c RCC_SYSCLKConfig
0000036c g     F .text	0000001c RCC_GetSYSCLKSource
00000388 g     F .text	0000003c RCC_HCLKConfig
000003c4 g     F .text	0000003c RCC_PCLK1Config
00000400 g     F .text	00000040 RCC_PCLK2Config
00000440 g     F .text	00000050 RCC_ITConfig
00000490 g     F .text	0000001c RCC_OTGFSCLKConfig
000004ac g     F .text	0000003c RCC_ADCCLKConfig
000004e8 g     F .text	0000001c RCC_I2S2CLKConfig
00000504 g     F .text	0000001c RCC_I2S3CLKConfig
00000520 g     F .text	00000048 RCC_LSEConfig
00000568 g     F .text	00000020 RCC_LSICmd
00000588 g     F .text	00000024 RCC_RTCCLKConfig
000005ac g     F .text	00000020 RCC_RTCCLKCmd
000005cc g     F .text	000001f8 RCC_GetClocksFreq
000007c4 g     F .text	00000044 RCC_AHBPeriphClockCmd
00000808 g     F .text	00000044 RCC_APB2PeriphClockCmd
0000084c g     F .text	00000044 RCC_APB1PeriphClockCmd
00000890 g     F .text	00000044 RCC_AHBPeriphResetCmd
000008d4 g     F .text	00000044 RCC_APB2PeriphResetCmd
00000918 g     F .text	00000044 RCC_APB1PeriphResetCmd
0000095c g     F .text	00000020 RCC_BackupResetCmd
0000097c g     F .text	00000020 RCC_ClockSecuritySystemCmd
0000099c g     F .text	00000020 RCC_MCOConfig
00000a40 g     F .text	0000001c RCC_ClearFlag
00000a5c g     F .text	00000040 RCC_GetITStatus
00000a9c g     F .text	00000020 RCC_ClearITPendingBit



Disassembly of section .text:

00000000 <RCC_DeInit>:
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
   4:	4b18      	ldr	r3, [pc, #96]	; (68 <RCC_DeInit+0x68>)
   6:	4a18      	ldr	r2, [pc, #96]	; (68 <RCC_DeInit+0x68>)
   8:	6812      	ldr	r2, [r2, #0]
   a:	f042 0201 	orr.w	r2, r2, #1
   e:	601a      	str	r2, [r3, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
  10:	4a15      	ldr	r2, [pc, #84]	; (68 <RCC_DeInit+0x68>)
  12:	4b15      	ldr	r3, [pc, #84]	; (68 <RCC_DeInit+0x68>)
  14:	6859      	ldr	r1, [r3, #4]
  16:	4b15      	ldr	r3, [pc, #84]	; (6c <RCC_DeInit+0x6c>)
  18:	ea01 0303 	and.w	r3, r1, r3
  1c:	6053      	str	r3, [r2, #4]
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
  1e:	4a12      	ldr	r2, [pc, #72]	; (68 <RCC_DeInit+0x68>)
  20:	4b11      	ldr	r3, [pc, #68]	; (68 <RCC_DeInit+0x68>)
  22:	681b      	ldr	r3, [r3, #0]
  24:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
  28:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  2c:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
  2e:	4b0e      	ldr	r3, [pc, #56]	; (68 <RCC_DeInit+0x68>)
  30:	4a0d      	ldr	r2, [pc, #52]	; (68 <RCC_DeInit+0x68>)
  32:	6812      	ldr	r2, [r2, #0]
  34:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  38:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
  3a:	4b0b      	ldr	r3, [pc, #44]	; (68 <RCC_DeInit+0x68>)
  3c:	4a0a      	ldr	r2, [pc, #40]	; (68 <RCC_DeInit+0x68>)
  3e:	6852      	ldr	r2, [r2, #4]
  40:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
  44:	605a      	str	r2, [r3, #4]

#ifdef STM32F10X_CL
  /* Reset PLL2ON and PLL3ON bits */
  RCC->CR &= (uint32_t)0xEBFFFFFF;
  46:	4b08      	ldr	r3, [pc, #32]	; (68 <RCC_DeInit+0x68>)
  48:	4a07      	ldr	r2, [pc, #28]	; (68 <RCC_DeInit+0x68>)
  4a:	6812      	ldr	r2, [r2, #0]
  4c:	f022 52a0 	bic.w	r2, r2, #335544320	; 0x14000000
  50:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x00FF0000;
  52:	4b05      	ldr	r3, [pc, #20]	; (68 <RCC_DeInit+0x68>)
  54:	f44f 027f 	mov.w	r2, #16711680	; 0xff0000
  58:	609a      	str	r2, [r3, #8]

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
  5a:	4b03      	ldr	r3, [pc, #12]	; (68 <RCC_DeInit+0x68>)
  5c:	f04f 0200 	mov.w	r2, #0
  60:	62da      	str	r2, [r3, #44]	; 0x2c
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
#endif /* STM32F10X_CL */

}
  62:	46bd      	mov	sp, r7
  64:	bc80      	pop	{r7}
  66:	4770      	bx	lr
  68:	40021000 	.word	0x40021000
  6c:	f0ff0000 	.word	0xf0ff0000

00000070 <RCC_HSEConfig>:
  *     @arg RCC_HSE_ON: HSE oscillator ON
  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint32_t RCC_HSE)
{
  70:	b480      	push	{r7}
  72:	b083      	sub	sp, #12
  74:	af00      	add	r7, sp, #0
  76:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
  78:	4b13      	ldr	r3, [pc, #76]	; (c8 <RCC_HSEConfig+0x58>)
  7a:	4a13      	ldr	r2, [pc, #76]	; (c8 <RCC_HSEConfig+0x58>)
  7c:	6812      	ldr	r2, [r2, #0]
  7e:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  82:	601a      	str	r2, [r3, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
  84:	4b10      	ldr	r3, [pc, #64]	; (c8 <RCC_HSEConfig+0x58>)
  86:	4a10      	ldr	r2, [pc, #64]	; (c8 <RCC_HSEConfig+0x58>)
  88:	6812      	ldr	r2, [r2, #0]
  8a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  8e:	601a      	str	r2, [r3, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  90:	687b      	ldr	r3, [r7, #4]
  92:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  96:	d003      	beq.n	a0 <RCC_HSEConfig+0x30>
  98:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
  9c:	d007      	beq.n	ae <RCC_HSEConfig+0x3e>
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
      break;
      
    default:
      break;
  9e:	e00d      	b.n	bc <RCC_HSEConfig+0x4c>
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
  {
    case RCC_HSE_ON:
      /* Set HSEON bit */
      RCC->CR |= CR_HSEON_Set;
  a0:	4b09      	ldr	r3, [pc, #36]	; (c8 <RCC_HSEConfig+0x58>)
  a2:	4a09      	ldr	r2, [pc, #36]	; (c8 <RCC_HSEConfig+0x58>)
  a4:	6812      	ldr	r2, [r2, #0]
  a6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
  aa:	601a      	str	r2, [r3, #0]
      break;
  ac:	e006      	b.n	bc <RCC_HSEConfig+0x4c>
      
    case RCC_HSE_Bypass:
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
  ae:	4b06      	ldr	r3, [pc, #24]	; (c8 <RCC_HSEConfig+0x58>)
  b0:	4a05      	ldr	r2, [pc, #20]	; (c8 <RCC_HSEConfig+0x58>)
  b2:	6812      	ldr	r2, [r2, #0]
  b4:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
  b8:	601a      	str	r2, [r3, #0]
      break;
  ba:	bf00      	nop
      
    default:
      break;
  }
}
  bc:	f107 070c 	add.w	r7, r7, #12
  c0:	46bd      	mov	sp, r7
  c2:	bc80      	pop	{r7}
  c4:	4770      	bx	lr
  c6:	bf00      	nop
  c8:	40021000 	.word	0x40021000

000000cc <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  cc:	b580      	push	{r7, lr}
  ce:	b082      	sub	sp, #8
  d0:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0;
  d2:	f04f 0300 	mov.w	r3, #0
  d6:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
  d8:	f04f 0300 	mov.w	r3, #0
  dc:	71fb      	strb	r3, [r7, #7]
  FlagStatus HSEStatus = RESET;
  de:	f04f 0300 	mov.w	r3, #0
  e2:	71bb      	strb	r3, [r7, #6]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
  e4:	f04f 0031 	mov.w	r0, #49	; 0x31
  e8:	f7ff fffe 	bl	9bc <RCC_GetFlagStatus>
			e8: R_ARM_THM_CALL	RCC_GetFlagStatus
  ec:	4603      	mov	r3, r0
  ee:	71bb      	strb	r3, [r7, #6]
    StartUpCounter++;  
  f0:	683b      	ldr	r3, [r7, #0]
  f2:	f103 0301 	add.w	r3, r3, #1
  f6:	603b      	str	r3, [r7, #0]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
  f8:	683b      	ldr	r3, [r7, #0]
  fa:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
  fe:	d002      	beq.n	106 <RCC_WaitForHSEStartUp+0x3a>
 100:	79bb      	ldrb	r3, [r7, #6]
 102:	2b00      	cmp	r3, #0
 104:	d0ee      	beq.n	e4 <RCC_WaitForHSEStartUp+0x18>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 106:	f04f 0031 	mov.w	r0, #49	; 0x31
 10a:	f7ff fffe 	bl	9bc <RCC_GetFlagStatus>
			10a: R_ARM_THM_CALL	RCC_GetFlagStatus
 10e:	4603      	mov	r3, r0
 110:	2b00      	cmp	r3, #0
 112:	d003      	beq.n	11c <RCC_WaitForHSEStartUp+0x50>
  {
    status = SUCCESS;
 114:	f04f 0301 	mov.w	r3, #1
 118:	71fb      	strb	r3, [r7, #7]
 11a:	e002      	b.n	122 <RCC_WaitForHSEStartUp+0x56>
  }
  else
  {
    status = ERROR;
 11c:	f04f 0300 	mov.w	r3, #0
 120:	71fb      	strb	r3, [r7, #7]
  }  
  return (status);
 122:	79fb      	ldrb	r3, [r7, #7]
}
 124:	4618      	mov	r0, r3
 126:	f107 0708 	add.w	r7, r7, #8
 12a:	46bd      	mov	sp, r7
 12c:	bd80      	pop	{r7, pc}
 12e:	bf00      	nop

00000130 <RCC_AdjustHSICalibrationValue>:
  * @param  HSICalibrationValue: specifies the calibration trimming value.
  *   This parameter must be a number between 0 and 0x1F.
  * @retval None
  */
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
{
 130:	b480      	push	{r7}
 132:	b085      	sub	sp, #20
 134:	af00      	add	r7, sp, #0
 136:	4603      	mov	r3, r0
 138:	71fb      	strb	r3, [r7, #7]
  uint32_t tmpreg = 0;
 13a:	f04f 0300 	mov.w	r3, #0
 13e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
  tmpreg = RCC->CR;
 140:	4b0a      	ldr	r3, [pc, #40]	; (16c <RCC_AdjustHSICalibrationValue+0x3c>)
 142:	681b      	ldr	r3, [r3, #0]
 144:	60fb      	str	r3, [r7, #12]
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= CR_HSITRIM_Mask;
 146:	68fb      	ldr	r3, [r7, #12]
 148:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 14c:	60fb      	str	r3, [r7, #12]
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 14e:	79fb      	ldrb	r3, [r7, #7]
 150:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 154:	68fa      	ldr	r2, [r7, #12]
 156:	ea42 0303 	orr.w	r3, r2, r3
 15a:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CR = tmpreg;
 15c:	4b03      	ldr	r3, [pc, #12]	; (16c <RCC_AdjustHSICalibrationValue+0x3c>)
 15e:	68fa      	ldr	r2, [r7, #12]
 160:	601a      	str	r2, [r3, #0]
}
 162:	f107 0714 	add.w	r7, r7, #20
 166:	46bd      	mov	sp, r7
 168:	bc80      	pop	{r7}
 16a:	4770      	bx	lr
 16c:	40021000 	.word	0x40021000

00000170 <RCC_HSICmd>:
  * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.
  * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_HSICmd(FunctionalState NewState)
{
 170:	b480      	push	{r7}
 172:	b083      	sub	sp, #12
 174:	af00      	add	r7, sp, #0
 176:	4603      	mov	r3, r0
 178:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 17a:	4b04      	ldr	r3, [pc, #16]	; (18c <RCC_HSICmd+0x1c>)
 17c:	79fa      	ldrb	r2, [r7, #7]
 17e:	601a      	str	r2, [r3, #0]
}
 180:	f107 070c 	add.w	r7, r7, #12
 184:	46bd      	mov	sp, r7
 186:	bc80      	pop	{r7}
 188:	4770      	bx	lr
 18a:	bf00      	nop
 18c:	42420000 	.word	0x42420000

00000190 <RCC_PLLConfig>:
  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 190:	b480      	push	{r7}
 192:	b085      	sub	sp, #20
 194:	af00      	add	r7, sp, #0
 196:	6078      	str	r0, [r7, #4]
 198:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 19a:	f04f 0300 	mov.w	r3, #0
 19e:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 1a0:	4b0b      	ldr	r3, [pc, #44]	; (1d0 <RCC_PLLConfig+0x40>)
 1a2:	685b      	ldr	r3, [r3, #4]
 1a4:	60fb      	str	r3, [r7, #12]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 1a6:	68fb      	ldr	r3, [r7, #12]
 1a8:	f423 1374 	bic.w	r3, r3, #3997696	; 0x3d0000
 1ac:	60fb      	str	r3, [r7, #12]
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 1ae:	687a      	ldr	r2, [r7, #4]
 1b0:	683b      	ldr	r3, [r7, #0]
 1b2:	ea42 0303 	orr.w	r3, r2, r3
 1b6:	68fa      	ldr	r2, [r7, #12]
 1b8:	ea42 0303 	orr.w	r3, r2, r3
 1bc:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 1be:	4b04      	ldr	r3, [pc, #16]	; (1d0 <RCC_PLLConfig+0x40>)
 1c0:	68fa      	ldr	r2, [r7, #12]
 1c2:	605a      	str	r2, [r3, #4]
}
 1c4:	f107 0714 	add.w	r7, r7, #20
 1c8:	46bd      	mov	sp, r7
 1ca:	bc80      	pop	{r7}
 1cc:	4770      	bx	lr
 1ce:	bf00      	nop
 1d0:	40021000 	.word	0x40021000

000001d4 <RCC_PLLCmd>:
  * @note   The PLL can not be disabled if it is used as system clock.
  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 1d4:	b480      	push	{r7}
 1d6:	b083      	sub	sp, #12
 1d8:	af00      	add	r7, sp, #0
 1da:	4603      	mov	r3, r0
 1dc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 1de:	4b04      	ldr	r3, [pc, #16]	; (1f0 <RCC_PLLCmd+0x1c>)
 1e0:	79fa      	ldrb	r2, [r7, #7]
 1e2:	601a      	str	r2, [r3, #0]
}
 1e4:	f107 070c 	add.w	r7, r7, #12
 1e8:	46bd      	mov	sp, r7
 1ea:	bc80      	pop	{r7}
 1ec:	4770      	bx	lr
 1ee:	bf00      	nop
 1f0:	42420060 	.word	0x42420060

000001f4 <RCC_PREDIV1Config>:
  * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
  *   This parameter can be RCC_PREDIV1_Divx where x:[1,16]
  * @retval None
  */
void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)
{
 1f4:	b480      	push	{r7}
 1f6:	b085      	sub	sp, #20
 1f8:	af00      	add	r7, sp, #0
 1fa:	6078      	str	r0, [r7, #4]
 1fc:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 1fe:	f04f 0300 	mov.w	r3, #0
 202:	60fb      	str	r3, [r7, #12]
  
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
 204:	4b0c      	ldr	r3, [pc, #48]	; (238 <RCC_PREDIV1Config+0x44>)
 206:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 208:	60fb      	str	r3, [r7, #12]
  /* Clear PREDIV1[3:0] and PREDIV1SRC bits */
  tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);
 20a:	68fb      	ldr	r3, [r7, #12]
 20c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 210:	f023 030f 	bic.w	r3, r3, #15
 214:	60fb      	str	r3, [r7, #12]
  /* Set the PREDIV1 clock source and division factor */
  tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;
 216:	687a      	ldr	r2, [r7, #4]
 218:	683b      	ldr	r3, [r7, #0]
 21a:	ea42 0303 	orr.w	r3, r2, r3
 21e:	68fa      	ldr	r2, [r7, #12]
 220:	ea42 0303 	orr.w	r3, r2, r3
 224:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 226:	4b04      	ldr	r3, [pc, #16]	; (238 <RCC_PREDIV1Config+0x44>)
 228:	68fa      	ldr	r2, [r7, #12]
 22a:	62da      	str	r2, [r3, #44]	; 0x2c
}
 22c:	f107 0714 	add.w	r7, r7, #20
 230:	46bd      	mov	sp, r7
 232:	bc80      	pop	{r7}
 234:	4770      	bx	lr
 236:	bf00      	nop
 238:	40021000 	.word	0x40021000

0000023c <RCC_PREDIV2Config>:
  * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.
  *   This parameter can be RCC_PREDIV2_Divx where x:[1,16]
  * @retval None
  */
void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)
{
 23c:	b480      	push	{r7}
 23e:	b085      	sub	sp, #20
 240:	af00      	add	r7, sp, #0
 242:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 244:	f04f 0300 	mov.w	r3, #0
 248:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));

  tmpreg = RCC->CFGR2;
 24a:	4b0a      	ldr	r3, [pc, #40]	; (274 <RCC_PREDIV2Config+0x38>)
 24c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 24e:	60fb      	str	r3, [r7, #12]
  /* Clear PREDIV2[3:0] bits */
  tmpreg &= ~CFGR2_PREDIV2;
 250:	68fb      	ldr	r3, [r7, #12]
 252:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 256:	60fb      	str	r3, [r7, #12]
  /* Set the PREDIV2 division factor */
  tmpreg |= RCC_PREDIV2_Div;
 258:	68fa      	ldr	r2, [r7, #12]
 25a:	687b      	ldr	r3, [r7, #4]
 25c:	ea42 0303 	orr.w	r3, r2, r3
 260:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 262:	4b04      	ldr	r3, [pc, #16]	; (274 <RCC_PREDIV2Config+0x38>)
 264:	68fa      	ldr	r2, [r7, #12]
 266:	62da      	str	r2, [r3, #44]	; 0x2c
}
 268:	f107 0714 	add.w	r7, r7, #20
 26c:	46bd      	mov	sp, r7
 26e:	bc80      	pop	{r7}
 270:	4770      	bx	lr
 272:	bf00      	nop
 274:	40021000 	.word	0x40021000

00000278 <RCC_PLL2Config>:
  * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.
  *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}
  * @retval None
  */
void RCC_PLL2Config(uint32_t RCC_PLL2Mul)
{
 278:	b480      	push	{r7}
 27a:	b085      	sub	sp, #20
 27c:	af00      	add	r7, sp, #0
 27e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 280:	f04f 0300 	mov.w	r3, #0
 284:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));

  tmpreg = RCC->CFGR2;
 286:	4b0a      	ldr	r3, [pc, #40]	; (2b0 <RCC_PLL2Config+0x38>)
 288:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 28a:	60fb      	str	r3, [r7, #12]
  /* Clear PLL2Mul[3:0] bits */
  tmpreg &= ~CFGR2_PLL2MUL;
 28c:	68fb      	ldr	r3, [r7, #12]
 28e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 292:	60fb      	str	r3, [r7, #12]
  /* Set the PLL2 configuration bits */
  tmpreg |= RCC_PLL2Mul;
 294:	68fa      	ldr	r2, [r7, #12]
 296:	687b      	ldr	r3, [r7, #4]
 298:	ea42 0303 	orr.w	r3, r2, r3
 29c:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 29e:	4b04      	ldr	r3, [pc, #16]	; (2b0 <RCC_PLL2Config+0x38>)
 2a0:	68fa      	ldr	r2, [r7, #12]
 2a2:	62da      	str	r2, [r3, #44]	; 0x2c
}
 2a4:	f107 0714 	add.w	r7, r7, #20
 2a8:	46bd      	mov	sp, r7
 2aa:	bc80      	pop	{r7}
 2ac:	4770      	bx	lr
 2ae:	bf00      	nop
 2b0:	40021000 	.word	0x40021000

000002b4 <RCC_PLL2Cmd>:
  *   - This function applies only to STM32 Connectivity line devices.
  * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLL2Cmd(FunctionalState NewState)
{
 2b4:	b480      	push	{r7}
 2b6:	b083      	sub	sp, #12
 2b8:	af00      	add	r7, sp, #0
 2ba:	4603      	mov	r3, r0
 2bc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;
 2be:	4b04      	ldr	r3, [pc, #16]	; (2d0 <RCC_PLL2Cmd+0x1c>)
 2c0:	79fa      	ldrb	r2, [r7, #7]
 2c2:	601a      	str	r2, [r3, #0]
}
 2c4:	f107 070c 	add.w	r7, r7, #12
 2c8:	46bd      	mov	sp, r7
 2ca:	bc80      	pop	{r7}
 2cc:	4770      	bx	lr
 2ce:	bf00      	nop
 2d0:	42420068 	.word	0x42420068

000002d4 <RCC_PLL3Config>:
  * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.
  *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}
  * @retval None
  */
void RCC_PLL3Config(uint32_t RCC_PLL3Mul)
{
 2d4:	b480      	push	{r7}
 2d6:	b085      	sub	sp, #20
 2d8:	af00      	add	r7, sp, #0
 2da:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 2dc:	f04f 0300 	mov.w	r3, #0
 2e0:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));

  tmpreg = RCC->CFGR2;
 2e2:	4b0a      	ldr	r3, [pc, #40]	; (30c <RCC_PLL3Config+0x38>)
 2e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 2e6:	60fb      	str	r3, [r7, #12]
  /* Clear PLL3Mul[3:0] bits */
  tmpreg &= ~CFGR2_PLL3MUL;
 2e8:	68fb      	ldr	r3, [r7, #12]
 2ea:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 2ee:	60fb      	str	r3, [r7, #12]
  /* Set the PLL3 configuration bits */
  tmpreg |= RCC_PLL3Mul;
 2f0:	68fa      	ldr	r2, [r7, #12]
 2f2:	687b      	ldr	r3, [r7, #4]
 2f4:	ea42 0303 	orr.w	r3, r2, r3
 2f8:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 2fa:	4b04      	ldr	r3, [pc, #16]	; (30c <RCC_PLL3Config+0x38>)
 2fc:	68fa      	ldr	r2, [r7, #12]
 2fe:	62da      	str	r2, [r3, #44]	; 0x2c
}
 300:	f107 0714 	add.w	r7, r7, #20
 304:	46bd      	mov	sp, r7
 306:	bc80      	pop	{r7}
 308:	4770      	bx	lr
 30a:	bf00      	nop
 30c:	40021000 	.word	0x40021000

00000310 <RCC_PLL3Cmd>:
  * @note   This function applies only to STM32 Connectivity line devices.
  * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLL3Cmd(FunctionalState NewState)
{
 310:	b480      	push	{r7}
 312:	b083      	sub	sp, #12
 314:	af00      	add	r7, sp, #0
 316:	4603      	mov	r3, r0
 318:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;
 31a:	4b04      	ldr	r3, [pc, #16]	; (32c <RCC_PLL3Cmd+0x1c>)
 31c:	79fa      	ldrb	r2, [r7, #7]
 31e:	601a      	str	r2, [r3, #0]
}
 320:	f107 070c 	add.w	r7, r7, #12
 324:	46bd      	mov	sp, r7
 326:	bc80      	pop	{r7}
 328:	4770      	bx	lr
 32a:	bf00      	nop
 32c:	42420070 	.word	0x42420070

00000330 <RCC_SYSCLKConfig>:
  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 330:	b480      	push	{r7}
 332:	b085      	sub	sp, #20
 334:	af00      	add	r7, sp, #0
 336:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 338:	f04f 0300 	mov.w	r3, #0
 33c:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 33e:	4b0a      	ldr	r3, [pc, #40]	; (368 <RCC_SYSCLKConfig+0x38>)
 340:	685b      	ldr	r3, [r3, #4]
 342:	60fb      	str	r3, [r7, #12]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 344:	68fb      	ldr	r3, [r7, #12]
 346:	f023 0303 	bic.w	r3, r3, #3
 34a:	60fb      	str	r3, [r7, #12]
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 34c:	68fa      	ldr	r2, [r7, #12]
 34e:	687b      	ldr	r3, [r7, #4]
 350:	ea42 0303 	orr.w	r3, r2, r3
 354:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 356:	4b04      	ldr	r3, [pc, #16]	; (368 <RCC_SYSCLKConfig+0x38>)
 358:	68fa      	ldr	r2, [r7, #12]
 35a:	605a      	str	r2, [r3, #4]
}
 35c:	f107 0714 	add.w	r7, r7, #20
 360:	46bd      	mov	sp, r7
 362:	bc80      	pop	{r7}
 364:	4770      	bx	lr
 366:	bf00      	nop
 368:	40021000 	.word	0x40021000

0000036c <RCC_GetSYSCLKSource>:
  *     - 0x00: HSI used as system clock
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 36c:	b480      	push	{r7}
 36e:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 370:	4b04      	ldr	r3, [pc, #16]	; (384 <RCC_GetSYSCLKSource+0x18>)
 372:	685b      	ldr	r3, [r3, #4]
 374:	b2db      	uxtb	r3, r3
 376:	f003 030c 	and.w	r3, r3, #12
 37a:	b2db      	uxtb	r3, r3
}
 37c:	4618      	mov	r0, r3
 37e:	46bd      	mov	sp, r7
 380:	bc80      	pop	{r7}
 382:	4770      	bx	lr
 384:	40021000 	.word	0x40021000

00000388 <RCC_HCLKConfig>:
  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 388:	b480      	push	{r7}
 38a:	b085      	sub	sp, #20
 38c:	af00      	add	r7, sp, #0
 38e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 390:	f04f 0300 	mov.w	r3, #0
 394:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 396:	4b0a      	ldr	r3, [pc, #40]	; (3c0 <RCC_HCLKConfig+0x38>)
 398:	685b      	ldr	r3, [r3, #4]
 39a:	60fb      	str	r3, [r7, #12]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 39c:	68fb      	ldr	r3, [r7, #12]
 39e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 3a2:	60fb      	str	r3, [r7, #12]
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 3a4:	68fa      	ldr	r2, [r7, #12]
 3a6:	687b      	ldr	r3, [r7, #4]
 3a8:	ea42 0303 	orr.w	r3, r2, r3
 3ac:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 3ae:	4b04      	ldr	r3, [pc, #16]	; (3c0 <RCC_HCLKConfig+0x38>)
 3b0:	68fa      	ldr	r2, [r7, #12]
 3b2:	605a      	str	r2, [r3, #4]
}
 3b4:	f107 0714 	add.w	r7, r7, #20
 3b8:	46bd      	mov	sp, r7
 3ba:	bc80      	pop	{r7}
 3bc:	4770      	bx	lr
 3be:	bf00      	nop
 3c0:	40021000 	.word	0x40021000

000003c4 <RCC_PCLK1Config>:
  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 3c4:	b480      	push	{r7}
 3c6:	b085      	sub	sp, #20
 3c8:	af00      	add	r7, sp, #0
 3ca:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 3cc:	f04f 0300 	mov.w	r3, #0
 3d0:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 3d2:	4b0a      	ldr	r3, [pc, #40]	; (3fc <RCC_PCLK1Config+0x38>)
 3d4:	685b      	ldr	r3, [r3, #4]
 3d6:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 3d8:	68fb      	ldr	r3, [r7, #12]
 3da:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 3de:	60fb      	str	r3, [r7, #12]
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 3e0:	68fa      	ldr	r2, [r7, #12]
 3e2:	687b      	ldr	r3, [r7, #4]
 3e4:	ea42 0303 	orr.w	r3, r2, r3
 3e8:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 3ea:	4b04      	ldr	r3, [pc, #16]	; (3fc <RCC_PCLK1Config+0x38>)
 3ec:	68fa      	ldr	r2, [r7, #12]
 3ee:	605a      	str	r2, [r3, #4]
}
 3f0:	f107 0714 	add.w	r7, r7, #20
 3f4:	46bd      	mov	sp, r7
 3f6:	bc80      	pop	{r7}
 3f8:	4770      	bx	lr
 3fa:	bf00      	nop
 3fc:	40021000 	.word	0x40021000

00000400 <RCC_PCLK2Config>:
  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 400:	b480      	push	{r7}
 402:	b085      	sub	sp, #20
 404:	af00      	add	r7, sp, #0
 406:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 408:	f04f 0300 	mov.w	r3, #0
 40c:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 40e:	4b0b      	ldr	r3, [pc, #44]	; (43c <RCC_PCLK2Config+0x3c>)
 410:	685b      	ldr	r3, [r3, #4]
 412:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 414:	68fb      	ldr	r3, [r7, #12]
 416:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 41a:	60fb      	str	r3, [r7, #12]
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 41c:	687b      	ldr	r3, [r7, #4]
 41e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 422:	68fa      	ldr	r2, [r7, #12]
 424:	ea42 0303 	orr.w	r3, r2, r3
 428:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 42a:	4b04      	ldr	r3, [pc, #16]	; (43c <RCC_PCLK2Config+0x3c>)
 42c:	68fa      	ldr	r2, [r7, #12]
 42e:	605a      	str	r2, [r3, #4]
}
 430:	f107 0714 	add.w	r7, r7, #20
 434:	46bd      	mov	sp, r7
 436:	bc80      	pop	{r7}
 438:	4770      	bx	lr
 43a:	bf00      	nop
 43c:	40021000 	.word	0x40021000

00000440 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 440:	b480      	push	{r7}
 442:	b083      	sub	sp, #12
 444:	af00      	add	r7, sp, #0
 446:	4602      	mov	r2, r0
 448:	460b      	mov	r3, r1
 44a:	71fa      	strb	r2, [r7, #7]
 44c:	71bb      	strb	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 44e:	79bb      	ldrb	r3, [r7, #6]
 450:	2b00      	cmp	r3, #0
 452:	d009      	beq.n	468 <RCC_ITConfig+0x28>
  {
    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 454:	4b0d      	ldr	r3, [pc, #52]	; (48c <RCC_ITConfig+0x4c>)
 456:	4a0d      	ldr	r2, [pc, #52]	; (48c <RCC_ITConfig+0x4c>)
 458:	7812      	ldrb	r2, [r2, #0]
 45a:	b2d1      	uxtb	r1, r2
 45c:	79fa      	ldrb	r2, [r7, #7]
 45e:	ea41 0202 	orr.w	r2, r1, r2
 462:	b2d2      	uxtb	r2, r2
 464:	701a      	strb	r2, [r3, #0]
 466:	e00b      	b.n	480 <RCC_ITConfig+0x40>
  }
  else
  {
    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 468:	4b08      	ldr	r3, [pc, #32]	; (48c <RCC_ITConfig+0x4c>)
 46a:	4a08      	ldr	r2, [pc, #32]	; (48c <RCC_ITConfig+0x4c>)
 46c:	7812      	ldrb	r2, [r2, #0]
 46e:	b2d1      	uxtb	r1, r2
 470:	79fa      	ldrb	r2, [r7, #7]
 472:	ea6f 0202 	mvn.w	r2, r2
 476:	b2d2      	uxtb	r2, r2
 478:	ea01 0202 	and.w	r2, r1, r2
 47c:	b2d2      	uxtb	r2, r2
 47e:	701a      	strb	r2, [r3, #0]
  }
}
 480:	f107 070c 	add.w	r7, r7, #12
 484:	46bd      	mov	sp, r7
 486:	bc80      	pop	{r7}
 488:	4770      	bx	lr
 48a:	bf00      	nop
 48c:	40021009 	.word	0x40021009

00000490 <RCC_OTGFSCLKConfig>:
  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source
  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source
  * @retval None
  */
void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)
{
 490:	b480      	push	{r7}
 492:	b083      	sub	sp, #12
 494:	af00      	add	r7, sp, #0
 496:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));

  *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;
 498:	4b03      	ldr	r3, [pc, #12]	; (4a8 <RCC_OTGFSCLKConfig+0x18>)
 49a:	687a      	ldr	r2, [r7, #4]
 49c:	601a      	str	r2, [r3, #0]
}
 49e:	f107 070c 	add.w	r7, r7, #12
 4a2:	46bd      	mov	sp, r7
 4a4:	bc80      	pop	{r7}
 4a6:	4770      	bx	lr
 4a8:	424200d8 	.word	0x424200d8

000004ac <RCC_ADCCLKConfig>:
  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
  * @retval None
  */
void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
{
 4ac:	b480      	push	{r7}
 4ae:	b085      	sub	sp, #20
 4b0:	af00      	add	r7, sp, #0
 4b2:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 4b4:	f04f 0300 	mov.w	r3, #0
 4b8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
  tmpreg = RCC->CFGR;
 4ba:	4b0a      	ldr	r3, [pc, #40]	; (4e4 <RCC_ADCCLKConfig+0x38>)
 4bc:	685b      	ldr	r3, [r3, #4]
 4be:	60fb      	str	r3, [r7, #12]
  /* Clear ADCPRE[1:0] bits */
  tmpreg &= CFGR_ADCPRE_Reset_Mask;
 4c0:	68fb      	ldr	r3, [r7, #12]
 4c2:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 4c6:	60fb      	str	r3, [r7, #12]
  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
  tmpreg |= RCC_PCLK2;
 4c8:	68fa      	ldr	r2, [r7, #12]
 4ca:	687b      	ldr	r3, [r7, #4]
 4cc:	ea42 0303 	orr.w	r3, r2, r3
 4d0:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 4d2:	4b04      	ldr	r3, [pc, #16]	; (4e4 <RCC_ADCCLKConfig+0x38>)
 4d4:	68fa      	ldr	r2, [r7, #12]
 4d6:	605a      	str	r2, [r3, #4]
}
 4d8:	f107 0714 	add.w	r7, r7, #20
 4dc:	46bd      	mov	sp, r7
 4de:	bc80      	pop	{r7}
 4e0:	4770      	bx	lr
 4e2:	bf00      	nop
 4e4:	40021000 	.word	0x40021000

000004e8 <RCC_I2S2CLKConfig>:
  *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry
  *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry
  * @retval None
  */
void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)
{
 4e8:	b480      	push	{r7}
 4ea:	b083      	sub	sp, #12
 4ec:	af00      	add	r7, sp, #0
 4ee:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));

  *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;
 4f0:	4b03      	ldr	r3, [pc, #12]	; (500 <RCC_I2S2CLKConfig+0x18>)
 4f2:	687a      	ldr	r2, [r7, #4]
 4f4:	601a      	str	r2, [r3, #0]
}
 4f6:	f107 070c 	add.w	r7, r7, #12
 4fa:	46bd      	mov	sp, r7
 4fc:	bc80      	pop	{r7}
 4fe:	4770      	bx	lr
 500:	424205c4 	.word	0x424205c4

00000504 <RCC_I2S3CLKConfig>:
  *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry
  *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry
  * @retval None
  */
void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)
{
 504:	b480      	push	{r7}
 506:	b083      	sub	sp, #12
 508:	af00      	add	r7, sp, #0
 50a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));

  *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;
 50c:	4b03      	ldr	r3, [pc, #12]	; (51c <RCC_I2S3CLKConfig+0x18>)
 50e:	687a      	ldr	r2, [r7, #4]
 510:	601a      	str	r2, [r3, #0]
}
 512:	f107 070c 	add.w	r7, r7, #12
 516:	46bd      	mov	sp, r7
 518:	bc80      	pop	{r7}
 51a:	4770      	bx	lr
 51c:	424205c8 	.word	0x424205c8

00000520 <RCC_LSEConfig>:
  *     @arg RCC_LSE_ON: LSE oscillator ON
  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
 520:	b480      	push	{r7}
 522:	b083      	sub	sp, #12
 524:	af00      	add	r7, sp, #0
 526:	4603      	mov	r3, r0
 528:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 52a:	4b0e      	ldr	r3, [pc, #56]	; (564 <RCC_LSEConfig+0x44>)
 52c:	f04f 0200 	mov.w	r2, #0
 530:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 532:	4b0c      	ldr	r3, [pc, #48]	; (564 <RCC_LSEConfig+0x44>)
 534:	f04f 0200 	mov.w	r2, #0
 538:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 53a:	79fb      	ldrb	r3, [r7, #7]
 53c:	2b01      	cmp	r3, #1
 53e:	d002      	beq.n	546 <RCC_LSEConfig+0x26>
 540:	2b04      	cmp	r3, #4
 542:	d005      	beq.n	550 <RCC_LSEConfig+0x30>
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
      break;            
      
    default:
      break;      
 544:	e009      	b.n	55a <RCC_LSEConfig+0x3a>
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 546:	4b07      	ldr	r3, [pc, #28]	; (564 <RCC_LSEConfig+0x44>)
 548:	f04f 0201 	mov.w	r2, #1
 54c:	701a      	strb	r2, [r3, #0]
      break;
 54e:	e004      	b.n	55a <RCC_LSEConfig+0x3a>
      
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 550:	4b04      	ldr	r3, [pc, #16]	; (564 <RCC_LSEConfig+0x44>)
 552:	f04f 0205 	mov.w	r2, #5
 556:	701a      	strb	r2, [r3, #0]
      break;            
 558:	bf00      	nop
      
    default:
      break;      
  }
}
 55a:	f107 070c 	add.w	r7, r7, #12
 55e:	46bd      	mov	sp, r7
 560:	bc80      	pop	{r7}
 562:	4770      	bx	lr
 564:	40021020 	.word	0x40021020

00000568 <RCC_LSICmd>:
  * @note   LSI can not be disabled if the IWDG is running.
  * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_LSICmd(FunctionalState NewState)
{
 568:	b480      	push	{r7}
 56a:	b083      	sub	sp, #12
 56c:	af00      	add	r7, sp, #0
 56e:	4603      	mov	r3, r0
 570:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 572:	4b04      	ldr	r3, [pc, #16]	; (584 <RCC_LSICmd+0x1c>)
 574:	79fa      	ldrb	r2, [r7, #7]
 576:	601a      	str	r2, [r3, #0]
}
 578:	f107 070c 	add.w	r7, r7, #12
 57c:	46bd      	mov	sp, r7
 57e:	bc80      	pop	{r7}
 580:	4770      	bx	lr
 582:	bf00      	nop
 584:	42420480 	.word	0x42420480

00000588 <RCC_RTCCLKConfig>:
  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock
  * @retval None
  */
void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
{
 588:	b480      	push	{r7}
 58a:	b083      	sub	sp, #12
 58c:	af00      	add	r7, sp, #0
 58e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 590:	4b05      	ldr	r3, [pc, #20]	; (5a8 <RCC_RTCCLKConfig+0x20>)
 592:	4a05      	ldr	r2, [pc, #20]	; (5a8 <RCC_RTCCLKConfig+0x20>)
 594:	6a11      	ldr	r1, [r2, #32]
 596:	687a      	ldr	r2, [r7, #4]
 598:	ea41 0202 	orr.w	r2, r1, r2
 59c:	621a      	str	r2, [r3, #32]
}
 59e:	f107 070c 	add.w	r7, r7, #12
 5a2:	46bd      	mov	sp, r7
 5a4:	bc80      	pop	{r7}
 5a6:	4770      	bx	lr
 5a8:	40021000 	.word	0x40021000

000005ac <RCC_RTCCLKCmd>:
  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.
  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_RTCCLKCmd(FunctionalState NewState)
{
 5ac:	b480      	push	{r7}
 5ae:	b083      	sub	sp, #12
 5b0:	af00      	add	r7, sp, #0
 5b2:	4603      	mov	r3, r0
 5b4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 5b6:	4b04      	ldr	r3, [pc, #16]	; (5c8 <RCC_RTCCLKCmd+0x1c>)
 5b8:	79fa      	ldrb	r2, [r7, #7]
 5ba:	601a      	str	r2, [r3, #0]
}
 5bc:	f107 070c 	add.w	r7, r7, #12
 5c0:	46bd      	mov	sp, r7
 5c2:	bc80      	pop	{r7}
 5c4:	4770      	bx	lr
 5c6:	bf00      	nop
 5c8:	4242043c 	.word	0x4242043c

000005cc <RCC_GetClocksFreq>:
  * @note   The result of this function could be not correct when using 
  *         fractional value for HSE crystal.  
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 5cc:	b480      	push	{r7}
 5ce:	b08b      	sub	sp, #44	; 0x2c
 5d0:	af00      	add	r7, sp, #0
 5d2:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
 5d4:	f04f 0300 	mov.w	r3, #0
 5d8:	623b      	str	r3, [r7, #32]
 5da:	f04f 0300 	mov.w	r3, #0
 5de:	627b      	str	r3, [r7, #36]	; 0x24
 5e0:	f04f 0300 	mov.w	r3, #0
 5e4:	61fb      	str	r3, [r7, #28]
 5e6:	f04f 0300 	mov.w	r3, #0
 5ea:	61bb      	str	r3, [r7, #24]

#ifdef  STM32F10X_CL
  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
 5ec:	f04f 0300 	mov.w	r3, #0
 5f0:	617b      	str	r3, [r7, #20]
 5f2:	f04f 0300 	mov.w	r3, #0
 5f6:	613b      	str	r3, [r7, #16]
 5f8:	f04f 0300 	mov.w	r3, #0
 5fc:	60fb      	str	r3, [r7, #12]
 5fe:	f04f 0300 	mov.w	r3, #0
 602:	60bb      	str	r3, [r7, #8]
#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
  uint32_t prediv1factor = 0;
#endif
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 604:	4b69      	ldr	r3, [pc, #420]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 606:	685b      	ldr	r3, [r3, #4]
 608:	f003 030c 	and.w	r3, r3, #12
 60c:	623b      	str	r3, [r7, #32]
  
  switch (tmp)
 60e:	6a3b      	ldr	r3, [r7, #32]
 610:	2b04      	cmp	r3, #4
 612:	d007      	beq.n	624 <RCC_GetClocksFreq+0x58>
 614:	2b08      	cmp	r3, #8
 616:	d009      	beq.n	62c <RCC_GetClocksFreq+0x60>
 618:	2b00      	cmp	r3, #0
 61a:	d165      	bne.n	6e8 <RCC_GetClocksFreq+0x11c>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 61c:	687b      	ldr	r3, [r7, #4]
 61e:	4a64      	ldr	r2, [pc, #400]	; (7b0 <RCC_GetClocksFreq+0x1e4>)
 620:	601a      	str	r2, [r3, #0]
      break;
 622:	e065      	b.n	6f0 <RCC_GetClocksFreq+0x124>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 624:	687b      	ldr	r3, [r7, #4]
 626:	4a63      	ldr	r2, [pc, #396]	; (7b4 <RCC_GetClocksFreq+0x1e8>)
 628:	601a      	str	r2, [r3, #0]
      break;
 62a:	e061      	b.n	6f0 <RCC_GetClocksFreq+0x124>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 62c:	4b5f      	ldr	r3, [pc, #380]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 62e:	685b      	ldr	r3, [r3, #4]
 630:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 634:	627b      	str	r3, [r7, #36]	; 0x24
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 636:	4b5d      	ldr	r3, [pc, #372]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 638:	685b      	ldr	r3, [r3, #4]
 63a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 63e:	61fb      	str	r3, [r7, #28]
          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
        }
 #endif
      }
#else
      pllmull = pllmull >> 18;
 640:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 642:	ea4f 4393 	mov.w	r3, r3, lsr #18
 646:	627b      	str	r3, [r7, #36]	; 0x24
      
      if (pllmull != 0x0D)
 648:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 64a:	2b0d      	cmp	r3, #13
 64c:	d004      	beq.n	658 <RCC_GetClocksFreq+0x8c>
      {
         pllmull += 2;
 64e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 650:	f103 0302 	add.w	r3, r3, #2
 654:	627b      	str	r3, [r7, #36]	; 0x24
 656:	e002      	b.n	65e <RCC_GetClocksFreq+0x92>
      }
      else
      { /* PLL multiplication factor = PLL input clock * 6.5 */
        pllmull = 13 / 2; 
 658:	f04f 0306 	mov.w	r3, #6
 65c:	627b      	str	r3, [r7, #36]	; 0x24
      }
            
      if (pllsource == 0x00)
 65e:	69fb      	ldr	r3, [r7, #28]
 660:	2b00      	cmp	r3, #0
 662:	d106      	bne.n	672 <RCC_GetClocksFreq+0xa6>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
 664:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 666:	4a54      	ldr	r2, [pc, #336]	; (7b8 <RCC_GetClocksFreq+0x1ec>)
 668:	fb02 f203 	mul.w	r2, r2, r3
 66c:	687b      	ldr	r3, [r7, #4]
 66e:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 670:	e03e      	b.n	6f0 <RCC_GetClocksFreq+0x124>
      }
      else
      {/* PREDIV1 selected as PLL clock entry */
        
        /* Get PREDIV1 clock source and division factor */
        prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
 672:	4b4e      	ldr	r3, [pc, #312]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 674:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 676:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 67a:	617b      	str	r3, [r7, #20]
        prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
 67c:	4b4b      	ldr	r3, [pc, #300]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 67e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 680:	f003 030f 	and.w	r3, r3, #15
 684:	f103 0301 	add.w	r3, r3, #1
 688:	613b      	str	r3, [r7, #16]
        
        if (prediv1source == 0)
 68a:	697b      	ldr	r3, [r7, #20]
 68c:	2b00      	cmp	r3, #0
 68e:	d109      	bne.n	6a4 <RCC_GetClocksFreq+0xd8>
        { /* HSE oscillator clock selected as PREDIV1 clock entry */
          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
 690:	4a48      	ldr	r2, [pc, #288]	; (7b4 <RCC_GetClocksFreq+0x1e8>)
 692:	693b      	ldr	r3, [r7, #16]
 694:	fbb2 f3f3 	udiv	r3, r2, r3
 698:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 69a:	fb02 f203 	mul.w	r2, r2, r3
 69e:	687b      	ldr	r3, [r7, #4]
 6a0:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 6a2:	e025      	b.n	6f0 <RCC_GetClocksFreq+0x124>
        }
        else
        {/* PLL2 clock selected as PREDIV1 clock entry */
          
          /* Get PREDIV2 division factor and PLL2 multiplication factor */
          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
 6a4:	4b41      	ldr	r3, [pc, #260]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 6a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 6a8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 6ac:	ea4f 1313 	mov.w	r3, r3, lsr #4
 6b0:	f103 0301 	add.w	r3, r3, #1
 6b4:	60fb      	str	r3, [r7, #12]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
 6b6:	4b3d      	ldr	r3, [pc, #244]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 6b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 6ba:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 6be:	ea4f 2313 	mov.w	r3, r3, lsr #8
 6c2:	f103 0302 	add.w	r3, r3, #2
 6c6:	60bb      	str	r3, [r7, #8]
          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
 6c8:	4a3a      	ldr	r2, [pc, #232]	; (7b4 <RCC_GetClocksFreq+0x1e8>)
 6ca:	68fb      	ldr	r3, [r7, #12]
 6cc:	fbb2 f3f3 	udiv	r3, r2, r3
 6d0:	68ba      	ldr	r2, [r7, #8]
 6d2:	fb02 f203 	mul.w	r2, r2, r3
 6d6:	693b      	ldr	r3, [r7, #16]
 6d8:	fbb2 f3f3 	udiv	r3, r2, r3
 6dc:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 6de:	fb02 f203 	mul.w	r2, r2, r3
 6e2:	687b      	ldr	r3, [r7, #4]
 6e4:	601a      	str	r2, [r3, #0]
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 6e6:	e003      	b.n	6f0 <RCC_GetClocksFreq+0x124>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 6e8:	687b      	ldr	r3, [r7, #4]
 6ea:	4a31      	ldr	r2, [pc, #196]	; (7b0 <RCC_GetClocksFreq+0x1e4>)
 6ec:	601a      	str	r2, [r3, #0]
      break;
 6ee:	bf00      	nop
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 6f0:	4b2e      	ldr	r3, [pc, #184]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 6f2:	685b      	ldr	r3, [r3, #4]
 6f4:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 6f8:	623b      	str	r3, [r7, #32]
  tmp = tmp >> 4;
 6fa:	6a3b      	ldr	r3, [r7, #32]
 6fc:	ea4f 1313 	mov.w	r3, r3, lsr #4
 700:	623b      	str	r3, [r7, #32]
  presc = APBAHBPrescTable[tmp];
 702:	4a2e      	ldr	r2, [pc, #184]	; (7bc <RCC_GetClocksFreq+0x1f0>)
 704:	6a3b      	ldr	r3, [r7, #32]
 706:	18d3      	adds	r3, r2, r3
 708:	781b      	ldrb	r3, [r3, #0]
 70a:	b2db      	uxtb	r3, r3
 70c:	61bb      	str	r3, [r7, #24]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 70e:	687b      	ldr	r3, [r7, #4]
 710:	681a      	ldr	r2, [r3, #0]
 712:	69bb      	ldr	r3, [r7, #24]
 714:	fa22 f203 	lsr.w	r2, r2, r3
 718:	687b      	ldr	r3, [r7, #4]
 71a:	605a      	str	r2, [r3, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 71c:	4b23      	ldr	r3, [pc, #140]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 71e:	685b      	ldr	r3, [r3, #4]
 720:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 724:	623b      	str	r3, [r7, #32]
  tmp = tmp >> 8;
 726:	6a3b      	ldr	r3, [r7, #32]
 728:	ea4f 2313 	mov.w	r3, r3, lsr #8
 72c:	623b      	str	r3, [r7, #32]
  presc = APBAHBPrescTable[tmp];
 72e:	4a23      	ldr	r2, [pc, #140]	; (7bc <RCC_GetClocksFreq+0x1f0>)
 730:	6a3b      	ldr	r3, [r7, #32]
 732:	18d3      	adds	r3, r2, r3
 734:	781b      	ldrb	r3, [r3, #0]
 736:	b2db      	uxtb	r3, r3
 738:	61bb      	str	r3, [r7, #24]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 73a:	687b      	ldr	r3, [r7, #4]
 73c:	685a      	ldr	r2, [r3, #4]
 73e:	69bb      	ldr	r3, [r7, #24]
 740:	fa22 f203 	lsr.w	r2, r2, r3
 744:	687b      	ldr	r3, [r7, #4]
 746:	609a      	str	r2, [r3, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 748:	4b18      	ldr	r3, [pc, #96]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 74a:	685b      	ldr	r3, [r3, #4]
 74c:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 750:	623b      	str	r3, [r7, #32]
  tmp = tmp >> 11;
 752:	6a3b      	ldr	r3, [r7, #32]
 754:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 758:	623b      	str	r3, [r7, #32]
  presc = APBAHBPrescTable[tmp];
 75a:	4a18      	ldr	r2, [pc, #96]	; (7bc <RCC_GetClocksFreq+0x1f0>)
 75c:	6a3b      	ldr	r3, [r7, #32]
 75e:	18d3      	adds	r3, r2, r3
 760:	781b      	ldrb	r3, [r3, #0]
 762:	b2db      	uxtb	r3, r3
 764:	61bb      	str	r3, [r7, #24]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 766:	687b      	ldr	r3, [r7, #4]
 768:	685a      	ldr	r2, [r3, #4]
 76a:	69bb      	ldr	r3, [r7, #24]
 76c:	fa22 f203 	lsr.w	r2, r2, r3
 770:	687b      	ldr	r3, [r7, #4]
 772:	60da      	str	r2, [r3, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 774:	4b0d      	ldr	r3, [pc, #52]	; (7ac <RCC_GetClocksFreq+0x1e0>)
 776:	685b      	ldr	r3, [r3, #4]
 778:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 77c:	623b      	str	r3, [r7, #32]
  tmp = tmp >> 14;
 77e:	6a3b      	ldr	r3, [r7, #32]
 780:	ea4f 3393 	mov.w	r3, r3, lsr #14
 784:	623b      	str	r3, [r7, #32]
  presc = ADCPrescTable[tmp];
 786:	4a0e      	ldr	r2, [pc, #56]	; (7c0 <RCC_GetClocksFreq+0x1f4>)
 788:	6a3b      	ldr	r3, [r7, #32]
 78a:	18d3      	adds	r3, r2, r3
 78c:	781b      	ldrb	r3, [r3, #0]
 78e:	b2db      	uxtb	r3, r3
 790:	61bb      	str	r3, [r7, #24]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 792:	687b      	ldr	r3, [r7, #4]
 794:	68da      	ldr	r2, [r3, #12]
 796:	69bb      	ldr	r3, [r7, #24]
 798:	fbb2 f2f3 	udiv	r2, r2, r3
 79c:	687b      	ldr	r3, [r7, #4]
 79e:	611a      	str	r2, [r3, #16]
}
 7a0:	f107 072c 	add.w	r7, r7, #44	; 0x2c
 7a4:	46bd      	mov	sp, r7
 7a6:	bc80      	pop	{r7}
 7a8:	4770      	bx	lr
 7aa:	bf00      	nop
 7ac:	40021000 	.word	0x40021000
 7b0:	007a1200 	.word	0x007a1200
 7b4:	017d7840 	.word	0x017d7840
 7b8:	003d0900 	.word	0x003d0900
 7bc:	00000000 	.word	0x00000000
			7bc: R_ARM_ABS32	.data
 7c0:	00000010 	.word	0x00000010
			7c0: R_ARM_ABS32	.data

000007c4 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 7c4:	b480      	push	{r7}
 7c6:	b083      	sub	sp, #12
 7c8:	af00      	add	r7, sp, #0
 7ca:	6078      	str	r0, [r7, #4]
 7cc:	460b      	mov	r3, r1
 7ce:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 7d0:	78fb      	ldrb	r3, [r7, #3]
 7d2:	2b00      	cmp	r3, #0
 7d4:	d007      	beq.n	7e6 <RCC_AHBPeriphClockCmd+0x22>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 7d6:	4b0b      	ldr	r3, [pc, #44]	; (804 <RCC_AHBPeriphClockCmd+0x40>)
 7d8:	4a0a      	ldr	r2, [pc, #40]	; (804 <RCC_AHBPeriphClockCmd+0x40>)
 7da:	6951      	ldr	r1, [r2, #20]
 7dc:	687a      	ldr	r2, [r7, #4]
 7de:	ea41 0202 	orr.w	r2, r1, r2
 7e2:	615a      	str	r2, [r3, #20]
 7e4:	e008      	b.n	7f8 <RCC_AHBPeriphClockCmd+0x34>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 7e6:	4b07      	ldr	r3, [pc, #28]	; (804 <RCC_AHBPeriphClockCmd+0x40>)
 7e8:	4a06      	ldr	r2, [pc, #24]	; (804 <RCC_AHBPeriphClockCmd+0x40>)
 7ea:	6951      	ldr	r1, [r2, #20]
 7ec:	687a      	ldr	r2, [r7, #4]
 7ee:	ea6f 0202 	mvn.w	r2, r2
 7f2:	ea01 0202 	and.w	r2, r1, r2
 7f6:	615a      	str	r2, [r3, #20]
  }
}
 7f8:	f107 070c 	add.w	r7, r7, #12
 7fc:	46bd      	mov	sp, r7
 7fe:	bc80      	pop	{r7}
 800:	4770      	bx	lr
 802:	bf00      	nop
 804:	40021000 	.word	0x40021000

00000808 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 808:	b480      	push	{r7}
 80a:	b083      	sub	sp, #12
 80c:	af00      	add	r7, sp, #0
 80e:	6078      	str	r0, [r7, #4]
 810:	460b      	mov	r3, r1
 812:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 814:	78fb      	ldrb	r3, [r7, #3]
 816:	2b00      	cmp	r3, #0
 818:	d007      	beq.n	82a <RCC_APB2PeriphClockCmd+0x22>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 81a:	4b0b      	ldr	r3, [pc, #44]	; (848 <RCC_APB2PeriphClockCmd+0x40>)
 81c:	4a0a      	ldr	r2, [pc, #40]	; (848 <RCC_APB2PeriphClockCmd+0x40>)
 81e:	6991      	ldr	r1, [r2, #24]
 820:	687a      	ldr	r2, [r7, #4]
 822:	ea41 0202 	orr.w	r2, r1, r2
 826:	619a      	str	r2, [r3, #24]
 828:	e008      	b.n	83c <RCC_APB2PeriphClockCmd+0x34>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 82a:	4b07      	ldr	r3, [pc, #28]	; (848 <RCC_APB2PeriphClockCmd+0x40>)
 82c:	4a06      	ldr	r2, [pc, #24]	; (848 <RCC_APB2PeriphClockCmd+0x40>)
 82e:	6991      	ldr	r1, [r2, #24]
 830:	687a      	ldr	r2, [r7, #4]
 832:	ea6f 0202 	mvn.w	r2, r2
 836:	ea01 0202 	and.w	r2, r1, r2
 83a:	619a      	str	r2, [r3, #24]
  }
}
 83c:	f107 070c 	add.w	r7, r7, #12
 840:	46bd      	mov	sp, r7
 842:	bc80      	pop	{r7}
 844:	4770      	bx	lr
 846:	bf00      	nop
 848:	40021000 	.word	0x40021000

0000084c <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 84c:	b480      	push	{r7}
 84e:	b083      	sub	sp, #12
 850:	af00      	add	r7, sp, #0
 852:	6078      	str	r0, [r7, #4]
 854:	460b      	mov	r3, r1
 856:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 858:	78fb      	ldrb	r3, [r7, #3]
 85a:	2b00      	cmp	r3, #0
 85c:	d007      	beq.n	86e <RCC_APB1PeriphClockCmd+0x22>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 85e:	4b0b      	ldr	r3, [pc, #44]	; (88c <RCC_APB1PeriphClockCmd+0x40>)
 860:	4a0a      	ldr	r2, [pc, #40]	; (88c <RCC_APB1PeriphClockCmd+0x40>)
 862:	69d1      	ldr	r1, [r2, #28]
 864:	687a      	ldr	r2, [r7, #4]
 866:	ea41 0202 	orr.w	r2, r1, r2
 86a:	61da      	str	r2, [r3, #28]
 86c:	e008      	b.n	880 <RCC_APB1PeriphClockCmd+0x34>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 86e:	4b07      	ldr	r3, [pc, #28]	; (88c <RCC_APB1PeriphClockCmd+0x40>)
 870:	4a06      	ldr	r2, [pc, #24]	; (88c <RCC_APB1PeriphClockCmd+0x40>)
 872:	69d1      	ldr	r1, [r2, #28]
 874:	687a      	ldr	r2, [r7, #4]
 876:	ea6f 0202 	mvn.w	r2, r2
 87a:	ea01 0202 	and.w	r2, r1, r2
 87e:	61da      	str	r2, [r3, #28]
  }
}
 880:	f107 070c 	add.w	r7, r7, #12
 884:	46bd      	mov	sp, r7
 886:	bc80      	pop	{r7}
 888:	4770      	bx	lr
 88a:	bf00      	nop
 88c:	40021000 	.word	0x40021000

00000890 <RCC_AHBPeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 890:	b480      	push	{r7}
 892:	b083      	sub	sp, #12
 894:	af00      	add	r7, sp, #0
 896:	6078      	str	r0, [r7, #4]
 898:	460b      	mov	r3, r1
 89a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 89c:	78fb      	ldrb	r3, [r7, #3]
 89e:	2b00      	cmp	r3, #0
 8a0:	d007      	beq.n	8b2 <RCC_AHBPeriphResetCmd+0x22>
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 8a2:	4b0b      	ldr	r3, [pc, #44]	; (8d0 <RCC_AHBPeriphResetCmd+0x40>)
 8a4:	4a0a      	ldr	r2, [pc, #40]	; (8d0 <RCC_AHBPeriphResetCmd+0x40>)
 8a6:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8a8:	687a      	ldr	r2, [r7, #4]
 8aa:	ea41 0202 	orr.w	r2, r1, r2
 8ae:	629a      	str	r2, [r3, #40]	; 0x28
 8b0:	e008      	b.n	8c4 <RCC_AHBPeriphResetCmd+0x34>
  }
  else
  {
    RCC->AHBRSTR &= ~RCC_AHBPeriph;
 8b2:	4b07      	ldr	r3, [pc, #28]	; (8d0 <RCC_AHBPeriphResetCmd+0x40>)
 8b4:	4a06      	ldr	r2, [pc, #24]	; (8d0 <RCC_AHBPeriphResetCmd+0x40>)
 8b6:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8b8:	687a      	ldr	r2, [r7, #4]
 8ba:	ea6f 0202 	mvn.w	r2, r2
 8be:	ea01 0202 	and.w	r2, r1, r2
 8c2:	629a      	str	r2, [r3, #40]	; 0x28
  }
}
 8c4:	f107 070c 	add.w	r7, r7, #12
 8c8:	46bd      	mov	sp, r7
 8ca:	bc80      	pop	{r7}
 8cc:	4770      	bx	lr
 8ce:	bf00      	nop
 8d0:	40021000 	.word	0x40021000

000008d4 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8d4:	b480      	push	{r7}
 8d6:	b083      	sub	sp, #12
 8d8:	af00      	add	r7, sp, #0
 8da:	6078      	str	r0, [r7, #4]
 8dc:	460b      	mov	r3, r1
 8de:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8e0:	78fb      	ldrb	r3, [r7, #3]
 8e2:	2b00      	cmp	r3, #0
 8e4:	d007      	beq.n	8f6 <RCC_APB2PeriphResetCmd+0x22>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8e6:	4b0b      	ldr	r3, [pc, #44]	; (914 <RCC_APB2PeriphResetCmd+0x40>)
 8e8:	4a0a      	ldr	r2, [pc, #40]	; (914 <RCC_APB2PeriphResetCmd+0x40>)
 8ea:	68d1      	ldr	r1, [r2, #12]
 8ec:	687a      	ldr	r2, [r7, #4]
 8ee:	ea41 0202 	orr.w	r2, r1, r2
 8f2:	60da      	str	r2, [r3, #12]
 8f4:	e008      	b.n	908 <RCC_APB2PeriphResetCmd+0x34>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8f6:	4b07      	ldr	r3, [pc, #28]	; (914 <RCC_APB2PeriphResetCmd+0x40>)
 8f8:	4a06      	ldr	r2, [pc, #24]	; (914 <RCC_APB2PeriphResetCmd+0x40>)
 8fa:	68d1      	ldr	r1, [r2, #12]
 8fc:	687a      	ldr	r2, [r7, #4]
 8fe:	ea6f 0202 	mvn.w	r2, r2
 902:	ea01 0202 	and.w	r2, r1, r2
 906:	60da      	str	r2, [r3, #12]
  }
}
 908:	f107 070c 	add.w	r7, r7, #12
 90c:	46bd      	mov	sp, r7
 90e:	bc80      	pop	{r7}
 910:	4770      	bx	lr
 912:	bf00      	nop
 914:	40021000 	.word	0x40021000

00000918 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 918:	b480      	push	{r7}
 91a:	b083      	sub	sp, #12
 91c:	af00      	add	r7, sp, #0
 91e:	6078      	str	r0, [r7, #4]
 920:	460b      	mov	r3, r1
 922:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 924:	78fb      	ldrb	r3, [r7, #3]
 926:	2b00      	cmp	r3, #0
 928:	d007      	beq.n	93a <RCC_APB1PeriphResetCmd+0x22>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 92a:	4b0b      	ldr	r3, [pc, #44]	; (958 <RCC_APB1PeriphResetCmd+0x40>)
 92c:	4a0a      	ldr	r2, [pc, #40]	; (958 <RCC_APB1PeriphResetCmd+0x40>)
 92e:	6911      	ldr	r1, [r2, #16]
 930:	687a      	ldr	r2, [r7, #4]
 932:	ea41 0202 	orr.w	r2, r1, r2
 936:	611a      	str	r2, [r3, #16]
 938:	e008      	b.n	94c <RCC_APB1PeriphResetCmd+0x34>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 93a:	4b07      	ldr	r3, [pc, #28]	; (958 <RCC_APB1PeriphResetCmd+0x40>)
 93c:	4a06      	ldr	r2, [pc, #24]	; (958 <RCC_APB1PeriphResetCmd+0x40>)
 93e:	6911      	ldr	r1, [r2, #16]
 940:	687a      	ldr	r2, [r7, #4]
 942:	ea6f 0202 	mvn.w	r2, r2
 946:	ea01 0202 	and.w	r2, r1, r2
 94a:	611a      	str	r2, [r3, #16]
  }
}
 94c:	f107 070c 	add.w	r7, r7, #12
 950:	46bd      	mov	sp, r7
 952:	bc80      	pop	{r7}
 954:	4770      	bx	lr
 956:	bf00      	nop
 958:	40021000 	.word	0x40021000

0000095c <RCC_BackupResetCmd>:
  * @param  NewState: new state of the Backup domain reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
 95c:	b480      	push	{r7}
 95e:	b083      	sub	sp, #12
 960:	af00      	add	r7, sp, #0
 962:	4603      	mov	r3, r0
 964:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 966:	4b04      	ldr	r3, [pc, #16]	; (978 <RCC_BackupResetCmd+0x1c>)
 968:	79fa      	ldrb	r2, [r7, #7]
 96a:	601a      	str	r2, [r3, #0]
}
 96c:	f107 070c 	add.w	r7, r7, #12
 970:	46bd      	mov	sp, r7
 972:	bc80      	pop	{r7}
 974:	4770      	bx	lr
 976:	bf00      	nop
 978:	42420440 	.word	0x42420440

0000097c <RCC_ClockSecuritySystemCmd>:
  * @param  NewState: new state of the Clock Security System..
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
 97c:	b480      	push	{r7}
 97e:	b083      	sub	sp, #12
 980:	af00      	add	r7, sp, #0
 982:	4603      	mov	r3, r0
 984:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 986:	4b04      	ldr	r3, [pc, #16]	; (998 <RCC_ClockSecuritySystemCmd+0x1c>)
 988:	79fa      	ldrb	r2, [r7, #7]
 98a:	601a      	str	r2, [r3, #0]
}
 98c:	f107 070c 	add.w	r7, r7, #12
 990:	46bd      	mov	sp, r7
 992:	bc80      	pop	{r7}
 994:	4770      	bx	lr
 996:	bf00      	nop
 998:	4242004c 	.word	0x4242004c

0000099c <RCC_MCOConfig>:
  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected
  *   
  * @retval None
  */
void RCC_MCOConfig(uint8_t RCC_MCO)
{
 99c:	b480      	push	{r7}
 99e:	b083      	sub	sp, #12
 9a0:	af00      	add	r7, sp, #0
 9a2:	4603      	mov	r3, r0
 9a4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCO));

  /* Perform Byte access to MCO bits to select the MCO source */
  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
 9a6:	4b04      	ldr	r3, [pc, #16]	; (9b8 <RCC_MCOConfig+0x1c>)
 9a8:	79fa      	ldrb	r2, [r7, #7]
 9aa:	701a      	strb	r2, [r3, #0]
}
 9ac:	f107 070c 	add.w	r7, r7, #12
 9b0:	46bd      	mov	sp, r7
 9b2:	bc80      	pop	{r7}
 9b4:	4770      	bx	lr
 9b6:	bf00      	nop
 9b8:	40021007 	.word	0x40021007

000009bc <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  *   
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 9bc:	b480      	push	{r7}
 9be:	b087      	sub	sp, #28
 9c0:	af00      	add	r7, sp, #0
 9c2:	4603      	mov	r3, r0
 9c4:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 9c6:	f04f 0300 	mov.w	r3, #0
 9ca:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 9cc:	f04f 0300 	mov.w	r3, #0
 9d0:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 9d2:	f04f 0300 	mov.w	r3, #0
 9d6:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 9d8:	79fb      	ldrb	r3, [r7, #7]
 9da:	ea4f 1353 	mov.w	r3, r3, lsr #5
 9de:	b2db      	uxtb	r3, r3
 9e0:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 9e2:	68fb      	ldr	r3, [r7, #12]
 9e4:	2b01      	cmp	r3, #1
 9e6:	d103      	bne.n	9f0 <RCC_GetFlagStatus+0x34>
  {
    statusreg = RCC->CR;
 9e8:	4b14      	ldr	r3, [pc, #80]	; (a3c <RCC_GetFlagStatus+0x80>)
 9ea:	681b      	ldr	r3, [r3, #0]
 9ec:	617b      	str	r3, [r7, #20]
 9ee:	e009      	b.n	a04 <RCC_GetFlagStatus+0x48>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 9f0:	68fb      	ldr	r3, [r7, #12]
 9f2:	2b02      	cmp	r3, #2
 9f4:	d103      	bne.n	9fe <RCC_GetFlagStatus+0x42>
  {
    statusreg = RCC->BDCR;
 9f6:	4b11      	ldr	r3, [pc, #68]	; (a3c <RCC_GetFlagStatus+0x80>)
 9f8:	6a1b      	ldr	r3, [r3, #32]
 9fa:	617b      	str	r3, [r7, #20]
 9fc:	e002      	b.n	a04 <RCC_GetFlagStatus+0x48>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 9fe:	4b0f      	ldr	r3, [pc, #60]	; (a3c <RCC_GetFlagStatus+0x80>)
 a00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 a02:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 a04:	79fb      	ldrb	r3, [r7, #7]
 a06:	f003 031f 	and.w	r3, r3, #31
 a0a:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 a0c:	68fb      	ldr	r3, [r7, #12]
 a0e:	697a      	ldr	r2, [r7, #20]
 a10:	fa22 f303 	lsr.w	r3, r2, r3
 a14:	f003 0301 	and.w	r3, r3, #1
 a18:	b2db      	uxtb	r3, r3
 a1a:	2b00      	cmp	r3, #0
 a1c:	d003      	beq.n	a26 <RCC_GetFlagStatus+0x6a>
  {
    bitstatus = SET;
 a1e:	f04f 0301 	mov.w	r3, #1
 a22:	74fb      	strb	r3, [r7, #19]
 a24:	e002      	b.n	a2c <RCC_GetFlagStatus+0x70>
  }
  else
  {
    bitstatus = RESET;
 a26:	f04f 0300 	mov.w	r3, #0
 a2a:	74fb      	strb	r3, [r7, #19]
  }

  /* Return the flag status */
  return bitstatus;
 a2c:	7cfb      	ldrb	r3, [r7, #19]
}
 a2e:	4618      	mov	r0, r3
 a30:	f107 071c 	add.w	r7, r7, #28
 a34:	46bd      	mov	sp, r7
 a36:	bc80      	pop	{r7}
 a38:	4770      	bx	lr
 a3a:	bf00      	nop
 a3c:	40021000 	.word	0x40021000

00000a40 <RCC_ClearFlag>:
  *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST
  * @param  None
  * @retval None
  */
void RCC_ClearFlag(void)
{
 a40:	b480      	push	{r7}
 a42:	af00      	add	r7, sp, #0
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= CSR_RMVF_Set;
 a44:	4b04      	ldr	r3, [pc, #16]	; (a58 <RCC_ClearFlag+0x18>)
 a46:	4a04      	ldr	r2, [pc, #16]	; (a58 <RCC_ClearFlag+0x18>)
 a48:	6a52      	ldr	r2, [r2, #36]	; 0x24
 a4a:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 a4e:	625a      	str	r2, [r3, #36]	; 0x24
}
 a50:	46bd      	mov	sp, r7
 a52:	bc80      	pop	{r7}
 a54:	4770      	bx	lr
 a56:	bf00      	nop
 a58:	40021000 	.word	0x40021000

00000a5c <RCC_GetITStatus>:
  *     @arg RCC_IT_CSS: Clock Security System interrupt
  *   
  * @retval The new state of RCC_IT (SET or RESET).
  */
ITStatus RCC_GetITStatus(uint8_t RCC_IT)
{
 a5c:	b480      	push	{r7}
 a5e:	b085      	sub	sp, #20
 a60:	af00      	add	r7, sp, #0
 a62:	4603      	mov	r3, r0
 a64:	71fb      	strb	r3, [r7, #7]
  ITStatus bitstatus = RESET;
 a66:	f04f 0300 	mov.w	r3, #0
 a6a:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 a6c:	4b0a      	ldr	r3, [pc, #40]	; (a98 <RCC_GetITStatus+0x3c>)
 a6e:	689a      	ldr	r2, [r3, #8]
 a70:	79fb      	ldrb	r3, [r7, #7]
 a72:	ea02 0303 	and.w	r3, r2, r3
 a76:	2b00      	cmp	r3, #0
 a78:	d003      	beq.n	a82 <RCC_GetITStatus+0x26>
  {
    bitstatus = SET;
 a7a:	f04f 0301 	mov.w	r3, #1
 a7e:	73fb      	strb	r3, [r7, #15]
 a80:	e002      	b.n	a88 <RCC_GetITStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
 a82:	f04f 0300 	mov.w	r3, #0
 a86:	73fb      	strb	r3, [r7, #15]
  }

  /* Return the RCC_IT status */
  return  bitstatus;
 a88:	7bfb      	ldrb	r3, [r7, #15]
}
 a8a:	4618      	mov	r0, r3
 a8c:	f107 0714 	add.w	r7, r7, #20
 a90:	46bd      	mov	sp, r7
 a92:	bc80      	pop	{r7}
 a94:	4770      	bx	lr
 a96:	bf00      	nop
 a98:	40021000 	.word	0x40021000

00000a9c <RCC_ClearITPendingBit>:
  *   
  *     @arg RCC_IT_CSS: Clock Security System interrupt
  * @retval None
  */
void RCC_ClearITPendingBit(uint8_t RCC_IT)
{
 a9c:	b480      	push	{r7}
 a9e:	b083      	sub	sp, #12
 aa0:	af00      	add	r7, sp, #0
 aa2:	4603      	mov	r3, r0
 aa4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 aa6:	4b04      	ldr	r3, [pc, #16]	; (ab8 <RCC_ClearITPendingBit+0x1c>)
 aa8:	79fa      	ldrb	r2, [r7, #7]
 aaa:	701a      	strb	r2, [r3, #0]
}
 aac:	f107 070c 	add.w	r7, r7, #12
 ab0:	46bd      	mov	sp, r7
 ab2:	bc80      	pop	{r7}
 ab4:	4770      	bx	lr
 ab6:	bf00      	nop
 ab8:	4002100a 	.word	0x4002100a
