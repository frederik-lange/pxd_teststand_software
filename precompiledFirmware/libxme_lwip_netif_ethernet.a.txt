In archive C:/BelleII/devenv/workspace/kekSVN-firmware-2/target/libxme_lwip_netif_ethernet.a:

enet.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  58568 Jul 30 19:07 2021 enet.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000ac  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000e0  2**0
                  ALLOC
  3 .debug_abbrev 000000c9  00000000  00000000  000000e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000011f  00000000  00000000  000001a9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000006ed  00000000  00000000  000002c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0000cf08  00000000  00000000  000009b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000009c  00000000  00000000  0000d8bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000045  00000000  00000000  0000d959  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 00000031  00000000  00000000  0000d99e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  0000d9cf  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000157  00000000  00000000  0000d9ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000db46  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000db71  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000068  00000000  00000000  0000dba4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 enet.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000056 Get_MAC_Address
00000058 g     F .text	0000000e EnetGetIPAddr
00000000         *UND*	00000000 lwIPLocalIPAddrGet
00000068 g     F .text	00000044 EnetInit
00000000         *UND*	00000000 ETH_driver_init
00000000         *UND*	00000000 Set_MAC_Address
00000000         *UND*	00000000 lwIPInit



Disassembly of section .text:

00000000 <Get_MAC_Address>:

/******************************************************************************/
/***   Implementation                                                       ***/
/******************************************************************************/
#if MAC_ADDR_FIRMWARE
void Get_MAC_Address (eth_mac_addr_t macAddress) {
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
	// In this implementation, the MAC address is compiled into the firmware.
	macAddress[0] = MAC_ADDR0;
   8:	687b      	ldr	r3, [r7, #4]
   a:	f04f 020e 	mov.w	r2, #14
   e:	701a      	strb	r2, [r3, #0]
	macAddress[1] = MAC_ADDR1;
  10:	687b      	ldr	r3, [r7, #4]
  12:	f103 0301 	add.w	r3, r3, #1
  16:	f04f 0211 	mov.w	r2, #17
  1a:	701a      	strb	r2, [r3, #0]
	macAddress[2] = MAC_ADDR2;
  1c:	687b      	ldr	r3, [r7, #4]
  1e:	f103 0302 	add.w	r3, r3, #2
  22:	f04f 02eb 	mov.w	r2, #235	; 0xeb
  26:	701a      	strb	r2, [r3, #0]
	macAddress[3] = MAC_ADDR3;
  28:	687b      	ldr	r3, [r7, #4]
  2a:	f103 0303 	add.w	r3, r3, #3
  2e:	f04f 0200 	mov.w	r2, #0
  32:	701a      	strb	r2, [r3, #0]
	macAddress[4] = MAC_ADDR4;
  34:	687b      	ldr	r3, [r7, #4]
  36:	f103 0304 	add.w	r3, r3, #4
  3a:	f04f 0200 	mov.w	r2, #0
  3e:	701a      	strb	r2, [r3, #0]
	macAddress[5] = MAC_ADDR5;
  40:	687b      	ldr	r3, [r7, #4]
  42:	f103 0305 	add.w	r3, r3, #5
  46:	f04f 0259 	mov.w	r2, #89	; 0x59
  4a:	701a      	strb	r2, [r3, #0]
}
  4c:	f107 070c 	add.w	r7, r7, #12
  50:	46bd      	mov	sp, r7
  52:	bc80      	pop	{r7}
  54:	4770      	bx	lr
  56:	bf00      	nop

00000058 <EnetGetIPAddr>:
#endif // #if MAC_ADDR_FIRMWARE

/// Returns the current IP address.
unsigned long
EnetGetIPAddr(void)
{
  58:	b580      	push	{r7, lr}
  5a:	af00      	add	r7, sp, #0
	// Return the current IP address.
	return(lwIPLocalIPAddrGet());
  5c:	f7ff fffe 	bl	0 <lwIPLocalIPAddrGet>
			5c: R_ARM_THM_CALL	lwIPLocalIPAddrGet
  60:	4603      	mov	r3, r0
}
  62:	4618      	mov	r0, r3
  64:	bd80      	pop	{r7, pc}
  66:	bf00      	nop

00000068 <EnetInit>:
#if !GET_MAC_ADDR_FROM_BOOTLOADER
void EnetInit(void)
#else
void EnetInit(eth_mac_addr_t macAddress)
#endif // #if !GET_MAC_ADDR_FROM_BOOTLOADER
{
  68:	b580      	push	{r7, lr}
  6a:	b084      	sub	sp, #16
  6c:	af02      	add	r7, sp, #8
#if !GET_MAC_ADDR_FROM_BOOTLOADER
	eth_mac_addr_t macAddress;
#endif // #if !GET_MAC_ADDR_FROM_BOOTLOADER

	// Initialize Ethernet peripheral
	ETH_driver_init();
  6e:	f7ff fffe 	bl	0 <ETH_driver_init>
			6e: R_ARM_THM_CALL	ETH_driver_init

#if !GET_MAC_ADDR_FROM_BOOTLOADER
	// Retrieve MAC address (e.g., from EEPROM, hard coded, etc.)
	Get_MAC_Address(macAddress);
  72:	463b      	mov	r3, r7
  74:	4618      	mov	r0, r3
  76:	f7ff fffe 	bl	0 <Get_MAC_Address>
			76: R_ARM_THM_CALL	Get_MAC_Address
#endif // #if !GET_MAC_ADDR_FROM_BOOTLOADER

    // Program the MAC address into the Ethernet controller.
	Set_MAC_Address(macAddress);
  7a:	463b      	mov	r3, r7
  7c:	4618      	mov	r0, r3
  7e:	f7ff fffe 	bl	0 <Set_MAC_Address>
			7e: R_ARM_THM_CALL	Set_MAC_Address

	// Initialize LWIP stack
	lwIPInit(macAddress,
  82:	463b      	mov	r3, r7
  84:	f04f 0201 	mov.w	r2, #1
  88:	9200      	str	r2, [sp, #0]
  8a:	4618      	mov	r0, r3
  8c:	4904      	ldr	r1, [pc, #16]	; (a0 <EnetInit+0x38>)
  8e:	4a05      	ldr	r2, [pc, #20]	; (a4 <EnetInit+0x3c>)
  90:	4b05      	ldr	r3, [pc, #20]	; (a8 <EnetInit+0x40>)
  92:	f7ff fffe 	bl	0 <lwIPInit>
			92: R_ARM_THM_CALL	lwIPInit
	// Initialization has been completed.
	//
#if NO_SYS
	g_bEnetInit = 1;
#endif
}
  96:	f107 0708 	add.w	r7, r7, #8
  9a:	46bd      	mov	sp, r7
  9c:	bd80      	pop	{r7, pc}
  9e:	bf00      	nop
  a0:	c0a81192 	.word	0xc0a81192
  a4:	fffffe00 	.word	0xfffffe00
  a8:	c0a81001 	.word	0xc0a81001

perf.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  11868 Jul 30 19:07 2021 perf.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000014  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000048  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000048  2**0
                  ALLOC
  3 .debug_abbrev 0000004e  00000000  00000000  00000048  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000005b  00000000  00000000  00000096  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000000ef  00000000  00000000  000000f1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 000024b2  00000000  00000000  000001e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000038  00000000  00000000  00002692  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000020  00000000  00000000  000026ca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_aranges 00000020  00000000  00000000  000026ea  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000007f  00000000  00000000  0000270a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002b  00000000  00000000  00002789  2**0
                  CONTENTS, READONLY
 12 .ARM.attributes 00000031  00000000  00000000  000027b4  2**0
                  CONTENTS, READONLY
 13 .debug_frame  0000002c  00000000  00000000  000027e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 perf.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000012 perf_init



Disassembly of section .text:

00000000 <perf_init>:

#include "arch/perf.h"

void
perf_init(char *fname)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
}
   8:	f107 070c 	add.w	r7, r7, #12
   c:	46bd      	mov	sp, r7
   e:	bc80      	pop	{r7}
  10:	4770      	bx	lr
  12:	bf00      	nop

lwiplib.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 371728 Jul 30 19:07 2021 lwiplib.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000378  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000005c  00000000  00000000  000003ac  2**2
                  ALLOC
  3 .debug_abbrev 00000184  00000000  00000000  000003ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000d0a  00000000  00000000  00000530  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000a2c  00000000  00000000  0000123a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0005685d  00000000  00000000  00001c66  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .rodata       00000008  00000000  00000000  000584c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .debug_loc    00000244  00000000  00000000  000584cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000009a  00000000  00000000  00058710  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_pubtypes 0000019d  00000000  00000000  000587aa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_aranges 00000020  00000000  00000000  00058947  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    000009a5  00000000  00000000  00058967  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002b  00000000  00000000  0005930c  2**0
                  CONTENTS, READONLY
 14 .ARM.attributes 00000031  00000000  00000000  00059337  2**0
                  CONTENTS, READONLY
 15 .debug_frame  00000150  00000000  00000000  00059368  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 lwiplib.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l     F .text	00000034 NVIC_EnableIRQ
00000034 l     F .text	00000038 NVIC_DisableIRQ
00000000 l       .bss	00000000 g_sNetIF
00000040 l       .bss	00000000 g_ulMDIXTimer
00000044 l       .bss	00000000 g_ulIPMode
00000048 l       .bss	00000000 g_ulIPAddr
0000004c l       .bss	00000000 g_ulNetMask
00000050 l       .bss	00000000 g_ulGWAddr
00000054 l       .bss	00000000 g_pcQueueMem
00000058 l       .bss	00000000 g_pInterrupt
0000006c l     F .text	00000044 lwIPInterruptTask
00000000 l    d  .rodata	00000000 .rodata
000000b0 l     F .text	000000f8 lwIPPrivateInit
00000264 l     F .text	000000cc lwIPPrivateNetworkConfigChange
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 i
00000000         *UND*	00000000 xQueueGenericReceive
00000000         *UND*	00000000 stm32_ethernetif_input
00000000         *UND*	00000000 xQueueGenericCreate
00000000         *UND*	00000000 xTaskGenericCreate
00000000         *UND*	00000000 lwip_htonl
00000000         *UND*	00000000 netif_add
00000000         *UND*	00000000 netif_set_default
00000000         *UND*	00000000 dhcp_start
00000000         *UND*	00000000 netif_set_up
00000000         *UND*	00000000 ethernetif_init
00000000         *UND*	00000000 tcpip_input
000001a8 g     F .text	0000004c lwIPInit
00000000         *UND*	00000000 tcpip_init
000001f4 g     F .text	00000034 ETH_IRQHandler
00000000         *UND*	00000000 xQueueGenericSendFromISR
00000228 g     F .text	00000014 lwIPLocalIPAddrGet
0000023c g     F .text	00000014 lwIPLocalNetMaskGet
00000250 g     F .text	00000014 lwIPLocalGWAddrGet
00000000         *UND*	00000000 netif_set_addr
00000000         *UND*	00000000 dhcp_stop
00000330 g     F .text	00000048 lwIPNetworkConfigChange
00000000         *UND*	00000000 tcpip_callback_with_block



Disassembly of section .text:

00000000 <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   0:	b480      	push	{r7}
   2:	b083      	sub	sp, #12
   4:	af00      	add	r7, sp, #0
   6:	4603      	mov	r3, r0
   8:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   a:	4b09      	ldr	r3, [pc, #36]	; (30 <NVIC_EnableIRQ+0x30>)
   c:	f997 2007 	ldrsb.w	r2, [r7, #7]
  10:	ea4f 1252 	mov.w	r2, r2, lsr #5
  14:	79f9      	ldrb	r1, [r7, #7]
  16:	f001 011f 	and.w	r1, r1, #31
  1a:	f04f 0001 	mov.w	r0, #1
  1e:	fa00 f101 	lsl.w	r1, r0, r1
  22:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  26:	f107 070c 	add.w	r7, r7, #12
  2a:	46bd      	mov	sp, r7
  2c:	bc80      	pop	{r7}
  2e:	4770      	bx	lr
  30:	e000e100 	.word	0xe000e100

00000034 <NVIC_DisableIRQ>:
 * 
 * Disable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  34:	b480      	push	{r7}
  36:	b083      	sub	sp, #12
  38:	af00      	add	r7, sp, #0
  3a:	4603      	mov	r3, r0
  3c:	71fb      	strb	r3, [r7, #7]
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
  3e:	4b0a      	ldr	r3, [pc, #40]	; (68 <NVIC_DisableIRQ+0x34>)
  40:	f997 2007 	ldrsb.w	r2, [r7, #7]
  44:	ea4f 1252 	mov.w	r2, r2, lsr #5
  48:	79f9      	ldrb	r1, [r7, #7]
  4a:	f001 011f 	and.w	r1, r1, #31
  4e:	f04f 0001 	mov.w	r0, #1
  52:	fa00 f101 	lsl.w	r1, r0, r1
  56:	f102 0220 	add.w	r2, r2, #32
  5a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
  5e:	f107 070c 	add.w	r7, r7, #12
  62:	46bd      	mov	sp, r7
  64:	bc80      	pop	{r7}
  66:	4770      	bx	lr
  68:	e000e100 	.word	0xe000e100

0000006c <lwIPInterruptTask>:
//
//*****************************************************************************
#if !NO_SYS
static void
lwIPInterruptTask(void *pvArg)
{
  6c:	b580      	push	{r7, lr}
  6e:	b082      	sub	sp, #8
  70:	af00      	add	r7, sp, #0
  72:	6078      	str	r0, [r7, #4]
    while(1)
    {
        //
        // Wait until the semaphore has been signalled.
        //
        while(xQueueReceive(g_pInterrupt, &pvArg, portMAX_DELAY) != pdPASS)
  74:	bf00      	nop
  76:	4b0c      	ldr	r3, [pc, #48]	; (a8 <lwIPInterruptTask+0x3c>)
  78:	681a      	ldr	r2, [r3, #0]
  7a:	f107 0304 	add.w	r3, r7, #4
  7e:	4610      	mov	r0, r2
  80:	4619      	mov	r1, r3
  82:	f04f 32ff 	mov.w	r2, #4294967295
  86:	f04f 0300 	mov.w	r3, #0
  8a:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			8a: R_ARM_THM_CALL	xQueueGenericReceive
  8e:	4603      	mov	r3, r0
  90:	2b01      	cmp	r3, #1
  92:	d1f0      	bne.n	76 <lwIPInterruptTask+0xa>
        {
        }
        // Processes any packets waiting to be sent or received.
        stm32_ethernetif_input(&g_sNetIF);
  94:	4805      	ldr	r0, [pc, #20]	; (ac <lwIPInterruptTask+0x40>)
  96:	f7ff fffe 	bl	0 <stm32_ethernetif_input>
			96: R_ARM_THM_CALL	stm32_ethernetif_input

        // Re-enable the Ethernet interrupts
        // Enable Ethernet global interrupt=61
		NVIC_EnableIRQ(ETH_IRQn);
  9a:	f04f 003d 	mov.w	r0, #61	; 0x3d
  9e:	f7ff ffaf 	bl	0 <NVIC_EnableIRQ>
    }
  a2:	bf00      	nop
    while(1)
    {
        //
        // Wait until the semaphore has been signalled.
        //
        while(xQueueReceive(g_pInterrupt, &pvArg, portMAX_DELAY) != pdPASS)
  a4:	e7e7      	b.n	76 <lwIPInterruptTask+0xa>
  a6:	bf00      	nop
  a8:	00000058 	.word	0x00000058
			a8: R_ARM_ABS32	.bss
  ac:	00000000 	.word	0x00000000
			ac: R_ARM_ABS32	.bss

000000b0 <lwIPPrivateInit>:
// RTOS.
//
//*****************************************************************************
static void
lwIPPrivateInit(void *pvArg)
{
  b0:	b580      	push	{r7, lr}
  b2:	b08a      	sub	sp, #40	; 0x28
  b4:	af04      	add	r7, sp, #16
  b6:	6078      	str	r0, [r7, #4]
    //
    // If using a RTOS, create a queue (to be used as a semaphore) to signal
    // the Ethernet interrupt task from the Ethernet interrupt handler.
    //
#if !NO_SYS
    g_pInterrupt = xQueueCreate(1, sizeof(void *));
  b8:	f04f 0001 	mov.w	r0, #1
  bc:	f04f 0104 	mov.w	r1, #4
  c0:	f04f 0200 	mov.w	r2, #0
  c4:	f7ff fffe 	bl	0 <xQueueGenericCreate>
			c4: R_ARM_THM_CALL	xQueueGenericCreate
  c8:	4602      	mov	r2, r0
  ca:	4b2d      	ldr	r3, [pc, #180]	; (180 <lwIPPrivateInit+0xd0>)
  cc:	601a      	str	r2, [r3, #0]

    //
    // If using a RTOS, create the Ethernet interrupt task.
    //
#if !NO_SYS
	xTaskCreate(
  ce:	4b2d      	ldr	r3, [pc, #180]	; (184 <lwIPPrivateInit+0xd4>)
  d0:	f04f 0201 	mov.w	r2, #1
  d4:	9200      	str	r2, [sp, #0]
  d6:	f04f 0200 	mov.w	r2, #0
  da:	9201      	str	r2, [sp, #4]
  dc:	f04f 0200 	mov.w	r2, #0
  e0:	9202      	str	r2, [sp, #8]
  e2:	f04f 0200 	mov.w	r2, #0
  e6:	9203      	str	r2, [sp, #12]
  e8:	4827      	ldr	r0, [pc, #156]	; (188 <lwIPPrivateInit+0xd8>)
  ea:	4619      	mov	r1, r3
  ec:	f04f 0280 	mov.w	r2, #128	; 0x80
  f0:	f04f 0300 	mov.w	r3, #0
  f4:	f7ff fffe 	bl	0 <xTaskGenericCreate>
			f4: R_ARM_THM_CALL	xTaskGenericCreate
#endif

    //
    // Setup the network address values.
    //
    if(g_ulIPMode == IPADDR_USE_STATIC)
  f8:	4b24      	ldr	r3, [pc, #144]	; (18c <lwIPPrivateInit+0xdc>)
  fa:	681b      	ldr	r3, [r3, #0]
  fc:	2b00      	cmp	r3, #0
  fe:	d115      	bne.n	12c <lwIPPrivateInit+0x7c>
    {
        ip_addr.addr = htonl(g_ulIPAddr);
 100:	4b23      	ldr	r3, [pc, #140]	; (190 <lwIPPrivateInit+0xe0>)
 102:	681b      	ldr	r3, [r3, #0]
 104:	4618      	mov	r0, r3
 106:	f7ff fffe 	bl	0 <lwip_htonl>
			106: R_ARM_THM_CALL	lwip_htonl
 10a:	4603      	mov	r3, r0
 10c:	617b      	str	r3, [r7, #20]
        net_mask.addr = htonl(g_ulNetMask);
 10e:	4b21      	ldr	r3, [pc, #132]	; (194 <lwIPPrivateInit+0xe4>)
 110:	681b      	ldr	r3, [r3, #0]
 112:	4618      	mov	r0, r3
 114:	f7ff fffe 	bl	0 <lwip_htonl>
			114: R_ARM_THM_CALL	lwip_htonl
 118:	4603      	mov	r3, r0
 11a:	613b      	str	r3, [r7, #16]
        gw_addr.addr = htonl(g_ulGWAddr);
 11c:	4b1e      	ldr	r3, [pc, #120]	; (198 <lwIPPrivateInit+0xe8>)
 11e:	681b      	ldr	r3, [r3, #0]
 120:	4618      	mov	r0, r3
 122:	f7ff fffe 	bl	0 <lwip_htonl>
			122: R_ARM_THM_CALL	lwip_htonl
 126:	4603      	mov	r3, r0
 128:	60fb      	str	r3, [r7, #12]
 12a:	e008      	b.n	13e <lwIPPrivateInit+0x8e>
    }
    else
    {
        ip_addr.addr = 0;
 12c:	f04f 0300 	mov.w	r3, #0
 130:	617b      	str	r3, [r7, #20]
        net_mask.addr = 0;
 132:	f04f 0300 	mov.w	r3, #0
 136:	613b      	str	r3, [r7, #16]
        gw_addr.addr = 0;
 138:	f04f 0300 	mov.w	r3, #0
 13c:	60fb      	str	r3, [r7, #12]
    //
#if NO_SYS
     netif_add(&g_sNetIF, &ip_addr, &net_mask, &gw_addr, NULL, ethernetif_init,
              ip_input);
#else
	netif_add(&g_sNetIF, &ip_addr, &net_mask, &gw_addr, NULL, ethernetif_init,
 13e:	f107 0114 	add.w	r1, r7, #20
 142:	f107 0210 	add.w	r2, r7, #16
 146:	f107 030c 	add.w	r3, r7, #12
 14a:	f04f 0000 	mov.w	r0, #0
 14e:	9000      	str	r0, [sp, #0]
 150:	4812      	ldr	r0, [pc, #72]	; (19c <lwIPPrivateInit+0xec>)
 152:	9001      	str	r0, [sp, #4]
 154:	4812      	ldr	r0, [pc, #72]	; (1a0 <lwIPPrivateInit+0xf0>)
 156:	9002      	str	r0, [sp, #8]
 158:	4812      	ldr	r0, [pc, #72]	; (1a4 <lwIPPrivateInit+0xf4>)
 15a:	f7ff fffe 	bl	0 <netif_add>
			15a: R_ARM_THM_CALL	netif_add
              tcpip_input);
#endif
    netif_set_default(&g_sNetIF);
 15e:	4811      	ldr	r0, [pc, #68]	; (48 <netif_set_default+0x48>)
 160:	f7ff fffe 	bl	0 <netif_set_default>
			160: R_ARM_THM_CALL	netif_set_default

    //
    // Start DHCP, if enabled.
    //
#if LWIP_DHCP
    if(g_ulIPMode == IPADDR_USE_DHCP)
 164:	4b09      	ldr	r3, [pc, #36]	; (18c <lwIPPrivateInit+0xdc>)
 166:	681b      	ldr	r3, [r3, #0]
 168:	2b01      	cmp	r3, #1
 16a:	d102      	bne.n	172 <lwIPPrivateInit+0xc2>
    {
        dhcp_start(&g_sNetIF);
 16c:	480d      	ldr	r0, [pc, #52]	; (1a4 <lwIPPrivateInit+0xf4>)
 16e:	f7ff fffe 	bl	0 <dhcp_start>
			16e: R_ARM_THM_CALL	dhcp_start
#endif

    //
    // Bring the interface up.
    //
    netif_set_up(&g_sNetIF);
 172:	480c      	ldr	r0, [pc, #48]	; (34 <netif_set_up+0x34>)
 174:	f7ff fffe 	bl	0 <netif_set_up>
			174: R_ARM_THM_CALL	netif_set_up
    //
#if !NO_SYS && HOST_TMR_INTERVAL
    sys_timeout(HOST_TMR_INTERVAL, lwIPPrivateHostTimer, NULL);
#endif

}
 178:	f107 0718 	add.w	r7, r7, #24
 17c:	46bd      	mov	sp, r7
 17e:	bd80      	pop	{r7, pc}
 180:	00000058 	.word	0x00000058
			180: R_ARM_ABS32	.bss
	...
			184: R_ARM_ABS32	.rodata
			188: R_ARM_ABS32	lwIPInterruptTask
 18c:	00000044 	.word	0x00000044
			18c: R_ARM_ABS32	.bss
 190:	00000048 	.word	0x00000048
			190: R_ARM_ABS32	.bss
 194:	0000004c 	.word	0x0000004c
			194: R_ARM_ABS32	.bss
 198:	00000050 	.word	0x00000050
			198: R_ARM_ABS32	.bss
	...
			19c: R_ARM_ABS32	ethernetif_init
			1a0: R_ARM_ABS32	tcpip_input
			1a4: R_ARM_ABS32	.bss

000001a8 <lwIPInit>:
//*****************************************************************************
void
lwIPInit(uint8_t *pucMAC, unsigned long ulIPAddr,
         unsigned long ulNetMask, unsigned long ulGWAddr,
         unsigned long ulIPMode)
{
 1a8:	b580      	push	{r7, lr}
 1aa:	b084      	sub	sp, #16
 1ac:	af00      	add	r7, sp, #0
 1ae:	60f8      	str	r0, [r7, #12]
 1b0:	60b9      	str	r1, [r7, #8]
 1b2:	607a      	str	r2, [r7, #4]
 1b4:	603b      	str	r3, [r7, #0]

    //
    // Save the network configuration for later use by the private
    // initialization.
    //
    g_ulIPMode = ulIPMode;
 1b6:	4b0a      	ldr	r3, [pc, #40]	; (1e0 <lwIPInit+0x38>)
 1b8:	69ba      	ldr	r2, [r7, #24]
 1ba:	601a      	str	r2, [r3, #0]
    g_ulIPAddr = ulIPAddr;
 1bc:	4b09      	ldr	r3, [pc, #36]	; (1e4 <lwIPInit+0x3c>)
 1be:	68ba      	ldr	r2, [r7, #8]
 1c0:	601a      	str	r2, [r3, #0]
    g_ulNetMask = ulNetMask;
 1c2:	4b09      	ldr	r3, [pc, #36]	; (1e8 <lwIPInit+0x40>)
 1c4:	687a      	ldr	r2, [r7, #4]
 1c6:	601a      	str	r2, [r3, #0]
    g_ulGWAddr = ulGWAddr;
 1c8:	4b08      	ldr	r3, [pc, #32]	; (1ec <lwIPInit+0x44>)
 1ca:	683a      	ldr	r2, [r7, #0]
 1cc:	601a      	str	r2, [r3, #0]
    // using a RTOS.
    //
#if NO_SYS
    lwIPPrivateInit(0);
#else
    tcpip_init(lwIPPrivateInit, 0);
 1ce:	4808      	ldr	r0, [pc, #32]	; (1f0 <lwIPInit+0x48>)
 1d0:	f04f 0100 	mov.w	r1, #0
 1d4:	f7ff fffe 	bl	0 <tcpip_init>
			1d4: R_ARM_THM_CALL	tcpip_init
#endif
}
 1d8:	f107 0710 	add.w	r7, r7, #16
 1dc:	46bd      	mov	sp, r7
 1de:	bd80      	pop	{r7, pc}
 1e0:	00000044 	.word	0x00000044
			1e0: R_ARM_ABS32	.bss
 1e4:	00000048 	.word	0x00000048
			1e4: R_ARM_ABS32	.bss
 1e8:	0000004c 	.word	0x0000004c
			1e8: R_ARM_ABS32	.bss
 1ec:	00000050 	.word	0x00000050
			1ec: R_ARM_ABS32	.bss
 1f0:	00000000 	.word	0x00000000
			1f0: R_ARM_ABS32	lwIPPrivateInit

000001f4 <ETH_IRQHandler>:
//!
//! \return None.
//
//*****************************************************************************
void ETH_IRQHandler(void)
{
 1f4:	b580      	push	{r7, lr}
 1f6:	b082      	sub	sp, #8
 1f8:	af00      	add	r7, sp, #0
    lwIPServiceTimers();
#else
    //
    // A RTOS is being used.  Signal the Ethernet interrupt task.
    //
    xQueueSendFromISR(g_pInterrupt,(void *) 1, &xWake);
 1fa:	4b0a      	ldr	r3, [pc, #40]	; (224 <ETH_IRQHandler+0x30>)
 1fc:	681a      	ldr	r2, [r3, #0]
 1fe:	f107 0304 	add.w	r3, r7, #4
 202:	4610      	mov	r0, r2
 204:	f04f 0101 	mov.w	r1, #1
 208:	461a      	mov	r2, r3
 20a:	f04f 0300 	mov.w	r3, #0
 20e:	f7ff fffe 	bl	0 <xQueueGenericSendFromISR>
			20e: R_ARM_THM_CALL	xQueueGenericSendFromISR
    // handled, they are not asserted.  Once they are handled by the Ethernet
    // interrupt task, it will re-enable the interrupts.
    //
    
	// TODO: stm32
	NVIC_DisableIRQ(ETH_IRQn);
 212:	f04f 003d 	mov.w	r0, #61	; 0x3d
 216:	f7ff ff0d 	bl	34 <NVIC_DisableIRQ>
    //
    //TODO: Check if that's ok here
    // taskYIELD();
#endif

}
 21a:	f107 0708 	add.w	r7, r7, #8
 21e:	46bd      	mov	sp, r7
 220:	bd80      	pop	{r7, pc}
 222:	bf00      	nop
 224:	00000058 	.word	0x00000058
			224: R_ARM_ABS32	.bss

00000228 <lwIPLocalIPAddrGet>:
//! \return Returns the assigned IP address for this interface.
//
//*****************************************************************************
unsigned long
lwIPLocalIPAddrGet(void)
{
 228:	b480      	push	{r7}
 22a:	af00      	add	r7, sp, #0
    return((unsigned long)g_sNetIF.ip_addr.addr);
 22c:	4b02      	ldr	r3, [pc, #8]	; (238 <lwIPLocalIPAddrGet+0x10>)
 22e:	685b      	ldr	r3, [r3, #4]
}
 230:	4618      	mov	r0, r3
 232:	46bd      	mov	sp, r7
 234:	bc80      	pop	{r7}
 236:	4770      	bx	lr
 238:	00000000 	.word	0x00000000
			238: R_ARM_ABS32	.bss

0000023c <lwIPLocalNetMaskGet>:
//! \return the assigned network mask for this interface.
//
//*****************************************************************************
unsigned long
lwIPLocalNetMaskGet(void)
{
 23c:	b480      	push	{r7}
 23e:	af00      	add	r7, sp, #0
    return((unsigned long)g_sNetIF.netmask.addr);
 240:	4b02      	ldr	r3, [pc, #8]	; (24c <lwIPLocalNetMaskGet+0x10>)
 242:	689b      	ldr	r3, [r3, #8]
}
 244:	4618      	mov	r0, r3
 246:	46bd      	mov	sp, r7
 248:	bc80      	pop	{r7}
 24a:	4770      	bx	lr
 24c:	00000000 	.word	0x00000000
			24c: R_ARM_ABS32	.bss

00000250 <lwIPLocalGWAddrGet>:
//! \return the assigned gateway address for this interface.
//
//*****************************************************************************
unsigned long
lwIPLocalGWAddrGet(void)
{
 250:	b480      	push	{r7}
 252:	af00      	add	r7, sp, #0
    return((unsigned long)g_sNetIF.gw.addr);
 254:	4b02      	ldr	r3, [pc, #8]	; (260 <lwIPLocalGWAddrGet+0x10>)
 256:	68db      	ldr	r3, [r3, #12]
}
 258:	4618      	mov	r0, r3
 25a:	46bd      	mov	sp, r7
 25c:	bc80      	pop	{r7}
 25e:	4770      	bx	lr
 260:	00000000 	.word	0x00000000
			260: R_ARM_ABS32	.bss

00000264 <lwIPPrivateNetworkConfigChange>:
// a RTOS.
//
//*****************************************************************************
static void
lwIPPrivateNetworkConfigChange(void *pvArg)
{
 264:	b580      	push	{r7, lr}
 266:	b086      	sub	sp, #24
 268:	af00      	add	r7, sp, #0
 26a:	6078      	str	r0, [r7, #4]
    struct ip_addr gw_addr;

    //
    // Get the new address mode.
    //
    ulIPMode = (unsigned long)pvArg;
 26c:	687b      	ldr	r3, [r7, #4]
 26e:	617b      	str	r3, [r7, #20]

    //
    // Setup the network address values.
    //
    if(ulIPMode == IPADDR_USE_STATIC)
 270:	697b      	ldr	r3, [r7, #20]
 272:	2b00      	cmp	r3, #0
 274:	d115      	bne.n	2a2 <lwIPPrivateNetworkConfigChange+0x3e>
    {
        ip_addr.addr = htonl(g_ulIPAddr);
 276:	4b29      	ldr	r3, [pc, #164]	; (31c <lwIPPrivateNetworkConfigChange+0xb8>)
 278:	681b      	ldr	r3, [r3, #0]
 27a:	4618      	mov	r0, r3
 27c:	f7ff fffe 	bl	0 <lwip_htonl>
			27c: R_ARM_THM_CALL	lwip_htonl
 280:	4603      	mov	r3, r0
 282:	613b      	str	r3, [r7, #16]
        net_mask.addr = htonl(g_ulNetMask);
 284:	4b26      	ldr	r3, [pc, #152]	; (320 <lwIPPrivateNetworkConfigChange+0xbc>)
 286:	681b      	ldr	r3, [r3, #0]
 288:	4618      	mov	r0, r3
 28a:	f7ff fffe 	bl	0 <lwip_htonl>
			28a: R_ARM_THM_CALL	lwip_htonl
 28e:	4603      	mov	r3, r0
 290:	60fb      	str	r3, [r7, #12]
        gw_addr.addr = htonl(g_ulGWAddr);
 292:	4b24      	ldr	r3, [pc, #144]	; (324 <lwIPPrivateNetworkConfigChange+0xc0>)
 294:	681b      	ldr	r3, [r3, #0]
 296:	4618      	mov	r0, r3
 298:	f7ff fffe 	bl	0 <lwip_htonl>
			298: R_ARM_THM_CALL	lwip_htonl
 29c:	4603      	mov	r3, r0
 29e:	60bb      	str	r3, [r7, #8]
 2a0:	e008      	b.n	2b4 <lwIPPrivateNetworkConfigChange+0x50>
    }
#if LWIP_DHCP || LWIP_AUTOIP
    else
    {
        ip_addr.addr = 0;
 2a2:	f04f 0300 	mov.w	r3, #0
 2a6:	613b      	str	r3, [r7, #16]
        net_mask.addr = 0;
 2a8:	f04f 0300 	mov.w	r3, #0
 2ac:	60fb      	str	r3, [r7, #12]
        gw_addr.addr = 0;
 2ae:	f04f 0300 	mov.w	r3, #0
 2b2:	60bb      	str	r3, [r7, #8]
#endif

    //
    // Switch on the current IP Address Aquisition mode.
    //
    switch(g_ulIPMode)
 2b4:	4b1c      	ldr	r3, [pc, #112]	; (328 <lwIPPrivateNetworkConfigChange+0xc4>)
 2b6:	681b      	ldr	r3, [r3, #0]
 2b8:	2b00      	cmp	r3, #0
 2ba:	d002      	beq.n	2c2 <lwIPPrivateNetworkConfigChange+0x5e>
 2bc:	2b01      	cmp	r3, #1
 2be:	d010      	beq.n	2e2 <lwIPPrivateNetworkConfigChange+0x7e>
 2c0:	e022      	b.n	308 <lwIPPrivateNetworkConfigChange+0xa4>
            //
            // Set the new address parameters.  This will change the address
            // configuration in lwIP, and if necessary, will reset any links
            // that are active.  This is valid for all three modes.
            //
            netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
 2c2:	f107 0110 	add.w	r1, r7, #16
 2c6:	f107 020c 	add.w	r2, r7, #12
 2ca:	f107 0308 	add.w	r3, r7, #8
 2ce:	4817      	ldr	r0, [pc, #92]	; (60 <netif_set_addr+0x60>)
 2d0:	f7ff fffe 	bl	0 <netif_set_addr>
			2d0: R_ARM_THM_CALL	netif_set_addr

            //
            // If we are going to DHCP mode, then start the DHCP server now.
            //
#if LWIP_DHCP
            if(ulIPMode == IPADDR_USE_DHCP)
 2d4:	697b      	ldr	r3, [r7, #20]
 2d6:	2b01      	cmp	r3, #1
 2d8:	d113      	bne.n	302 <lwIPPrivateNetworkConfigChange+0x9e>
            {
                dhcp_start(&g_sNetIF);
 2da:	4814      	ldr	r0, [pc, #80]	; (32c <lwIPPrivateNetworkConfigChange+0xc8>)
 2dc:	f7ff fffe 	bl	0 <dhcp_start>
			2dc: R_ARM_THM_CALL	dhcp_start
#endif

            //
            // And we're done.
            //
            break;
 2e0:	e012      	b.n	308 <lwIPPrivateNetworkConfigChange+0xa4>
        {
            //
            // If we are going to static IP addressing, then disable DHCP and
            // force the new static IP address.
            //
            if(ulIPMode == IPADDR_USE_STATIC)
 2e2:	697b      	ldr	r3, [r7, #20]
 2e4:	2b00      	cmp	r3, #0
 2e6:	d10e      	bne.n	306 <lwIPPrivateNetworkConfigChange+0xa2>
            {
                dhcp_stop(&g_sNetIF);
 2e8:	4810      	ldr	r0, [pc, #64]	; (32c <lwIPPrivateNetworkConfigChange+0xc8>)
 2ea:	f7ff fffe 	bl	0 <dhcp_stop>
			2ea: R_ARM_THM_CALL	dhcp_stop
                netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
 2ee:	f107 0110 	add.w	r1, r7, #16
 2f2:	f107 020c 	add.w	r2, r7, #12
 2f6:	f107 0308 	add.w	r3, r7, #8
 2fa:	480c      	ldr	r0, [pc, #48]	; (34 <netif_set_addr+0x34>)
 2fc:	f7ff fffe 	bl	0 <netif_set_addr>
			2fc: R_ARM_THM_CALL	netif_set_addr
                dhcp_stop(&g_sNetIF);
                netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
                autoip_start(&g_sNetIF);
            }
#endif
            break;
 300:	e002      	b.n	308 <lwIPPrivateNetworkConfigChange+0xa4>
#endif

            //
            // And we're done.
            //
            break;
 302:	bf00      	nop
 304:	e000      	b.n	308 <lwIPPrivateNetworkConfigChange+0xa4>
                dhcp_stop(&g_sNetIF);
                netif_set_addr(&g_sNetIF, &ip_addr, &net_mask, &gw_addr);
                autoip_start(&g_sNetIF);
            }
#endif
            break;
 306:	bf00      	nop
    }

    //
    // Bring the interface up.
    //
    netif_set_up(&g_sNetIF);
 308:	4808      	ldr	r0, [pc, #32]	; (32c <lwIPPrivateNetworkConfigChange+0xc8>)
 30a:	f7ff fffe 	bl	0 <netif_set_up>
			30a: R_ARM_THM_CALL	netif_set_up

    //
    // Save the new mode.
    //
    g_ulIPMode = ulIPMode;
 30e:	4b06      	ldr	r3, [pc, #24]	; (328 <lwIPPrivateNetworkConfigChange+0xc4>)
 310:	697a      	ldr	r2, [r7, #20]
 312:	601a      	str	r2, [r3, #0]
}
 314:	f107 0718 	add.w	r7, r7, #24
 318:	46bd      	mov	sp, r7
 31a:	bd80      	pop	{r7, pc}
 31c:	00000048 	.word	0x00000048
			31c: R_ARM_ABS32	.bss
 320:	0000004c 	.word	0x0000004c
			320: R_ARM_ABS32	.bss
 324:	00000050 	.word	0x00000050
			324: R_ARM_ABS32	.bss
 328:	00000044 	.word	0x00000044
			328: R_ARM_ABS32	.bss
 32c:	00000000 	.word	0x00000000
			32c: R_ARM_ABS32	.bss

00000330 <lwIPNetworkConfigChange>:
//
//*****************************************************************************
void
lwIPNetworkConfigChange(unsigned long ulIPAddr, unsigned long ulNetMask,
                        unsigned long ulGWAddr, unsigned long ulIPMode)
{
 330:	b580      	push	{r7, lr}
 332:	b084      	sub	sp, #16
 334:	af00      	add	r7, sp, #0
 336:	60f8      	str	r0, [r7, #12]
 338:	60b9      	str	r1, [r7, #8]
 33a:	607a      	str	r2, [r7, #4]
 33c:	603b      	str	r3, [r7, #0]

    //
    // Save the network configuration for later use by the private network
    // configuration change.
    //
    g_ulIPAddr = ulIPAddr;
 33e:	4b0a      	ldr	r3, [pc, #40]	; (368 <lwIPNetworkConfigChange+0x38>)
 340:	68fa      	ldr	r2, [r7, #12]
 342:	601a      	str	r2, [r3, #0]
    g_ulNetMask = ulNetMask;
 344:	4b09      	ldr	r3, [pc, #36]	; (36c <lwIPNetworkConfigChange+0x3c>)
 346:	68ba      	ldr	r2, [r7, #8]
 348:	601a      	str	r2, [r3, #0]
    g_ulGWAddr = ulGWAddr;
 34a:	4b09      	ldr	r3, [pc, #36]	; (370 <lwIPNetworkConfigChange+0x40>)
 34c:	687a      	ldr	r2, [r7, #4]
 34e:	601a      	str	r2, [r3, #0]
    // thread's context if using a RTOS.
    //
#if NO_SYS
    lwIPPrivateNetworkConfigChange((void *)ulIPMode);
#else
    tcpip_callback(lwIPPrivateNetworkConfigChange, (void *)ulIPMode);
 350:	683b      	ldr	r3, [r7, #0]
 352:	4808      	ldr	r0, [pc, #32]	; (374 <lwIPNetworkConfigChange+0x44>)
 354:	4619      	mov	r1, r3
 356:	f04f 0201 	mov.w	r2, #1
 35a:	f7ff fffe 	bl	0 <tcpip_callback_with_block>
			35a: R_ARM_THM_CALL	tcpip_callback_with_block
#endif
}
 35e:	f107 0710 	add.w	r7, r7, #16
 362:	46bd      	mov	sp, r7
 364:	bd80      	pop	{r7, pc}
 366:	bf00      	nop
 368:	00000048 	.word	0x00000048
			368: R_ARM_ABS32	.bss
 36c:	0000004c 	.word	0x0000004c
			36c: R_ARM_ABS32	.bss
 370:	00000050 	.word	0x00000050
			370: R_ARM_ABS32	.bss
 374:	00000000 	.word	0x00000000
			374: R_ARM_ABS32	lwIPPrivateNetworkConfigChange

stm32_eth.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 392824 Jul 30 19:07 2021 stm32_eth.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000023d0  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00002404  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00002404  2**0
                  ALLOC
  3 .debug_abbrev 000001ff  00000000  00000000  00002404  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00001e31  00000000  00000000  00002603  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000932  00000000  00000000  00004434  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00053176  00000000  00000000  00004d66  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    000014d8  00000000  00000000  00057edc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000b7f  00000000  00000000  000593b4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000000c1  00000000  00000000  00059f33  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00059ff4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    0000149a  00000000  00000000  0005a014  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0005b4ae  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0005b4d9  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000abc  00000000  00000000  0005b50c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 stm32_eth.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
000023a4 l     F .text	0000002c ETH_Delay
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 DMATxDescToSet
00000004       O *COM*	00000004 DMARxDescToGet
00000004       O *COM*	00000004 DMAPTPTxDescToSet
00000004       O *COM*	00000004 DMAPTPRxDescToGet
00000000 g     F .text	0000001e ETH_DeInit
00000000         *UND*	00000000 RCC_AHBPeriphResetCmd
00000020 g     F .text	000003b4 ETH_Init
00000000         *UND*	00000000 RCC_GetClocksFreq
000009ac g     F .text	000000bc ETH_WritePHYRegister
000008f8 g     F .text	000000b4 ETH_ReadPHYRegister
000003d4 g     F .text	000001a8 ETH_StructInit
0000057c g     F .text	0000002a ETH_Start
00000ad0 g     F .text	00000038 ETH_MACTransmissionCmd
00001618 g     F .text	0000002c ETH_FlushTransmitFIFO
00000b08 g     F .text	00000038 ETH_MACReceptionCmd
00001684 g     F .text	00000058 ETH_DMATransmissionCmd
000016dc g     F .text	00000058 ETH_DMAReceptionCmd
000005a8 g     F .text	00000128 ETH_HandleTxPkt
000006d0 g     F .text	00000150 ETH_HandleRxPkt
00000820 g     F .text	0000005c ETH_GetRxPktSize
00001398 g     F .text	00000028 ETH_GetDMARxDescFrameLength
0000087c g     F .text	0000007c ETH_DropRxPkt
00000a68 g     F .text	00000066 ETH_PHYLoopBackCmd
00000b40 g     F .text	0000003c ETH_GetFlowControlBusyStatus
00000b7c g     F .text	0000001c ETH_InitiatePauseControlFrame
00000b98 g     F .text	00000038 ETH_BackPressureActivationCmd
00000bd0 g     F .text	0000003c ETH_GetMACFlagStatus
00000c0c g     F .text	0000003c ETH_GetMACITStatus
00000c48 g     F .text	00000044 ETH_MACITConfig
00000c8c g     F .text	0000007c ETH_MACAddressConfig
00000d08 g     F .text	00000084 ETH_GetMACAddress
00000d8c g     F .text	00000050 ETH_MACAddressPerfectFilterCmd
00000ddc g     F .text	0000004c ETH_MACAddressFilterConfig
00000e28 g     F .text	00000048 ETH_MACAddressMaskBytesFilterConfig
00000e70 g     F .text	000000a0 ETH_DMATxDescChainInit
00000f10 g     F .text	0000009c ETH_DMATxDescRingInit
00000fac g     F .text	0000003a ETH_GetDMATxDescFlagStatus
00000fe8 g     F .text	00000020 ETH_GetDMATxDescCollisionCount
00001008 g     F .text	0000001e ETH_SetDMATxDescOwnBit
00001028 g     F .text	00000036 ETH_DMATxDescTransmitITConfig
00001060 g     F .text	00000020 ETH_DMATxDescFrameSegmentConfig
00001080 g     F .text	00000020 ETH_DMATxDescChecksumInsertionConfig
000010a0 g     F .text	00000036 ETH_DMATxDescCRCCmd
000010d8 g     F .text	00000036 ETH_DMATxDescEndOfRingCmd
00001110 g     F .text	00000036 ETH_DMATxDescSecondAddressChainedCmd
00001148 g     F .text	00000036 ETH_DMATxDescShortFramePaddingCmd
00001180 g     F .text	00000036 ETH_DMATxDescTimeStampCmd
000011b8 g     F .text	0000002c ETH_DMATxDescBufferSizeConfig
000011e4 g     F .text	000000a8 ETH_DMARxDescChainInit
0000128c g     F .text	000000b0 ETH_DMARxDescRingInit
0000133c g     F .text	0000003a ETH_GetDMARxDescFlagStatus
00001378 g     F .text	0000001e ETH_SetDMARxDescOwnBit
000013c0 g     F .text	00000036 ETH_DMARxDescReceiveITConfig
000013f8 g     F .text	00000036 ETH_DMARxDescEndOfRingCmd
00001430 g     F .text	00000036 ETH_DMARxDescSecondAddressChainedCmd
00001468 g     F .text	0000003c ETH_GetDMARxDescBufferSize
000014a4 g     F .text	00000024 ETH_SoftwareReset
000014c8 g     F .text	00000040 ETH_GetSoftwareResetStatus
00001508 g     F .text	00000044 ETH_GetDMAFlagStatus
0000154c g     F .text	00000024 ETH_DMAClearFlag
00001570 g     F .text	00000044 ETH_GetDMAITStatus
000015b4 g     F .text	00000024 ETH_DMAClearITPendingBit
000015d8 g     F .text	00000020 ETH_GetTransmitProcessState
000015f8 g     F .text	00000020 ETH_GetReceiveProcessState
00001644 g     F .text	00000040 ETH_GetFlushTransmitFIFOStatus
00001734 g     F .text	00000060 ETH_DMAITConfig
00001794 g     F .text	00000040 ETH_GetDMAOverflowStatus
000017d4 g     F .text	00000028 ETH_GetRxOverflowMissedFrameCounter
000017fc g     F .text	00000020 ETH_GetBufferUnavailableMissedFrameCounter
0000181c g     F .text	0000001c ETH_GetCurrentTxDescStartAddress
00001838 g     F .text	0000001c ETH_GetCurrentRxDescStartAddress
00001854 g     F .text	0000001c ETH_GetCurrentTxBufferAddress
00001870 g     F .text	0000001c ETH_GetCurrentRxBufferAddress
0000188c g     F .text	00000020 ETH_ResumeDMATransmission
000018ac g     F .text	00000020 ETH_ResumeDMAReception
000018cc g     F .text	0000001c ETH_ResetWakeUpFrameFilterRegisterPointer
000018e8 g     F .text	00000044 ETH_SetWakeUpFrameFilterRegister
0000192c g     F .text	00000038 ETH_GlobalUnicastWakeUpCmd
00001964 g     F .text	0000003c ETH_GetPMTFlagStatus
000019a0 g     F .text	00000038 ETH_WakeUpFrameDetectionCmd
000019d8 g     F .text	00000038 ETH_MagicPacketDetectionCmd
00001a10 g     F .text	00000038 ETH_PowerDownCmd
00001a48 g     F .text	00000040 ETH_MMCCounterFreezeCmd
00001a88 g     F .text	00000040 ETH_MMCResetOnReadCmd
00001ac8 g     F .text	00000040 ETH_MMCCounterRolloverCmd
00001b08 g     F .text	00000020 ETH_MMCCountersReset
00001b28 g     F .text	00000090 ETH_MMCITConfig
00001bb8 g     F .text	00000088 ETH_GetMMCITStatus
00001c40 g     F .text	00000020 ETH_GetMMCRegister
00001c60 g     F .text	00000020 ETH_EnablePTPTimeStampAddend
00001c80 g     F .text	00000020 ETH_EnablePTPTimeStampInterruptTrigger
00001ca0 g     F .text	00000020 ETH_EnablePTPTimeStampUpdate
00001cc0 g     F .text	00000020 ETH_InitializePTPTimeStamp
00001ce0 g     F .text	00000040 ETH_PTPUpdateMethodConfig
00001d20 g     F .text	00000040 ETH_PTPTimeStampCmd
00001d60 g     F .text	00000040 ETH_GetPTPFlagStatus
00001da0 g     F .text	00000020 ETH_SetPTPSubSecondIncrement
00001dc0 g     F .text	00000030 ETH_SetPTPTimeStampUpdate
00001df0 g     F .text	00000020 ETH_SetPTPTimeStampAddend
00001e10 g     F .text	00000028 ETH_SetPTPTargetTime
00001e38 g     F .text	00000020 ETH_GetPTPRegister
00001e58 g     F .text	000000e0 ETH_DMAPTPTxDescChainInit
00001f38 g     F .text	000000e8 ETH_DMAPTPRxDescChainInit
00002020 g     F .text	000001e8 ETH_HandlePTPTxPkt
00002208 g     F .text	0000019c ETH_HandlePTPRxPkt



Disassembly of section .text:

00000000 <ETH_DeInit>:
  * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
       0:	b580      	push	{r7, lr}
       2:	af00      	add	r7, sp, #0
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, ENABLE);
       4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
       8:	f04f 0101 	mov.w	r1, #1
       c:	f7ff fffe 	bl	0 <RCC_AHBPeriphResetCmd>
			c: R_ARM_THM_CALL	RCC_AHBPeriphResetCmd
  RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ETH_MAC, DISABLE);
      10:	f44f 4080 	mov.w	r0, #16384	; 0x4000
      14:	f04f 0100 	mov.w	r1, #0
      18:	f7ff fffe 	bl	0 <RCC_AHBPeriphResetCmd>
			18: R_ARM_THM_CALL	RCC_AHBPeriphResetCmd
}
      1c:	bd80      	pop	{r7, pc}
      1e:	bf00      	nop

00000020 <ETH_Init>:
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
      20:	b580      	push	{r7, lr}
      22:	b08c      	sub	sp, #48	; 0x30
      24:	af00      	add	r7, sp, #0
      26:	6078      	str	r0, [r7, #4]
      28:	460b      	mov	r3, r1
      2a:	807b      	strh	r3, [r7, #2]
  uint32_t RegValue = 0, tmpreg = 0;
      2c:	f04f 0300 	mov.w	r3, #0
      30:	62bb      	str	r3, [r7, #40]	; 0x28
      32:	f04f 0300 	mov.w	r3, #0
      36:	62fb      	str	r3, [r7, #44]	; 0x2c
  __IO uint32_t i = 0;
      38:	f04f 0300 	mov.w	r3, #0
      3c:	623b      	str	r3, [r7, #32]
  RCC_ClocksTypeDef  rcc_clocks;
  uint32_t hclk = 60000000;
      3e:	4b65      	ldr	r3, [pc, #404]	; (1d4 <ETH_Init+0x1b4>)
      40:	627b      	str	r3, [r7, #36]	; 0x24
  __IO uint32_t timeout = 0;
      42:	f04f 0300 	mov.w	r3, #0
      46:	60bb      	str	r3, [r7, #8]
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
      48:	4b63      	ldr	r3, [pc, #396]	; (1d8 <ETH_Init+0x1b8>)
      4a:	691b      	ldr	r3, [r3, #16]
      4c:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
      4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
      50:	f023 031c 	bic.w	r3, r3, #28
      54:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
      56:	f107 030c 	add.w	r3, r7, #12
      5a:	4618      	mov	r0, r3
      5c:	f7ff fffe 	bl	0 <RCC_GetClocksFreq>
			5c: R_ARM_THM_CALL	RCC_GetClocksFreq
  hclk = rcc_clocks.HCLK_Frequency;
      60:	693b      	ldr	r3, [r7, #16]
      62:	627b      	str	r3, [r7, #36]	; 0x24
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
      64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
      66:	4b5d      	ldr	r3, [pc, #372]	; (1dc <ETH_Init+0x1bc>)
      68:	429a      	cmp	r2, r3
      6a:	d908      	bls.n	7e <ETH_Init+0x5e>
      6c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
      6e:	4b5c      	ldr	r3, [pc, #368]	; (1e0 <ETH_Init+0x1c0>)
      70:	429a      	cmp	r2, r3
      72:	d804      	bhi.n	7e <ETH_Init+0x5e>
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
      74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
      76:	f043 0308 	orr.w	r3, r3, #8
      7a:	62fb      	str	r3, [r7, #44]	; 0x2c
      7c:	e00b      	b.n	96 <ETH_Init+0x76>
  }
  else if((hclk >= 35000000)&&(hclk < 60000000))
      7e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
      80:	4b57      	ldr	r3, [pc, #348]	; (1e0 <ETH_Init+0x1c0>)
      82:	429a      	cmp	r2, r3
      84:	d907      	bls.n	96 <ETH_Init+0x76>
      86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
      88:	4b56      	ldr	r3, [pc, #344]	; (1e4 <ETH_Init+0x1c4>)
      8a:	429a      	cmp	r2, r3
      8c:	d803      	bhi.n	96 <ETH_Init+0x76>
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
      8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
      90:	f043 030c 	orr.w	r3, r3, #12
      94:	62fb      	str	r3, [r7, #44]	; 0x2c
  {
    /* CSR Clock Range between 60-72 MHz */   
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
      96:	4b50      	ldr	r3, [pc, #320]	; (1d8 <ETH_Init+0x1b8>)
      98:	6afa      	ldr	r2, [r7, #44]	; 0x2c
      9a:	611a      	str	r2, [r3, #16]
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
      9c:	887b      	ldrh	r3, [r7, #2]
      9e:	4618      	mov	r0, r3
      a0:	f04f 0100 	mov.w	r1, #0
      a4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
      a8:	f7ff fffe 	bl	9ac <ETH_WritePHYRegister>
			a8: R_ARM_THM_CALL	ETH_WritePHYRegister
      ac:	4603      	mov	r3, r0
      ae:	2b00      	cmp	r3, #0
      b0:	d102      	bne.n	b8 <ETH_Init+0x98>
  {
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
      b2:	f04f 0300 	mov.w	r3, #0
      b6:	e182      	b.n	3be <ETH_Init+0x39e>
  }
  
  /* Delay to assure PHY reset */
  _eth_delay_(PHY_ResetDelay);
      b8:	484b      	ldr	r0, [pc, #300]	; (1e8 <ETH_Init+0x1c8>)
      ba:	f002 f973 	bl	23a4 <ETH_Delay>
#ifdef XME_BSP_STM32_ETHERNET_PHY_DP83848J
	// Workaround speed LED being permanently on: Turn off link and speed LED
	ETH_WritePHYRegister(PHYAddress, LEDCR, LEDCR_LNKLED_FORCE_OFF | LEDCR_SPEEDLED_FORCE_OFF );
#endif // #ifdef XME_BSP_STM32_ETHERNET_PHY_DP83848J

  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
      be:	687b      	ldr	r3, [r7, #4]
      c0:	681b      	ldr	r3, [r3, #0]
      c2:	2b00      	cmp	r3, #0
      c4:	d06c      	beq.n	1a0 <ETH_Init+0x180>
  {  
    /* We wait for linked status... */
    do
    {
      timeout++;
      c6:	68bb      	ldr	r3, [r7, #8]
      c8:	f103 0301 	add.w	r3, r3, #1
      cc:	60bb      	str	r3, [r7, #8]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
      ce:	887b      	ldrh	r3, [r7, #2]
      d0:	4618      	mov	r0, r3
      d2:	f04f 0101 	mov.w	r1, #1
      d6:	f7ff fffe 	bl	8f8 <ETH_ReadPHYRegister>
			d6: R_ARM_THM_CALL	ETH_ReadPHYRegister
      da:	4603      	mov	r3, r0
      dc:	f003 0304 	and.w	r3, r3, #4
      e0:	2b00      	cmp	r3, #0
      e2:	d103      	bne.n	ec <ETH_Init+0xcc>
      e4:	68ba      	ldr	r2, [r7, #8]
      e6:	4b41      	ldr	r3, [pc, #260]	; (1ec <ETH_Init+0x1cc>)
      e8:	429a      	cmp	r2, r3
      ea:	d9ec      	bls.n	c6 <ETH_Init+0xa6>
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
      ec:	68ba      	ldr	r2, [r7, #8]
      ee:	4b40      	ldr	r3, [pc, #256]	; (1f0 <ETH_Init+0x1d0>)
      f0:	429a      	cmp	r2, r3
      f2:	d102      	bne.n	fa <ETH_Init+0xda>
    {
      return ETH_ERROR;
      f4:	f04f 0300 	mov.w	r3, #0
      f8:	e161      	b.n	3be <ETH_Init+0x39e>
    }
    /* Reset Timeout counter */
    timeout = 0;
      fa:	f04f 0300 	mov.w	r3, #0
      fe:	60bb      	str	r3, [r7, #8]
    
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
     100:	887b      	ldrh	r3, [r7, #2]
     102:	4618      	mov	r0, r3
     104:	f04f 0100 	mov.w	r1, #0
     108:	f44f 5280 	mov.w	r2, #4096	; 0x1000
     10c:	f7ff fffe 	bl	9ac <ETH_WritePHYRegister>
			10c: R_ARM_THM_CALL	ETH_WritePHYRegister
     110:	4603      	mov	r3, r0
     112:	2b00      	cmp	r3, #0
     114:	d102      	bne.n	11c <ETH_Init+0xfc>
    {
      /* Return ERROR in case of write timeout */
      return ETH_ERROR;
     116:	f04f 0300 	mov.w	r3, #0
     11a:	e150      	b.n	3be <ETH_Init+0x39e>
    }
    
    /* Wait until the autonegotiation will be completed */
    do
    {
      timeout++;
     11c:	68bb      	ldr	r3, [r7, #8]
     11e:	f103 0301 	add.w	r3, r3, #1
     122:	60bb      	str	r3, [r7, #8]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
     124:	887b      	ldrh	r3, [r7, #2]
     126:	4618      	mov	r0, r3
     128:	f04f 0101 	mov.w	r1, #1
     12c:	f7ff fffe 	bl	8f8 <ETH_ReadPHYRegister>
			12c: R_ARM_THM_CALL	ETH_ReadPHYRegister
     130:	4603      	mov	r3, r0
     132:	f003 0320 	and.w	r3, r3, #32
     136:	2b00      	cmp	r3, #0
     138:	d103      	bne.n	142 <ETH_Init+0x122>
     13a:	68ba      	ldr	r2, [r7, #8]
     13c:	4b2b      	ldr	r3, [pc, #172]	; (1ec <ETH_Init+0x1cc>)
     13e:	429a      	cmp	r2, r3
     140:	d9ec      	bls.n	11c <ETH_Init+0xfc>
    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
     142:	68ba      	ldr	r2, [r7, #8]
     144:	4b2a      	ldr	r3, [pc, #168]	; (1f0 <ETH_Init+0x1d0>)
     146:	429a      	cmp	r2, r3
     148:	d102      	bne.n	150 <ETH_Init+0x130>
    {
      return ETH_ERROR;
     14a:	f04f 0300 	mov.w	r3, #0
     14e:	e136      	b.n	3be <ETH_Init+0x39e>
    }
    /* Reset Timeout counter */
    timeout = 0;
     150:	f04f 0300 	mov.w	r3, #0
     154:	60bb      	str	r3, [r7, #8]
    
    /* Read the result of the autonegotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
     156:	887b      	ldrh	r3, [r7, #2]
     158:	4618      	mov	r0, r3
     15a:	f04f 0110 	mov.w	r1, #16
     15e:	f7ff fffe 	bl	8f8 <ETH_ReadPHYRegister>
			15e: R_ARM_THM_CALL	ETH_ReadPHYRegister
     162:	4603      	mov	r3, r0
     164:	62bb      	str	r3, [r7, #40]	; 0x28
  
    /* Configure the MAC with the Duplex Mode fixed by the autonegotiation process */
    if((RegValue & PHY_Duplex_Status) != (uint32_t)RESET)
     166:	6abb      	ldr	r3, [r7, #40]	; 0x28
     168:	f003 0304 	and.w	r3, r3, #4
     16c:	2b00      	cmp	r3, #0
     16e:	d004      	beq.n	17a <ETH_Init+0x15a>
    {
      /* Set Ethernet duplex mode to FullDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;
     170:	687b      	ldr	r3, [r7, #4]
     172:	f44f 6200 	mov.w	r2, #2048	; 0x800
     176:	621a      	str	r2, [r3, #32]
     178:	e003      	b.n	182 <ETH_Init+0x162>
            
    }
    else
    {
      /* Set Ethernet duplex mode to HalfDuplex following the autonegotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
     17a:	687b      	ldr	r3, [r7, #4]
     17c:	f04f 0200 	mov.w	r2, #0
     180:	621a      	str	r2, [r3, #32]
    }
    /* Configure the MAC with the speed fixed by the autonegotiation process */
    if(RegValue & PHY_Speed_Status)
     182:	6abb      	ldr	r3, [r7, #40]	; 0x28
     184:	f003 0302 	and.w	r3, r3, #2
     188:	2b00      	cmp	r3, #0
     18a:	d004      	beq.n	196 <ETH_Init+0x176>
    {  
      /* Set Ethernet speed to 10M following the autonegotiation */    
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
     18c:	687b      	ldr	r3, [r7, #4]
     18e:	f04f 0200 	mov.w	r2, #0
     192:	615a      	str	r2, [r3, #20]
     194:	e032      	b.n	1fc <ETH_Init+0x1dc>
    }
    else
    {   
      /* Set Ethernet speed to 100M following the autonegotiation */ 
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
     196:	687b      	ldr	r3, [r7, #4]
     198:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     19c:	615a      	str	r2, [r3, #20]
     19e:	e02d      	b.n	1fc <ETH_Init+0x1dc>
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
     1a0:	687b      	ldr	r3, [r7, #4]
     1a2:	6a1b      	ldr	r3, [r3, #32]
     1a4:	ea4f 03d3 	mov.w	r3, r3, lsr #3
     1a8:	b29a      	uxth	r2, r3
                                                   (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
     1aa:	687b      	ldr	r3, [r7, #4]
     1ac:	695b      	ldr	r3, [r3, #20]
     1ae:	ea4f 0353 	mov.w	r3, r3, lsr #1
     1b2:	b29b      	uxth	r3, r3
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
     1b4:	ea42 0303 	orr.w	r3, r2, r3
     1b8:	b29b      	uxth	r3, r3
     1ba:	887a      	ldrh	r2, [r7, #2]
     1bc:	4610      	mov	r0, r2
     1be:	f04f 0100 	mov.w	r1, #0
     1c2:	461a      	mov	r2, r3
     1c4:	f7ff fffe 	bl	9ac <ETH_WritePHYRegister>
			1c4: R_ARM_THM_CALL	ETH_WritePHYRegister
     1c8:	4603      	mov	r3, r0
     1ca:	2b00      	cmp	r3, #0
     1cc:	d112      	bne.n	1f4 <ETH_Init+0x1d4>
                                                   (uint16_t)(ETH_InitStruct->ETH_Speed >> 1))))
    {
      /* Return ERROR in case of write timeout */
      return ETH_ERROR;
     1ce:	f04f 0300 	mov.w	r3, #0
     1d2:	e0f4      	b.n	3be <ETH_Init+0x39e>
     1d4:	03938700 	.word	0x03938700
     1d8:	40028000 	.word	0x40028000
     1dc:	01312cff 	.word	0x01312cff
     1e0:	02160ebf 	.word	0x02160ebf
     1e4:	039386ff 	.word	0x039386ff
     1e8:	000fffff 	.word	0x000fffff
     1ec:	0004fffe 	.word	0x0004fffe
     1f0:	0004ffff 	.word	0x0004ffff
    }
    /* Delay to assure PHY configuration */
    _eth_delay_(PHY_ConfigDelay);
     1f4:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
     1f8:	f002 f8d4 	bl	23a4 <ETH_Delay>
#endif // #ifdef XME_BSP_STM32_ETHERNET_PHY_DP83848J


  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
     1fc:	4b72      	ldr	r3, [pc, #456]	; (3c8 <ETH_Init+0x3a8>)
     1fe:	681b      	ldr	r3, [r3, #0]
     200:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= MACCR_CLEAR_MASK;
     202:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     204:	4b71      	ldr	r3, [pc, #452]	; (3cc <ETH_Init+0x3ac>)
     206:	ea02 0303 	and.w	r3, r2, r3
     20a:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
     20c:	687b      	ldr	r3, [r7, #4]
     20e:	685a      	ldr	r2, [r3, #4]
                  ETH_InitStruct->ETH_Jabber | 
     210:	687b      	ldr	r3, [r7, #4]
     212:	689b      	ldr	r3, [r3, #8]
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
     214:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_Jabber | 
                  ETH_InitStruct->ETH_InterFrameGap |
     216:	687b      	ldr	r3, [r7, #4]
     218:	68db      	ldr	r3, [r3, #12]
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
                  ETH_InitStruct->ETH_Jabber | 
     21a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_InterFrameGap |
                  ETH_InitStruct->ETH_CarrierSense |
     21c:	687b      	ldr	r3, [r7, #4]
     21e:	691b      	ldr	r3, [r3, #16]
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
                  ETH_InitStruct->ETH_Jabber | 
                  ETH_InitStruct->ETH_InterFrameGap |
     220:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_CarrierSense |
                  ETH_InitStruct->ETH_Speed | 
     222:	687b      	ldr	r3, [r7, #4]
     224:	695b      	ldr	r3, [r3, #20]
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
                  ETH_InitStruct->ETH_Jabber | 
                  ETH_InitStruct->ETH_InterFrameGap |
                  ETH_InitStruct->ETH_CarrierSense |
     226:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_Speed | 
                  ETH_InitStruct->ETH_ReceiveOwn |
     228:	687b      	ldr	r3, [r7, #4]
     22a:	699b      	ldr	r3, [r3, #24]
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
                  ETH_InitStruct->ETH_Jabber | 
                  ETH_InitStruct->ETH_InterFrameGap |
                  ETH_InitStruct->ETH_CarrierSense |
                  ETH_InitStruct->ETH_Speed | 
     22c:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ReceiveOwn |
                  ETH_InitStruct->ETH_LoopbackMode |
     22e:	687b      	ldr	r3, [r7, #4]
     230:	69db      	ldr	r3, [r3, #28]
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
                  ETH_InitStruct->ETH_Jabber | 
                  ETH_InitStruct->ETH_InterFrameGap |
                  ETH_InitStruct->ETH_CarrierSense |
                  ETH_InitStruct->ETH_Speed | 
                  ETH_InitStruct->ETH_ReceiveOwn |
     232:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_LoopbackMode |
                  ETH_InitStruct->ETH_Mode | 
     234:	687b      	ldr	r3, [r7, #4]
     236:	6a1b      	ldr	r3, [r3, #32]
                  ETH_InitStruct->ETH_Jabber | 
                  ETH_InitStruct->ETH_InterFrameGap |
                  ETH_InitStruct->ETH_CarrierSense |
                  ETH_InitStruct->ETH_Speed | 
                  ETH_InitStruct->ETH_ReceiveOwn |
                  ETH_InitStruct->ETH_LoopbackMode |
     238:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_Mode | 
                  ETH_InitStruct->ETH_ChecksumOffload |    
     23a:	687b      	ldr	r3, [r7, #4]
     23c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                  ETH_InitStruct->ETH_InterFrameGap |
                  ETH_InitStruct->ETH_CarrierSense |
                  ETH_InitStruct->ETH_Speed | 
                  ETH_InitStruct->ETH_ReceiveOwn |
                  ETH_InitStruct->ETH_LoopbackMode |
                  ETH_InitStruct->ETH_Mode | 
     23e:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ChecksumOffload |    
                  ETH_InitStruct->ETH_RetryTransmission | 
     240:	687b      	ldr	r3, [r7, #4]
     242:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                  ETH_InitStruct->ETH_CarrierSense |
                  ETH_InitStruct->ETH_Speed | 
                  ETH_InitStruct->ETH_ReceiveOwn |
                  ETH_InitStruct->ETH_LoopbackMode |
                  ETH_InitStruct->ETH_Mode | 
                  ETH_InitStruct->ETH_ChecksumOffload |    
     244:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_RetryTransmission | 
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
     246:	687b      	ldr	r3, [r7, #4]
     248:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                  ETH_InitStruct->ETH_Speed | 
                  ETH_InitStruct->ETH_ReceiveOwn |
                  ETH_InitStruct->ETH_LoopbackMode |
                  ETH_InitStruct->ETH_Mode | 
                  ETH_InitStruct->ETH_ChecksumOffload |    
                  ETH_InitStruct->ETH_RetryTransmission | 
     24a:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
                  ETH_InitStruct->ETH_BackOffLimit | 
     24c:	687b      	ldr	r3, [r7, #4]
     24e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                  ETH_InitStruct->ETH_ReceiveOwn |
                  ETH_InitStruct->ETH_LoopbackMode |
                  ETH_InitStruct->ETH_Mode | 
                  ETH_InitStruct->ETH_ChecksumOffload |    
                  ETH_InitStruct->ETH_RetryTransmission | 
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
     250:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_BackOffLimit | 
                  ETH_InitStruct->ETH_DeferralCheck);
     252:	687b      	ldr	r3, [r7, #4]
     254:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  /* Set the IPC bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
     256:	ea42 0303 	orr.w	r3, r2, r3
     25a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     25c:	ea42 0303 	orr.w	r3, r2, r3
     260:	62fb      	str	r3, [r7, #44]	; 0x2c
                  ETH_InitStruct->ETH_RetryTransmission | 
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
                  ETH_InitStruct->ETH_BackOffLimit | 
                  ETH_InitStruct->ETH_DeferralCheck);
  /* Write to ETHERNET MACCR */
  ETH->MACCR = (uint32_t)tmpreg;
     262:	4b59      	ldr	r3, [pc, #356]	; (3c8 <ETH_Init+0x3a8>)
     264:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     266:	601a      	str	r2, [r3, #0]
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
     268:	4b57      	ldr	r3, [pc, #348]	; (3c8 <ETH_Init+0x3a8>)
     26a:	687a      	ldr	r2, [r7, #4]
     26c:	6b91      	ldr	r1, [r2, #56]	; 0x38
                          ETH_InitStruct->ETH_SourceAddrFilter |
     26e:	687a      	ldr	r2, [r7, #4]
     270:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
     272:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
     274:	687a      	ldr	r2, [r7, #4]
     276:	6c12      	ldr	r2, [r2, #64]	; 0x40
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
                          ETH_InitStruct->ETH_SourceAddrFilter |
     278:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_PassControlFrames |
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
     27a:	687a      	ldr	r2, [r7, #4]
     27c:	6c52      	ldr	r2, [r2, #68]	; 0x44
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
     27e:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
                          ETH_InitStruct->ETH_DestinationAddrFilter |
     280:	687a      	ldr	r2, [r7, #4]
     282:	6c92      	ldr	r2, [r2, #72]	; 0x48
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
     284:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_DestinationAddrFilter |
                          ETH_InitStruct->ETH_PromiscuousMode |
     286:	687a      	ldr	r2, [r7, #4]
     288:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
                          ETH_InitStruct->ETH_DestinationAddrFilter |
     28a:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
     28c:	687a      	ldr	r2, [r7, #4]
     28e:	6d12      	ldr	r2, [r2, #80]	; 0x50
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
                          ETH_InitStruct->ETH_DestinationAddrFilter |
                          ETH_InitStruct->ETH_PromiscuousMode |
     290:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_MulticastFramesFilter |
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
     292:	687a      	ldr	r2, [r7, #4]
     294:	6d52      	ldr	r2, [r2, #84]	; 0x54
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
     296:	ea41 0202 	orr.w	r2, r1, r2
     29a:	605a      	str	r2, [r3, #4]
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
     29c:	4b4a      	ldr	r3, [pc, #296]	; (3c8 <ETH_Init+0x3a8>)
     29e:	687a      	ldr	r2, [r7, #4]
     2a0:	6d92      	ldr	r2, [r2, #88]	; 0x58
     2a2:	609a      	str	r2, [r3, #8]
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
     2a4:	4b48      	ldr	r3, [pc, #288]	; (3c8 <ETH_Init+0x3a8>)
     2a6:	687a      	ldr	r2, [r7, #4]
     2a8:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
     2aa:	60da      	str	r2, [r3, #12]
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
     2ac:	4b46      	ldr	r3, [pc, #280]	; (3c8 <ETH_Init+0x3a8>)
     2ae:	699b      	ldr	r3, [r3, #24]
     2b0:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear xx bits */
  tmpreg &= MACFCR_CLEAR_MASK;
     2b2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     2b4:	f64f 7341 	movw	r3, #65345	; 0xff41
     2b8:	ea02 0303 	and.w	r3, r2, r3
     2bc:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
     2be:	687b      	ldr	r3, [r7, #4]
     2c0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
     2c2:	ea4f 4203 	mov.w	r2, r3, lsl #16
                   ETH_InitStruct->ETH_ZeroQuantaPause |
     2c6:	687b      	ldr	r3, [r7, #4]
     2c8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
     2ca:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_ZeroQuantaPause |
                   ETH_InitStruct->ETH_PauseLowThreshold |
     2cc:	687b      	ldr	r3, [r7, #4]
     2ce:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
                   ETH_InitStruct->ETH_ZeroQuantaPause |
     2d0:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
     2d2:	687b      	ldr	r3, [r7, #4]
     2d4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
                   ETH_InitStruct->ETH_ZeroQuantaPause |
                   ETH_InitStruct->ETH_PauseLowThreshold |
     2d6:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
                   ETH_InitStruct->ETH_ReceiveFlowControl |
     2d8:	687b      	ldr	r3, [r7, #4]
     2da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
                   ETH_InitStruct->ETH_ZeroQuantaPause |
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
     2dc:	431a      	orrs	r2, r3
                   ETH_InitStruct->ETH_ReceiveFlowControl |
                   ETH_InitStruct->ETH_TransmitFlowControl); 
     2de:	687b      	ldr	r3, [r7, #4]
     2e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
     2e2:	ea42 0303 	orr.w	r3, r2, r3
     2e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     2e8:	ea42 0303 	orr.w	r3, r2, r3
     2ec:	62fb      	str	r3, [r7, #44]	; 0x2c
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
                   ETH_InitStruct->ETH_ReceiveFlowControl |
                   ETH_InitStruct->ETH_TransmitFlowControl); 
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
     2ee:	4b36      	ldr	r3, [pc, #216]	; (3c8 <ETH_Init+0x3a8>)
     2f0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     2f2:	619a      	str	r2, [r3, #24]
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
     2f4:	4b34      	ldr	r3, [pc, #208]	; (3c8 <ETH_Init+0x3a8>)
     2f6:	687a      	ldr	r2, [r7, #4]
     2f8:	6f91      	ldr	r1, [r2, #120]	; 0x78
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
     2fa:	687a      	ldr	r2, [r7, #4]
     2fc:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
     2fe:	ea41 0202 	orr.w	r2, r1, r2
     302:	61da      	str	r2, [r3, #28]
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
     304:	4b30      	ldr	r3, [pc, #192]	; (3c8 <ETH_Init+0x3a8>)
     306:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     30a:	f103 0318 	add.w	r3, r3, #24
     30e:	681b      	ldr	r3, [r3, #0]
     310:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
     312:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     314:	4b2e      	ldr	r3, [pc, #184]	; (3d0 <ETH_Init+0x3b0>)
     316:	ea02 0303 	and.w	r3, r2, r3
     31a:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
     31c:	687b      	ldr	r3, [r7, #4]
     31e:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
                  ETH_InitStruct->ETH_ReceiveStoreForward |
     322:	687b      	ldr	r3, [r7, #4]
     324:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
     328:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ReceiveStoreForward |
                  ETH_InitStruct->ETH_FlushReceivedFrame |
     32a:	687b      	ldr	r3, [r7, #4]
     32c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
                  ETH_InitStruct->ETH_ReceiveStoreForward |
     330:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_FlushReceivedFrame |
                  ETH_InitStruct->ETH_TransmitStoreForward | 
     332:	687b      	ldr	r3, [r7, #4]
     334:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
                  ETH_InitStruct->ETH_ReceiveStoreForward |
                  ETH_InitStruct->ETH_FlushReceivedFrame |
     338:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_TransmitStoreForward | 
                  ETH_InitStruct->ETH_TransmitThresholdControl |
     33a:	687b      	ldr	r3, [r7, #4]
     33c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
                  ETH_InitStruct->ETH_ReceiveStoreForward |
                  ETH_InitStruct->ETH_FlushReceivedFrame |
                  ETH_InitStruct->ETH_TransmitStoreForward | 
     340:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_TransmitThresholdControl |
                  ETH_InitStruct->ETH_ForwardErrorFrames |
     342:	687b      	ldr	r3, [r7, #4]
     344:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
                  ETH_InitStruct->ETH_ReceiveStoreForward |
                  ETH_InitStruct->ETH_FlushReceivedFrame |
                  ETH_InitStruct->ETH_TransmitStoreForward | 
                  ETH_InitStruct->ETH_TransmitThresholdControl |
     348:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ForwardErrorFrames |
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
     34a:	687b      	ldr	r3, [r7, #4]
     34c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
                  ETH_InitStruct->ETH_ReceiveStoreForward |
                  ETH_InitStruct->ETH_FlushReceivedFrame |
                  ETH_InitStruct->ETH_TransmitStoreForward | 
                  ETH_InitStruct->ETH_TransmitThresholdControl |
                  ETH_InitStruct->ETH_ForwardErrorFrames |
     350:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
     352:	687b      	ldr	r3, [r7, #4]
     354:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
                  ETH_InitStruct->ETH_ReceiveStoreForward |
                  ETH_InitStruct->ETH_FlushReceivedFrame |
                  ETH_InitStruct->ETH_TransmitStoreForward | 
                  ETH_InitStruct->ETH_TransmitThresholdControl |
                  ETH_InitStruct->ETH_ForwardErrorFrames |
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
     358:	431a      	orrs	r2, r3
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
                  ETH_InitStruct->ETH_SecondFrameOperate); 
     35a:	687b      	ldr	r3, [r7, #4]
     35c:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
     360:	ea42 0303 	orr.w	r3, r2, r3
     364:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     366:	ea42 0303 	orr.w	r3, r2, r3
     36a:	62fb      	str	r3, [r7, #44]	; 0x2c
                  ETH_InitStruct->ETH_ForwardErrorFrames |
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
                  ETH_InitStruct->ETH_SecondFrameOperate); 
  /* Write to ETHERNET DMAOMR */
  ETH->DMAOMR = (uint32_t)tmpreg;
     36c:	4b16      	ldr	r3, [pc, #88]	; (3c8 <ETH_Init+0x3a8>)
     36e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     372:	f103 0318 	add.w	r3, r3, #24
     376:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     378:	601a      	str	r2, [r3, #0]
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
     37a:	4b13      	ldr	r3, [pc, #76]	; (3c8 <ETH_Init+0x3a8>)
     37c:	687a      	ldr	r2, [r7, #4]
     37e:	f8d2 10a4 	ldr.w	r1, [r2, #164]	; 0xa4
                          ETH_InitStruct->ETH_FixedBurst |
     382:	687a      	ldr	r2, [r7, #4]
     384:	f8d2 20a8 	ldr.w	r2, [r2, #168]	; 0xa8
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
     388:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_FixedBurst |
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
     38a:	687a      	ldr	r2, [r7, #4]
     38c:	f8d2 20ac 	ldr.w	r2, [r2, #172]	; 0xac
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
                          ETH_InitStruct->ETH_FixedBurst |
     390:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                          ETH_InitStruct->ETH_TxDMABurstLength | 
     392:	687a      	ldr	r2, [r7, #4]
     394:	f8d2 20b0 	ldr.w	r2, [r2, #176]	; 0xb0
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
                          ETH_InitStruct->ETH_FixedBurst |
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
     398:	4311      	orrs	r1, r2
                          ETH_InitStruct->ETH_TxDMABurstLength | 
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
     39a:	687a      	ldr	r2, [r7, #4]
     39c:	f8d2 20b4 	ldr.w	r2, [r2, #180]	; 0xb4
     3a0:	ea4f 0282 	mov.w	r2, r2, lsl #2
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
                          ETH_InitStruct->ETH_FixedBurst |
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                          ETH_InitStruct->ETH_TxDMABurstLength | 
     3a4:	4311      	orrs	r1, r2
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
                          ETH_InitStruct->ETH_DMAArbitration |
     3a6:	687a      	ldr	r2, [r7, #4]
     3a8:	f8d2 20b8 	ldr.w	r2, [r2, #184]	; 0xb8
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
                          ETH_InitStruct->ETH_FixedBurst |
                          ETH_InitStruct->ETH_RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                          ETH_InitStruct->ETH_TxDMABurstLength | 
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
     3ac:	ea41 0202 	orr.w	r2, r1, r2
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
     3b0:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
     3b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     3b8:	601a      	str	r2, [r3, #0]
                          ETH_InitStruct->ETH_TxDMABurstLength | 
                         (ETH_InitStruct->ETH_DescriptorSkipLength << 2) |
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */  
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
     3ba:	f04f 0301 	mov.w	r3, #1
}
     3be:	4618      	mov	r0, r3
     3c0:	f107 0730 	add.w	r7, r7, #48	; 0x30
     3c4:	46bd      	mov	sp, r7
     3c6:	bd80      	pop	{r7, pc}
     3c8:	40028000 	.word	0x40028000
     3cc:	ff20810f 	.word	0xff20810f
     3d0:	f8de3f23 	.word	0xf8de3f23

000003d4 <ETH_StructInit>:
  * @brief  Fills each ETH_InitStruct member with its default value.
  * @param  ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized.
  * @retval None
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
     3d4:	b480      	push	{r7}
     3d6:	b083      	sub	sp, #12
     3d8:	af00      	add	r7, sp, #0
     3da:	6078      	str	r0, [r7, #4]
  /* ETH_InitStruct members default value */
  /*------------------------   MAC   -----------------------------------*/     
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;           
     3dc:	687b      	ldr	r3, [r7, #4]
     3de:	f04f 0200 	mov.w	r2, #0
     3e2:	601a      	str	r2, [r3, #0]
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;                   
     3e4:	687b      	ldr	r3, [r7, #4]
     3e6:	f04f 0200 	mov.w	r2, #0
     3ea:	605a      	str	r2, [r3, #4]
  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                     
     3ec:	687b      	ldr	r3, [r7, #4]
     3ee:	f04f 0200 	mov.w	r2, #0
     3f2:	609a      	str	r2, [r3, #8]
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                          
     3f4:	687b      	ldr	r3, [r7, #4]
     3f6:	f04f 0200 	mov.w	r2, #0
     3fa:	60da      	str	r2, [r3, #12]
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                              
     3fc:	687b      	ldr	r3, [r7, #4]
     3fe:	f04f 0200 	mov.w	r2, #0
     402:	611a      	str	r2, [r3, #16]
  ETH_InitStruct->ETH_Speed = ETH_Speed_10M;                       
     404:	687b      	ldr	r3, [r7, #4]
     406:	f04f 0200 	mov.w	r2, #0
     40a:	615a      	str	r2, [r3, #20]
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;               
     40c:	687b      	ldr	r3, [r7, #4]
     40e:	f04f 0200 	mov.w	r2, #0
     412:	619a      	str	r2, [r3, #24]
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
     414:	687b      	ldr	r3, [r7, #4]
     416:	f04f 0200 	mov.w	r2, #0
     41a:	61da      	str	r2, [r3, #28]
  ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;                       
     41c:	687b      	ldr	r3, [r7, #4]
     41e:	f04f 0200 	mov.w	r2, #0
     422:	621a      	str	r2, [r3, #32]
  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                            
     424:	687b      	ldr	r3, [r7, #4]
     426:	f04f 0200 	mov.w	r2, #0
     42a:	625a      	str	r2, [r3, #36]	; 0x24
  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                  
     42c:	687b      	ldr	r3, [r7, #4]
     42e:	f04f 0200 	mov.w	r2, #0
     432:	629a      	str	r2, [r3, #40]	; 0x28
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                         
     434:	687b      	ldr	r3, [r7, #4]
     436:	f04f 0200 	mov.w	r2, #0
     43a:	62da      	str	r2, [r3, #44]	; 0x2c
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;                                                                
     43c:	687b      	ldr	r3, [r7, #4]
     43e:	f04f 0200 	mov.w	r2, #0
     442:	631a      	str	r2, [r3, #48]	; 0x30
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
     444:	687b      	ldr	r3, [r7, #4]
     446:	f04f 0200 	mov.w	r2, #0
     44a:	635a      	str	r2, [r3, #52]	; 0x34
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;                                                               
     44c:	687b      	ldr	r3, [r7, #4]
     44e:	f04f 0200 	mov.w	r2, #0
     452:	639a      	str	r2, [r3, #56]	; 0x38
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;                                
     454:	687b      	ldr	r3, [r7, #4]
     456:	f04f 0200 	mov.w	r2, #0
     45a:	63da      	str	r2, [r3, #60]	; 0x3c
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;          
     45c:	687b      	ldr	r3, [r7, #4]
     45e:	f04f 0240 	mov.w	r2, #64	; 0x40
     462:	641a      	str	r2, [r3, #64]	; 0x40
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
     464:	687b      	ldr	r3, [r7, #4]
     466:	f04f 0220 	mov.w	r2, #32
     46a:	645a      	str	r2, [r3, #68]	; 0x44
  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;      
     46c:	687b      	ldr	r3, [r7, #4]
     46e:	f04f 0200 	mov.w	r2, #0
     472:	649a      	str	r2, [r3, #72]	; 0x48
  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
     474:	687b      	ldr	r3, [r7, #4]
     476:	f04f 0200 	mov.w	r2, #0
     47a:	64da      	str	r2, [r3, #76]	; 0x4c
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;      
     47c:	687b      	ldr	r3, [r7, #4]
     47e:	f04f 0200 	mov.w	r2, #0
     482:	651a      	str	r2, [r3, #80]	; 0x50
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
     484:	687b      	ldr	r3, [r7, #4]
     486:	f04f 0200 	mov.w	r2, #0
     48a:	655a      	str	r2, [r3, #84]	; 0x54
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
     48c:	687b      	ldr	r3, [r7, #4]
     48e:	f04f 0200 	mov.w	r2, #0
     492:	659a      	str	r2, [r3, #88]	; 0x58
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
     494:	687b      	ldr	r3, [r7, #4]
     496:	f04f 0200 	mov.w	r2, #0
     49a:	65da      	str	r2, [r3, #92]	; 0x5c
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
     49c:	687b      	ldr	r3, [r7, #4]
     49e:	f04f 0200 	mov.w	r2, #0
     4a2:	661a      	str	r2, [r3, #96]	; 0x60
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
     4a4:	687b      	ldr	r3, [r7, #4]
     4a6:	f04f 0280 	mov.w	r2, #128	; 0x80
     4aa:	665a      	str	r2, [r3, #100]	; 0x64
  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
     4ac:	687b      	ldr	r3, [r7, #4]
     4ae:	f04f 0200 	mov.w	r2, #0
     4b2:	669a      	str	r2, [r3, #104]	; 0x68
  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
     4b4:	687b      	ldr	r3, [r7, #4]
     4b6:	f04f 0200 	mov.w	r2, #0
     4ba:	66da      	str	r2, [r3, #108]	; 0x6c
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
     4bc:	687b      	ldr	r3, [r7, #4]
     4be:	f04f 0200 	mov.w	r2, #0
     4c2:	671a      	str	r2, [r3, #112]	; 0x70
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;      
     4c4:	687b      	ldr	r3, [r7, #4]
     4c6:	f04f 0200 	mov.w	r2, #0
     4ca:	675a      	str	r2, [r3, #116]	; 0x74
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
     4cc:	687b      	ldr	r3, [r7, #4]
     4ce:	f04f 0200 	mov.w	r2, #0
     4d2:	679a      	str	r2, [r3, #120]	; 0x78
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
     4d4:	687b      	ldr	r3, [r7, #4]
     4d6:	f04f 0200 	mov.w	r2, #0
     4da:	67da      	str	r2, [r3, #124]	; 0x7c
  /*------------------------   DMA   -----------------------------------*/  
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
     4dc:	687b      	ldr	r3, [r7, #4]
     4de:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
     4e2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
     4e6:	687b      	ldr	r3, [r7, #4]
     4e8:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
     4ec:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;       
     4f0:	687b      	ldr	r3, [r7, #4]
     4f2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
     4f6:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
     4fa:	687b      	ldr	r3, [r7, #4]
     4fc:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
     500:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
     504:	687b      	ldr	r3, [r7, #4]
     506:	f04f 0200 	mov.w	r2, #0
     50a:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
     50e:	687b      	ldr	r3, [r7, #4]
     510:	f04f 0200 	mov.w	r2, #0
     514:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
     518:	687b      	ldr	r3, [r7, #4]
     51a:	f04f 0200 	mov.w	r2, #0
     51e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;   
     522:	687b      	ldr	r3, [r7, #4]
     524:	f04f 0200 	mov.w	r2, #0
     528:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
     52c:	687b      	ldr	r3, [r7, #4]
     52e:	f04f 0200 	mov.w	r2, #0
     532:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
     536:	687b      	ldr	r3, [r7, #4]
     538:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
     53c:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Disable;
     540:	687b      	ldr	r3, [r7, #4]
     542:	f04f 0200 	mov.w	r2, #0
     546:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat;
     54a:	687b      	ldr	r3, [r7, #4]
     54c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
     550:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat;
     554:	687b      	ldr	r3, [r7, #4]
     556:	f44f 7280 	mov.w	r2, #256	; 0x100
     55a:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0;
     55e:	687b      	ldr	r3, [r7, #4]
     560:	f04f 0200 	mov.w	r2, #0
     564:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
     568:	687b      	ldr	r3, [r7, #4]
     56a:	f04f 0200 	mov.w	r2, #0
     56e:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
}
     572:	f107 070c 	add.w	r7, r7, #12
     576:	46bd      	mov	sp, r7
     578:	bc80      	pop	{r7}
     57a:	4770      	bx	lr

0000057c <ETH_Start>:
  * @brief  Enables ENET MAC and DMA reception/transmission 
  * @param  None
  * @retval None
  */
void ETH_Start(void)
{
     57c:	b580      	push	{r7, lr}
     57e:	af00      	add	r7, sp, #0
  /* Enable transmit state machine of the MAC for transmission on the MII */  
  ETH_MACTransmissionCmd(ENABLE);
     580:	f04f 0001 	mov.w	r0, #1
     584:	f7ff fffe 	bl	ad0 <ETH_MACTransmissionCmd>
			584: R_ARM_THM_CALL	ETH_MACTransmissionCmd
  /* Flush Transmit FIFO */
  ETH_FlushTransmitFIFO();
     588:	f7ff fffe 	bl	1618 <ETH_FlushTransmitFIFO>
			588: R_ARM_THM_CALL	ETH_FlushTransmitFIFO
  /* Enable receive state machine of the MAC for reception from the MII */  
  ETH_MACReceptionCmd(ENABLE);
     58c:	f04f 0001 	mov.w	r0, #1
     590:	f7ff fffe 	bl	b08 <ETH_MACReceptionCmd>
			590: R_ARM_THM_CALL	ETH_MACReceptionCmd
 
  /* Start DMA transmission */
  ETH_DMATransmissionCmd(ENABLE); 
     594:	f04f 0001 	mov.w	r0, #1
     598:	f7ff fffe 	bl	1684 <ETH_DMATransmissionCmd>
			598: R_ARM_THM_CALL	ETH_DMATransmissionCmd
  /* Start DMA reception */
  ETH_DMAReceptionCmd(ENABLE);   
     59c:	f04f 0001 	mov.w	r0, #1
     5a0:	f7ff fffe 	bl	16dc <ETH_DMAReceptionCmd>
			5a0: R_ARM_THM_CALL	ETH_DMAReceptionCmd
}
     5a4:	bd80      	pop	{r7, pc}
     5a6:	bf00      	nop

000005a8 <ETH_HandleTxPkt>:
  * @param  FrameLength: Tx Packet size.
  * @retval ETH_ERROR: in case of Tx desc owned by DMA
  *         ETH_SUCCESS: for correct transmission
  */
uint32_t ETH_HandleTxPkt(uint8_t *ppkt, uint16_t FrameLength)
{ 
     5a8:	b480      	push	{r7}
     5aa:	b085      	sub	sp, #20
     5ac:	af00      	add	r7, sp, #0
     5ae:	6078      	str	r0, [r7, #4]
     5b0:	460b      	mov	r3, r1
     5b2:	807b      	strh	r3, [r7, #2]
  uint32_t offset = 0;
     5b4:	f04f 0300 	mov.w	r3, #0
     5b8:	60fb      	str	r3, [r7, #12]
    
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
     5ba:	4b43      	ldr	r3, [pc, #268]	; (6c8 <ETH_HandleTxPkt+0x120>)
     5bc:	681b      	ldr	r3, [r3, #0]
     5be:	681b      	ldr	r3, [r3, #0]
     5c0:	2b00      	cmp	r3, #0
     5c2:	da02      	bge.n	5ca <ETH_HandleTxPkt+0x22>
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
     5c4:	f04f 0300 	mov.w	r3, #0
     5c8:	e078      	b.n	6bc <ETH_HandleTxPkt+0x114>
  }
  
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)       
     5ca:	f04f 0300 	mov.w	r3, #0
     5ce:	60fb      	str	r3, [r7, #12]
     5d0:	e00d      	b.n	5ee <ETH_HandleTxPkt+0x46>
  {
    (*(__IO uint8_t *)((DMATxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
     5d2:	4b3d      	ldr	r3, [pc, #244]	; (6c8 <ETH_HandleTxPkt+0x120>)
     5d4:	681b      	ldr	r3, [r3, #0]
     5d6:	689a      	ldr	r2, [r3, #8]
     5d8:	68fb      	ldr	r3, [r7, #12]
     5da:	18d3      	adds	r3, r2, r3
     5dc:	6879      	ldr	r1, [r7, #4]
     5de:	68fa      	ldr	r2, [r7, #12]
     5e0:	188a      	adds	r2, r1, r2
     5e2:	7812      	ldrb	r2, [r2, #0]
     5e4:	701a      	strb	r2, [r3, #0]
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  }
  
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)       
     5e6:	68fb      	ldr	r3, [r7, #12]
     5e8:	f103 0301 	add.w	r3, r3, #1
     5ec:	60fb      	str	r3, [r7, #12]
     5ee:	887a      	ldrh	r2, [r7, #2]
     5f0:	68fb      	ldr	r3, [r7, #12]
     5f2:	429a      	cmp	r2, r3
     5f4:	d8ed      	bhi.n	5d2 <ETH_HandleTxPkt+0x2a>
  {
    (*(__IO uint8_t *)((DMATxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
        
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
     5f6:	4b34      	ldr	r3, [pc, #208]	; (6c8 <ETH_HandleTxPkt+0x120>)
     5f8:	681a      	ldr	r2, [r3, #0]
     5fa:	887b      	ldrh	r3, [r7, #2]
     5fc:	ea4f 43c3 	mov.w	r3, r3, lsl #19
     600:	ea4f 43d3 	mov.w	r3, r3, lsr #19
     604:	6053      	str	r3, [r2, #4]
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
     606:	4b30      	ldr	r3, [pc, #192]	; (6c8 <ETH_HandleTxPkt+0x120>)
     608:	681b      	ldr	r3, [r3, #0]
     60a:	4a2f      	ldr	r2, [pc, #188]	; (6c8 <ETH_HandleTxPkt+0x120>)
     60c:	6812      	ldr	r2, [r2, #0]
     60e:	6812      	ldr	r2, [r2, #0]
     610:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
     614:	601a      	str	r2, [r3, #0]
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
     616:	4b2c      	ldr	r3, [pc, #176]	; (6c8 <ETH_HandleTxPkt+0x120>)
     618:	681b      	ldr	r3, [r3, #0]
     61a:	4a2b      	ldr	r2, [pc, #172]	; (6c8 <ETH_HandleTxPkt+0x120>)
     61c:	6812      	ldr	r2, [r2, #0]
     61e:	6812      	ldr	r2, [r2, #0]
     620:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
     624:	601a      	str	r2, [r3, #0]
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
     626:	4b29      	ldr	r3, [pc, #164]	; (6cc <ETH_HandleTxPkt+0x124>)
     628:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     62c:	f103 0314 	add.w	r3, r3, #20
     630:	681b      	ldr	r3, [r3, #0]
     632:	f003 0304 	and.w	r3, r3, #4
     636:	2b00      	cmp	r3, #0
     638:	d00f      	beq.n	65a <ETH_HandleTxPkt+0xb2>
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
     63a:	4b24      	ldr	r3, [pc, #144]	; (6cc <ETH_HandleTxPkt+0x124>)
     63c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     640:	f103 0314 	add.w	r3, r3, #20
     644:	f04f 0204 	mov.w	r2, #4
     648:	601a      	str	r2, [r3, #0]
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
     64a:	4b20      	ldr	r3, [pc, #128]	; (6cc <ETH_HandleTxPkt+0x124>)
     64c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     650:	f103 0304 	add.w	r3, r3, #4
     654:	f04f 0200 	mov.w	r2, #0
     658:	601a      	str	r2, [r3, #0]
  }
  
  /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */  
  /* Chained Mode */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_TCH) != (uint32_t)RESET)
     65a:	4b1b      	ldr	r3, [pc, #108]	; (6c8 <ETH_HandleTxPkt+0x120>)
     65c:	681b      	ldr	r3, [r3, #0]
     65e:	681b      	ldr	r3, [r3, #0]
     660:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
     664:	2b00      	cmp	r3, #0
     666:	d006      	beq.n	676 <ETH_HandleTxPkt+0xce>
  {     
    /* Selects the next DMA Tx descriptor list for next buffer to send */ 
    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet->Buffer2NextDescAddr);    
     668:	4b17      	ldr	r3, [pc, #92]	; (6c8 <ETH_HandleTxPkt+0x120>)
     66a:	681b      	ldr	r3, [r3, #0]
     66c:	68db      	ldr	r3, [r3, #12]
     66e:	461a      	mov	r2, r3
     670:	4b15      	ldr	r3, [pc, #84]	; (6c8 <ETH_HandleTxPkt+0x120>)
     672:	601a      	str	r2, [r3, #0]
     674:	e020      	b.n	6b8 <ETH_HandleTxPkt+0x110>
  }
  else /* Ring Mode */
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
     676:	4b14      	ldr	r3, [pc, #80]	; (6c8 <ETH_HandleTxPkt+0x120>)
     678:	681b      	ldr	r3, [r3, #0]
     67a:	681b      	ldr	r3, [r3, #0]
     67c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
     680:	2b00      	cmp	r3, #0
     682:	d009      	beq.n	698 <ETH_HandleTxPkt+0xf0>
    {
      /* Selects the first DMA Tx descriptor for next buffer to send: last Tx descriptor was used */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);      
     684:	4b11      	ldr	r3, [pc, #68]	; (6cc <ETH_HandleTxPkt+0x124>)
     686:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     68a:	f103 0310 	add.w	r3, r3, #16
     68e:	681b      	ldr	r3, [r3, #0]
     690:	461a      	mov	r2, r3
     692:	4b0d      	ldr	r3, [pc, #52]	; (6c8 <ETH_HandleTxPkt+0x120>)
     694:	601a      	str	r2, [r3, #0]
     696:	e00f      	b.n	6b8 <ETH_HandleTxPkt+0x110>
    }
    else
    {  
      /* Selects the next DMA Tx descriptor list for next buffer to send */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
     698:	4b0c      	ldr	r3, [pc, #48]	; (6cc <ETH_HandleTxPkt+0x124>)
     69a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     69e:	681b      	ldr	r3, [r3, #0]
     6a0:	f003 037c 	and.w	r3, r3, #124	; 0x7c
     6a4:	ea4f 0293 	mov.w	r2, r3, lsr #2
     6a8:	4b07      	ldr	r3, [pc, #28]	; (6c8 <ETH_HandleTxPkt+0x120>)
     6aa:	681b      	ldr	r3, [r3, #0]
     6ac:	18d3      	adds	r3, r2, r3
     6ae:	f103 0310 	add.w	r3, r3, #16
     6b2:	461a      	mov	r2, r3
     6b4:	4b04      	ldr	r3, [pc, #16]	; (6c8 <ETH_HandleTxPkt+0x120>)
     6b6:	601a      	str	r2, [r3, #0]
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;   
     6b8:	f04f 0301 	mov.w	r3, #1
}
     6bc:	4618      	mov	r0, r3
     6be:	f107 0714 	add.w	r7, r7, #20
     6c2:	46bd      	mov	sp, r7
     6c4:	bc80      	pop	{r7}
     6c6:	4770      	bx	lr
     6c8:	00000000 	.word	0x00000000
			6c8: R_ARM_ABS32	DMATxDescToSet
     6cc:	40028000 	.word	0x40028000

000006d0 <ETH_HandleRxPkt>:
  * @param  ppkt: pointer to the application packet receive buffer.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandleRxPkt(uint8_t *ppkt)
{ 
     6d0:	b480      	push	{r7}
     6d2:	b085      	sub	sp, #20
     6d4:	af00      	add	r7, sp, #0
     6d6:	6078      	str	r0, [r7, #4]
  uint32_t offset = 0, framelength = 0;
     6d8:	f04f 0300 	mov.w	r3, #0
     6dc:	60fb      	str	r3, [r7, #12]
     6de:	f04f 0300 	mov.w	r3, #0
     6e2:	60bb      	str	r3, [r7, #8]
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
     6e4:	4b4b      	ldr	r3, [pc, #300]	; (814 <ETH_HandleRxPkt+0x144>)
     6e6:	681b      	ldr	r3, [r3, #0]
     6e8:	681b      	ldr	r3, [r3, #0]
     6ea:	2b00      	cmp	r3, #0
     6ec:	da02      	bge.n	6f4 <ETH_HandleRxPkt+0x24>
  {
    /* Return error: OWN bit set */
    return ETH_ERROR; 
     6ee:	f04f 0300 	mov.w	r3, #0
     6f2:	e089      	b.n	808 <ETH_HandleRxPkt+0x138>
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
     6f4:	4b47      	ldr	r3, [pc, #284]	; (814 <ETH_HandleRxPkt+0x144>)
     6f6:	681b      	ldr	r3, [r3, #0]
     6f8:	681b      	ldr	r3, [r3, #0]
     6fa:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
     6fe:	2b00      	cmp	r3, #0
     700:	d130      	bne.n	764 <ETH_HandleRxPkt+0x94>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&  
     702:	4b44      	ldr	r3, [pc, #272]	; (814 <ETH_HandleRxPkt+0x144>)
     704:	681b      	ldr	r3, [r3, #0]
     706:	681b      	ldr	r3, [r3, #0]
     708:	f403 7380 	and.w	r3, r3, #256	; 0x100
  {
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
     70c:	2b00      	cmp	r3, #0
     70e:	d029      	beq.n	764 <ETH_HandleRxPkt+0x94>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&  
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
     710:	4b40      	ldr	r3, [pc, #256]	; (814 <ETH_HandleRxPkt+0x144>)
     712:	681b      	ldr	r3, [r3, #0]
     714:	681b      	ldr	r3, [r3, #0]
     716:	f403 7300 	and.w	r3, r3, #512	; 0x200
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&  
     71a:	2b00      	cmp	r3, #0
     71c:	d022      	beq.n	764 <ETH_HandleRxPkt+0x94>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
     71e:	4b3d      	ldr	r3, [pc, #244]	; (814 <ETH_HandleRxPkt+0x144>)
     720:	681b      	ldr	r3, [r3, #0]
     722:	681a      	ldr	r2, [r3, #0]
     724:	4b3c      	ldr	r3, [pc, #240]	; (818 <ETH_HandleRxPkt+0x148>)
     726:	ea02 0303 	and.w	r3, r2, r3
     72a:	ea4f 4313 	mov.w	r3, r3, lsr #16
     72e:	f1a3 0304 	sub.w	r3, r3, #4
     732:	60bb      	str	r3, [r7, #8]
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */
    for(offset=0; offset<framelength; offset++)       
     734:	f04f 0300 	mov.w	r3, #0
     738:	60fb      	str	r3, [r7, #12]
     73a:	e00e      	b.n	75a <ETH_HandleRxPkt+0x8a>
    {
      (*(ppkt + offset)) = (*(__IO uint8_t *)((DMARxDescToGet->Buffer1Addr) + offset));
     73c:	687a      	ldr	r2, [r7, #4]
     73e:	68fb      	ldr	r3, [r7, #12]
     740:	18d3      	adds	r3, r2, r3
     742:	4a34      	ldr	r2, [pc, #208]	; (814 <ETH_HandleRxPkt+0x144>)
     744:	6812      	ldr	r2, [r2, #0]
     746:	6891      	ldr	r1, [r2, #8]
     748:	68fa      	ldr	r2, [r7, #12]
     74a:	188a      	adds	r2, r1, r2
     74c:	7812      	ldrb	r2, [r2, #0]
     74e:	b2d2      	uxtb	r2, r2
     750:	701a      	strb	r2, [r3, #0]
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */
    for(offset=0; offset<framelength; offset++)       
     752:	68fb      	ldr	r3, [r7, #12]
     754:	f103 0301 	add.w	r3, r3, #1
     758:	60fb      	str	r3, [r7, #12]
     75a:	68fa      	ldr	r2, [r7, #12]
     75c:	68bb      	ldr	r3, [r7, #8]
     75e:	429a      	cmp	r2, r3
     760:	d3ec      	bcc.n	73c <ETH_HandleRxPkt+0x6c>
  {
    /* Return error: OWN bit set */
    return ETH_ERROR; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) && 
     762:	e002      	b.n	76a <ETH_HandleRxPkt+0x9a>
    }
  }
  else
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
     764:	f04f 0300 	mov.w	r3, #0
     768:	60bb      	str	r3, [r7, #8]
  }
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN; 
     76a:	4b2a      	ldr	r3, [pc, #168]	; (814 <ETH_HandleRxPkt+0x144>)
     76c:	681b      	ldr	r3, [r3, #0]
     76e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
     772:	601a      	str	r2, [r3, #0]
 
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
     774:	4b29      	ldr	r3, [pc, #164]	; (81c <ETH_HandleRxPkt+0x14c>)
     776:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     77a:	f103 0314 	add.w	r3, r3, #20
     77e:	681b      	ldr	r3, [r3, #0]
     780:	f003 0380 	and.w	r3, r3, #128	; 0x80
     784:	2b00      	cmp	r3, #0
     786:	d00f      	beq.n	7a8 <ETH_HandleRxPkt+0xd8>
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
     788:	4b24      	ldr	r3, [pc, #144]	; (81c <ETH_HandleRxPkt+0x14c>)
     78a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     78e:	f103 0314 	add.w	r3, r3, #20
     792:	f04f 0280 	mov.w	r2, #128	; 0x80
     796:	601a      	str	r2, [r3, #0]
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
     798:	4b20      	ldr	r3, [pc, #128]	; (81c <ETH_HandleRxPkt+0x14c>)
     79a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     79e:	f103 0308 	add.w	r3, r3, #8
     7a2:	f04f 0200 	mov.w	r2, #0
     7a6:	601a      	str	r2, [r3, #0]
  }
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */      
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
     7a8:	4b1a      	ldr	r3, [pc, #104]	; (814 <ETH_HandleRxPkt+0x144>)
     7aa:	681b      	ldr	r3, [r3, #0]
     7ac:	685b      	ldr	r3, [r3, #4]
     7ae:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
     7b2:	2b00      	cmp	r3, #0
     7b4:	d006      	beq.n	7c4 <ETH_HandleRxPkt+0xf4>
  {     
    /* Selects the next DMA Rx descriptor list for next buffer to read */ 
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
     7b6:	4b17      	ldr	r3, [pc, #92]	; (814 <ETH_HandleRxPkt+0x144>)
     7b8:	681b      	ldr	r3, [r3, #0]
     7ba:	68db      	ldr	r3, [r3, #12]
     7bc:	461a      	mov	r2, r3
     7be:	4b15      	ldr	r3, [pc, #84]	; (814 <ETH_HandleRxPkt+0x144>)
     7c0:	601a      	str	r2, [r3, #0]
     7c2:	e020      	b.n	806 <ETH_HandleRxPkt+0x136>
  }
  else /* Ring Mode */
  {   
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
     7c4:	4b13      	ldr	r3, [pc, #76]	; (814 <ETH_HandleRxPkt+0x144>)
     7c6:	681b      	ldr	r3, [r3, #0]
     7c8:	685b      	ldr	r3, [r3, #4]
     7ca:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
     7ce:	2b00      	cmp	r3, #0
     7d0:	d009      	beq.n	7e6 <ETH_HandleRxPkt+0x116>
    {
      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);      
     7d2:	4b12      	ldr	r3, [pc, #72]	; (81c <ETH_HandleRxPkt+0x14c>)
     7d4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     7d8:	f103 030c 	add.w	r3, r3, #12
     7dc:	681b      	ldr	r3, [r3, #0]
     7de:	461a      	mov	r2, r3
     7e0:	4b0c      	ldr	r3, [pc, #48]	; (814 <ETH_HandleRxPkt+0x144>)
     7e2:	601a      	str	r2, [r3, #0]
     7e4:	e00f      	b.n	806 <ETH_HandleRxPkt+0x136>
    }
    else
    { 
      /* Selects the next DMA Rx descriptor list for next buffer to read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
     7e6:	4b0d      	ldr	r3, [pc, #52]	; (81c <ETH_HandleRxPkt+0x14c>)
     7e8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     7ec:	681b      	ldr	r3, [r3, #0]
     7ee:	f003 037c 	and.w	r3, r3, #124	; 0x7c
     7f2:	ea4f 0293 	mov.w	r2, r3, lsr #2
     7f6:	4b07      	ldr	r3, [pc, #28]	; (814 <ETH_HandleRxPkt+0x144>)
     7f8:	681b      	ldr	r3, [r3, #0]
     7fa:	18d3      	adds	r3, r2, r3
     7fc:	f103 0310 	add.w	r3, r3, #16
     800:	461a      	mov	r2, r3
     802:	4b04      	ldr	r3, [pc, #16]	; (814 <ETH_HandleRxPkt+0x144>)
     804:	601a      	str	r2, [r3, #0]
    }
  }
  
  /* Return Frame Length/ERROR */
  return (framelength);  
     806:	68bb      	ldr	r3, [r7, #8]
}
     808:	4618      	mov	r0, r3
     80a:	f107 0714 	add.w	r7, r7, #20
     80e:	46bd      	mov	sp, r7
     810:	bc80      	pop	{r7}
     812:	4770      	bx	lr
     814:	00000000 	.word	0x00000000
			814: R_ARM_ABS32	DMARxDescToGet
     818:	3fff0000 	.word	0x3fff0000
     81c:	40028000 	.word	0x40028000

00000820 <ETH_GetRxPktSize>:
  * @brief  Get the size of received the received packet.
  * @param  None
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(void)
{
     820:	b580      	push	{r7, lr}
     822:	b082      	sub	sp, #8
     824:	af00      	add	r7, sp, #0
  uint32_t frameLength = 0;
     826:	f04f 0300 	mov.w	r3, #0
     82a:	607b      	str	r3, [r7, #4]
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     82c:	4b12      	ldr	r3, [pc, #72]	; (878 <ETH_GetRxPktSize+0x58>)
     82e:	681b      	ldr	r3, [r3, #0]
     830:	681b      	ldr	r3, [r3, #0]
     832:	2b00      	cmp	r3, #0
     834:	db1a      	blt.n	86c <ETH_GetRxPktSize+0x4c>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     836:	4b10      	ldr	r3, [pc, #64]	; (878 <ETH_GetRxPktSize+0x58>)
     838:	681b      	ldr	r3, [r3, #0]
     83a:	681b      	ldr	r3, [r3, #0]
     83c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(void)
{
  uint32_t frameLength = 0;
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     840:	2b00      	cmp	r3, #0
     842:	d113      	bne.n	86c <ETH_GetRxPktSize+0x4c>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     844:	4b0c      	ldr	r3, [pc, #48]	; (878 <ETH_GetRxPktSize+0x58>)
     846:	681b      	ldr	r3, [r3, #0]
     848:	681b      	ldr	r3, [r3, #0]
     84a:	f403 7380 	and.w	r3, r3, #256	; 0x100
  */
uint32_t ETH_GetRxPktSize(void)
{
  uint32_t frameLength = 0;
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     84e:	2b00      	cmp	r3, #0
     850:	d00c      	beq.n	86c <ETH_GetRxPktSize+0x4c>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
     852:	4b09      	ldr	r3, [pc, #36]	; (878 <ETH_GetRxPktSize+0x58>)
     854:	681b      	ldr	r3, [r3, #0]
     856:	681b      	ldr	r3, [r3, #0]
     858:	f403 7300 	and.w	r3, r3, #512	; 0x200
uint32_t ETH_GetRxPktSize(void)
{
  uint32_t frameLength = 0;
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     85c:	2b00      	cmp	r3, #0
     85e:	d005      	beq.n	86c <ETH_GetRxPktSize+0x4c>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the size of the packet: including 4 bytes of the CRC */
    frameLength = ETH_GetDMARxDescFrameLength(DMARxDescToGet);
     860:	4b05      	ldr	r3, [pc, #20]	; (878 <ETH_GetRxPktSize+0x58>)
     862:	681b      	ldr	r3, [r3, #0]
     864:	4618      	mov	r0, r3
     866:	f7ff fffe 	bl	1398 <ETH_GetDMARxDescFrameLength>
			866: R_ARM_THM_CALL	ETH_GetDMARxDescFrameLength
     86a:	6078      	str	r0, [r7, #4]
  }
 
 /* Return Frame Length */ 
 return frameLength;
     86c:	687b      	ldr	r3, [r7, #4]
}
     86e:	4618      	mov	r0, r3
     870:	f107 0708 	add.w	r7, r7, #8
     874:	46bd      	mov	sp, r7
     876:	bd80      	pop	{r7, pc}
     878:	00000000 	.word	0x00000000
			878: R_ARM_ABS32	DMARxDescToGet

0000087c <ETH_DropRxPkt>:
  * @brief  Drop a Received packet (too small packet, etc...)
  * @param  None
  * @retval None
  */
void ETH_DropRxPkt(void)
{
     87c:	b480      	push	{r7}
     87e:	af00      	add	r7, sp, #0
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status = ETH_DMARxDesc_OWN;  
     880:	4b1b      	ldr	r3, [pc, #108]	; (8f0 <ETH_DropRxPkt+0x74>)
     882:	681b      	ldr	r3, [r3, #0]
     884:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
     888:	601a      	str	r2, [r3, #0]
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
     88a:	4b19      	ldr	r3, [pc, #100]	; (8f0 <ETH_DropRxPkt+0x74>)
     88c:	681b      	ldr	r3, [r3, #0]
     88e:	685b      	ldr	r3, [r3, #4]
     890:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
     894:	2b00      	cmp	r3, #0
     896:	d006      	beq.n	8a6 <ETH_DropRxPkt+0x2a>
  {
    /* Selects the next DMA Rx descriptor list for next buffer read */
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
     898:	4b15      	ldr	r3, [pc, #84]	; (8f0 <ETH_DropRxPkt+0x74>)
     89a:	681b      	ldr	r3, [r3, #0]
     89c:	68db      	ldr	r3, [r3, #12]
     89e:	461a      	mov	r2, r3
     8a0:	4b13      	ldr	r3, [pc, #76]	; (8f0 <ETH_DropRxPkt+0x74>)
     8a2:	601a      	str	r2, [r3, #0]
     8a4:	e020      	b.n	8e8 <ETH_DropRxPkt+0x6c>
  }
  else /* Ring Mode */
  {
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
     8a6:	4b12      	ldr	r3, [pc, #72]	; (8f0 <ETH_DropRxPkt+0x74>)
     8a8:	681b      	ldr	r3, [r3, #0]
     8aa:	685b      	ldr	r3, [r3, #4]
     8ac:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
     8b0:	2b00      	cmp	r3, #0
     8b2:	d009      	beq.n	8c8 <ETH_DropRxPkt+0x4c>
    {
      /* Selects the next DMA Rx descriptor list for next buffer read: this will
         be the first Rx descriptor in this case */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);
     8b4:	4b0f      	ldr	r3, [pc, #60]	; (8f4 <ETH_DropRxPkt+0x78>)
     8b6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     8ba:	f103 030c 	add.w	r3, r3, #12
     8be:	681b      	ldr	r3, [r3, #0]
     8c0:	461a      	mov	r2, r3
     8c2:	4b0b      	ldr	r3, [pc, #44]	; (8f0 <ETH_DropRxPkt+0x74>)
     8c4:	601a      	str	r2, [r3, #0]
     8c6:	e00f      	b.n	8e8 <ETH_DropRxPkt+0x6c>
    }
    else
    {
      /* Selects the next DMA Rx descriptor list for next buffer read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));
     8c8:	4b0a      	ldr	r3, [pc, #40]	; (8f4 <ETH_DropRxPkt+0x78>)
     8ca:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     8ce:	681b      	ldr	r3, [r3, #0]
     8d0:	f003 037c 	and.w	r3, r3, #124	; 0x7c
     8d4:	ea4f 0293 	mov.w	r2, r3, lsr #2
     8d8:	4b05      	ldr	r3, [pc, #20]	; (8f0 <ETH_DropRxPkt+0x74>)
     8da:	681b      	ldr	r3, [r3, #0]
     8dc:	18d3      	adds	r3, r2, r3
     8de:	f103 0310 	add.w	r3, r3, #16
     8e2:	461a      	mov	r2, r3
     8e4:	4b02      	ldr	r3, [pc, #8]	; (8f0 <ETH_DropRxPkt+0x74>)
     8e6:	601a      	str	r2, [r3, #0]
    }
  }
}
     8e8:	46bd      	mov	sp, r7
     8ea:	bc80      	pop	{r7}
     8ec:	4770      	bx	lr
     8ee:	bf00      	nop
     8f0:	00000000 	.word	0x00000000
			8f0: R_ARM_ABS32	DMARxDescToGet
     8f4:	40028000 	.word	0x40028000

000008f8 <ETH_ReadPHYRegister>:
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
     8f8:	b480      	push	{r7}
     8fa:	b085      	sub	sp, #20
     8fc:	af00      	add	r7, sp, #0
     8fe:	4602      	mov	r2, r0
     900:	460b      	mov	r3, r1
     902:	80fa      	strh	r2, [r7, #6]
     904:	80bb      	strh	r3, [r7, #4]
  uint32_t tmpreg = 0;     
     906:	f04f 0300 	mov.w	r3, #0
     90a:	60fb      	str	r3, [r7, #12]
__IO uint32_t timeout = 0;
     90c:	f04f 0300 	mov.w	r3, #0
     910:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
     912:	4b23      	ldr	r3, [pc, #140]	; (9a0 <ETH_ReadPHYRegister+0xa8>)
     914:	691b      	ldr	r3, [r3, #16]
     916:	60fb      	str	r3, [r7, #12]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
     918:	68fb      	ldr	r3, [r7, #12]
     91a:	f003 031c 	and.w	r3, r3, #28
     91e:	60fb      	str	r3, [r7, #12]
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
     920:	88fb      	ldrh	r3, [r7, #6]
     922:	ea4f 23c3 	mov.w	r3, r3, lsl #11
     926:	ea4f 4303 	mov.w	r3, r3, lsl #16
     92a:	ea4f 4313 	mov.w	r3, r3, lsr #16
     92e:	68fa      	ldr	r2, [r7, #12]
     930:	ea42 0303 	orr.w	r3, r2, r3
     934:	60fb      	str	r3, [r7, #12]
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
     936:	88bb      	ldrh	r3, [r7, #4]
     938:	ea4f 1383 	mov.w	r3, r3, lsl #6
     93c:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
     940:	68fa      	ldr	r2, [r7, #12]
     942:	ea42 0303 	orr.w	r3, r2, r3
     946:	60fb      	str	r3, [r7, #12]
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
     948:	68fb      	ldr	r3, [r7, #12]
     94a:	f023 0302 	bic.w	r3, r3, #2
     94e:	60fb      	str	r3, [r7, #12]
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
     950:	68fb      	ldr	r3, [r7, #12]
     952:	f043 0301 	orr.w	r3, r3, #1
     956:	60fb      	str	r3, [r7, #12]
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
     958:	4b11      	ldr	r3, [pc, #68]	; (9a0 <ETH_ReadPHYRegister+0xa8>)
     95a:	68fa      	ldr	r2, [r7, #12]
     95c:	611a      	str	r2, [r3, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
     95e:	68bb      	ldr	r3, [r7, #8]
     960:	f103 0301 	add.w	r3, r3, #1
     964:	60bb      	str	r3, [r7, #8]
    tmpreg = ETH->MACMIIAR;
     966:	4b0e      	ldr	r3, [pc, #56]	; (9a0 <ETH_ReadPHYRegister+0xa8>)
     968:	691b      	ldr	r3, [r3, #16]
     96a:	60fb      	str	r3, [r7, #12]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
     96c:	68fb      	ldr	r3, [r7, #12]
     96e:	f003 0301 	and.w	r3, r3, #1
     972:	b2db      	uxtb	r3, r3
     974:	2b00      	cmp	r3, #0
     976:	d003      	beq.n	980 <ETH_ReadPHYRegister+0x88>
     978:	68ba      	ldr	r2, [r7, #8]
     97a:	4b0a      	ldr	r3, [pc, #40]	; (9a4 <ETH_ReadPHYRegister+0xac>)
     97c:	429a      	cmp	r2, r3
     97e:	d9ee      	bls.n	95e <ETH_ReadPHYRegister+0x66>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
     980:	68ba      	ldr	r2, [r7, #8]
     982:	4b09      	ldr	r3, [pc, #36]	; (9a8 <ETH_ReadPHYRegister+0xb0>)
     984:	429a      	cmp	r2, r3
     986:	d102      	bne.n	98e <ETH_ReadPHYRegister+0x96>
  {
    return (uint16_t)ETH_ERROR;
     988:	f04f 0300 	mov.w	r3, #0
     98c:	e002      	b.n	994 <ETH_ReadPHYRegister+0x9c>
  }
  
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
     98e:	4b04      	ldr	r3, [pc, #16]	; (9a0 <ETH_ReadPHYRegister+0xa8>)
     990:	695b      	ldr	r3, [r3, #20]
     992:	b29b      	uxth	r3, r3
}
     994:	4618      	mov	r0, r3
     996:	f107 0714 	add.w	r7, r7, #20
     99a:	46bd      	mov	sp, r7
     99c:	bc80      	pop	{r7}
     99e:	4770      	bx	lr
     9a0:	40028000 	.word	0x40028000
     9a4:	0004fffe 	.word	0x0004fffe
     9a8:	0004ffff 	.word	0x0004ffff

000009ac <ETH_WritePHYRegister>:
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
     9ac:	b480      	push	{r7}
     9ae:	b085      	sub	sp, #20
     9b0:	af00      	add	r7, sp, #0
     9b2:	4613      	mov	r3, r2
     9b4:	4602      	mov	r2, r0
     9b6:	80fa      	strh	r2, [r7, #6]
     9b8:	460a      	mov	r2, r1
     9ba:	80ba      	strh	r2, [r7, #4]
     9bc:	807b      	strh	r3, [r7, #2]
  uint32_t tmpreg = 0;     
     9be:	f04f 0300 	mov.w	r3, #0
     9c2:	60fb      	str	r3, [r7, #12]
  __IO uint32_t timeout = 0;
     9c4:	f04f 0300 	mov.w	r3, #0
     9c8:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
     9ca:	4b24      	ldr	r3, [pc, #144]	; (a5c <ETH_WritePHYRegister+0xb0>)
     9cc:	691b      	ldr	r3, [r3, #16]
     9ce:	60fb      	str	r3, [r7, #12]
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
     9d0:	68fb      	ldr	r3, [r7, #12]
     9d2:	f003 031c 	and.w	r3, r3, #28
     9d6:	60fb      	str	r3, [r7, #12]
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
     9d8:	88fb      	ldrh	r3, [r7, #6]
     9da:	ea4f 23c3 	mov.w	r3, r3, lsl #11
     9de:	ea4f 4303 	mov.w	r3, r3, lsl #16
     9e2:	ea4f 4313 	mov.w	r3, r3, lsr #16
     9e6:	68fa      	ldr	r2, [r7, #12]
     9e8:	ea42 0303 	orr.w	r3, r2, r3
     9ec:	60fb      	str	r3, [r7, #12]
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
     9ee:	88bb      	ldrh	r3, [r7, #4]
     9f0:	ea4f 1383 	mov.w	r3, r3, lsl #6
     9f4:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
     9f8:	68fa      	ldr	r2, [r7, #12]
     9fa:	ea42 0303 	orr.w	r3, r2, r3
     9fe:	60fb      	str	r3, [r7, #12]
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
     a00:	68fb      	ldr	r3, [r7, #12]
     a02:	f043 0302 	orr.w	r3, r3, #2
     a06:	60fb      	str	r3, [r7, #12]
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
     a08:	68fb      	ldr	r3, [r7, #12]
     a0a:	f043 0301 	orr.w	r3, r3, #1
     a0e:	60fb      	str	r3, [r7, #12]
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
     a10:	4b12      	ldr	r3, [pc, #72]	; (a5c <ETH_WritePHYRegister+0xb0>)
     a12:	887a      	ldrh	r2, [r7, #2]
     a14:	615a      	str	r2, [r3, #20]
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
     a16:	4b11      	ldr	r3, [pc, #68]	; (a5c <ETH_WritePHYRegister+0xb0>)
     a18:	68fa      	ldr	r2, [r7, #12]
     a1a:	611a      	str	r2, [r3, #16]
  /* Check for the Busy flag */
  do
  {
    timeout++;
     a1c:	68bb      	ldr	r3, [r7, #8]
     a1e:	f103 0301 	add.w	r3, r3, #1
     a22:	60bb      	str	r3, [r7, #8]
    tmpreg = ETH->MACMIIAR;
     a24:	4b0d      	ldr	r3, [pc, #52]	; (a5c <ETH_WritePHYRegister+0xb0>)
     a26:	691b      	ldr	r3, [r3, #16]
     a28:	60fb      	str	r3, [r7, #12]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
     a2a:	68fb      	ldr	r3, [r7, #12]
     a2c:	f003 0301 	and.w	r3, r3, #1
     a30:	b2db      	uxtb	r3, r3
     a32:	2b00      	cmp	r3, #0
     a34:	d003      	beq.n	a3e <ETH_WritePHYRegister+0x92>
     a36:	68ba      	ldr	r2, [r7, #8]
     a38:	4b09      	ldr	r3, [pc, #36]	; (a60 <ETH_WritePHYRegister+0xb4>)
     a3a:	429a      	cmp	r2, r3
     a3c:	d9ee      	bls.n	a1c <ETH_WritePHYRegister+0x70>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
     a3e:	68ba      	ldr	r2, [r7, #8]
     a40:	4b08      	ldr	r3, [pc, #32]	; (a64 <ETH_WritePHYRegister+0xb8>)
     a42:	429a      	cmp	r2, r3
     a44:	d102      	bne.n	a4c <ETH_WritePHYRegister+0xa0>
  {
    return ETH_ERROR;
     a46:	f04f 0300 	mov.w	r3, #0
     a4a:	e001      	b.n	a50 <ETH_WritePHYRegister+0xa4>
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;  
     a4c:	f04f 0301 	mov.w	r3, #1
}
     a50:	4618      	mov	r0, r3
     a52:	f107 0714 	add.w	r7, r7, #20
     a56:	46bd      	mov	sp, r7
     a58:	bc80      	pop	{r7}
     a5a:	4770      	bx	lr
     a5c:	40028000 	.word	0x40028000
     a60:	0004fffe 	.word	0x0004fffe
     a64:	0004ffff 	.word	0x0004ffff

00000a68 <ETH_PHYLoopBackCmd>:
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
     a68:	b580      	push	{r7, lr}
     a6a:	b084      	sub	sp, #16
     a6c:	af00      	add	r7, sp, #0
     a6e:	4602      	mov	r2, r0
     a70:	460b      	mov	r3, r1
     a72:	80fa      	strh	r2, [r7, #6]
     a74:	717b      	strb	r3, [r7, #5]
  uint16_t tmpreg = 0;
     a76:	f04f 0300 	mov.w	r3, #0
     a7a:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
     a7c:	88fb      	ldrh	r3, [r7, #6]
     a7e:	4618      	mov	r0, r3
     a80:	f04f 0100 	mov.w	r1, #0
     a84:	f7ff fffe 	bl	8f8 <ETH_ReadPHYRegister>
			a84: R_ARM_THM_CALL	ETH_ReadPHYRegister
     a88:	4603      	mov	r3, r0
     a8a:	81fb      	strh	r3, [r7, #14]
  
  if (NewState != DISABLE)
     a8c:	797b      	ldrb	r3, [r7, #5]
     a8e:	2b00      	cmp	r3, #0
     a90:	d004      	beq.n	a9c <ETH_PHYLoopBackCmd+0x34>
  {
    /* Enable the PHY loopback mode */
    tmpreg |= PHY_Loopback;  
     a92:	89fb      	ldrh	r3, [r7, #14]
     a94:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
     a98:	81fb      	strh	r3, [r7, #14]
     a9a:	e003      	b.n	aa4 <ETH_PHYLoopBackCmd+0x3c>
  }
  else
  {
    /* Disable the PHY loopback mode: normal mode */
    tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
     a9c:	89fb      	ldrh	r3, [r7, #14]
     a9e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
     aa2:	81fb      	strh	r3, [r7, #14]
  }
  /* Update the PHY control register with the new configuration */
  if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
     aa4:	88fa      	ldrh	r2, [r7, #6]
     aa6:	89fb      	ldrh	r3, [r7, #14]
     aa8:	4610      	mov	r0, r2
     aaa:	f04f 0100 	mov.w	r1, #0
     aae:	461a      	mov	r2, r3
     ab0:	f7ff fffe 	bl	9ac <ETH_WritePHYRegister>
			ab0: R_ARM_THM_CALL	ETH_WritePHYRegister
     ab4:	4603      	mov	r3, r0
     ab6:	2b00      	cmp	r3, #0
     ab8:	d002      	beq.n	ac0 <ETH_PHYLoopBackCmd+0x58>
  {
    return ETH_SUCCESS;
     aba:	f04f 0301 	mov.w	r3, #1
     abe:	e001      	b.n	ac4 <ETH_PHYLoopBackCmd+0x5c>
  }
  else
  {
    /* Return SUCCESS */
    return ETH_ERROR; 
     ac0:	f04f 0300 	mov.w	r3, #0
  }   
}
     ac4:	4618      	mov	r0, r3
     ac6:	f107 0710 	add.w	r7, r7, #16
     aca:	46bd      	mov	sp, r7
     acc:	bd80      	pop	{r7, pc}
     ace:	bf00      	nop

00000ad0 <ETH_MACTransmissionCmd>:
  * @param  NewState: new state of the MAC transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
     ad0:	b480      	push	{r7}
     ad2:	b083      	sub	sp, #12
     ad4:	af00      	add	r7, sp, #0
     ad6:	4603      	mov	r3, r0
     ad8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
     ada:	79fb      	ldrb	r3, [r7, #7]
     adc:	2b00      	cmp	r3, #0
     ade:	d006      	beq.n	aee <ETH_MACTransmissionCmd+0x1e>
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
     ae0:	4b08      	ldr	r3, [pc, #32]	; (b04 <ETH_MACTransmissionCmd+0x34>)
     ae2:	4a08      	ldr	r2, [pc, #32]	; (b04 <ETH_MACTransmissionCmd+0x34>)
     ae4:	6812      	ldr	r2, [r2, #0]
     ae6:	f042 0208 	orr.w	r2, r2, #8
     aea:	601a      	str	r2, [r3, #0]
     aec:	e005      	b.n	afa <ETH_MACTransmissionCmd+0x2a>
  }
  else
  {
    /* Disable the MAC transmission */
    ETH->MACCR &= ~ETH_MACCR_TE;
     aee:	4b05      	ldr	r3, [pc, #20]	; (b04 <ETH_MACTransmissionCmd+0x34>)
     af0:	4a04      	ldr	r2, [pc, #16]	; (b04 <ETH_MACTransmissionCmd+0x34>)
     af2:	6812      	ldr	r2, [r2, #0]
     af4:	f022 0208 	bic.w	r2, r2, #8
     af8:	601a      	str	r2, [r3, #0]
  }
}
     afa:	f107 070c 	add.w	r7, r7, #12
     afe:	46bd      	mov	sp, r7
     b00:	bc80      	pop	{r7}
     b02:	4770      	bx	lr
     b04:	40028000 	.word	0x40028000

00000b08 <ETH_MACReceptionCmd>:
  * @param  NewState: new state of the MAC reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
     b08:	b480      	push	{r7}
     b0a:	b083      	sub	sp, #12
     b0c:	af00      	add	r7, sp, #0
     b0e:	4603      	mov	r3, r0
     b10:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
     b12:	79fb      	ldrb	r3, [r7, #7]
     b14:	2b00      	cmp	r3, #0
     b16:	d006      	beq.n	b26 <ETH_MACReceptionCmd+0x1e>
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
     b18:	4b08      	ldr	r3, [pc, #32]	; (b3c <ETH_MACReceptionCmd+0x34>)
     b1a:	4a08      	ldr	r2, [pc, #32]	; (b3c <ETH_MACReceptionCmd+0x34>)
     b1c:	6812      	ldr	r2, [r2, #0]
     b1e:	f042 0204 	orr.w	r2, r2, #4
     b22:	601a      	str	r2, [r3, #0]
     b24:	e005      	b.n	b32 <ETH_MACReceptionCmd+0x2a>
  }
  else
  {
    /* Disable the MAC reception */
    ETH->MACCR &= ~ETH_MACCR_RE;
     b26:	4b05      	ldr	r3, [pc, #20]	; (b3c <ETH_MACReceptionCmd+0x34>)
     b28:	4a04      	ldr	r2, [pc, #16]	; (b3c <ETH_MACReceptionCmd+0x34>)
     b2a:	6812      	ldr	r2, [r2, #0]
     b2c:	f022 0204 	bic.w	r2, r2, #4
     b30:	601a      	str	r2, [r3, #0]
  }
}
     b32:	f107 070c 	add.w	r7, r7, #12
     b36:	46bd      	mov	sp, r7
     b38:	bc80      	pop	{r7}
     b3a:	4770      	bx	lr
     b3c:	40028000 	.word	0x40028000

00000b40 <ETH_GetFlowControlBusyStatus>:
  * @brief  Checks whether the ETHERNET flow control busy bit is set or not.
  * @param  None
  * @retval The new state of flow control busy status bit (SET or RESET).
  */
FlagStatus ETH_GetFlowControlBusyStatus(void)
{
     b40:	b480      	push	{r7}
     b42:	b083      	sub	sp, #12
     b44:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
     b46:	f04f 0300 	mov.w	r3, #0
     b4a:	71fb      	strb	r3, [r7, #7]
  /* The Flow Control register should not be written to until this bit is cleared */
  if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
     b4c:	4b0a      	ldr	r3, [pc, #40]	; (b78 <ETH_GetFlowControlBusyStatus+0x38>)
     b4e:	699b      	ldr	r3, [r3, #24]
     b50:	f003 0301 	and.w	r3, r3, #1
     b54:	b2db      	uxtb	r3, r3
     b56:	2b00      	cmp	r3, #0
     b58:	d003      	beq.n	b62 <ETH_GetFlowControlBusyStatus+0x22>
  {
    bitstatus = SET;
     b5a:	f04f 0301 	mov.w	r3, #1
     b5e:	71fb      	strb	r3, [r7, #7]
     b60:	e002      	b.n	b68 <ETH_GetFlowControlBusyStatus+0x28>
  }
  else
  {
    bitstatus = RESET;
     b62:	f04f 0300 	mov.w	r3, #0
     b66:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
     b68:	79fb      	ldrb	r3, [r7, #7]
}
     b6a:	4618      	mov	r0, r3
     b6c:	f107 070c 	add.w	r7, r7, #12
     b70:	46bd      	mov	sp, r7
     b72:	bc80      	pop	{r7}
     b74:	4770      	bx	lr
     b76:	bf00      	nop
     b78:	40028000 	.word	0x40028000

00000b7c <ETH_InitiatePauseControlFrame>:
  * @brief  Initiate a Pause Control Frame (Full-duplex only).
  * @param  None
  * @retval None
  */
void ETH_InitiatePauseControlFrame(void)  
{ 
     b7c:	b480      	push	{r7}
     b7e:	af00      	add	r7, sp, #0
  /* When Set In full duplex MAC initiates pause control frame */
  ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
     b80:	4b04      	ldr	r3, [pc, #16]	; (b94 <ETH_InitiatePauseControlFrame+0x18>)
     b82:	4a04      	ldr	r2, [pc, #16]	; (b94 <ETH_InitiatePauseControlFrame+0x18>)
     b84:	6992      	ldr	r2, [r2, #24]
     b86:	f042 0201 	orr.w	r2, r2, #1
     b8a:	619a      	str	r2, [r3, #24]
}
     b8c:	46bd      	mov	sp, r7
     b8e:	bc80      	pop	{r7}
     b90:	4770      	bx	lr
     b92:	bf00      	nop
     b94:	40028000 	.word	0x40028000

00000b98 <ETH_BackPressureActivationCmd>:
  * @param  NewState: new state of the MAC BackPressure operation activation.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_BackPressureActivationCmd(FunctionalState NewState)   
{ 
     b98:	b480      	push	{r7}
     b9a:	b083      	sub	sp, #12
     b9c:	af00      	add	r7, sp, #0
     b9e:	4603      	mov	r3, r0
     ba0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
     ba2:	79fb      	ldrb	r3, [r7, #7]
     ba4:	2b00      	cmp	r3, #0
     ba6:	d006      	beq.n	bb6 <ETH_BackPressureActivationCmd+0x1e>
  {
    /* Activate the MAC BackPressure operation */
    /* In Half duplex: during backpressure, when the MAC receives a new frame,
    the transmitter starts sending a JAM pattern resulting in a collision */
    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
     ba8:	4b08      	ldr	r3, [pc, #32]	; (bcc <ETH_BackPressureActivationCmd+0x34>)
     baa:	4a08      	ldr	r2, [pc, #32]	; (bcc <ETH_BackPressureActivationCmd+0x34>)
     bac:	6992      	ldr	r2, [r2, #24]
     bae:	f042 0201 	orr.w	r2, r2, #1
     bb2:	619a      	str	r2, [r3, #24]
     bb4:	e005      	b.n	bc2 <ETH_BackPressureActivationCmd+0x2a>
  }
  else
  {
    /* Desactivate the MAC BackPressure operation */
    ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
     bb6:	4b05      	ldr	r3, [pc, #20]	; (bcc <ETH_BackPressureActivationCmd+0x34>)
     bb8:	4a04      	ldr	r2, [pc, #16]	; (bcc <ETH_BackPressureActivationCmd+0x34>)
     bba:	6992      	ldr	r2, [r2, #24]
     bbc:	f022 0201 	bic.w	r2, r2, #1
     bc0:	619a      	str	r2, [r3, #24]
  } 
}
     bc2:	f107 070c 	add.w	r7, r7, #12
     bc6:	46bd      	mov	sp, r7
     bc8:	bc80      	pop	{r7}
     bca:	4770      	bx	lr
     bcc:	40028000 	.word	0x40028000

00000bd0 <ETH_GetMACFlagStatus>:
  *     @arg ETH_MAC_FLAG_MMC  : MMC flag  
  *     @arg ETH_MAC_FLAG_PMT  : PMT flag  
  * @retval The new state of ETHERNET MAC flag (SET or RESET).
  */
FlagStatus ETH_GetMACFlagStatus(uint32_t ETH_MAC_FLAG)
{
     bd0:	b480      	push	{r7}
     bd2:	b085      	sub	sp, #20
     bd4:	af00      	add	r7, sp, #0
     bd6:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
     bd8:	f04f 0300 	mov.w	r3, #0
     bdc:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_FLAG(ETH_MAC_FLAG)); 
  if ((ETH->MACSR & ETH_MAC_FLAG) != (uint32_t)RESET)
     bde:	4b0a      	ldr	r3, [pc, #40]	; (c08 <ETH_GetMACFlagStatus+0x38>)
     be0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     be2:	687b      	ldr	r3, [r7, #4]
     be4:	ea02 0303 	and.w	r3, r2, r3
     be8:	2b00      	cmp	r3, #0
     bea:	d003      	beq.n	bf4 <ETH_GetMACFlagStatus+0x24>
  {
    bitstatus = SET;
     bec:	f04f 0301 	mov.w	r3, #1
     bf0:	73fb      	strb	r3, [r7, #15]
     bf2:	e002      	b.n	bfa <ETH_GetMACFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
     bf4:	f04f 0300 	mov.w	r3, #0
     bf8:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
     bfa:	7bfb      	ldrb	r3, [r7, #15]
}
     bfc:	4618      	mov	r0, r3
     bfe:	f107 0714 	add.w	r7, r7, #20
     c02:	46bd      	mov	sp, r7
     c04:	bc80      	pop	{r7}
     c06:	4770      	bx	lr
     c08:	40028000 	.word	0x40028000

00000c0c <ETH_GetMACITStatus>:
  *     @arg ETH_MAC_IT_MMC  : MMC interrupt 
  *     @arg ETH_MAC_IT_PMT  : PMT interrupt 
  * @retval The new state of ETHERNET MAC interrupt (SET or RESET).
  */
ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
{
     c0c:	b480      	push	{r7}
     c0e:	b085      	sub	sp, #20
     c10:	af00      	add	r7, sp, #0
     c12:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
     c14:	f04f 0300 	mov.w	r3, #0
     c18:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
  if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
     c1a:	4b0a      	ldr	r3, [pc, #40]	; (c44 <ETH_GetMACITStatus+0x38>)
     c1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
     c1e:	687b      	ldr	r3, [r7, #4]
     c20:	ea02 0303 	and.w	r3, r2, r3
     c24:	2b00      	cmp	r3, #0
     c26:	d003      	beq.n	c30 <ETH_GetMACITStatus+0x24>
  {
    bitstatus = SET;
     c28:	f04f 0301 	mov.w	r3, #1
     c2c:	73fb      	strb	r3, [r7, #15]
     c2e:	e002      	b.n	c36 <ETH_GetMACITStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
     c30:	f04f 0300 	mov.w	r3, #0
     c34:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
     c36:	7bfb      	ldrb	r3, [r7, #15]
}
     c38:	4618      	mov	r0, r3
     c3a:	f107 0714 	add.w	r7, r7, #20
     c3e:	46bd      	mov	sp, r7
     c40:	bc80      	pop	{r7}
     c42:	4770      	bx	lr
     c44:	40028000 	.word	0x40028000

00000c48 <ETH_MACITConfig>:
  * @param  NewState: new state of the specified ETHERNET MAC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACITConfig(uint32_t ETH_MAC_IT, FunctionalState NewState)
{
     c48:	b480      	push	{r7}
     c4a:	b083      	sub	sp, #12
     c4c:	af00      	add	r7, sp, #0
     c4e:	6078      	str	r0, [r7, #4]
     c50:	460b      	mov	r3, r1
     c52:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
     c54:	78fb      	ldrb	r3, [r7, #3]
     c56:	2b00      	cmp	r3, #0
     c58:	d009      	beq.n	c6e <ETH_MACITConfig+0x26>
  {
    /* Enable the selected ETHERNET MAC interrupts */
    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
     c5a:	4b0b      	ldr	r3, [pc, #44]	; (c88 <ETH_MACITConfig+0x40>)
     c5c:	4a0a      	ldr	r2, [pc, #40]	; (c88 <ETH_MACITConfig+0x40>)
     c5e:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
     c60:	687a      	ldr	r2, [r7, #4]
     c62:	ea6f 0202 	mvn.w	r2, r2
     c66:	ea01 0202 	and.w	r2, r1, r2
     c6a:	63da      	str	r2, [r3, #60]	; 0x3c
     c6c:	e006      	b.n	c7c <ETH_MACITConfig+0x34>
  }
  else
  {
    /* Disable the selected ETHERNET MAC interrupts */
    ETH->MACIMR |= ETH_MAC_IT;
     c6e:	4b06      	ldr	r3, [pc, #24]	; (c88 <ETH_MACITConfig+0x40>)
     c70:	4a05      	ldr	r2, [pc, #20]	; (c88 <ETH_MACITConfig+0x40>)
     c72:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
     c74:	687a      	ldr	r2, [r7, #4]
     c76:	ea41 0202 	orr.w	r2, r1, r2
     c7a:	63da      	str	r2, [r3, #60]	; 0x3c
  }
}
     c7c:	f107 070c 	add.w	r7, r7, #12
     c80:	46bd      	mov	sp, r7
     c82:	bc80      	pop	{r7}
     c84:	4770      	bx	lr
     c86:	bf00      	nop
     c88:	40028000 	.word	0x40028000

00000c8c <ETH_MACAddressConfig>:
  *     @arg ETH_MAC_Address3 : MAC Address3
  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
  * @retval None
  */
void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
{
     c8c:	b480      	push	{r7}
     c8e:	b085      	sub	sp, #20
     c90:	af00      	add	r7, sp, #0
     c92:	6078      	str	r0, [r7, #4]
     c94:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selectecd MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
     c96:	683b      	ldr	r3, [r7, #0]
     c98:	f103 0305 	add.w	r3, r3, #5
     c9c:	781b      	ldrb	r3, [r3, #0]
     c9e:	ea4f 2203 	mov.w	r2, r3, lsl #8
     ca2:	683b      	ldr	r3, [r7, #0]
     ca4:	f103 0304 	add.w	r3, r3, #4
     ca8:	781b      	ldrb	r3, [r3, #0]
     caa:	ea42 0303 	orr.w	r3, r2, r3
     cae:	60fb      	str	r3, [r7, #12]
  /* Load the selectecd MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
     cb0:	687a      	ldr	r2, [r7, #4]
     cb2:	4b13      	ldr	r3, [pc, #76]	; (d00 <ETH_MACAddressConfig+0x74>)
     cb4:	18d3      	adds	r3, r2, r3
     cb6:	68fa      	ldr	r2, [r7, #12]
     cb8:	601a      	str	r2, [r3, #0]
  /* Calculate the selectecd MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
     cba:	683b      	ldr	r3, [r7, #0]
     cbc:	f103 0303 	add.w	r3, r3, #3
     cc0:	781b      	ldrb	r3, [r3, #0]
     cc2:	ea4f 6203 	mov.w	r2, r3, lsl #24
     cc6:	683b      	ldr	r3, [r7, #0]
     cc8:	f103 0302 	add.w	r3, r3, #2
     ccc:	781b      	ldrb	r3, [r3, #0]
     cce:	ea4f 4303 	mov.w	r3, r3, lsl #16
     cd2:	431a      	orrs	r2, r3
     cd4:	683b      	ldr	r3, [r7, #0]
     cd6:	f103 0301 	add.w	r3, r3, #1
     cda:	781b      	ldrb	r3, [r3, #0]
     cdc:	ea4f 2303 	mov.w	r3, r3, lsl #8
     ce0:	431a      	orrs	r2, r3
     ce2:	683b      	ldr	r3, [r7, #0]
     ce4:	781b      	ldrb	r3, [r3, #0]
     ce6:	ea42 0303 	orr.w	r3, r2, r3
     cea:	60fb      	str	r3, [r7, #12]
 
  /* Load the selectecd MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
     cec:	687a      	ldr	r2, [r7, #4]
     cee:	4b05      	ldr	r3, [pc, #20]	; (d04 <ETH_MACAddressConfig+0x78>)
     cf0:	18d3      	adds	r3, r2, r3
     cf2:	68fa      	ldr	r2, [r7, #12]
     cf4:	601a      	str	r2, [r3, #0]
}
     cf6:	f107 0714 	add.w	r7, r7, #20
     cfa:	46bd      	mov	sp, r7
     cfc:	bc80      	pop	{r7}
     cfe:	4770      	bx	lr
     d00:	40028040 	.word	0x40028040
     d04:	40028044 	.word	0x40028044

00000d08 <ETH_GetMACAddress>:
  *     @arg ETH_MAC_Address3 : MAC Address3
  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
  * @retval None
  */
void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
{
     d08:	b480      	push	{r7}
     d0a:	b085      	sub	sp, #20
     d0c:	af00      	add	r7, sp, #0
     d0e:	6078      	str	r0, [r7, #4]
     d10:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Get the selectecd MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
     d12:	687a      	ldr	r2, [r7, #4]
     d14:	4b1b      	ldr	r3, [pc, #108]	; (d84 <ETH_GetMACAddress+0x7c>)
     d16:	18d3      	adds	r3, r2, r3
     d18:	681b      	ldr	r3, [r3, #0]
     d1a:	60fb      	str	r3, [r7, #12]
 
  /* Calculate the selectecd MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
     d1c:	683b      	ldr	r3, [r7, #0]
     d1e:	f103 0305 	add.w	r3, r3, #5
     d22:	68fa      	ldr	r2, [r7, #12]
     d24:	ea4f 2212 	mov.w	r2, r2, lsr #8
     d28:	b2d2      	uxtb	r2, r2
     d2a:	701a      	strb	r2, [r3, #0]
  Addr[4] = (tmpreg & (uint8_t)0xFF);
     d2c:	683b      	ldr	r3, [r7, #0]
     d2e:	f103 0304 	add.w	r3, r3, #4
     d32:	68fa      	ldr	r2, [r7, #12]
     d34:	b2d2      	uxtb	r2, r2
     d36:	701a      	strb	r2, [r3, #0]
  /* Load the selectecd MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
     d38:	687a      	ldr	r2, [r7, #4]
     d3a:	4b13      	ldr	r3, [pc, #76]	; (d88 <ETH_GetMACAddress+0x80>)
     d3c:	18d3      	adds	r3, r2, r3
     d3e:	681b      	ldr	r3, [r3, #0]
     d40:	60fb      	str	r3, [r7, #12]
  /* Calculate the selectecd MAC address buffer */
  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
     d42:	683b      	ldr	r3, [r7, #0]
     d44:	f103 0303 	add.w	r3, r3, #3
     d48:	68fa      	ldr	r2, [r7, #12]
     d4a:	ea4f 6212 	mov.w	r2, r2, lsr #24
     d4e:	b2d2      	uxtb	r2, r2
     d50:	701a      	strb	r2, [r3, #0]
  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
     d52:	683b      	ldr	r3, [r7, #0]
     d54:	f103 0302 	add.w	r3, r3, #2
     d58:	68fa      	ldr	r2, [r7, #12]
     d5a:	ea4f 4212 	mov.w	r2, r2, lsr #16
     d5e:	b2d2      	uxtb	r2, r2
     d60:	701a      	strb	r2, [r3, #0]
  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
     d62:	683b      	ldr	r3, [r7, #0]
     d64:	f103 0301 	add.w	r3, r3, #1
     d68:	68fa      	ldr	r2, [r7, #12]
     d6a:	ea4f 2212 	mov.w	r2, r2, lsr #8
     d6e:	b2d2      	uxtb	r2, r2
     d70:	701a      	strb	r2, [r3, #0]
  Addr[0] = (tmpreg & (uint8_t)0xFF);
     d72:	68fb      	ldr	r3, [r7, #12]
     d74:	b2da      	uxtb	r2, r3
     d76:	683b      	ldr	r3, [r7, #0]
     d78:	701a      	strb	r2, [r3, #0]
}
     d7a:	f107 0714 	add.w	r7, r7, #20
     d7e:	46bd      	mov	sp, r7
     d80:	bc80      	pop	{r7}
     d82:	4770      	bx	lr
     d84:	40028040 	.word	0x40028040
     d88:	40028044 	.word	0x40028044

00000d8c <ETH_MACAddressPerfectFilterCmd>:
  * @param  NewState: new state of the specified ETHERNET MAC address use.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MACAddressPerfectFilterCmd(uint32_t MacAddr, FunctionalState NewState)
{
     d8c:	b480      	push	{r7}
     d8e:	b083      	sub	sp, #12
     d90:	af00      	add	r7, sp, #0
     d92:	6078      	str	r0, [r7, #4]
     d94:	460b      	mov	r3, r1
     d96:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
     d98:	78fb      	ldrb	r3, [r7, #3]
     d9a:	2b00      	cmp	r3, #0
     d9c:	d00b      	beq.n	db6 <ETH_MACAddressPerfectFilterCmd+0x2a>
  {
    /* Enable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
     d9e:	687a      	ldr	r2, [r7, #4]
     da0:	4b0d      	ldr	r3, [pc, #52]	; (dd8 <ETH_MACAddressPerfectFilterCmd+0x4c>)
     da2:	18d3      	adds	r3, r2, r3
     da4:	461a      	mov	r2, r3
     da6:	6879      	ldr	r1, [r7, #4]
     da8:	4b0b      	ldr	r3, [pc, #44]	; (dd8 <ETH_MACAddressPerfectFilterCmd+0x4c>)
     daa:	18cb      	adds	r3, r1, r3
     dac:	681b      	ldr	r3, [r3, #0]
     dae:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     db2:	6013      	str	r3, [r2, #0]
     db4:	e00a      	b.n	dcc <ETH_MACAddressPerfectFilterCmd+0x40>
  }
  else
  {
    /* Disable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
     db6:	687a      	ldr	r2, [r7, #4]
     db8:	4b07      	ldr	r3, [pc, #28]	; (dd8 <ETH_MACAddressPerfectFilterCmd+0x4c>)
     dba:	18d3      	adds	r3, r2, r3
     dbc:	461a      	mov	r2, r3
     dbe:	6879      	ldr	r1, [r7, #4]
     dc0:	4b05      	ldr	r3, [pc, #20]	; (dd8 <ETH_MACAddressPerfectFilterCmd+0x4c>)
     dc2:	18cb      	adds	r3, r1, r3
     dc4:	681b      	ldr	r3, [r3, #0]
     dc6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
     dca:	6013      	str	r3, [r2, #0]
  }
}
     dcc:	f107 070c 	add.w	r7, r7, #12
     dd0:	46bd      	mov	sp, r7
     dd2:	bc80      	pop	{r7}
     dd4:	4770      	bx	lr
     dd6:	bf00      	nop
     dd8:	40028040 	.word	0x40028040

00000ddc <ETH_MACAddressFilterConfig>:
  *     @arg ETH_MAC_AddressFilter_DA : MAC Address is used to compare with the
  *                                     DA fields of the received frame.
  * @retval None
  */
void ETH_MACAddressFilterConfig(uint32_t MacAddr, uint32_t Filter)
{
     ddc:	b480      	push	{r7}
     dde:	b083      	sub	sp, #12
     de0:	af00      	add	r7, sp, #0
     de2:	6078      	str	r0, [r7, #4]
     de4:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
  
  if (Filter != ETH_MAC_AddressFilter_DA)
     de6:	683b      	ldr	r3, [r7, #0]
     de8:	2b08      	cmp	r3, #8
     dea:	d00b      	beq.n	e04 <ETH_MACAddressFilterConfig+0x28>
  {
    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
     dec:	687a      	ldr	r2, [r7, #4]
     dee:	4b0d      	ldr	r3, [pc, #52]	; (e24 <ETH_MACAddressFilterConfig+0x48>)
     df0:	18d3      	adds	r3, r2, r3
     df2:	461a      	mov	r2, r3
     df4:	6879      	ldr	r1, [r7, #4]
     df6:	4b0b      	ldr	r3, [pc, #44]	; (e24 <ETH_MACAddressFilterConfig+0x48>)
     df8:	18cb      	adds	r3, r1, r3
     dfa:	681b      	ldr	r3, [r3, #0]
     dfc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
     e00:	6013      	str	r3, [r2, #0]
     e02:	e00a      	b.n	e1a <ETH_MACAddressFilterConfig+0x3e>
  }
  else
  {
    /* The selected ETHERNET MAC address is used to compare with the DA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
     e04:	687a      	ldr	r2, [r7, #4]
     e06:	4b07      	ldr	r3, [pc, #28]	; (e24 <ETH_MACAddressFilterConfig+0x48>)
     e08:	18d3      	adds	r3, r2, r3
     e0a:	461a      	mov	r2, r3
     e0c:	6879      	ldr	r1, [r7, #4]
     e0e:	4b05      	ldr	r3, [pc, #20]	; (e24 <ETH_MACAddressFilterConfig+0x48>)
     e10:	18cb      	adds	r3, r1, r3
     e12:	681b      	ldr	r3, [r3, #0]
     e14:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
     e18:	6013      	str	r3, [r2, #0]
  }
}
     e1a:	f107 070c 	add.w	r7, r7, #12
     e1e:	46bd      	mov	sp, r7
     e20:	bc80      	pop	{r7}
     e22:	4770      	bx	lr
     e24:	40028040 	.word	0x40028040

00000e28 <ETH_MACAddressMaskBytesFilterConfig>:
  *     @arg ETH_MAC_AddressMask_Byte2 : Mask MAC Address low reg bits [15:8].
  *     @arg ETH_MAC_AddressMask_Byte1 : Mask MAC Address low reg bits [7:0].
  * @retval None
  */
void ETH_MACAddressMaskBytesFilterConfig(uint32_t MacAddr, uint32_t MaskByte)
{
     e28:	b480      	push	{r7}
     e2a:	b083      	sub	sp, #12
     e2c:	af00      	add	r7, sp, #0
     e2e:	6078      	str	r0, [r7, #4]
     e30:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
  
  /* Clear MBC bits in the selected MAC address  high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
     e32:	687a      	ldr	r2, [r7, #4]
     e34:	4b0d      	ldr	r3, [pc, #52]	; (e6c <ETH_MACAddressMaskBytesFilterConfig+0x44>)
     e36:	18d3      	adds	r3, r2, r3
     e38:	461a      	mov	r2, r3
     e3a:	6879      	ldr	r1, [r7, #4]
     e3c:	4b0b      	ldr	r3, [pc, #44]	; (e6c <ETH_MACAddressMaskBytesFilterConfig+0x44>)
     e3e:	18cb      	adds	r3, r1, r3
     e40:	681b      	ldr	r3, [r3, #0]
     e42:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
     e46:	6013      	str	r3, [r2, #0]
  /* Set the selected Filetr mask bytes */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
     e48:	687a      	ldr	r2, [r7, #4]
     e4a:	4b08      	ldr	r3, [pc, #32]	; (e6c <ETH_MACAddressMaskBytesFilterConfig+0x44>)
     e4c:	18d3      	adds	r3, r2, r3
     e4e:	461a      	mov	r2, r3
     e50:	6879      	ldr	r1, [r7, #4]
     e52:	4b06      	ldr	r3, [pc, #24]	; (e6c <ETH_MACAddressMaskBytesFilterConfig+0x44>)
     e54:	18cb      	adds	r3, r1, r3
     e56:	6819      	ldr	r1, [r3, #0]
     e58:	683b      	ldr	r3, [r7, #0]
     e5a:	ea41 0303 	orr.w	r3, r1, r3
     e5e:	6013      	str	r3, [r2, #0]
}
     e60:	f107 070c 	add.w	r7, r7, #12
     e64:	46bd      	mov	sp, r7
     e66:	bc80      	pop	{r7}
     e68:	4770      	bx	lr
     e6a:	bf00      	nop
     e6c:	40028040 	.word	0x40028040

00000e70 <ETH_DMATxDescChainInit>:
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
     e70:	b480      	push	{r7}
     e72:	b087      	sub	sp, #28
     e74:	af00      	add	r7, sp, #0
     e76:	60f8      	str	r0, [r7, #12]
     e78:	60b9      	str	r1, [r7, #8]
     e7a:	607a      	str	r2, [r7, #4]
  uint32_t i = 0;
     e7c:	f04f 0300 	mov.w	r3, #0
     e80:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
     e82:	4b21      	ldr	r3, [pc, #132]	; (f08 <ETH_DMATxDescChainInit+0x98>)
     e84:	68fa      	ldr	r2, [r7, #12]
     e86:	601a      	str	r2, [r3, #0]
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
     e88:	f04f 0300 	mov.w	r3, #0
     e8c:	617b      	str	r3, [r7, #20]
     e8e:	e02b      	b.n	ee8 <ETH_DMATxDescChainInit+0x78>
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
     e90:	697b      	ldr	r3, [r7, #20]
     e92:	ea4f 1303 	mov.w	r3, r3, lsl #4
     e96:	68fa      	ldr	r2, [r7, #12]
     e98:	18d3      	adds	r3, r2, r3
     e9a:	613b      	str	r3, [r7, #16]
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
     e9c:	693b      	ldr	r3, [r7, #16]
     e9e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
     ea2:	601a      	str	r2, [r3, #0]
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
     ea4:	697b      	ldr	r3, [r7, #20]
     ea6:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
     eaa:	fb02 f303 	mul.w	r3, r2, r3
     eae:	68ba      	ldr	r2, [r7, #8]
     eb0:	18d3      	adds	r3, r2, r3
     eb2:	461a      	mov	r2, r3
     eb4:	693b      	ldr	r3, [r7, #16]
     eb6:	609a      	str	r2, [r3, #8]
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
     eb8:	687b      	ldr	r3, [r7, #4]
     eba:	f103 32ff 	add.w	r2, r3, #4294967295
     ebe:	697b      	ldr	r3, [r7, #20]
     ec0:	429a      	cmp	r2, r3
     ec2:	d90a      	bls.n	eda <ETH_DMATxDescChainInit+0x6a>
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
     ec4:	697b      	ldr	r3, [r7, #20]
     ec6:	f103 0301 	add.w	r3, r3, #1
     eca:	ea4f 1303 	mov.w	r3, r3, lsl #4
     ece:	68fa      	ldr	r2, [r7, #12]
     ed0:	18d3      	adds	r3, r2, r3
     ed2:	461a      	mov	r2, r3
     ed4:	693b      	ldr	r3, [r7, #16]
     ed6:	60da      	str	r2, [r3, #12]
     ed8:	e002      	b.n	ee0 <ETH_DMATxDescChainInit+0x70>
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
     eda:	68fa      	ldr	r2, [r7, #12]
     edc:	693b      	ldr	r3, [r7, #16]
     ede:	60da      	str	r2, [r3, #12]
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
     ee0:	697b      	ldr	r3, [r7, #20]
     ee2:	f103 0301 	add.w	r3, r3, #1
     ee6:	617b      	str	r3, [r7, #20]
     ee8:	697a      	ldr	r2, [r7, #20]
     eea:	687b      	ldr	r3, [r7, #4]
     eec:	429a      	cmp	r2, r3
     eee:	d3cf      	bcc.n	e90 <ETH_DMATxDescChainInit+0x20>
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
     ef0:	4b06      	ldr	r3, [pc, #24]	; (f0c <ETH_DMATxDescChainInit+0x9c>)
     ef2:	68fa      	ldr	r2, [r7, #12]
     ef4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     ef8:	f103 0310 	add.w	r3, r3, #16
     efc:	601a      	str	r2, [r3, #0]
}
     efe:	f107 071c 	add.w	r7, r7, #28
     f02:	46bd      	mov	sp, r7
     f04:	bc80      	pop	{r7}
     f06:	4770      	bx	lr
     f08:	00000000 	.word	0x00000000
			f08: R_ARM_ABS32	DMATxDescToSet
     f0c:	40028000 	.word	0x40028000

00000f10 <ETH_DMATxDescRingInit>:
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMATxDescRingInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t *TxBuff1, uint8_t *TxBuff2, uint32_t TxBuffCount)
{
     f10:	b480      	push	{r7}
     f12:	b087      	sub	sp, #28
     f14:	af00      	add	r7, sp, #0
     f16:	60f8      	str	r0, [r7, #12]
     f18:	60b9      	str	r1, [r7, #8]
     f1a:	607a      	str	r2, [r7, #4]
     f1c:	603b      	str	r3, [r7, #0]
  uint32_t i = 0;
     f1e:	f04f 0300 	mov.w	r3, #0
     f22:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
     f24:	4b1f      	ldr	r3, [pc, #124]	; (fa4 <ETH_DMATxDescRingInit+0x94>)
     f26:	68fa      	ldr	r2, [r7, #12]
     f28:	601a      	str	r2, [r3, #0]
  /* Fill each DMATxDesc descriptor with the right values */  
  for(i=0; i < TxBuffCount; i++)
     f2a:	f04f 0300 	mov.w	r3, #0
     f2e:	617b      	str	r3, [r7, #20]
     f30:	e027      	b.n	f82 <ETH_DMATxDescRingInit+0x72>
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
     f32:	697b      	ldr	r3, [r7, #20]
     f34:	ea4f 1303 	mov.w	r3, r3, lsl #4
     f38:	68fa      	ldr	r2, [r7, #12]
     f3a:	18d3      	adds	r3, r2, r3
     f3c:	613b      	str	r3, [r7, #16]
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff1[i*ETH_MAX_PACKET_SIZE]);
     f3e:	697b      	ldr	r3, [r7, #20]
     f40:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
     f44:	fb02 f303 	mul.w	r3, r2, r3
     f48:	68ba      	ldr	r2, [r7, #8]
     f4a:	18d3      	adds	r3, r2, r3
     f4c:	461a      	mov	r2, r3
     f4e:	693b      	ldr	r3, [r7, #16]
     f50:	609a      	str	r2, [r3, #8]
    
    /* Set Buffer2 address pointer */
    DMATxDesc->Buffer2NextDescAddr = (uint32_t)(&TxBuff2[i*ETH_MAX_PACKET_SIZE]);
     f52:	697b      	ldr	r3, [r7, #20]
     f54:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
     f58:	fb02 f303 	mul.w	r3, r2, r3
     f5c:	687a      	ldr	r2, [r7, #4]
     f5e:	18d3      	adds	r3, r2, r3
     f60:	461a      	mov	r2, r3
     f62:	693b      	ldr	r3, [r7, #16]
     f64:	60da      	str	r2, [r3, #12]
    
    /* Set Transmit End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (TxBuffCount-1))
     f66:	683b      	ldr	r3, [r7, #0]
     f68:	f103 32ff 	add.w	r2, r3, #4294967295
     f6c:	697b      	ldr	r3, [r7, #20]
     f6e:	429a      	cmp	r2, r3
     f70:	d103      	bne.n	f7a <ETH_DMATxDescRingInit+0x6a>
    {
      /* Set Transmit End of Ring bit */
      DMATxDesc->Status = ETH_DMATxDesc_TER;
     f72:	693b      	ldr	r3, [r7, #16]
     f74:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
     f78:	601a      	str	r2, [r3, #0]
  ETH_DMADESCTypeDef *DMATxDesc;
 
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */  
  for(i=0; i < TxBuffCount; i++)
     f7a:	697b      	ldr	r3, [r7, #20]
     f7c:	f103 0301 	add.w	r3, r3, #1
     f80:	617b      	str	r3, [r7, #20]
     f82:	697a      	ldr	r2, [r7, #20]
     f84:	683b      	ldr	r3, [r7, #0]
     f86:	429a      	cmp	r2, r3
     f88:	d3d3      	bcc.n	f32 <ETH_DMATxDescRingInit+0x22>
      DMATxDesc->Status = ETH_DMATxDesc_TER;
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR =  (uint32_t) DMATxDescTab;
     f8a:	4b07      	ldr	r3, [pc, #28]	; (fa8 <ETH_DMATxDescRingInit+0x98>)
     f8c:	68fa      	ldr	r2, [r7, #12]
     f8e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     f92:	f103 0310 	add.w	r3, r3, #16
     f96:	601a      	str	r2, [r3, #0]
}
     f98:	f107 071c 	add.w	r7, r7, #28
     f9c:	46bd      	mov	sp, r7
     f9e:	bc80      	pop	{r7}
     fa0:	4770      	bx	lr
     fa2:	bf00      	nop
     fa4:	00000000 	.word	0x00000000
			fa4: R_ARM_ABS32	DMATxDescToSet
     fa8:	40028000 	.word	0x40028000

00000fac <ETH_GetDMATxDescFlagStatus>:
  *     @arg ETH_DMATxDesc_UF  : Underflow Error: late data arrival from the memory
  *     @arg ETH_DMATxDesc_DB  : Deferred Bit
  * @retval The new state of ETH_DMATxDescFlag (SET or RESET).
  */
FlagStatus ETH_GetDMATxDescFlagStatus(ETH_DMADESCTypeDef *DMATxDesc, uint32_t ETH_DMATxDescFlag)
{
     fac:	b480      	push	{r7}
     fae:	b085      	sub	sp, #20
     fb0:	af00      	add	r7, sp, #0
     fb2:	6078      	str	r0, [r7, #4]
     fb4:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
     fb6:	f04f 0300 	mov.w	r3, #0
     fba:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_DMATxDESC_GET_FLAG(ETH_DMATxDescFlag));
  
  if ((DMATxDesc->Status & ETH_DMATxDescFlag) != (uint32_t)RESET)
     fbc:	687b      	ldr	r3, [r7, #4]
     fbe:	681a      	ldr	r2, [r3, #0]
     fc0:	683b      	ldr	r3, [r7, #0]
     fc2:	ea02 0303 	and.w	r3, r2, r3
     fc6:	2b00      	cmp	r3, #0
     fc8:	d003      	beq.n	fd2 <ETH_GetDMATxDescFlagStatus+0x26>
  {
    bitstatus = SET;
     fca:	f04f 0301 	mov.w	r3, #1
     fce:	73fb      	strb	r3, [r7, #15]
     fd0:	e002      	b.n	fd8 <ETH_GetDMATxDescFlagStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
     fd2:	f04f 0300 	mov.w	r3, #0
     fd6:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
     fd8:	7bfb      	ldrb	r3, [r7, #15]
}
     fda:	4618      	mov	r0, r3
     fdc:	f107 0714 	add.w	r7, r7, #20
     fe0:	46bd      	mov	sp, r7
     fe2:	bc80      	pop	{r7}
     fe4:	4770      	bx	lr
     fe6:	bf00      	nop

00000fe8 <ETH_GetDMATxDescCollisionCount>:
  * @brief  Returns the specified ETHERNET DMA Tx Desc collision count.
  * @param  DMATxDesc: pointer on a DMA Tx descriptor                     
  * @retval The Transmit descriptor collision counter value.
  */
uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
{
     fe8:	b480      	push	{r7}
     fea:	b083      	sub	sp, #12
     fec:	af00      	add	r7, sp, #0
     fee:	6078      	str	r0, [r7, #4]
  /* Return the Receive descriptor frame length */
  return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
     ff0:	687b      	ldr	r3, [r7, #4]
     ff2:	681b      	ldr	r3, [r3, #0]
     ff4:	f003 0378 	and.w	r3, r3, #120	; 0x78
     ff8:	ea4f 03d3 	mov.w	r3, r3, lsr #3
}
     ffc:	4618      	mov	r0, r3
     ffe:	f107 070c 	add.w	r7, r7, #12
    1002:	46bd      	mov	sp, r7
    1004:	bc80      	pop	{r7}
    1006:	4770      	bx	lr

00001008 <ETH_SetDMATxDescOwnBit>:
  * @brief  Set the specified DMA Tx Desc Own bit.
  * @param  DMATxDesc: Pointer on a Tx desc
  * @retval None
  */
void ETH_SetDMATxDescOwnBit(ETH_DMADESCTypeDef *DMATxDesc)
{
    1008:	b480      	push	{r7}
    100a:	b083      	sub	sp, #12
    100c:	af00      	add	r7, sp, #0
    100e:	6078      	str	r0, [r7, #4]
  /* Set the DMA Tx Desc Own bit */
  DMATxDesc->Status |= ETH_DMATxDesc_OWN;
    1010:	687b      	ldr	r3, [r7, #4]
    1012:	681b      	ldr	r3, [r3, #0]
    1014:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    1018:	687b      	ldr	r3, [r7, #4]
    101a:	601a      	str	r2, [r3, #0]
}
    101c:	f107 070c 	add.w	r7, r7, #12
    1020:	46bd      	mov	sp, r7
    1022:	bc80      	pop	{r7}
    1024:	4770      	bx	lr
    1026:	bf00      	nop

00001028 <ETH_DMATxDescTransmitITConfig>:
  * @param  NewState: new state of the DMA Tx Desc transmit interrupt.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    1028:	b480      	push	{r7}
    102a:	b083      	sub	sp, #12
    102c:	af00      	add	r7, sp, #0
    102e:	6078      	str	r0, [r7, #4]
    1030:	460b      	mov	r3, r1
    1032:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1034:	78fb      	ldrb	r3, [r7, #3]
    1036:	2b00      	cmp	r3, #0
    1038:	d006      	beq.n	1048 <ETH_DMATxDescTransmitITConfig+0x20>
  {
    /* Enable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status |= ETH_DMATxDesc_IC;
    103a:	687b      	ldr	r3, [r7, #4]
    103c:	681b      	ldr	r3, [r3, #0]
    103e:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    1042:	687b      	ldr	r3, [r7, #4]
    1044:	601a      	str	r2, [r3, #0]
    1046:	e005      	b.n	1054 <ETH_DMATxDescTransmitITConfig+0x2c>
  }
  else
  {
    /* Disable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
    1048:	687b      	ldr	r3, [r7, #4]
    104a:	681b      	ldr	r3, [r3, #0]
    104c:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    1050:	687b      	ldr	r3, [r7, #4]
    1052:	601a      	str	r2, [r3, #0]
  }
}
    1054:	f107 070c 	add.w	r7, r7, #12
    1058:	46bd      	mov	sp, r7
    105a:	bc80      	pop	{r7}
    105c:	4770      	bx	lr
    105e:	bf00      	nop

00001060 <ETH_DMATxDescFrameSegmentConfig>:
  *     @arg ETH_DMATxDesc_LastSegment  : actual Tx desc contain last segment 
  *     @arg ETH_DMATxDesc_FirstSegment : actual Tx desc contain first segment                   
  * @retval None
  */
void ETH_DMATxDescFrameSegmentConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_FrameSegment)
{
    1060:	b480      	push	{r7}
    1062:	b083      	sub	sp, #12
    1064:	af00      	add	r7, sp, #0
    1066:	6078      	str	r0, [r7, #4]
    1068:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_SEGMENT(DMATxDesc_FrameSegment));
  
  /* Selects the DMA Tx Desc Frame segment */
  DMATxDesc->Status |= DMATxDesc_FrameSegment;
    106a:	687b      	ldr	r3, [r7, #4]
    106c:	681a      	ldr	r2, [r3, #0]
    106e:	683b      	ldr	r3, [r7, #0]
    1070:	431a      	orrs	r2, r3
    1072:	687b      	ldr	r3, [r7, #4]
    1074:	601a      	str	r2, [r3, #0]
}
    1076:	f107 070c 	add.w	r7, r7, #12
    107a:	46bd      	mov	sp, r7
    107c:	bc80      	pop	{r7}
    107e:	4770      	bx	lr

00001080 <ETH_DMATxDescChecksumInsertionConfig>:
  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPSegment : TCP/UDP/ICMP checksum. Pseudo header checksum is assumed to be present
  *     @arg ETH_DMATxDesc_ChecksumTCPUDPICMPFull : TCP/UDP/ICMP checksum fully in hardware including pseudo header                                                                
  * @retval None
  */
void ETH_DMATxDescChecksumInsertionConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t DMATxDesc_Checksum)
{
    1080:	b480      	push	{r7}
    1082:	b083      	sub	sp, #12
    1084:	af00      	add	r7, sp, #0
    1086:	6078      	str	r0, [r7, #4]
    1088:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
  
  /* Set the selected DMA Tx desc checksum insertion control */
  DMATxDesc->Status |= DMATxDesc_Checksum;
    108a:	687b      	ldr	r3, [r7, #4]
    108c:	681a      	ldr	r2, [r3, #0]
    108e:	683b      	ldr	r3, [r7, #0]
    1090:	431a      	orrs	r2, r3
    1092:	687b      	ldr	r3, [r7, #4]
    1094:	601a      	str	r2, [r3, #0]
}
    1096:	f107 070c 	add.w	r7, r7, #12
    109a:	46bd      	mov	sp, r7
    109c:	bc80      	pop	{r7}
    109e:	4770      	bx	lr

000010a0 <ETH_DMATxDescCRCCmd>:
  * @param  NewState: new state of the specified DMA Tx Desc CRC.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    10a0:	b480      	push	{r7}
    10a2:	b083      	sub	sp, #12
    10a4:	af00      	add	r7, sp, #0
    10a6:	6078      	str	r0, [r7, #4]
    10a8:	460b      	mov	r3, r1
    10aa:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    10ac:	78fb      	ldrb	r3, [r7, #3]
    10ae:	2b00      	cmp	r3, #0
    10b0:	d006      	beq.n	10c0 <ETH_DMATxDescCRCCmd+0x20>
  {
    /* Enable the selected DMA Tx Desc CRC */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
    10b2:	687b      	ldr	r3, [r7, #4]
    10b4:	681b      	ldr	r3, [r3, #0]
    10b6:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
    10ba:	687b      	ldr	r3, [r7, #4]
    10bc:	601a      	str	r2, [r3, #0]
    10be:	e005      	b.n	10cc <ETH_DMATxDescCRCCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Tx Desc CRC */
    DMATxDesc->Status |= ETH_DMATxDesc_DC; 
    10c0:	687b      	ldr	r3, [r7, #4]
    10c2:	681b      	ldr	r3, [r3, #0]
    10c4:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
    10c8:	687b      	ldr	r3, [r7, #4]
    10ca:	601a      	str	r2, [r3, #0]
  }
}
    10cc:	f107 070c 	add.w	r7, r7, #12
    10d0:	46bd      	mov	sp, r7
    10d2:	bc80      	pop	{r7}
    10d4:	4770      	bx	lr
    10d6:	bf00      	nop

000010d8 <ETH_DMATxDescEndOfRingCmd>:
  * @param  NewState: new state of the specified DMA Tx Desc end of ring.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    10d8:	b480      	push	{r7}
    10da:	b083      	sub	sp, #12
    10dc:	af00      	add	r7, sp, #0
    10de:	6078      	str	r0, [r7, #4]
    10e0:	460b      	mov	r3, r1
    10e2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    10e4:	78fb      	ldrb	r3, [r7, #3]
    10e6:	2b00      	cmp	r3, #0
    10e8:	d006      	beq.n	10f8 <ETH_DMATxDescEndOfRingCmd+0x20>
  {
    /* Enable the selected DMA Tx Desc end of ring */
    DMATxDesc->Status |= ETH_DMATxDesc_TER;  
    10ea:	687b      	ldr	r3, [r7, #4]
    10ec:	681b      	ldr	r3, [r3, #0]
    10ee:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    10f2:	687b      	ldr	r3, [r7, #4]
    10f4:	601a      	str	r2, [r3, #0]
    10f6:	e005      	b.n	1104 <ETH_DMATxDescEndOfRingCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Tx Desc end of ring */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_TER); 
    10f8:	687b      	ldr	r3, [r7, #4]
    10fa:	681b      	ldr	r3, [r3, #0]
    10fc:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
    1100:	687b      	ldr	r3, [r7, #4]
    1102:	601a      	str	r2, [r3, #0]
  }
}
    1104:	f107 070c 	add.w	r7, r7, #12
    1108:	46bd      	mov	sp, r7
    110a:	bc80      	pop	{r7}
    110c:	4770      	bx	lr
    110e:	bf00      	nop

00001110 <ETH_DMATxDescSecondAddressChainedCmd>:
  * @param  NewState: new state of the specified DMA Tx Desc second address chained.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    1110:	b480      	push	{r7}
    1112:	b083      	sub	sp, #12
    1114:	af00      	add	r7, sp, #0
    1116:	6078      	str	r0, [r7, #4]
    1118:	460b      	mov	r3, r1
    111a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    111c:	78fb      	ldrb	r3, [r7, #3]
    111e:	2b00      	cmp	r3, #0
    1120:	d006      	beq.n	1130 <ETH_DMATxDescSecondAddressChainedCmd+0x20>
  {
    /* Enable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
    1122:	687b      	ldr	r3, [r7, #4]
    1124:	681b      	ldr	r3, [r3, #0]
    1126:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
    112a:	687b      	ldr	r3, [r7, #4]
    112c:	601a      	str	r2, [r3, #0]
    112e:	e005      	b.n	113c <ETH_DMATxDescSecondAddressChainedCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
    1130:	687b      	ldr	r3, [r7, #4]
    1132:	681b      	ldr	r3, [r3, #0]
    1134:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
    1138:	687b      	ldr	r3, [r7, #4]
    113a:	601a      	str	r2, [r3, #0]
  }
}
    113c:	f107 070c 	add.w	r7, r7, #12
    1140:	46bd      	mov	sp, r7
    1142:	bc80      	pop	{r7}
    1144:	4770      	bx	lr
    1146:	bf00      	nop

00001148 <ETH_DMATxDescShortFramePaddingCmd>:
  * @param  NewState: new state of the specified DMA Tx Desc padding for frame shorter than 64 bytes.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    1148:	b480      	push	{r7}
    114a:	b083      	sub	sp, #12
    114c:	af00      	add	r7, sp, #0
    114e:	6078      	str	r0, [r7, #4]
    1150:	460b      	mov	r3, r1
    1152:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1154:	78fb      	ldrb	r3, [r7, #3]
    1156:	2b00      	cmp	r3, #0
    1158:	d006      	beq.n	1168 <ETH_DMATxDescShortFramePaddingCmd+0x20>
  {
    /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
    115a:	687b      	ldr	r3, [r7, #4]
    115c:	681b      	ldr	r3, [r3, #0]
    115e:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
    1162:	687b      	ldr	r3, [r7, #4]
    1164:	601a      	str	r2, [r3, #0]
    1166:	e005      	b.n	1174 <ETH_DMATxDescShortFramePaddingCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
    DMATxDesc->Status |= ETH_DMATxDesc_DP; 
    1168:	687b      	ldr	r3, [r7, #4]
    116a:	681b      	ldr	r3, [r3, #0]
    116c:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    1170:	687b      	ldr	r3, [r7, #4]
    1172:	601a      	str	r2, [r3, #0]
  }
}
    1174:	f107 070c 	add.w	r7, r7, #12
    1178:	46bd      	mov	sp, r7
    117a:	bc80      	pop	{r7}
    117c:	4770      	bx	lr
    117e:	bf00      	nop

00001180 <ETH_DMATxDescTimeStampCmd>:
  * @param  NewState: new state of the specified DMA Tx Desc time stamp.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATxDescTimeStampCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
    1180:	b480      	push	{r7}
    1182:	b083      	sub	sp, #12
    1184:	af00      	add	r7, sp, #0
    1186:	6078      	str	r0, [r7, #4]
    1188:	460b      	mov	r3, r1
    118a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    118c:	78fb      	ldrb	r3, [r7, #3]
    118e:	2b00      	cmp	r3, #0
    1190:	d006      	beq.n	11a0 <ETH_DMATxDescTimeStampCmd+0x20>
  {
    /* Enable the selected DMA Tx Desc time stamp */
    DMATxDesc->Status |= ETH_DMATxDesc_TTSE;  
    1192:	687b      	ldr	r3, [r7, #4]
    1194:	681b      	ldr	r3, [r3, #0]
    1196:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    119a:	687b      	ldr	r3, [r7, #4]
    119c:	601a      	str	r2, [r3, #0]
    119e:	e005      	b.n	11ac <ETH_DMATxDescTimeStampCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Tx Desc time stamp */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TTSE); 
    11a0:	687b      	ldr	r3, [r7, #4]
    11a2:	681b      	ldr	r3, [r3, #0]
    11a4:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
    11a8:	687b      	ldr	r3, [r7, #4]
    11aa:	601a      	str	r2, [r3, #0]
  }
}
    11ac:	f107 070c 	add.w	r7, r7, #12
    11b0:	46bd      	mov	sp, r7
    11b2:	bc80      	pop	{r7}
    11b4:	4770      	bx	lr
    11b6:	bf00      	nop

000011b8 <ETH_DMATxDescBufferSizeConfig>:
  * @param  BufferSize1: specifies the Tx desc buffer1 size.
  * @param  BufferSize2: specifies the Tx desc buffer2 size (put "0" if not used).
  * @retval None
  */
void ETH_DMATxDescBufferSizeConfig(ETH_DMADESCTypeDef *DMATxDesc, uint32_t BufferSize1, uint32_t BufferSize2)
{
    11b8:	b480      	push	{r7}
    11ba:	b085      	sub	sp, #20
    11bc:	af00      	add	r7, sp, #0
    11be:	60f8      	str	r0, [r7, #12]
    11c0:	60b9      	str	r1, [r7, #8]
    11c2:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
  
  /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
  DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
    11c4:	68fb      	ldr	r3, [r7, #12]
    11c6:	685a      	ldr	r2, [r3, #4]
    11c8:	687b      	ldr	r3, [r7, #4]
    11ca:	ea4f 4103 	mov.w	r1, r3, lsl #16
    11ce:	68bb      	ldr	r3, [r7, #8]
    11d0:	ea41 0303 	orr.w	r3, r1, r3
    11d4:	431a      	orrs	r2, r3
    11d6:	68fb      	ldr	r3, [r7, #12]
    11d8:	605a      	str	r2, [r3, #4]
}
    11da:	f107 0714 	add.w	r7, r7, #20
    11de:	46bd      	mov	sp, r7
    11e0:	bc80      	pop	{r7}
    11e2:	4770      	bx	lr

000011e4 <ETH_DMARxDescChainInit>:
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
    11e4:	b480      	push	{r7}
    11e6:	b087      	sub	sp, #28
    11e8:	af00      	add	r7, sp, #0
    11ea:	60f8      	str	r0, [r7, #12]
    11ec:	60b9      	str	r1, [r7, #8]
    11ee:	607a      	str	r2, [r7, #4]
  uint32_t i = 0;
    11f0:	f04f 0300 	mov.w	r3, #0
    11f4:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
    11f6:	4b23      	ldr	r3, [pc, #140]	; (1284 <ETH_DMARxDescChainInit+0xa0>)
    11f8:	68fa      	ldr	r2, [r7, #12]
    11fa:	601a      	str	r2, [r3, #0]
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
    11fc:	f04f 0300 	mov.w	r3, #0
    1200:	617b      	str	r3, [r7, #20]
    1202:	e02f      	b.n	1264 <ETH_DMARxDescChainInit+0x80>
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    1204:	697b      	ldr	r3, [r7, #20]
    1206:	ea4f 1303 	mov.w	r3, r3, lsl #4
    120a:	68fa      	ldr	r2, [r7, #12]
    120c:	18d3      	adds	r3, r2, r3
    120e:	613b      	str	r3, [r7, #16]
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
    1210:	693b      	ldr	r3, [r7, #16]
    1212:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    1216:	601a      	str	r2, [r3, #0]

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
    1218:	693b      	ldr	r3, [r7, #16]
    121a:	f244 52f0 	movw	r2, #17904	; 0x45f0
    121e:	605a      	str	r2, [r3, #4]
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
    1220:	697b      	ldr	r3, [r7, #20]
    1222:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    1226:	fb02 f303 	mul.w	r3, r2, r3
    122a:	68ba      	ldr	r2, [r7, #8]
    122c:	18d3      	adds	r3, r2, r3
    122e:	461a      	mov	r2, r3
    1230:	693b      	ldr	r3, [r7, #16]
    1232:	609a      	str	r2, [r3, #8]
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
    1234:	687b      	ldr	r3, [r7, #4]
    1236:	f103 32ff 	add.w	r2, r3, #4294967295
    123a:	697b      	ldr	r3, [r7, #20]
    123c:	429a      	cmp	r2, r3
    123e:	d90a      	bls.n	1256 <ETH_DMARxDescChainInit+0x72>
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
    1240:	697b      	ldr	r3, [r7, #20]
    1242:	f103 0301 	add.w	r3, r3, #1
    1246:	ea4f 1303 	mov.w	r3, r3, lsl #4
    124a:	68fa      	ldr	r2, [r7, #12]
    124c:	18d3      	adds	r3, r2, r3
    124e:	461a      	mov	r2, r3
    1250:	693b      	ldr	r3, [r7, #16]
    1252:	60da      	str	r2, [r3, #12]
    1254:	e002      	b.n	125c <ETH_DMARxDescChainInit+0x78>
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    1256:	68fa      	ldr	r2, [r7, #12]
    1258:	693b      	ldr	r3, [r7, #16]
    125a:	60da      	str	r2, [r3, #12]
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
    125c:	697b      	ldr	r3, [r7, #20]
    125e:	f103 0301 	add.w	r3, r3, #1
    1262:	617b      	str	r3, [r7, #20]
    1264:	697a      	ldr	r2, [r7, #20]
    1266:	687b      	ldr	r3, [r7, #4]
    1268:	429a      	cmp	r2, r3
    126a:	d3cb      	bcc.n	1204 <ETH_DMARxDescChainInit+0x20>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }
   
  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
    126c:	4b06      	ldr	r3, [pc, #24]	; (1288 <ETH_DMARxDescChainInit+0xa4>)
    126e:	68fa      	ldr	r2, [r7, #12]
    1270:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1274:	f103 030c 	add.w	r3, r3, #12
    1278:	601a      	str	r2, [r3, #0]
}
    127a:	f107 071c 	add.w	r7, r7, #28
    127e:	46bd      	mov	sp, r7
    1280:	bc80      	pop	{r7}
    1282:	4770      	bx	lr
    1284:	00000000 	.word	0x00000000
			1284: R_ARM_ABS32	DMARxDescToGet
    1288:	40028000 	.word	0x40028000

0000128c <ETH_DMARxDescRingInit>:
  *   Note: see decriptor skip length defined in ETH_DMA_InitStruct
  *   for the number of Words to skip between two unchained descriptors.  
  * @retval None
  */
void ETH_DMARxDescRingInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff1, uint8_t *RxBuff2, uint32_t RxBuffCount)
{
    128c:	b480      	push	{r7}
    128e:	b087      	sub	sp, #28
    1290:	af00      	add	r7, sp, #0
    1292:	60f8      	str	r0, [r7, #12]
    1294:	60b9      	str	r1, [r7, #8]
    1296:	607a      	str	r2, [r7, #4]
    1298:	603b      	str	r3, [r7, #0]
  uint32_t i = 0;
    129a:	f04f 0300 	mov.w	r3, #0
    129e:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
    12a0:	4b24      	ldr	r3, [pc, #144]	; (1334 <ETH_DMARxDescRingInit+0xa8>)
    12a2:	68fa      	ldr	r2, [r7, #12]
    12a4:	601a      	str	r2, [r3, #0]
  /* Fill each DMARxDesc descriptor with the right values */  
  for(i=0; i < RxBuffCount; i++)
    12a6:	f04f 0300 	mov.w	r3, #0
    12aa:	617b      	str	r3, [r7, #20]
    12ac:	e031      	b.n	1312 <ETH_DMARxDescRingInit+0x86>
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i; 
    12ae:	697b      	ldr	r3, [r7, #20]
    12b0:	ea4f 1303 	mov.w	r3, r3, lsl #4
    12b4:	68fa      	ldr	r2, [r7, #12]
    12b6:	18d3      	adds	r3, r2, r3
    12b8:	613b      	str	r3, [r7, #16]
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN; 
    12ba:	693b      	ldr	r3, [r7, #16]
    12bc:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    12c0:	601a      	str	r2, [r3, #0]
    /* Set Buffer1 size */
    DMARxDesc->ControlBufferSize = ETH_MAX_PACKET_SIZE;  
    12c2:	693b      	ldr	r3, [r7, #16]
    12c4:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    12c8:	605a      	str	r2, [r3, #4]
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff1[i*ETH_MAX_PACKET_SIZE]); 
    12ca:	697b      	ldr	r3, [r7, #20]
    12cc:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    12d0:	fb02 f303 	mul.w	r3, r2, r3
    12d4:	68ba      	ldr	r2, [r7, #8]
    12d6:	18d3      	adds	r3, r2, r3
    12d8:	461a      	mov	r2, r3
    12da:	693b      	ldr	r3, [r7, #16]
    12dc:	609a      	str	r2, [r3, #8]
    
    /* Set Buffer2 address pointer */
    DMARxDesc->Buffer2NextDescAddr = (uint32_t)(&RxBuff2[i*ETH_MAX_PACKET_SIZE]); 
    12de:	697b      	ldr	r3, [r7, #20]
    12e0:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    12e4:	fb02 f303 	mul.w	r3, r2, r3
    12e8:	687a      	ldr	r2, [r7, #4]
    12ea:	18d3      	adds	r3, r2, r3
    12ec:	461a      	mov	r2, r3
    12ee:	693b      	ldr	r3, [r7, #16]
    12f0:	60da      	str	r2, [r3, #12]
    
    /* Set Receive End of Ring bit for last descriptor: The DMA returns to the base
       address of the list, creating a Desciptor Ring */
    if(i == (RxBuffCount-1))
    12f2:	683b      	ldr	r3, [r7, #0]
    12f4:	f103 32ff 	add.w	r2, r3, #4294967295
    12f8:	697b      	ldr	r3, [r7, #20]
    12fa:	429a      	cmp	r2, r3
    12fc:	d105      	bne.n	130a <ETH_DMARxDescRingInit+0x7e>
    {
      /* Set Receive End of Ring bit */
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
    12fe:	693b      	ldr	r3, [r7, #16]
    1300:	685b      	ldr	r3, [r3, #4]
    1302:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
    1306:	693b      	ldr	r3, [r7, #16]
    1308:	605a      	str	r2, [r3, #4]
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */  
  for(i=0; i < RxBuffCount; i++)
    130a:	697b      	ldr	r3, [r7, #20]
    130c:	f103 0301 	add.w	r3, r3, #1
    1310:	617b      	str	r3, [r7, #20]
    1312:	697a      	ldr	r2, [r7, #20]
    1314:	683b      	ldr	r3, [r7, #0]
    1316:	429a      	cmp	r2, r3
    1318:	d3c9      	bcc.n	12ae <ETH_DMARxDescRingInit+0x22>
      DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;
    }
  }
   
  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
    131a:	4b07      	ldr	r3, [pc, #28]	; (1338 <ETH_DMARxDescRingInit+0xac>)
    131c:	68fa      	ldr	r2, [r7, #12]
    131e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1322:	f103 030c 	add.w	r3, r3, #12
    1326:	601a      	str	r2, [r3, #0]
}
    1328:	f107 071c 	add.w	r7, r7, #28
    132c:	46bd      	mov	sp, r7
    132e:	bc80      	pop	{r7}
    1330:	4770      	bx	lr
    1332:	bf00      	nop
    1334:	00000000 	.word	0x00000000
			1334: R_ARM_ABS32	DMARxDescToGet
    1338:	40028000 	.word	0x40028000

0000133c <ETH_GetDMARxDescFlagStatus>:
  *     @arg ETH_DMARxDesc_CE:          CRC error
  *     @arg ETH_DMARxDesc_MAMPCE:      Rx MAC Address/Payload Checksum Error: Rx MAC address matched/ Rx Payload Checksum Error
  * @retval The new state of ETH_DMARxDescFlag (SET or RESET).
  */
FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
{
    133c:	b480      	push	{r7}
    133e:	b085      	sub	sp, #20
    1340:	af00      	add	r7, sp, #0
    1342:	6078      	str	r0, [r7, #4]
    1344:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
    1346:	f04f 0300 	mov.w	r3, #0
    134a:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
  if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
    134c:	687b      	ldr	r3, [r7, #4]
    134e:	681a      	ldr	r2, [r3, #0]
    1350:	683b      	ldr	r3, [r7, #0]
    1352:	ea02 0303 	and.w	r3, r2, r3
    1356:	2b00      	cmp	r3, #0
    1358:	d003      	beq.n	1362 <ETH_GetDMARxDescFlagStatus+0x26>
  {
    bitstatus = SET;
    135a:	f04f 0301 	mov.w	r3, #1
    135e:	73fb      	strb	r3, [r7, #15]
    1360:	e002      	b.n	1368 <ETH_GetDMARxDescFlagStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
    1362:	f04f 0300 	mov.w	r3, #0
    1366:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
    1368:	7bfb      	ldrb	r3, [r7, #15]
}
    136a:	4618      	mov	r0, r3
    136c:	f107 0714 	add.w	r7, r7, #20
    1370:	46bd      	mov	sp, r7
    1372:	bc80      	pop	{r7}
    1374:	4770      	bx	lr
    1376:	bf00      	nop

00001378 <ETH_SetDMARxDescOwnBit>:
  * @brief  Set the specified DMA Rx Desc Own bit.
  * @param  DMARxDesc: Pointer on a Rx desc
  * @retval None
  */
void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
{
    1378:	b480      	push	{r7}
    137a:	b083      	sub	sp, #12
    137c:	af00      	add	r7, sp, #0
    137e:	6078      	str	r0, [r7, #4]
  /* Set the DMA Rx Desc Own bit */
  DMARxDesc->Status |= ETH_DMARxDesc_OWN;
    1380:	687b      	ldr	r3, [r7, #4]
    1382:	681b      	ldr	r3, [r3, #0]
    1384:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    1388:	687b      	ldr	r3, [r7, #4]
    138a:	601a      	str	r2, [r3, #0]
}
    138c:	f107 070c 	add.w	r7, r7, #12
    1390:	46bd      	mov	sp, r7
    1392:	bc80      	pop	{r7}
    1394:	4770      	bx	lr
    1396:	bf00      	nop

00001398 <ETH_GetDMARxDescFrameLength>:
  * @brief  Returns the specified DMA Rx Desc frame length.
  * @param  DMARxDesc: pointer on a DMA Rx descriptor                     
  * @retval The Rx descriptor received frame length.
  */
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
{
    1398:	b480      	push	{r7}
    139a:	b083      	sub	sp, #12
    139c:	af00      	add	r7, sp, #0
    139e:	6078      	str	r0, [r7, #4]
  /* Return the Receive descriptor frame length */
  return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
    13a0:	687b      	ldr	r3, [r7, #4]
    13a2:	681a      	ldr	r2, [r3, #0]
    13a4:	4b05      	ldr	r3, [pc, #20]	; (13bc <ETH_GetDMARxDescFrameLength+0x24>)
    13a6:	ea02 0303 	and.w	r3, r2, r3
    13aa:	ea4f 4313 	mov.w	r3, r3, lsr #16
}
    13ae:	4618      	mov	r0, r3
    13b0:	f107 070c 	add.w	r7, r7, #12
    13b4:	46bd      	mov	sp, r7
    13b6:	bc80      	pop	{r7}
    13b8:	4770      	bx	lr
    13ba:	bf00      	nop
    13bc:	3fff0000 	.word	0x3fff0000

000013c0 <ETH_DMARxDescReceiveITConfig>:
  * @param  NewState: new state of the specified DMA Rx Desc interrupt.
  *   This parameter can be: ENABLE or DISABLE.                   
  * @retval None
  */
void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
    13c0:	b480      	push	{r7}
    13c2:	b083      	sub	sp, #12
    13c4:	af00      	add	r7, sp, #0
    13c6:	6078      	str	r0, [r7, #4]
    13c8:	460b      	mov	r3, r1
    13ca:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    13cc:	78fb      	ldrb	r3, [r7, #3]
    13ce:	2b00      	cmp	r3, #0
    13d0:	d006      	beq.n	13e0 <ETH_DMARxDescReceiveITConfig+0x20>
  {
    /* Enable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
    13d2:	687b      	ldr	r3, [r7, #4]
    13d4:	685b      	ldr	r3, [r3, #4]
    13d6:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    13da:	687b      	ldr	r3, [r7, #4]
    13dc:	605a      	str	r2, [r3, #4]
    13de:	e005      	b.n	13ec <ETH_DMARxDescReceiveITConfig+0x2c>
  }
  else
  {
    /* Disable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
    13e0:	687b      	ldr	r3, [r7, #4]
    13e2:	685b      	ldr	r3, [r3, #4]
    13e4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    13e8:	687b      	ldr	r3, [r7, #4]
    13ea:	605a      	str	r2, [r3, #4]
  }
}
    13ec:	f107 070c 	add.w	r7, r7, #12
    13f0:	46bd      	mov	sp, r7
    13f2:	bc80      	pop	{r7}
    13f4:	4770      	bx	lr
    13f6:	bf00      	nop

000013f8 <ETH_DMARxDescEndOfRingCmd>:
  * @param  NewState: new state of the specified DMA Rx Desc end of ring.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMARxDescEndOfRingCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
    13f8:	b480      	push	{r7}
    13fa:	b083      	sub	sp, #12
    13fc:	af00      	add	r7, sp, #0
    13fe:	6078      	str	r0, [r7, #4]
    1400:	460b      	mov	r3, r1
    1402:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1404:	78fb      	ldrb	r3, [r7, #3]
    1406:	2b00      	cmp	r3, #0
    1408:	d006      	beq.n	1418 <ETH_DMARxDescEndOfRingCmd+0x20>
  {
    /* Enable the selected DMA Rx Desc end of ring */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RER;  
    140a:	687b      	ldr	r3, [r7, #4]
    140c:	685b      	ldr	r3, [r3, #4]
    140e:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
    1412:	687b      	ldr	r3, [r7, #4]
    1414:	605a      	str	r2, [r3, #4]
    1416:	e005      	b.n	1424 <ETH_DMARxDescEndOfRingCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Rx Desc end of ring */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_RER); 
    1418:	687b      	ldr	r3, [r7, #4]
    141a:	685b      	ldr	r3, [r3, #4]
    141c:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
    1420:	687b      	ldr	r3, [r7, #4]
    1422:	605a      	str	r2, [r3, #4]
  }
}
    1424:	f107 070c 	add.w	r7, r7, #12
    1428:	46bd      	mov	sp, r7
    142a:	bc80      	pop	{r7}
    142c:	4770      	bx	lr
    142e:	bf00      	nop

00001430 <ETH_DMARxDescSecondAddressChainedCmd>:
  * @param  NewState: new state of the specified DMA Rx Desc second address chained.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMARxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
    1430:	b480      	push	{r7}
    1432:	b083      	sub	sp, #12
    1434:	af00      	add	r7, sp, #0
    1436:	6078      	str	r0, [r7, #4]
    1438:	460b      	mov	r3, r1
    143a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    143c:	78fb      	ldrb	r3, [r7, #3]
    143e:	2b00      	cmp	r3, #0
    1440:	d006      	beq.n	1450 <ETH_DMARxDescSecondAddressChainedCmd+0x20>
  {
    /* Enable the selected DMA Rx Desc second address chained */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_RCH;  
    1442:	687b      	ldr	r3, [r7, #4]
    1444:	685b      	ldr	r3, [r3, #4]
    1446:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
    144a:	687b      	ldr	r3, [r7, #4]
    144c:	605a      	str	r2, [r3, #4]
    144e:	e005      	b.n	145c <ETH_DMARxDescSecondAddressChainedCmd+0x2c>
  }
  else
  {
    /* Disable the selected DMA Rx Desc second address chained */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_RCH); 
    1450:	687b      	ldr	r3, [r7, #4]
    1452:	685b      	ldr	r3, [r3, #4]
    1454:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
    1458:	687b      	ldr	r3, [r7, #4]
    145a:	605a      	str	r2, [r3, #4]
  }
}
    145c:	f107 070c 	add.w	r7, r7, #12
    1460:	46bd      	mov	sp, r7
    1462:	bc80      	pop	{r7}
    1464:	4770      	bx	lr
    1466:	bf00      	nop

00001468 <ETH_GetDMARxDescBufferSize>:
  *     @arg ETH_DMARxDesc_Buffer1 : DMA Rx Desc Buffer1
  *     @arg ETH_DMARxDesc_Buffer2 : DMA Rx Desc Buffer2                     
  * @retval The Receive descriptor frame length.
  */
uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
{
    1468:	b480      	push	{r7}
    146a:	b083      	sub	sp, #12
    146c:	af00      	add	r7, sp, #0
    146e:	6078      	str	r0, [r7, #4]
    1470:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
  
  if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
    1472:	683b      	ldr	r3, [r7, #0]
    1474:	2b00      	cmp	r3, #0
    1476:	d007      	beq.n	1488 <ETH_GetDMARxDescBufferSize+0x20>
  {
    /* Return the DMA Rx Desc buffer2 size */
    return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
    1478:	687b      	ldr	r3, [r7, #4]
    147a:	685a      	ldr	r2, [r3, #4]
    147c:	4b08      	ldr	r3, [pc, #32]	; (14a0 <ETH_GetDMARxDescBufferSize+0x38>)
    147e:	ea02 0303 	and.w	r3, r2, r3
    1482:	ea4f 4313 	mov.w	r3, r3, lsr #16
    1486:	e005      	b.n	1494 <ETH_GetDMARxDescBufferSize+0x2c>
  }
  else
  {
    /* Return the DMA Rx Desc buffer1 size */
    return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
    1488:	687b      	ldr	r3, [r7, #4]
    148a:	685b      	ldr	r3, [r3, #4]
    148c:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    1490:	ea4f 43d3 	mov.w	r3, r3, lsr #19
  }
}
    1494:	4618      	mov	r0, r3
    1496:	f107 070c 	add.w	r7, r7, #12
    149a:	46bd      	mov	sp, r7
    149c:	bc80      	pop	{r7}
    149e:	4770      	bx	lr
    14a0:	1fff0000 	.word	0x1fff0000

000014a4 <ETH_SoftwareReset>:
  * @brief  Resets all MAC subsystem internal registers and logic.
  * @param  None
  * @retval None
  */
void ETH_SoftwareReset(void)
{
    14a4:	b480      	push	{r7}
    14a6:	af00      	add	r7, sp, #0
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  ETH->DMABMR |= ETH_DMABMR_SR;
    14a8:	4b06      	ldr	r3, [pc, #24]	; (14c4 <ETH_SoftwareReset+0x20>)
    14aa:	4a06      	ldr	r2, [pc, #24]	; (14c4 <ETH_SoftwareReset+0x20>)
    14ac:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    14b0:	6812      	ldr	r2, [r2, #0]
    14b2:	f042 0201 	orr.w	r2, r2, #1
    14b6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    14ba:	601a      	str	r2, [r3, #0]
}
    14bc:	46bd      	mov	sp, r7
    14be:	bc80      	pop	{r7}
    14c0:	4770      	bx	lr
    14c2:	bf00      	nop
    14c4:	40028000 	.word	0x40028000

000014c8 <ETH_GetSoftwareResetStatus>:
  * @brief  Checks whether the ETHERNET software reset bit is set or not.
  * @param  None
  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
  */
FlagStatus ETH_GetSoftwareResetStatus(void)
{
    14c8:	b480      	push	{r7}
    14ca:	b083      	sub	sp, #12
    14cc:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
    14ce:	f04f 0300 	mov.w	r3, #0
    14d2:	71fb      	strb	r3, [r7, #7]
  if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
    14d4:	4b0b      	ldr	r3, [pc, #44]	; (1504 <ETH_GetSoftwareResetStatus+0x3c>)
    14d6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    14da:	681b      	ldr	r3, [r3, #0]
    14dc:	f003 0301 	and.w	r3, r3, #1
    14e0:	b2db      	uxtb	r3, r3
    14e2:	2b00      	cmp	r3, #0
    14e4:	d003      	beq.n	14ee <ETH_GetSoftwareResetStatus+0x26>
  {
    bitstatus = SET;
    14e6:	f04f 0301 	mov.w	r3, #1
    14ea:	71fb      	strb	r3, [r7, #7]
    14ec:	e002      	b.n	14f4 <ETH_GetSoftwareResetStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
    14ee:	f04f 0300 	mov.w	r3, #0
    14f2:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus;
    14f4:	79fb      	ldrb	r3, [r7, #7]
}
    14f6:	4618      	mov	r0, r3
    14f8:	f107 070c 	add.w	r7, r7, #12
    14fc:	46bd      	mov	sp, r7
    14fe:	bc80      	pop	{r7}
    1500:	4770      	bx	lr
    1502:	bf00      	nop
    1504:	40028000 	.word	0x40028000

00001508 <ETH_GetDMAFlagStatus>:
  *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
  *     @arg ETH_DMA_FLAG_T   : Transmit flag 
  * @retval The new state of ETH_DMA_FLAG (SET or RESET).
  */
FlagStatus ETH_GetDMAFlagStatus(uint32_t ETH_DMA_FLAG)
{  
    1508:	b480      	push	{r7}
    150a:	b085      	sub	sp, #20
    150c:	af00      	add	r7, sp, #0
    150e:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
    1510:	f04f 0300 	mov.w	r3, #0
    1514:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_FLAG));
  if ((ETH->DMASR & ETH_DMA_FLAG) != (uint32_t)RESET)
    1516:	4b0c      	ldr	r3, [pc, #48]	; (1548 <ETH_GetDMAFlagStatus+0x40>)
    1518:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    151c:	f103 0314 	add.w	r3, r3, #20
    1520:	681a      	ldr	r2, [r3, #0]
    1522:	687b      	ldr	r3, [r7, #4]
    1524:	ea02 0303 	and.w	r3, r2, r3
    1528:	2b00      	cmp	r3, #0
    152a:	d003      	beq.n	1534 <ETH_GetDMAFlagStatus+0x2c>
  {
    bitstatus = SET;
    152c:	f04f 0301 	mov.w	r3, #1
    1530:	73fb      	strb	r3, [r7, #15]
    1532:	e002      	b.n	153a <ETH_GetDMAFlagStatus+0x32>
  }
  else
  {
    bitstatus = RESET;
    1534:	f04f 0300 	mov.w	r3, #0
    1538:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
    153a:	7bfb      	ldrb	r3, [r7, #15]
}
    153c:	4618      	mov	r0, r3
    153e:	f107 0714 	add.w	r7, r7, #20
    1542:	46bd      	mov	sp, r7
    1544:	bc80      	pop	{r7}
    1546:	4770      	bx	lr
    1548:	40028000 	.word	0x40028000

0000154c <ETH_DMAClearFlag>:
  *     @arg ETH_DMA_FLAG_TPS : Transmit process stopped flag 
  *     @arg ETH_DMA_FLAG_T   : Transmit flag
  * @retval None
  */
void ETH_DMAClearFlag(uint32_t ETH_DMA_FLAG)
{
    154c:	b480      	push	{r7}
    154e:	b083      	sub	sp, #12
    1550:	af00      	add	r7, sp, #0
    1552:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_FLAG(ETH_DMA_FLAG));
  
  /* Clear the selected ETHERNET DMA FLAG */
  ETH->DMASR = (uint32_t) ETH_DMA_FLAG;
    1554:	4b05      	ldr	r3, [pc, #20]	; (156c <ETH_DMAClearFlag+0x20>)
    1556:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    155a:	f103 0314 	add.w	r3, r3, #20
    155e:	687a      	ldr	r2, [r7, #4]
    1560:	601a      	str	r2, [r3, #0]
}
    1562:	f107 070c 	add.w	r7, r7, #12
    1566:	46bd      	mov	sp, r7
    1568:	bc80      	pop	{r7}
    156a:	4770      	bx	lr
    156c:	40028000 	.word	0x40028000

00001570 <ETH_GetDMAITStatus>:
  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
  *     @arg ETH_DMA_IT_T   : Transmit interrupt 
  * @retval The new state of ETH_DMA_IT (SET or RESET).
  */
ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
{  
    1570:	b480      	push	{r7}
    1572:	b085      	sub	sp, #20
    1574:	af00      	add	r7, sp, #0
    1576:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
    1578:	f04f 0300 	mov.w	r3, #0
    157c:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
  if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
    157e:	4b0c      	ldr	r3, [pc, #48]	; (15b0 <ETH_GetDMAITStatus+0x40>)
    1580:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1584:	f103 0314 	add.w	r3, r3, #20
    1588:	681a      	ldr	r2, [r3, #0]
    158a:	687b      	ldr	r3, [r7, #4]
    158c:	ea02 0303 	and.w	r3, r2, r3
    1590:	2b00      	cmp	r3, #0
    1592:	d003      	beq.n	159c <ETH_GetDMAITStatus+0x2c>
  {
    bitstatus = SET;
    1594:	f04f 0301 	mov.w	r3, #1
    1598:	73fb      	strb	r3, [r7, #15]
    159a:	e002      	b.n	15a2 <ETH_GetDMAITStatus+0x32>
  }
  else
  {
    bitstatus = RESET;
    159c:	f04f 0300 	mov.w	r3, #0
    15a0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
    15a2:	7bfb      	ldrb	r3, [r7, #15]
}
    15a4:	4618      	mov	r0, r3
    15a6:	f107 0714 	add.w	r7, r7, #20
    15aa:	46bd      	mov	sp, r7
    15ac:	bc80      	pop	{r7}
    15ae:	4770      	bx	lr
    15b0:	40028000 	.word	0x40028000

000015b4 <ETH_DMAClearITPendingBit>:
  *     @arg ETH_DMA_IT_TPS : Transmit process stopped interrupt 
  *     @arg ETH_DMA_IT_T   : Transmit interrupt
  * @retval None
  */
void ETH_DMAClearITPendingBit(uint32_t ETH_DMA_IT)
{
    15b4:	b480      	push	{r7}
    15b6:	b083      	sub	sp, #12
    15b8:	af00      	add	r7, sp, #0
    15ba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  
  /* Clear the selected ETHERNET DMA IT */
  ETH->DMASR = (uint32_t) ETH_DMA_IT;
    15bc:	4b05      	ldr	r3, [pc, #20]	; (15d4 <ETH_DMAClearITPendingBit+0x20>)
    15be:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    15c2:	f103 0314 	add.w	r3, r3, #20
    15c6:	687a      	ldr	r2, [r7, #4]
    15c8:	601a      	str	r2, [r3, #0]
}
    15ca:	f107 070c 	add.w	r7, r7, #12
    15ce:	46bd      	mov	sp, r7
    15d0:	bc80      	pop	{r7}
    15d2:	4770      	bx	lr
    15d4:	40028000 	.word	0x40028000

000015d8 <ETH_GetTransmitProcessState>:
  *     - ETH_DMA_TransmitProcess_Reading   : unning - reading the data from host memory
  *     - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Desciptor unavailabe
  *     - ETH_DMA_TransmitProcess_Closing   : Running - closing Rx descriptor  
  */
uint32_t ETH_GetTransmitProcessState(void)
{
    15d8:	b480      	push	{r7}
    15da:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
    15dc:	4b05      	ldr	r3, [pc, #20]	; (15f4 <ETH_GetTransmitProcessState+0x1c>)
    15de:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    15e2:	f103 0314 	add.w	r3, r3, #20
    15e6:	681b      	ldr	r3, [r3, #0]
    15e8:	f003 0301 	and.w	r3, r3, #1
}
    15ec:	4618      	mov	r0, r3
    15ee:	46bd      	mov	sp, r7
    15f0:	bc80      	pop	{r7}
    15f2:	4770      	bx	lr
    15f4:	40028000 	.word	0x40028000

000015f8 <ETH_GetReceiveProcessState>:
  *     - ETH_DMA_ReceiveProcess_Suspended : Suspended - Rx Desciptor unavailable
  *     - ETH_DMA_ReceiveProcess_Closing   : Running - closing descriptor
  *     - ETH_DMA_ReceiveProcess_Queuing   : Running - queuing the recieve frame into host memory  
  */
uint32_t ETH_GetReceiveProcessState(void)
{
    15f8:	b480      	push	{r7}
    15fa:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
    15fc:	4b05      	ldr	r3, [pc, #20]	; (1614 <ETH_GetReceiveProcessState+0x1c>)
    15fe:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1602:	f103 0314 	add.w	r3, r3, #20
    1606:	681b      	ldr	r3, [r3, #0]
    1608:	f003 0340 	and.w	r3, r3, #64	; 0x40
}
    160c:	4618      	mov	r0, r3
    160e:	46bd      	mov	sp, r7
    1610:	bc80      	pop	{r7}
    1612:	4770      	bx	lr
    1614:	40028000 	.word	0x40028000

00001618 <ETH_FlushTransmitFIFO>:
  * @brief  Clears the ETHERNET transmit FIFO.
  * @param  None                
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
    1618:	b480      	push	{r7}
    161a:	af00      	add	r7, sp, #0
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
    161c:	4908      	ldr	r1, [pc, #32]	; (1640 <ETH_FlushTransmitFIFO+0x28>)
    161e:	4b08      	ldr	r3, [pc, #32]	; (1640 <ETH_FlushTransmitFIFO+0x28>)
    1620:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1624:	f103 0318 	add.w	r3, r3, #24
    1628:	681b      	ldr	r3, [r3, #0]
    162a:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
    162e:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    1632:	f103 0318 	add.w	r3, r3, #24
    1636:	601a      	str	r2, [r3, #0]
}
    1638:	46bd      	mov	sp, r7
    163a:	bc80      	pop	{r7}
    163c:	4770      	bx	lr
    163e:	bf00      	nop
    1640:	40028000 	.word	0x40028000

00001644 <ETH_GetFlushTransmitFIFOStatus>:
  * @brief  Checks whether the ETHERNET transmit FIFO bit is cleared or not.
  * @param  None                
  * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET).
  */
FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
{   
    1644:	b480      	push	{r7}
    1646:	b083      	sub	sp, #12
    1648:	af00      	add	r7, sp, #0
  FlagStatus bitstatus = RESET;
    164a:	f04f 0300 	mov.w	r3, #0
    164e:	71fb      	strb	r3, [r7, #7]
  if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
    1650:	4b0b      	ldr	r3, [pc, #44]	; (1680 <ETH_GetFlushTransmitFIFOStatus+0x3c>)
    1652:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1656:	f103 0318 	add.w	r3, r3, #24
    165a:	681b      	ldr	r3, [r3, #0]
    165c:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    1660:	2b00      	cmp	r3, #0
    1662:	d003      	beq.n	166c <ETH_GetFlushTransmitFIFOStatus+0x28>
  {
    bitstatus = SET;
    1664:	f04f 0301 	mov.w	r3, #1
    1668:	71fb      	strb	r3, [r7, #7]
    166a:	e002      	b.n	1672 <ETH_GetFlushTransmitFIFOStatus+0x2e>
  }
  else
  {
    bitstatus = RESET;
    166c:	f04f 0300 	mov.w	r3, #0
    1670:	71fb      	strb	r3, [r7, #7]
  }
  return bitstatus; 
    1672:	79fb      	ldrb	r3, [r7, #7]
}
    1674:	4618      	mov	r0, r3
    1676:	f107 070c 	add.w	r7, r7, #12
    167a:	46bd      	mov	sp, r7
    167c:	bc80      	pop	{r7}
    167e:	4770      	bx	lr
    1680:	40028000 	.word	0x40028000

00001684 <ETH_DMATransmissionCmd>:
  * @param  NewState: new state of the DMA transmission.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMATransmissionCmd(FunctionalState NewState)
{ 
    1684:	b480      	push	{r7}
    1686:	b083      	sub	sp, #12
    1688:	af00      	add	r7, sp, #0
    168a:	4603      	mov	r3, r0
    168c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    168e:	79fb      	ldrb	r3, [r7, #7]
    1690:	2b00      	cmp	r3, #0
    1692:	d00e      	beq.n	16b2 <ETH_DMATransmissionCmd+0x2e>
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
    1694:	4910      	ldr	r1, [pc, #64]	; (16d8 <ETH_DMATransmissionCmd+0x54>)
    1696:	4b10      	ldr	r3, [pc, #64]	; (16d8 <ETH_DMATransmissionCmd+0x54>)
    1698:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    169c:	f103 0318 	add.w	r3, r3, #24
    16a0:	681b      	ldr	r3, [r3, #0]
    16a2:	f443 5200 	orr.w	r2, r3, #8192	; 0x2000
    16a6:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    16aa:	f103 0318 	add.w	r3, r3, #24
    16ae:	601a      	str	r2, [r3, #0]
    16b0:	e00d      	b.n	16ce <ETH_DMATransmissionCmd+0x4a>
  }
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
    16b2:	4909      	ldr	r1, [pc, #36]	; (16d8 <ETH_DMATransmissionCmd+0x54>)
    16b4:	4b08      	ldr	r3, [pc, #32]	; (16d8 <ETH_DMATransmissionCmd+0x54>)
    16b6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    16ba:	f103 0318 	add.w	r3, r3, #24
    16be:	681b      	ldr	r3, [r3, #0]
    16c0:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
    16c4:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    16c8:	f103 0318 	add.w	r3, r3, #24
    16cc:	601a      	str	r2, [r3, #0]
  }
}
    16ce:	f107 070c 	add.w	r7, r7, #12
    16d2:	46bd      	mov	sp, r7
    16d4:	bc80      	pop	{r7}
    16d6:	4770      	bx	lr
    16d8:	40028000 	.word	0x40028000

000016dc <ETH_DMAReceptionCmd>:
  * @param  NewState: new state of the DMA reception.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAReceptionCmd(FunctionalState NewState)
{ 
    16dc:	b480      	push	{r7}
    16de:	b083      	sub	sp, #12
    16e0:	af00      	add	r7, sp, #0
    16e2:	4603      	mov	r3, r0
    16e4:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    16e6:	79fb      	ldrb	r3, [r7, #7]
    16e8:	2b00      	cmp	r3, #0
    16ea:	d00e      	beq.n	170a <ETH_DMAReceptionCmd+0x2e>
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
    16ec:	4910      	ldr	r1, [pc, #64]	; (1730 <ETH_DMAReceptionCmd+0x54>)
    16ee:	4b10      	ldr	r3, [pc, #64]	; (1730 <ETH_DMAReceptionCmd+0x54>)
    16f0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    16f4:	f103 0318 	add.w	r3, r3, #24
    16f8:	681b      	ldr	r3, [r3, #0]
    16fa:	f043 0202 	orr.w	r2, r3, #2
    16fe:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    1702:	f103 0318 	add.w	r3, r3, #24
    1706:	601a      	str	r2, [r3, #0]
    1708:	e00d      	b.n	1726 <ETH_DMAReceptionCmd+0x4a>
  }
  else
  {
    /* Disable the DMA reception */
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
    170a:	4909      	ldr	r1, [pc, #36]	; (1730 <ETH_DMAReceptionCmd+0x54>)
    170c:	4b08      	ldr	r3, [pc, #32]	; (1730 <ETH_DMAReceptionCmd+0x54>)
    170e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1712:	f103 0318 	add.w	r3, r3, #24
    1716:	681b      	ldr	r3, [r3, #0]
    1718:	f023 0202 	bic.w	r2, r3, #2
    171c:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    1720:	f103 0318 	add.w	r3, r3, #24
    1724:	601a      	str	r2, [r3, #0]
  }
}
    1726:	f107 070c 	add.w	r7, r7, #12
    172a:	46bd      	mov	sp, r7
    172c:	bc80      	pop	{r7}
    172e:	4770      	bx	lr
    1730:	40028000 	.word	0x40028000

00001734 <ETH_DMAITConfig>:
  * @param  NewState: new state of the specified ETHERNET DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_DMAITConfig(uint32_t ETH_DMA_IT, FunctionalState NewState)
{
    1734:	b480      	push	{r7}
    1736:	b083      	sub	sp, #12
    1738:	af00      	add	r7, sp, #0
    173a:	6078      	str	r0, [r7, #4]
    173c:	460b      	mov	r3, r1
    173e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
    1740:	78fb      	ldrb	r3, [r7, #3]
    1742:	2b00      	cmp	r3, #0
    1744:	d00e      	beq.n	1764 <ETH_DMAITConfig+0x30>
  {
    /* Enable the selected ETHERNET DMA interrupts */
    ETH->DMAIER |= ETH_DMA_IT;
    1746:	4912      	ldr	r1, [pc, #72]	; (1790 <ETH_DMAITConfig+0x5c>)
    1748:	4b11      	ldr	r3, [pc, #68]	; (1790 <ETH_DMAITConfig+0x5c>)
    174a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    174e:	f103 031c 	add.w	r3, r3, #28
    1752:	681a      	ldr	r2, [r3, #0]
    1754:	687b      	ldr	r3, [r7, #4]
    1756:	431a      	orrs	r2, r3
    1758:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    175c:	f103 031c 	add.w	r3, r3, #28
    1760:	601a      	str	r2, [r3, #0]
    1762:	e00f      	b.n	1784 <ETH_DMAITConfig+0x50>
  }
  else
  {
    /* Disable the selected ETHERNET DMA interrupts */
    ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
    1764:	490a      	ldr	r1, [pc, #40]	; (1790 <ETH_DMAITConfig+0x5c>)
    1766:	4b0a      	ldr	r3, [pc, #40]	; (1790 <ETH_DMAITConfig+0x5c>)
    1768:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    176c:	f103 031c 	add.w	r3, r3, #28
    1770:	681a      	ldr	r2, [r3, #0]
    1772:	687b      	ldr	r3, [r7, #4]
    1774:	ea6f 0303 	mvn.w	r3, r3
    1778:	401a      	ands	r2, r3
    177a:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
    177e:	f103 031c 	add.w	r3, r3, #28
    1782:	601a      	str	r2, [r3, #0]
  }
}
    1784:	f107 070c 	add.w	r7, r7, #12
    1788:	46bd      	mov	sp, r7
    178a:	bc80      	pop	{r7}
    178c:	4770      	bx	lr
    178e:	bf00      	nop
    1790:	40028000 	.word	0x40028000

00001794 <ETH_GetDMAOverflowStatus>:
  *     @arg ETH_DMA_Overflow_RxFIFOCounter : Overflow for FIFO Overflow Counter
  *     @arg ETH_DMA_Overflow_MissedFrameCounter : Overflow for Missed Frame Counter
  * @retval The new state of ETHERNET DMA overflow Flag (SET or RESET).
  */
FlagStatus ETH_GetDMAOverflowStatus(uint32_t ETH_DMA_Overflow)
{
    1794:	b480      	push	{r7}
    1796:	b085      	sub	sp, #20
    1798:	af00      	add	r7, sp, #0
    179a:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
    179c:	f04f 0300 	mov.w	r3, #0
    17a0:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
  
  if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
    17a2:	4b0b      	ldr	r3, [pc, #44]	; (17d0 <ETH_GetDMAOverflowStatus+0x3c>)
    17a4:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    17a8:	681a      	ldr	r2, [r3, #0]
    17aa:	687b      	ldr	r3, [r7, #4]
    17ac:	ea02 0303 	and.w	r3, r2, r3
    17b0:	2b00      	cmp	r3, #0
    17b2:	d003      	beq.n	17bc <ETH_GetDMAOverflowStatus+0x28>
  {
    bitstatus = SET;
    17b4:	f04f 0301 	mov.w	r3, #1
    17b8:	73fb      	strb	r3, [r7, #15]
    17ba:	e002      	b.n	17c2 <ETH_GetDMAOverflowStatus+0x2e>
  }
  else
  {
    bitstatus = RESET;
    17bc:	f04f 0300 	mov.w	r3, #0
    17c0:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
    17c2:	7bfb      	ldrb	r3, [r7, #15]
}
    17c4:	4618      	mov	r0, r3
    17c6:	f107 0714 	add.w	r7, r7, #20
    17ca:	46bd      	mov	sp, r7
    17cc:	bc80      	pop	{r7}
    17ce:	4770      	bx	lr
    17d0:	40028000 	.word	0x40028000

000017d4 <ETH_GetRxOverflowMissedFrameCounter>:
  * @brief  Get the ETHERNET DMA Rx Overflow Missed Frame Counter value.
  * @param  None
  * @retval The value of Rx overflow Missed Frame Counter.
  */
uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
{
    17d4:	b480      	push	{r7}
    17d6:	af00      	add	r7, sp, #0
  return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
    17d8:	4b06      	ldr	r3, [pc, #24]	; (17f4 <ETH_GetRxOverflowMissedFrameCounter+0x20>)
    17da:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    17de:	681a      	ldr	r2, [r3, #0]
    17e0:	4b05      	ldr	r3, [pc, #20]	; (17f8 <ETH_GetRxOverflowMissedFrameCounter+0x24>)
    17e2:	ea02 0303 	and.w	r3, r2, r3
    17e6:	ea4f 4353 	mov.w	r3, r3, lsr #17
}
    17ea:	4618      	mov	r0, r3
    17ec:	46bd      	mov	sp, r7
    17ee:	bc80      	pop	{r7}
    17f0:	4770      	bx	lr
    17f2:	bf00      	nop
    17f4:	40028000 	.word	0x40028000
    17f8:	0ffe0000 	.word	0x0ffe0000

000017fc <ETH_GetBufferUnavailableMissedFrameCounter>:
  * @brief  Get the ETHERNET DMA Buffer Unavailable Missed Frame Counter value.
  * @param  None
  * @retval The value of Buffer unavailable Missed Frame Counter.
  */
uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
{
    17fc:	b480      	push	{r7}
    17fe:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
    1800:	4b05      	ldr	r3, [pc, #20]	; (1818 <ETH_GetBufferUnavailableMissedFrameCounter+0x1c>)
    1802:	f503 5381 	add.w	r3, r3, #4128	; 0x1020
    1806:	681b      	ldr	r3, [r3, #0]
    1808:	ea4f 4303 	mov.w	r3, r3, lsl #16
    180c:	ea4f 4313 	mov.w	r3, r3, lsr #16
}
    1810:	4618      	mov	r0, r3
    1812:	46bd      	mov	sp, r7
    1814:	bc80      	pop	{r7}
    1816:	4770      	bx	lr
    1818:	40028000 	.word	0x40028000

0000181c <ETH_GetCurrentTxDescStartAddress>:
  * @brief  Get the ETHERNET DMA DMACHTDR register value.
  * @param  None
  * @retval The value of the current Tx desc start address.
  */
uint32_t ETH_GetCurrentTxDescStartAddress(void)
{
    181c:	b480      	push	{r7}
    181e:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMACHTDR));
    1820:	4b04      	ldr	r3, [pc, #16]	; (1834 <ETH_GetCurrentTxDescStartAddress+0x18>)
    1822:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    1826:	f103 0308 	add.w	r3, r3, #8
    182a:	681b      	ldr	r3, [r3, #0]
}
    182c:	4618      	mov	r0, r3
    182e:	46bd      	mov	sp, r7
    1830:	bc80      	pop	{r7}
    1832:	4770      	bx	lr
    1834:	40028000 	.word	0x40028000

00001838 <ETH_GetCurrentRxDescStartAddress>:
  * @brief  Get the ETHERNET DMA DMACHRDR register value.
  * @param  None
  * @retval The value of the current Rx desc start address.
  */
uint32_t ETH_GetCurrentRxDescStartAddress(void)
{
    1838:	b480      	push	{r7}
    183a:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMACHRDR));
    183c:	4b04      	ldr	r3, [pc, #16]	; (1850 <ETH_GetCurrentRxDescStartAddress+0x18>)
    183e:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    1842:	f103 030c 	add.w	r3, r3, #12
    1846:	681b      	ldr	r3, [r3, #0]
}
    1848:	4618      	mov	r0, r3
    184a:	46bd      	mov	sp, r7
    184c:	bc80      	pop	{r7}
    184e:	4770      	bx	lr
    1850:	40028000 	.word	0x40028000

00001854 <ETH_GetCurrentTxBufferAddress>:
  * @brief  Get the ETHERNET DMA DMACHTBAR register value.
  * @param  None
  * @retval The value of the current Tx buffer address.
  */
uint32_t ETH_GetCurrentTxBufferAddress(void)
{
    1854:	b480      	push	{r7}
    1856:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMACHTBAR));
    1858:	4b04      	ldr	r3, [pc, #16]	; (186c <ETH_GetCurrentTxBufferAddress+0x18>)
    185a:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    185e:	f103 0310 	add.w	r3, r3, #16
    1862:	681b      	ldr	r3, [r3, #0]
}
    1864:	4618      	mov	r0, r3
    1866:	46bd      	mov	sp, r7
    1868:	bc80      	pop	{r7}
    186a:	4770      	bx	lr
    186c:	40028000 	.word	0x40028000

00001870 <ETH_GetCurrentRxBufferAddress>:
  * @brief  Get the ETHERNET DMA DMACHRBAR register value.
  * @param  None
  * @retval The value of the current Rx buffer address.
  */
uint32_t ETH_GetCurrentRxBufferAddress(void)
{
    1870:	b480      	push	{r7}
    1872:	af00      	add	r7, sp, #0
  return ((uint32_t)(ETH->DMACHRBAR));
    1874:	4b04      	ldr	r3, [pc, #16]	; (1888 <ETH_GetCurrentRxBufferAddress+0x18>)
    1876:	f503 5382 	add.w	r3, r3, #4160	; 0x1040
    187a:	f103 0314 	add.w	r3, r3, #20
    187e:	681b      	ldr	r3, [r3, #0]
}
    1880:	4618      	mov	r0, r3
    1882:	46bd      	mov	sp, r7
    1884:	bc80      	pop	{r7}
    1886:	4770      	bx	lr
    1888:	40028000 	.word	0x40028000

0000188c <ETH_ResumeDMATransmission>:
  *   (the data written could be anything). This forces  the DMA to resume transmission.
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMATransmission(void)
{
    188c:	b480      	push	{r7}
    188e:	af00      	add	r7, sp, #0
  ETH->DMATPDR = 0;
    1890:	4b05      	ldr	r3, [pc, #20]	; (18a8 <ETH_ResumeDMATransmission+0x1c>)
    1892:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1896:	f103 0304 	add.w	r3, r3, #4
    189a:	f04f 0200 	mov.w	r2, #0
    189e:	601a      	str	r2, [r3, #0]
}
    18a0:	46bd      	mov	sp, r7
    18a2:	bc80      	pop	{r7}
    18a4:	4770      	bx	lr
    18a6:	bf00      	nop
    18a8:	40028000 	.word	0x40028000

000018ac <ETH_ResumeDMAReception>:
  *   (the data written could be anything). This forces the DMA to resume reception.
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMAReception(void)
{
    18ac:	b480      	push	{r7}
    18ae:	af00      	add	r7, sp, #0
  ETH->DMARPDR = 0;
    18b0:	4b05      	ldr	r3, [pc, #20]	; (18c8 <ETH_ResumeDMAReception+0x1c>)
    18b2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    18b6:	f103 0308 	add.w	r3, r3, #8
    18ba:	f04f 0200 	mov.w	r2, #0
    18be:	601a      	str	r2, [r3, #0]
}
    18c0:	46bd      	mov	sp, r7
    18c2:	bc80      	pop	{r7}
    18c4:	4770      	bx	lr
    18c6:	bf00      	nop
    18c8:	40028000 	.word	0x40028000

000018cc <ETH_ResetWakeUpFrameFilterRegisterPointer>:
  * @brief  Reset Wakeup frame filter register pointer.
  * @param  None
  * @retval None
  */
void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
{  
    18cc:	b480      	push	{r7}
    18ce:	af00      	add	r7, sp, #0
  /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
  ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
    18d0:	4b04      	ldr	r3, [pc, #16]	; (18e4 <ETH_ResetWakeUpFrameFilterRegisterPointer+0x18>)
    18d2:	4a04      	ldr	r2, [pc, #16]	; (18e4 <ETH_ResetWakeUpFrameFilterRegisterPointer+0x18>)
    18d4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    18d6:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    18da:	62da      	str	r2, [r3, #44]	; 0x2c
}
    18dc:	46bd      	mov	sp, r7
    18de:	bc80      	pop	{r7}
    18e0:	4770      	bx	lr
    18e2:	bf00      	nop
    18e4:	40028000 	.word	0x40028000

000018e8 <ETH_SetWakeUpFrameFilterRegister>:
  * @brief  Populates the remote wakeup frame registers.
  * @param  Buffer: Pointer on remote WakeUp Frame Filter Register buffer data (8 words).
  * @retval None
  */
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
    18e8:	b480      	push	{r7}
    18ea:	b085      	sub	sp, #20
    18ec:	af00      	add	r7, sp, #0
    18ee:	6078      	str	r0, [r7, #4]
  uint32_t i = 0;
    18f0:	f04f 0300 	mov.w	r3, #0
    18f4:	60fb      	str	r3, [r7, #12]
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
    18f6:	f04f 0300 	mov.w	r3, #0
    18fa:	60fb      	str	r3, [r7, #12]
    18fc:	e00b      	b.n	1916 <ETH_SetWakeUpFrameFilterRegister+0x2e>
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
    18fe:	4b0a      	ldr	r3, [pc, #40]	; (1928 <ETH_SetWakeUpFrameFilterRegister+0x40>)
    1900:	68fa      	ldr	r2, [r7, #12]
    1902:	ea4f 0282 	mov.w	r2, r2, lsl #2
    1906:	6879      	ldr	r1, [r7, #4]
    1908:	188a      	adds	r2, r1, r2
    190a:	6812      	ldr	r2, [r2, #0]
    190c:	629a      	str	r2, [r3, #40]	; 0x28
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
    190e:	68fb      	ldr	r3, [r7, #12]
    1910:	f103 0301 	add.w	r3, r3, #1
    1914:	60fb      	str	r3, [r7, #12]
    1916:	68fb      	ldr	r3, [r7, #12]
    1918:	2b07      	cmp	r3, #7
    191a:	d9f0      	bls.n	18fe <ETH_SetWakeUpFrameFilterRegister+0x16>
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
  }
}
    191c:	f107 0714 	add.w	r7, r7, #20
    1920:	46bd      	mov	sp, r7
    1922:	bc80      	pop	{r7}
    1924:	4770      	bx	lr
    1926:	bf00      	nop
    1928:	40028000 	.word	0x40028000

0000192c <ETH_GlobalUnicastWakeUpCmd>:
  * @param  NewState: new state of the MAC Global Unicast Wake-Up.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
{ 
    192c:	b480      	push	{r7}
    192e:	b083      	sub	sp, #12
    1930:	af00      	add	r7, sp, #0
    1932:	4603      	mov	r3, r0
    1934:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1936:	79fb      	ldrb	r3, [r7, #7]
    1938:	2b00      	cmp	r3, #0
    193a:	d006      	beq.n	194a <ETH_GlobalUnicastWakeUpCmd+0x1e>
  {
    /* Enable the MAC Global Unicast Wake-Up */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
    193c:	4b08      	ldr	r3, [pc, #32]	; (1960 <ETH_GlobalUnicastWakeUpCmd+0x34>)
    193e:	4a08      	ldr	r2, [pc, #32]	; (1960 <ETH_GlobalUnicastWakeUpCmd+0x34>)
    1940:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    1942:	f442 7200 	orr.w	r2, r2, #512	; 0x200
    1946:	62da      	str	r2, [r3, #44]	; 0x2c
    1948:	e005      	b.n	1956 <ETH_GlobalUnicastWakeUpCmd+0x2a>
  }
  else
  {
    /* Disable the MAC Global Unicast Wake-Up */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
    194a:	4b05      	ldr	r3, [pc, #20]	; (1960 <ETH_GlobalUnicastWakeUpCmd+0x34>)
    194c:	4a04      	ldr	r2, [pc, #16]	; (1960 <ETH_GlobalUnicastWakeUpCmd+0x34>)
    194e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    1950:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    1954:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
    1956:	f107 070c 	add.w	r7, r7, #12
    195a:	46bd      	mov	sp, r7
    195c:	bc80      	pop	{r7}
    195e:	4770      	bx	lr
    1960:	40028000 	.word	0x40028000

00001964 <ETH_GetPMTFlagStatus>:
  *     @arg ETH_PMT_FLAG_WUFR    : Wake-Up Frame Received 
  *     @arg ETH_PMT_FLAG_MPR     : Magic Packet Received
  * @retval The new state of ETHERNET PMT Flag (SET or RESET).
  */
FlagStatus ETH_GetPMTFlagStatus(uint32_t ETH_PMT_FLAG)
{
    1964:	b480      	push	{r7}
    1966:	b085      	sub	sp, #20
    1968:	af00      	add	r7, sp, #0
    196a:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
    196c:	f04f 0300 	mov.w	r3, #0
    1970:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
  
  if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
    1972:	4b0a      	ldr	r3, [pc, #40]	; (199c <ETH_GetPMTFlagStatus+0x38>)
    1974:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1976:	687b      	ldr	r3, [r7, #4]
    1978:	ea02 0303 	and.w	r3, r2, r3
    197c:	2b00      	cmp	r3, #0
    197e:	d003      	beq.n	1988 <ETH_GetPMTFlagStatus+0x24>
  {
    bitstatus = SET;
    1980:	f04f 0301 	mov.w	r3, #1
    1984:	73fb      	strb	r3, [r7, #15]
    1986:	e002      	b.n	198e <ETH_GetPMTFlagStatus+0x2a>
  }
  else
  {
    bitstatus = RESET;
    1988:	f04f 0300 	mov.w	r3, #0
    198c:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
    198e:	7bfb      	ldrb	r3, [r7, #15]
}
    1990:	4618      	mov	r0, r3
    1992:	f107 0714 	add.w	r7, r7, #20
    1996:	46bd      	mov	sp, r7
    1998:	bc80      	pop	{r7}
    199a:	4770      	bx	lr
    199c:	40028000 	.word	0x40028000

000019a0 <ETH_WakeUpFrameDetectionCmd>:
  * @param  NewState: new state of the MAC Wake-Up Frame Detection.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
{ 
    19a0:	b480      	push	{r7}
    19a2:	b083      	sub	sp, #12
    19a4:	af00      	add	r7, sp, #0
    19a6:	4603      	mov	r3, r0
    19a8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    19aa:	79fb      	ldrb	r3, [r7, #7]
    19ac:	2b00      	cmp	r3, #0
    19ae:	d006      	beq.n	19be <ETH_WakeUpFrameDetectionCmd+0x1e>
  {
    /* Enable the MAC Wake-Up Frame Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
    19b0:	4b08      	ldr	r3, [pc, #32]	; (19d4 <ETH_WakeUpFrameDetectionCmd+0x34>)
    19b2:	4a08      	ldr	r2, [pc, #32]	; (19d4 <ETH_WakeUpFrameDetectionCmd+0x34>)
    19b4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    19b6:	f042 0204 	orr.w	r2, r2, #4
    19ba:	62da      	str	r2, [r3, #44]	; 0x2c
    19bc:	e005      	b.n	19ca <ETH_WakeUpFrameDetectionCmd+0x2a>
  }
  else
  {
    /* Disable the MAC Wake-Up Frame Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
    19be:	4b05      	ldr	r3, [pc, #20]	; (19d4 <ETH_WakeUpFrameDetectionCmd+0x34>)
    19c0:	4a04      	ldr	r2, [pc, #16]	; (19d4 <ETH_WakeUpFrameDetectionCmd+0x34>)
    19c2:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    19c4:	f022 0204 	bic.w	r2, r2, #4
    19c8:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
    19ca:	f107 070c 	add.w	r7, r7, #12
    19ce:	46bd      	mov	sp, r7
    19d0:	bc80      	pop	{r7}
    19d2:	4770      	bx	lr
    19d4:	40028000 	.word	0x40028000

000019d8 <ETH_MagicPacketDetectionCmd>:
  * @param  NewState: new state of the MAC Magic Packet Detection.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
{ 
    19d8:	b480      	push	{r7}
    19da:	b083      	sub	sp, #12
    19dc:	af00      	add	r7, sp, #0
    19de:	4603      	mov	r3, r0
    19e0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    19e2:	79fb      	ldrb	r3, [r7, #7]
    19e4:	2b00      	cmp	r3, #0
    19e6:	d006      	beq.n	19f6 <ETH_MagicPacketDetectionCmd+0x1e>
  {
    /* Enable the MAC Magic Packet Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
    19e8:	4b08      	ldr	r3, [pc, #32]	; (1a0c <ETH_MagicPacketDetectionCmd+0x34>)
    19ea:	4a08      	ldr	r2, [pc, #32]	; (1a0c <ETH_MagicPacketDetectionCmd+0x34>)
    19ec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    19ee:	f042 0202 	orr.w	r2, r2, #2
    19f2:	62da      	str	r2, [r3, #44]	; 0x2c
    19f4:	e005      	b.n	1a02 <ETH_MagicPacketDetectionCmd+0x2a>
  }
  else
  {
    /* Disable the MAC Magic Packet Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
    19f6:	4b05      	ldr	r3, [pc, #20]	; (1a0c <ETH_MagicPacketDetectionCmd+0x34>)
    19f8:	4a04      	ldr	r2, [pc, #16]	; (1a0c <ETH_MagicPacketDetectionCmd+0x34>)
    19fa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    19fc:	f022 0202 	bic.w	r2, r2, #2
    1a00:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
    1a02:	f107 070c 	add.w	r7, r7, #12
    1a06:	46bd      	mov	sp, r7
    1a08:	bc80      	pop	{r7}
    1a0a:	4770      	bx	lr
    1a0c:	40028000 	.word	0x40028000

00001a10 <ETH_PowerDownCmd>:
  * @param  NewState: new state of the MAC Power Down.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_PowerDownCmd(FunctionalState NewState)
{ 
    1a10:	b480      	push	{r7}
    1a12:	b083      	sub	sp, #12
    1a14:	af00      	add	r7, sp, #0
    1a16:	4603      	mov	r3, r0
    1a18:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1a1a:	79fb      	ldrb	r3, [r7, #7]
    1a1c:	2b00      	cmp	r3, #0
    1a1e:	d006      	beq.n	1a2e <ETH_PowerDownCmd+0x1e>
  {
    /* Enable the MAC Power Down */
    /* This puts the MAC in power down mode */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
    1a20:	4b08      	ldr	r3, [pc, #32]	; (1a44 <ETH_PowerDownCmd+0x34>)
    1a22:	4a08      	ldr	r2, [pc, #32]	; (1a44 <ETH_PowerDownCmd+0x34>)
    1a24:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    1a26:	f042 0201 	orr.w	r2, r2, #1
    1a2a:	62da      	str	r2, [r3, #44]	; 0x2c
    1a2c:	e005      	b.n	1a3a <ETH_PowerDownCmd+0x2a>
  }
  else
  {
    /* Disable the MAC Power Down */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
    1a2e:	4b05      	ldr	r3, [pc, #20]	; (1a44 <ETH_PowerDownCmd+0x34>)
    1a30:	4a04      	ldr	r2, [pc, #16]	; (1a44 <ETH_PowerDownCmd+0x34>)
    1a32:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
    1a34:	f022 0201 	bic.w	r2, r2, #1
    1a38:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
    1a3a:	f107 070c 	add.w	r7, r7, #12
    1a3e:	46bd      	mov	sp, r7
    1a40:	bc80      	pop	{r7}
    1a42:	4770      	bx	lr
    1a44:	40028000 	.word	0x40028000

00001a48 <ETH_MMCCounterFreezeCmd>:
  * @param  NewState: new state of the MMC Counter Freeze.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
{
    1a48:	b480      	push	{r7}
    1a4a:	b083      	sub	sp, #12
    1a4c:	af00      	add	r7, sp, #0
    1a4e:	4603      	mov	r3, r0
    1a50:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1a52:	79fb      	ldrb	r3, [r7, #7]
    1a54:	2b00      	cmp	r3, #0
    1a56:	d008      	beq.n	1a6a <ETH_MMCCounterFreezeCmd+0x22>
  {
    /* Enable the MMC Counter Freeze */
    ETH->MMCCR |= ETH_MMCCR_MCF;
    1a58:	4b0a      	ldr	r3, [pc, #40]	; (1a84 <ETH_MMCCounterFreezeCmd+0x3c>)
    1a5a:	4a0a      	ldr	r2, [pc, #40]	; (1a84 <ETH_MMCCounterFreezeCmd+0x3c>)
    1a5c:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1a60:	f042 0208 	orr.w	r2, r2, #8
    1a64:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    1a68:	e007      	b.n	1a7a <ETH_MMCCounterFreezeCmd+0x32>
  }
  else
  {
    /* Disable the MMC Counter Freeze */
    ETH->MMCCR &= ~ETH_MMCCR_MCF;
    1a6a:	4b06      	ldr	r3, [pc, #24]	; (1a84 <ETH_MMCCounterFreezeCmd+0x3c>)
    1a6c:	4a05      	ldr	r2, [pc, #20]	; (1a84 <ETH_MMCCounterFreezeCmd+0x3c>)
    1a6e:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1a72:	f022 0208 	bic.w	r2, r2, #8
    1a76:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
}
    1a7a:	f107 070c 	add.w	r7, r7, #12
    1a7e:	46bd      	mov	sp, r7
    1a80:	bc80      	pop	{r7}
    1a82:	4770      	bx	lr
    1a84:	40028000 	.word	0x40028000

00001a88 <ETH_MMCResetOnReadCmd>:
  * @param  NewState: new state of the MMC Reset On Read.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCResetOnReadCmd(FunctionalState NewState)
{
    1a88:	b480      	push	{r7}
    1a8a:	b083      	sub	sp, #12
    1a8c:	af00      	add	r7, sp, #0
    1a8e:	4603      	mov	r3, r0
    1a90:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1a92:	79fb      	ldrb	r3, [r7, #7]
    1a94:	2b00      	cmp	r3, #0
    1a96:	d008      	beq.n	1aaa <ETH_MMCResetOnReadCmd+0x22>
  {
    /* Enable the MMC Counter reset on read */
    ETH->MMCCR |= ETH_MMCCR_ROR; 
    1a98:	4b0a      	ldr	r3, [pc, #40]	; (1ac4 <ETH_MMCResetOnReadCmd+0x3c>)
    1a9a:	4a0a      	ldr	r2, [pc, #40]	; (1ac4 <ETH_MMCResetOnReadCmd+0x3c>)
    1a9c:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1aa0:	f042 0204 	orr.w	r2, r2, #4
    1aa4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    1aa8:	e007      	b.n	1aba <ETH_MMCResetOnReadCmd+0x32>
  }
  else
  {
    /* Disable the MMC Counter reset on read */
    ETH->MMCCR &= ~ETH_MMCCR_ROR;
    1aaa:	4b06      	ldr	r3, [pc, #24]	; (1ac4 <ETH_MMCResetOnReadCmd+0x3c>)
    1aac:	4a05      	ldr	r2, [pc, #20]	; (1ac4 <ETH_MMCResetOnReadCmd+0x3c>)
    1aae:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1ab2:	f022 0204 	bic.w	r2, r2, #4
    1ab6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
}
    1aba:	f107 070c 	add.w	r7, r7, #12
    1abe:	46bd      	mov	sp, r7
    1ac0:	bc80      	pop	{r7}
    1ac2:	4770      	bx	lr
    1ac4:	40028000 	.word	0x40028000

00001ac8 <ETH_MMCCounterRolloverCmd>:
  * @param  NewState: new state of the MMC Counter Stop Rollover.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
{
    1ac8:	b480      	push	{r7}
    1aca:	b083      	sub	sp, #12
    1acc:	af00      	add	r7, sp, #0
    1ace:	4603      	mov	r3, r0
    1ad0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1ad2:	79fb      	ldrb	r3, [r7, #7]
    1ad4:	2b00      	cmp	r3, #0
    1ad6:	d008      	beq.n	1aea <ETH_MMCCounterRolloverCmd+0x22>
  {
    /* Disable the MMC Counter Stop Rollover  */
    ETH->MMCCR &= ~ETH_MMCCR_CSR;
    1ad8:	4b0a      	ldr	r3, [pc, #40]	; (1b04 <ETH_MMCCounterRolloverCmd+0x3c>)
    1ada:	4a0a      	ldr	r2, [pc, #40]	; (1b04 <ETH_MMCCounterRolloverCmd+0x3c>)
    1adc:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1ae0:	f022 0202 	bic.w	r2, r2, #2
    1ae4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    1ae8:	e007      	b.n	1afa <ETH_MMCCounterRolloverCmd+0x32>
  }
  else
  {
    /* Enable the MMC Counter Stop Rollover */
    ETH->MMCCR |= ETH_MMCCR_CSR; 
    1aea:	4b06      	ldr	r3, [pc, #24]	; (1b04 <ETH_MMCCounterRolloverCmd+0x3c>)
    1aec:	4a05      	ldr	r2, [pc, #20]	; (1b04 <ETH_MMCCounterRolloverCmd+0x3c>)
    1aee:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1af2:	f042 0202 	orr.w	r2, r2, #2
    1af6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }
}
    1afa:	f107 070c 	add.w	r7, r7, #12
    1afe:	46bd      	mov	sp, r7
    1b00:	bc80      	pop	{r7}
    1b02:	4770      	bx	lr
    1b04:	40028000 	.word	0x40028000

00001b08 <ETH_MMCCountersReset>:
  * @brief  Resets the MMC Counters.
  * @param  None
  * @retval None
  */
void ETH_MMCCountersReset(void)
{
    1b08:	b480      	push	{r7}
    1b0a:	af00      	add	r7, sp, #0
  /* Resets the MMC Counters */
  ETH->MMCCR |= ETH_MMCCR_CR; 
    1b0c:	4b05      	ldr	r3, [pc, #20]	; (1b24 <ETH_MMCCountersReset+0x1c>)
    1b0e:	4a05      	ldr	r2, [pc, #20]	; (1b24 <ETH_MMCCountersReset+0x1c>)
    1b10:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
    1b14:	f042 0201 	orr.w	r2, r2, #1
    1b18:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
    1b1c:	46bd      	mov	sp, r7
    1b1e:	bc80      	pop	{r7}
    1b20:	4770      	bx	lr
    1b22:	bf00      	nop
    1b24:	40028000 	.word	0x40028000

00001b28 <ETH_MMCITConfig>:
  * @param  NewState: new state of the specified ETHERNET MMC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_MMCITConfig(uint32_t ETH_MMC_IT, FunctionalState NewState)
{ 
    1b28:	b480      	push	{r7}
    1b2a:	b083      	sub	sp, #12
    1b2c:	af00      	add	r7, sp, #0
    1b2e:	6078      	str	r0, [r7, #4]
    1b30:	460b      	mov	r3, r1
    1b32:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
    1b34:	687b      	ldr	r3, [r7, #4]
    1b36:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
    1b3a:	2b00      	cmp	r3, #0
    1b3c:	d01c      	beq.n	1b78 <ETH_MMCITConfig+0x50>
  {
    /* Remove egister mak from IT */
    ETH_MMC_IT &= 0xEFFFFFFF;
    1b3e:	687b      	ldr	r3, [r7, #4]
    1b40:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    1b44:	607b      	str	r3, [r7, #4]
  
    /* ETHERNET MMC Rx interrupts selected */
    if (NewState != DISABLE)
    1b46:	78fb      	ldrb	r3, [r7, #3]
    1b48:	2b00      	cmp	r3, #0
    1b4a:	d00b      	beq.n	1b64 <ETH_MMCITConfig+0x3c>
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
    1b4c:	4b19      	ldr	r3, [pc, #100]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b4e:	4a19      	ldr	r2, [pc, #100]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b50:	f8d2 110c 	ldr.w	r1, [r2, #268]	; 0x10c
    1b54:	687a      	ldr	r2, [r7, #4]
    1b56:	ea6f 0202 	mvn.w	r2, r2
    1b5a:	ea01 0202 	and.w	r2, r1, r2
    1b5e:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    1b62:	e021      	b.n	1ba8 <ETH_MMCITConfig+0x80>
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR |= ETH_MMC_IT;    
    1b64:	4b13      	ldr	r3, [pc, #76]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b66:	4a13      	ldr	r2, [pc, #76]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b68:	f8d2 110c 	ldr.w	r1, [r2, #268]	; 0x10c
    1b6c:	687a      	ldr	r2, [r7, #4]
    1b6e:	ea41 0202 	orr.w	r2, r1, r2
    1b72:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    1b76:	e017      	b.n	1ba8 <ETH_MMCITConfig+0x80>
    }
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    if (NewState != DISABLE)
    1b78:	78fb      	ldrb	r3, [r7, #3]
    1b7a:	2b00      	cmp	r3, #0
    1b7c:	d00b      	beq.n	1b96 <ETH_MMCITConfig+0x6e>
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
    1b7e:	4b0d      	ldr	r3, [pc, #52]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b80:	4a0c      	ldr	r2, [pc, #48]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b82:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
    1b86:	687a      	ldr	r2, [r7, #4]
    1b88:	ea6f 0202 	mvn.w	r2, r2
    1b8c:	ea01 0202 	and.w	r2, r1, r2
    1b90:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    1b94:	e008      	b.n	1ba8 <ETH_MMCITConfig+0x80>
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR |= ETH_MMC_IT;    
    1b96:	4b07      	ldr	r3, [pc, #28]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b98:	4a06      	ldr	r2, [pc, #24]	; (1bb4 <ETH_MMCITConfig+0x8c>)
    1b9a:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
    1b9e:	687a      	ldr	r2, [r7, #4]
    1ba0:	ea41 0202 	orr.w	r2, r1, r2
    1ba4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
    }  
  }
}
    1ba8:	f107 070c 	add.w	r7, r7, #12
    1bac:	46bd      	mov	sp, r7
    1bae:	bc80      	pop	{r7}
    1bb0:	4770      	bx	lr
    1bb2:	bf00      	nop
    1bb4:	40028000 	.word	0x40028000

00001bb8 <ETH_GetMMCITStatus>:
  *     @arg ETH_MMC_IT_RxAEC : When Rx alignment error counter reaches half the maximum value 
  *     @arg ETH_MMC_IT_RxCEC : When Rx crc error counter reaches half the maximum value 
  * @retval The value of ETHERNET MMC IT (SET or RESET).
  */
ITStatus ETH_GetMMCITStatus(uint32_t ETH_MMC_IT)
{
    1bb8:	b480      	push	{r7}
    1bba:	b085      	sub	sp, #20
    1bbc:	af00      	add	r7, sp, #0
    1bbe:	6078      	str	r0, [r7, #4]
  ITStatus bitstatus = RESET;
    1bc0:	f04f 0300 	mov.w	r3, #0
    1bc4:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
  
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
    1bc6:	687b      	ldr	r3, [r7, #4]
    1bc8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
    1bcc:	2b00      	cmp	r3, #0
    1bce:	d017      	beq.n	1c00 <ETH_GetMMCITStatus+0x48>
  {
    /* ETHERNET MMC Rx interrupts selected */
    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occured */ 
    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
    1bd0:	4b1a      	ldr	r3, [pc, #104]	; (1c3c <ETH_GetMMCITStatus+0x84>)
    1bd2:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    1bd6:	687b      	ldr	r3, [r7, #4]
    1bd8:	ea02 0303 	and.w	r3, r2, r3
    1bdc:	2b00      	cmp	r3, #0
    1bde:	d00b      	beq.n	1bf8 <ETH_GetMMCITStatus+0x40>
    1be0:	4b16      	ldr	r3, [pc, #88]	; (1c3c <ETH_GetMMCITStatus+0x84>)
    1be2:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    1be6:	687b      	ldr	r3, [r7, #4]
    1be8:	ea02 0303 	and.w	r3, r2, r3
    1bec:	2b00      	cmp	r3, #0
    1bee:	d003      	beq.n	1bf8 <ETH_GetMMCITStatus+0x40>
    {
      bitstatus = SET;
    1bf0:	f04f 0301 	mov.w	r3, #1
    1bf4:	73fb      	strb	r3, [r7, #15]
    1bf6:	e01a      	b.n	1c2e <ETH_GetMMCITStatus+0x76>
    }
    else
    {
      bitstatus = RESET;
    1bf8:	f04f 0300 	mov.w	r3, #0
    1bfc:	73fb      	strb	r3, [r7, #15]
    1bfe:	e016      	b.n	1c2e <ETH_GetMMCITStatus+0x76>
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occured */  
    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) != (uint32_t)RESET))
    1c00:	4b0e      	ldr	r3, [pc, #56]	; (1c3c <ETH_GetMMCITStatus+0x84>)
    1c02:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
    1c06:	687b      	ldr	r3, [r7, #4]
    1c08:	ea02 0303 	and.w	r3, r2, r3
    1c0c:	2b00      	cmp	r3, #0
    1c0e:	d00b      	beq.n	1c28 <ETH_GetMMCITStatus+0x70>
    1c10:	4b0a      	ldr	r3, [pc, #40]	; (1c3c <ETH_GetMMCITStatus+0x84>)
    1c12:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
    1c16:	687b      	ldr	r3, [r7, #4]
    1c18:	ea02 0303 	and.w	r3, r2, r3
    1c1c:	2b00      	cmp	r3, #0
    1c1e:	d003      	beq.n	1c28 <ETH_GetMMCITStatus+0x70>
    {
      bitstatus = SET;
    1c20:	f04f 0301 	mov.w	r3, #1
    1c24:	73fb      	strb	r3, [r7, #15]
    1c26:	e002      	b.n	1c2e <ETH_GetMMCITStatus+0x76>
    }
    else
    {
      bitstatus = RESET;
    1c28:	f04f 0300 	mov.w	r3, #0
    1c2c:	73fb      	strb	r3, [r7, #15]
    }  
  }    
    
  return bitstatus;
    1c2e:	7bfb      	ldrb	r3, [r7, #15]
}
    1c30:	4618      	mov	r0, r3
    1c32:	f107 0714 	add.w	r7, r7, #20
    1c36:	46bd      	mov	sp, r7
    1c38:	bc80      	pop	{r7}
    1c3a:	4770      	bx	lr
    1c3c:	40028000 	.word	0x40028000

00001c40 <ETH_GetMMCRegister>:
  *     @arg ETH_MMCRFAECR  : MMC RFAECR register 
  *     @arg ETH_MMCRGUFCR  : MMC RGUFCRregister 
  * @retval The value of ETHERNET MMC Register value.
  */
uint32_t ETH_GetMMCRegister(uint32_t ETH_MMCReg)
{
    1c40:	b480      	push	{r7}
    1c42:	b083      	sub	sp, #12
    1c44:	af00      	add	r7, sp, #0
    1c46:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
    1c48:	687b      	ldr	r3, [r7, #4]
    1c4a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    1c4e:	f503 3320 	add.w	r3, r3, #163840	; 0x28000
    1c52:	681b      	ldr	r3, [r3, #0]
}
    1c54:	4618      	mov	r0, r3
    1c56:	f107 070c 	add.w	r7, r7, #12
    1c5a:	46bd      	mov	sp, r7
    1c5c:	bc80      	pop	{r7}
    1c5e:	4770      	bx	lr

00001c60 <ETH_EnablePTPTimeStampAddend>:
  * @brief  Updated the PTP block for fine correction with the Time Stamp Addend register value.
  * @param  None
  * @retval None
  */
void ETH_EnablePTPTimeStampAddend(void)
{
    1c60:	b480      	push	{r7}
    1c62:	af00      	add	r7, sp, #0
  /* Enable the PTP block update with the Time Stamp Addend register value */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSARU;    
    1c64:	4b05      	ldr	r3, [pc, #20]	; (1c7c <ETH_EnablePTPTimeStampAddend+0x1c>)
    1c66:	4a05      	ldr	r2, [pc, #20]	; (1c7c <ETH_EnablePTPTimeStampAddend+0x1c>)
    1c68:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1c6c:	f042 0220 	orr.w	r2, r2, #32
    1c70:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
}
    1c74:	46bd      	mov	sp, r7
    1c76:	bc80      	pop	{r7}
    1c78:	4770      	bx	lr
    1c7a:	bf00      	nop
    1c7c:	40028000 	.word	0x40028000

00001c80 <ETH_EnablePTPTimeStampInterruptTrigger>:
  * @brief  Enable the PTP Time Stamp interrupt trigger
  * @param  None
  * @retval None
  */
void ETH_EnablePTPTimeStampInterruptTrigger(void)
{
    1c80:	b480      	push	{r7}
    1c82:	af00      	add	r7, sp, #0
  /* Enable the PTP target time interrupt */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSITE;    
    1c84:	4b05      	ldr	r3, [pc, #20]	; (1c9c <ETH_EnablePTPTimeStampInterruptTrigger+0x1c>)
    1c86:	4a05      	ldr	r2, [pc, #20]	; (1c9c <ETH_EnablePTPTimeStampInterruptTrigger+0x1c>)
    1c88:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1c8c:	f042 0210 	orr.w	r2, r2, #16
    1c90:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
}
    1c94:	46bd      	mov	sp, r7
    1c96:	bc80      	pop	{r7}
    1c98:	4770      	bx	lr
    1c9a:	bf00      	nop
    1c9c:	40028000 	.word	0x40028000

00001ca0 <ETH_EnablePTPTimeStampUpdate>:
  * @brief  Updated the PTP system time with the Time Stamp Update register value.
  * @param  None
  * @retval None
  */
void ETH_EnablePTPTimeStampUpdate(void)
{
    1ca0:	b480      	push	{r7}
    1ca2:	af00      	add	r7, sp, #0
  /* Enable the PTP system time update with the Time Stamp Update register value */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSSTU;    
    1ca4:	4b05      	ldr	r3, [pc, #20]	; (1cbc <ETH_EnablePTPTimeStampUpdate+0x1c>)
    1ca6:	4a05      	ldr	r2, [pc, #20]	; (1cbc <ETH_EnablePTPTimeStampUpdate+0x1c>)
    1ca8:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1cac:	f042 0208 	orr.w	r2, r2, #8
    1cb0:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
}
    1cb4:	46bd      	mov	sp, r7
    1cb6:	bc80      	pop	{r7}
    1cb8:	4770      	bx	lr
    1cba:	bf00      	nop
    1cbc:	40028000 	.word	0x40028000

00001cc0 <ETH_InitializePTPTimeStamp>:
  * @brief  Initialize the PTP Time Stamp
  * @param  None
  * @retval None
  */
void ETH_InitializePTPTimeStamp(void)
{
    1cc0:	b480      	push	{r7}
    1cc2:	af00      	add	r7, sp, #0
  /* Initialize the PTP Time Stamp */
  ETH->PTPTSCR |= ETH_PTPTSCR_TSSTI;    
    1cc4:	4b05      	ldr	r3, [pc, #20]	; (1cdc <ETH_InitializePTPTimeStamp+0x1c>)
    1cc6:	4a05      	ldr	r2, [pc, #20]	; (1cdc <ETH_InitializePTPTimeStamp+0x1c>)
    1cc8:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1ccc:	f042 0204 	orr.w	r2, r2, #4
    1cd0:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
}
    1cd4:	46bd      	mov	sp, r7
    1cd6:	bc80      	pop	{r7}
    1cd8:	4770      	bx	lr
    1cda:	bf00      	nop
    1cdc:	40028000 	.word	0x40028000

00001ce0 <ETH_PTPUpdateMethodConfig>:
  *     @arg ETH_PTP_FineUpdate   : Fine Update method 
  *     @arg ETH_PTP_CoarseUpdate : Coarse Update method 
  * @retval None
  */
void ETH_PTPUpdateMethodConfig(uint32_t UpdateMethod)
{
    1ce0:	b480      	push	{r7}
    1ce2:	b083      	sub	sp, #12
    1ce4:	af00      	add	r7, sp, #0
    1ce6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PTP_UPDATE(UpdateMethod));
  
  if (UpdateMethod != ETH_PTP_CoarseUpdate)
    1ce8:	687b      	ldr	r3, [r7, #4]
    1cea:	2b00      	cmp	r3, #0
    1cec:	d008      	beq.n	1d00 <ETH_PTPUpdateMethodConfig+0x20>
  {
    /* Enable the PTP Fine Update method */
    ETH->PTPTSCR |= ETH_PTPTSCR_TSFCU;
    1cee:	4b0b      	ldr	r3, [pc, #44]	; (1d1c <ETH_PTPUpdateMethodConfig+0x3c>)
    1cf0:	4a0a      	ldr	r2, [pc, #40]	; (1d1c <ETH_PTPUpdateMethodConfig+0x3c>)
    1cf2:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1cf6:	f042 0202 	orr.w	r2, r2, #2
    1cfa:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
    1cfe:	e007      	b.n	1d10 <ETH_PTPUpdateMethodConfig+0x30>
  }
  else
  {
    /* Disable the PTP Coarse Update method */
    ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSFCU);
    1d00:	4b06      	ldr	r3, [pc, #24]	; (1d1c <ETH_PTPUpdateMethodConfig+0x3c>)
    1d02:	4a06      	ldr	r2, [pc, #24]	; (1d1c <ETH_PTPUpdateMethodConfig+0x3c>)
    1d04:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1d08:	f022 0202 	bic.w	r2, r2, #2
    1d0c:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
  } 
}
    1d10:	f107 070c 	add.w	r7, r7, #12
    1d14:	46bd      	mov	sp, r7
    1d16:	bc80      	pop	{r7}
    1d18:	4770      	bx	lr
    1d1a:	bf00      	nop
    1d1c:	40028000 	.word	0x40028000

00001d20 <ETH_PTPTimeStampCmd>:
  * @param  NewState: new state of the PTP time stamp for transmit and receive frames
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void ETH_PTPTimeStampCmd(FunctionalState NewState)
{
    1d20:	b480      	push	{r7}
    1d22:	b083      	sub	sp, #12
    1d24:	af00      	add	r7, sp, #0
    1d26:	4603      	mov	r3, r0
    1d28:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
    1d2a:	79fb      	ldrb	r3, [r7, #7]
    1d2c:	2b00      	cmp	r3, #0
    1d2e:	d008      	beq.n	1d42 <ETH_PTPTimeStampCmd+0x22>
  {
    /* Enable the PTP time stamp for transmit and receive frames */
    ETH->PTPTSCR |= ETH_PTPTSCR_TSE;
    1d30:	4b0a      	ldr	r3, [pc, #40]	; (1d5c <ETH_PTPTimeStampCmd+0x3c>)
    1d32:	4a0a      	ldr	r2, [pc, #40]	; (1d5c <ETH_PTPTimeStampCmd+0x3c>)
    1d34:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1d38:	f042 0201 	orr.w	r2, r2, #1
    1d3c:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
    1d40:	e007      	b.n	1d52 <ETH_PTPTimeStampCmd+0x32>
  }
  else
  {
    /* Disable the PTP time stamp for transmit and receive frames */
    ETH->PTPTSCR &= (~(uint32_t)ETH_PTPTSCR_TSE);
    1d42:	4b06      	ldr	r3, [pc, #24]	; (1d5c <ETH_PTPTimeStampCmd+0x3c>)
    1d44:	4a05      	ldr	r2, [pc, #20]	; (1d5c <ETH_PTPTimeStampCmd+0x3c>)
    1d46:	f8d2 2700 	ldr.w	r2, [r2, #1792]	; 0x700
    1d4a:	f022 0201 	bic.w	r2, r2, #1
    1d4e:	f8c3 2700 	str.w	r2, [r3, #1792]	; 0x700
  }
}
    1d52:	f107 070c 	add.w	r7, r7, #12
    1d56:	46bd      	mov	sp, r7
    1d58:	bc80      	pop	{r7}
    1d5a:	4770      	bx	lr
    1d5c:	40028000 	.word	0x40028000

00001d60 <ETH_GetPTPFlagStatus>:
  *     @arg ETH_PTP_FLAG_TSSTU : Time Stamp Update 
  *     @arg ETH_PTP_FLAG_TSSTI  : Time Stamp Initialize                       
  * @retval The new state of ETHERNET PTP Flag (SET or RESET).
  */
FlagStatus ETH_GetPTPFlagStatus(uint32_t ETH_PTP_FLAG)
{
    1d60:	b480      	push	{r7}
    1d62:	b085      	sub	sp, #20
    1d64:	af00      	add	r7, sp, #0
    1d66:	6078      	str	r0, [r7, #4]
  FlagStatus bitstatus = RESET;
    1d68:	f04f 0300 	mov.w	r3, #0
    1d6c:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_ETH_PTP_GET_FLAG(ETH_PTP_FLAG));
  
  if ((ETH->PTPTSCR & ETH_PTP_FLAG) != (uint32_t)RESET)
    1d6e:	4b0b      	ldr	r3, [pc, #44]	; (1d9c <ETH_GetPTPFlagStatus+0x3c>)
    1d70:	f8d3 2700 	ldr.w	r2, [r3, #1792]	; 0x700
    1d74:	687b      	ldr	r3, [r7, #4]
    1d76:	ea02 0303 	and.w	r3, r2, r3
    1d7a:	2b00      	cmp	r3, #0
    1d7c:	d003      	beq.n	1d86 <ETH_GetPTPFlagStatus+0x26>
  {
    bitstatus = SET;
    1d7e:	f04f 0301 	mov.w	r3, #1
    1d82:	73fb      	strb	r3, [r7, #15]
    1d84:	e002      	b.n	1d8c <ETH_GetPTPFlagStatus+0x2c>
  }
  else
  {
    bitstatus = RESET;
    1d86:	f04f 0300 	mov.w	r3, #0
    1d8a:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
    1d8c:	7bfb      	ldrb	r3, [r7, #15]
}
    1d8e:	4618      	mov	r0, r3
    1d90:	f107 0714 	add.w	r7, r7, #20
    1d94:	46bd      	mov	sp, r7
    1d96:	bc80      	pop	{r7}
    1d98:	4770      	bx	lr
    1d9a:	bf00      	nop
    1d9c:	40028000 	.word	0x40028000

00001da0 <ETH_SetPTPSubSecondIncrement>:
  * @brief  Sets the system time Sub-Second Increment value.
  * @param  SubSecondValue: specifies the PTP Sub-Second Increment Register value.
  * @retval None
  */
void ETH_SetPTPSubSecondIncrement(uint32_t SubSecondValue)
{
    1da0:	b480      	push	{r7}
    1da2:	b083      	sub	sp, #12
    1da4:	af00      	add	r7, sp, #0
    1da6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PTP_SUBSECOND_INCREMENT(SubSecondValue));
  /* Set the PTP Sub-Second Increment Register */
  ETH->PTPSSIR = SubSecondValue;    
    1da8:	4b04      	ldr	r3, [pc, #16]	; (1dbc <ETH_SetPTPSubSecondIncrement+0x1c>)
    1daa:	687a      	ldr	r2, [r7, #4]
    1dac:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
}
    1db0:	f107 070c 	add.w	r7, r7, #12
    1db4:	46bd      	mov	sp, r7
    1db6:	bc80      	pop	{r7}
    1db8:	4770      	bx	lr
    1dba:	bf00      	nop
    1dbc:	40028000 	.word	0x40028000

00001dc0 <ETH_SetPTPTimeStampUpdate>:
  * @param  SubSecondValue: specifies the PTP Time update sub-second value.
  *   This parameter is a 31 bit value, bit32 correspond to the sign.
  * @retval None
  */
void ETH_SetPTPTimeStampUpdate(uint32_t Sign, uint32_t SecondValue, uint32_t SubSecondValue)
{
    1dc0:	b480      	push	{r7}
    1dc2:	b085      	sub	sp, #20
    1dc4:	af00      	add	r7, sp, #0
    1dc6:	60f8      	str	r0, [r7, #12]
    1dc8:	60b9      	str	r1, [r7, #8]
    1dca:	607a      	str	r2, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PTP_TIME_SIGN(Sign));  
  assert_param(IS_ETH_PTP_TIME_STAMP_UPDATE_SUBSECOND(SubSecondValue)); 
  /* Set the PTP Time Update High Register */
  ETH->PTPTSHUR = SecondValue;
    1dcc:	4b07      	ldr	r3, [pc, #28]	; (1dec <ETH_SetPTPTimeStampUpdate+0x2c>)
    1dce:	68ba      	ldr	r2, [r7, #8]
    1dd0:	f8c3 2710 	str.w	r2, [r3, #1808]	; 0x710
  
  /* Set the PTP Time Update Low Register with sign */
  ETH->PTPTSLUR = Sign | SubSecondValue;   
    1dd4:	4b05      	ldr	r3, [pc, #20]	; (1dec <ETH_SetPTPTimeStampUpdate+0x2c>)
    1dd6:	68f9      	ldr	r1, [r7, #12]
    1dd8:	687a      	ldr	r2, [r7, #4]
    1dda:	ea41 0202 	orr.w	r2, r1, r2
    1dde:	f8c3 2714 	str.w	r2, [r3, #1812]	; 0x714
}
    1de2:	f107 0714 	add.w	r7, r7, #20
    1de6:	46bd      	mov	sp, r7
    1de8:	bc80      	pop	{r7}
    1dea:	4770      	bx	lr
    1dec:	40028000 	.word	0x40028000

00001df0 <ETH_SetPTPTimeStampAddend>:
  * @brief  Sets the Time Stamp Addend value.
  * @param  Value: specifies the PTP Time Stamp Addend Register value.
  * @retval None
  */
void ETH_SetPTPTimeStampAddend(uint32_t Value)
{
    1df0:	b480      	push	{r7}
    1df2:	b083      	sub	sp, #12
    1df4:	af00      	add	r7, sp, #0
    1df6:	6078      	str	r0, [r7, #4]
  /* Set the PTP Time Stamp Addend Register */
  ETH->PTPTSAR = Value;    
    1df8:	4b04      	ldr	r3, [pc, #16]	; (1e0c <ETH_SetPTPTimeStampAddend+0x1c>)
    1dfa:	687a      	ldr	r2, [r7, #4]
    1dfc:	f8c3 2718 	str.w	r2, [r3, #1816]	; 0x718
}
    1e00:	f107 070c 	add.w	r7, r7, #12
    1e04:	46bd      	mov	sp, r7
    1e06:	bc80      	pop	{r7}
    1e08:	4770      	bx	lr
    1e0a:	bf00      	nop
    1e0c:	40028000 	.word	0x40028000

00001e10 <ETH_SetPTPTargetTime>:
  * @param  HighValue: specifies the PTP Target Time High Register value.
  * @param  LowValue: specifies the PTP Target Time Low Register value.
  * @retval None
  */
void ETH_SetPTPTargetTime(uint32_t HighValue, uint32_t LowValue)
{
    1e10:	b480      	push	{r7}
    1e12:	b083      	sub	sp, #12
    1e14:	af00      	add	r7, sp, #0
    1e16:	6078      	str	r0, [r7, #4]
    1e18:	6039      	str	r1, [r7, #0]
  /* Set the PTP Target Time High Register */
  ETH->PTPTTHR = HighValue;
    1e1a:	4b06      	ldr	r3, [pc, #24]	; (1e34 <ETH_SetPTPTargetTime+0x24>)
    1e1c:	687a      	ldr	r2, [r7, #4]
    1e1e:	f8c3 271c 	str.w	r2, [r3, #1820]	; 0x71c
  /* Set the PTP Target Time Low Register */
  ETH->PTPTTLR = LowValue;    
    1e22:	4b04      	ldr	r3, [pc, #16]	; (1e34 <ETH_SetPTPTargetTime+0x24>)
    1e24:	683a      	ldr	r2, [r7, #0]
    1e26:	f8c3 2720 	str.w	r2, [r3, #1824]	; 0x720
}
    1e2a:	f107 070c 	add.w	r7, r7, #12
    1e2e:	46bd      	mov	sp, r7
    1e30:	bc80      	pop	{r7}
    1e32:	4770      	bx	lr
    1e34:	40028000 	.word	0x40028000

00001e38 <ETH_GetPTPRegister>:
  *     @arg ETH_PTPTTHR  : Target Time High Register 
  *     @arg ETH_PTPTTLR  : Target Time Low Register 
  * @retval The value of ETHERNET PTP Register value.
  */
uint32_t ETH_GetPTPRegister(uint32_t ETH_PTPReg)
{
    1e38:	b480      	push	{r7}
    1e3a:	b083      	sub	sp, #12
    1e3c:	af00      	add	r7, sp, #0
    1e3e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PTP_REGISTER(ETH_PTPReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_PTPReg));
    1e40:	687b      	ldr	r3, [r7, #4]
    1e42:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    1e46:	f503 3320 	add.w	r3, r3, #163840	; 0x28000
    1e4a:	681b      	ldr	r3, [r3, #0]
}
    1e4c:	4618      	mov	r0, r3
    1e4e:	f107 070c 	add.w	r7, r7, #12
    1e52:	46bd      	mov	sp, r7
    1e54:	bc80      	pop	{r7}
    1e56:	4770      	bx	lr

00001e58 <ETH_DMAPTPTxDescChainInit>:
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMAPTPTxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, ETH_DMADESCTypeDef *DMAPTPTxDescTab,
                               uint8_t* TxBuff, uint32_t TxBuffCount)
{
    1e58:	b480      	push	{r7}
    1e5a:	b087      	sub	sp, #28
    1e5c:	af00      	add	r7, sp, #0
    1e5e:	60f8      	str	r0, [r7, #12]
    1e60:	60b9      	str	r1, [r7, #8]
    1e62:	607a      	str	r2, [r7, #4]
    1e64:	603b      	str	r3, [r7, #0]
  uint32_t i = 0;
    1e66:	f04f 0300 	mov.w	r3, #0
    1e6a:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
    1e6c:	4b2f      	ldr	r3, [pc, #188]	; (1f2c <ETH_DMAPTPTxDescChainInit+0xd4>)
    1e6e:	68fa      	ldr	r2, [r7, #12]
    1e70:	601a      	str	r2, [r3, #0]
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
    1e72:	4b2f      	ldr	r3, [pc, #188]	; (1f30 <ETH_DMAPTPTxDescChainInit+0xd8>)
    1e74:	68ba      	ldr	r2, [r7, #8]
    1e76:	601a      	str	r2, [r3, #0]
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
    1e78:	f04f 0300 	mov.w	r3, #0
    1e7c:	617b      	str	r3, [r7, #20]
    1e7e:	e03b      	b.n	1ef8 <ETH_DMAPTPTxDescChainInit+0xa0>
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab+i;
    1e80:	697b      	ldr	r3, [r7, #20]
    1e82:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1e86:	68fa      	ldr	r2, [r7, #12]
    1e88:	18d3      	adds	r3, r2, r3
    1e8a:	613b      	str	r3, [r7, #16]
    /* Set Second Address Chained bit and enable PTP */
    DMATxDesc->Status = ETH_DMATxDesc_TCH | ETH_DMATxDesc_TTSE;  
    1e8c:	693b      	ldr	r3, [r7, #16]
    1e8e:	f04f 7204 	mov.w	r2, #34603008	; 0x2100000
    1e92:	601a      	str	r2, [r3, #0]
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr =(uint32_t)(&TxBuff[i*ETH_MAX_PACKET_SIZE]);
    1e94:	697b      	ldr	r3, [r7, #20]
    1e96:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    1e9a:	fb02 f303 	mul.w	r3, r2, r3
    1e9e:	687a      	ldr	r2, [r7, #4]
    1ea0:	18d3      	adds	r3, r2, r3
    1ea2:	461a      	mov	r2, r3
    1ea4:	693b      	ldr	r3, [r7, #16]
    1ea6:	609a      	str	r2, [r3, #8]
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (TxBuffCount-1))
    1ea8:	683b      	ldr	r3, [r7, #0]
    1eaa:	f103 32ff 	add.w	r2, r3, #4294967295
    1eae:	697b      	ldr	r3, [r7, #20]
    1eb0:	429a      	cmp	r2, r3
    1eb2:	d90a      	bls.n	1eca <ETH_DMAPTPTxDescChainInit+0x72>
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
    1eb4:	697b      	ldr	r3, [r7, #20]
    1eb6:	f103 0301 	add.w	r3, r3, #1
    1eba:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1ebe:	68fa      	ldr	r2, [r7, #12]
    1ec0:	18d3      	adds	r3, r2, r3
    1ec2:	461a      	mov	r2, r3
    1ec4:	693b      	ldr	r3, [r7, #16]
    1ec6:	60da      	str	r2, [r3, #12]
    1ec8:	e002      	b.n	1ed0 <ETH_DMAPTPTxDescChainInit+0x78>
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    1eca:	68fa      	ldr	r2, [r7, #12]
    1ecc:	693b      	ldr	r3, [r7, #16]
    1ece:	60da      	str	r2, [r3, #12]
    }
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
    1ed0:	697b      	ldr	r3, [r7, #20]
    1ed2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1ed6:	68ba      	ldr	r2, [r7, #8]
    1ed8:	18d3      	adds	r3, r2, r3
    1eda:	693a      	ldr	r2, [r7, #16]
    1edc:	6892      	ldr	r2, [r2, #8]
    1ede:	609a      	str	r2, [r3, #8]
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
    1ee0:	697b      	ldr	r3, [r7, #20]
    1ee2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1ee6:	68ba      	ldr	r2, [r7, #8]
    1ee8:	18d3      	adds	r3, r2, r3
    1eea:	693a      	ldr	r2, [r7, #16]
    1eec:	68d2      	ldr	r2, [r2, #12]
    1eee:	60da      	str	r2, [r3, #12]
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  DMAPTPTxDescToSet = DMAPTPTxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
    1ef0:	697b      	ldr	r3, [r7, #20]
    1ef2:	f103 0301 	add.w	r3, r3, #1
    1ef6:	617b      	str	r3, [r7, #20]
    1ef8:	697a      	ldr	r2, [r7, #20]
    1efa:	683b      	ldr	r3, [r7, #0]
    1efc:	429a      	cmp	r2, r3
    1efe:	d3bf      	bcc.n	1e80 <ETH_DMAPTPTxDescChainInit+0x28>
    /* make DMAPTPTxDescTab points to the same addresses as DMATxDescTab */
    (&DMAPTPTxDescTab[i])->Buffer1Addr = DMATxDesc->Buffer1Addr;
    (&DMAPTPTxDescTab[i])->Buffer2NextDescAddr = DMATxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPTxDescTab desc status record the first list address */
  (&DMAPTPTxDescTab[i-1])->Status = (uint32_t) DMAPTPTxDescTab;
    1f00:	697b      	ldr	r3, [r7, #20]
    1f02:	f103 33ff 	add.w	r3, r3, #4294967295
    1f06:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1f0a:	68ba      	ldr	r2, [r7, #8]
    1f0c:	18d3      	adds	r3, r2, r3
    1f0e:	68ba      	ldr	r2, [r7, #8]
    1f10:	601a      	str	r2, [r3, #0]

  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
    1f12:	4b08      	ldr	r3, [pc, #32]	; (1f34 <ETH_DMAPTPTxDescChainInit+0xdc>)
    1f14:	68fa      	ldr	r2, [r7, #12]
    1f16:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    1f1a:	f103 0310 	add.w	r3, r3, #16
    1f1e:	601a      	str	r2, [r3, #0]
}
    1f20:	f107 071c 	add.w	r7, r7, #28
    1f24:	46bd      	mov	sp, r7
    1f26:	bc80      	pop	{r7}
    1f28:	4770      	bx	lr
    1f2a:	bf00      	nop
	...
			1f2c: R_ARM_ABS32	DMATxDescToSet
			1f30: R_ARM_ABS32	DMAPTPTxDescToSet
    1f34:	40028000 	.word	0x40028000

00001f38 <ETH_DMAPTPRxDescChainInit>:
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMAPTPRxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, ETH_DMADESCTypeDef *DMAPTPRxDescTab,
                               uint8_t *RxBuff, uint32_t RxBuffCount)
{
    1f38:	b480      	push	{r7}
    1f3a:	b087      	sub	sp, #28
    1f3c:	af00      	add	r7, sp, #0
    1f3e:	60f8      	str	r0, [r7, #12]
    1f40:	60b9      	str	r1, [r7, #8]
    1f42:	607a      	str	r2, [r7, #4]
    1f44:	603b      	str	r3, [r7, #0]
  uint32_t i = 0;
    1f46:	f04f 0300 	mov.w	r3, #0
    1f4a:	617b      	str	r3, [r7, #20]
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
    1f4c:	4b31      	ldr	r3, [pc, #196]	; (2014 <ETH_DMAPTPRxDescChainInit+0xdc>)
    1f4e:	68fa      	ldr	r2, [r7, #12]
    1f50:	601a      	str	r2, [r3, #0]
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
    1f52:	4b31      	ldr	r3, [pc, #196]	; (2018 <ETH_DMAPTPRxDescChainInit+0xe0>)
    1f54:	68ba      	ldr	r2, [r7, #8]
    1f56:	601a      	str	r2, [r3, #0]
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
    1f58:	f04f 0300 	mov.w	r3, #0
    1f5c:	617b      	str	r3, [r7, #20]
    1f5e:	e03f      	b.n	1fe0 <ETH_DMAPTPRxDescChainInit+0xa8>
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    1f60:	697b      	ldr	r3, [r7, #20]
    1f62:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1f66:	68fa      	ldr	r2, [r7, #12]
    1f68:	18d3      	adds	r3, r2, r3
    1f6a:	613b      	str	r3, [r7, #16]
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
    1f6c:	693b      	ldr	r3, [r7, #16]
    1f6e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    1f72:	601a      	str	r2, [r3, #0]

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_MAX_PACKET_SIZE;  
    1f74:	693b      	ldr	r3, [r7, #16]
    1f76:	f244 52f0 	movw	r2, #17904	; 0x45f0
    1f7a:	605a      	str	r2, [r3, #4]
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_MAX_PACKET_SIZE]);
    1f7c:	697b      	ldr	r3, [r7, #20]
    1f7e:	f44f 62be 	mov.w	r2, #1520	; 0x5f0
    1f82:	fb02 f303 	mul.w	r3, r2, r3
    1f86:	687a      	ldr	r2, [r7, #4]
    1f88:	18d3      	adds	r3, r2, r3
    1f8a:	461a      	mov	r2, r3
    1f8c:	693b      	ldr	r3, [r7, #16]
    1f8e:	609a      	str	r2, [r3, #8]
    
    /* Initialize the next descriptor with the Next Desciptor Polling Enable */
    if(i < (RxBuffCount-1))
    1f90:	683b      	ldr	r3, [r7, #0]
    1f92:	f103 32ff 	add.w	r2, r3, #4294967295
    1f96:	697b      	ldr	r3, [r7, #20]
    1f98:	429a      	cmp	r2, r3
    1f9a:	d90a      	bls.n	1fb2 <ETH_DMAPTPRxDescChainInit+0x7a>
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
    1f9c:	697b      	ldr	r3, [r7, #20]
    1f9e:	f103 0301 	add.w	r3, r3, #1
    1fa2:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1fa6:	68fa      	ldr	r2, [r7, #12]
    1fa8:	18d3      	adds	r3, r2, r3
    1faa:	461a      	mov	r2, r3
    1fac:	693b      	ldr	r3, [r7, #16]
    1fae:	60da      	str	r2, [r3, #12]
    1fb0:	e002      	b.n	1fb8 <ETH_DMAPTPRxDescChainInit+0x80>
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    1fb2:	68fa      	ldr	r2, [r7, #12]
    1fb4:	693b      	ldr	r3, [r7, #16]
    1fb6:	60da      	str	r2, [r3, #12]
    }
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
    1fb8:	697b      	ldr	r3, [r7, #20]
    1fba:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1fbe:	68ba      	ldr	r2, [r7, #8]
    1fc0:	18d3      	adds	r3, r2, r3
    1fc2:	693a      	ldr	r2, [r7, #16]
    1fc4:	6892      	ldr	r2, [r2, #8]
    1fc6:	609a      	str	r2, [r3, #8]
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
    1fc8:	697b      	ldr	r3, [r7, #20]
    1fca:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1fce:	68ba      	ldr	r2, [r7, #8]
    1fd0:	18d3      	adds	r3, r2, r3
    1fd2:	693a      	ldr	r2, [r7, #16]
    1fd4:	68d2      	ldr	r2, [r2, #12]
    1fd6:	60da      	str	r2, [r3, #12]
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  DMAPTPRxDescToGet = DMAPTPRxDescTab;
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
    1fd8:	697b      	ldr	r3, [r7, #20]
    1fda:	f103 0301 	add.w	r3, r3, #1
    1fde:	617b      	str	r3, [r7, #20]
    1fe0:	697a      	ldr	r2, [r7, #20]
    1fe2:	683b      	ldr	r3, [r7, #0]
    1fe4:	429a      	cmp	r2, r3
    1fe6:	d3bb      	bcc.n	1f60 <ETH_DMAPTPRxDescChainInit+0x28>
    /* Make DMAPTPRxDescTab points to the same addresses as DMARxDescTab */
    (&DMAPTPRxDescTab[i])->Buffer1Addr = DMARxDesc->Buffer1Addr;
    (&DMAPTPRxDescTab[i])->Buffer2NextDescAddr = DMARxDesc->Buffer2NextDescAddr;
  }
  /* Store on the last DMAPTPRxDescTab desc status record the first list address */
  (&DMAPTPRxDescTab[i-1])->Status = (uint32_t) DMAPTPRxDescTab;
    1fe8:	697b      	ldr	r3, [r7, #20]
    1fea:	f103 33ff 	add.w	r3, r3, #4294967295
    1fee:	ea4f 1303 	mov.w	r3, r3, lsl #4
    1ff2:	68ba      	ldr	r2, [r7, #8]
    1ff4:	18d3      	adds	r3, r2, r3
    1ff6:	68ba      	ldr	r2, [r7, #8]
    1ff8:	601a      	str	r2, [r3, #0]

  /* Set Receive Desciptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab;  
    1ffa:	4b08      	ldr	r3, [pc, #32]	; (201c <ETH_DMAPTPRxDescChainInit+0xe4>)
    1ffc:	68fa      	ldr	r2, [r7, #12]
    1ffe:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2002:	f103 030c 	add.w	r3, r3, #12
    2006:	601a      	str	r2, [r3, #0]
}
    2008:	f107 071c 	add.w	r7, r7, #28
    200c:	46bd      	mov	sp, r7
    200e:	bc80      	pop	{r7}
    2010:	4770      	bx	lr
    2012:	bf00      	nop
	...
			2014: R_ARM_ABS32	DMARxDescToGet
			2018: R_ARM_ABS32	DMAPTPRxDescToGet
    201c:	40028000 	.word	0x40028000

00002020 <ETH_HandlePTPTxPkt>:
  * @param  PTPTxTab: Pointer on the first PTP Tx table to store Time stamp values.
  * @retval ETH_ERROR: in case of Tx desc owned by DMA
  *         ETH_SUCCESS: for correct transmission
  */
uint32_t ETH_HandlePTPTxPkt(uint8_t *ppkt, uint16_t FrameLength, uint32_t *PTPTxTab)
{
    2020:	b480      	push	{r7}
    2022:	b087      	sub	sp, #28
    2024:	af00      	add	r7, sp, #0
    2026:	60f8      	str	r0, [r7, #12]
    2028:	460b      	mov	r3, r1
    202a:	607a      	str	r2, [r7, #4]
    202c:	817b      	strh	r3, [r7, #10]
  uint32_t offset = 0, timeout = 0;
    202e:	f04f 0300 	mov.w	r3, #0
    2032:	617b      	str	r3, [r7, #20]
    2034:	f04f 0300 	mov.w	r3, #0
    2038:	613b      	str	r3, [r7, #16]
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (uint32_t)RESET)
    203a:	4b6f      	ldr	r3, [pc, #444]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    203c:	681b      	ldr	r3, [r3, #0]
    203e:	681b      	ldr	r3, [r3, #0]
    2040:	2b00      	cmp	r3, #0
    2042:	da02      	bge.n	204a <ETH_HandlePTPTxPkt+0x2a>
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
    2044:	f04f 0300 	mov.w	r3, #0
    2048:	e0d0      	b.n	21ec <ETH_HandlePTPTxPkt+0x1cc>
  }
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)
    204a:	f04f 0300 	mov.w	r3, #0
    204e:	617b      	str	r3, [r7, #20]
    2050:	e00d      	b.n	206e <ETH_HandlePTPTxPkt+0x4e>
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
    2052:	4b6a      	ldr	r3, [pc, #424]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    2054:	681b      	ldr	r3, [r3, #0]
    2056:	689a      	ldr	r2, [r3, #8]
    2058:	697b      	ldr	r3, [r7, #20]
    205a:	18d3      	adds	r3, r2, r3
    205c:	68f9      	ldr	r1, [r7, #12]
    205e:	697a      	ldr	r2, [r7, #20]
    2060:	188a      	adds	r2, r1, r2
    2062:	7812      	ldrb	r2, [r2, #0]
    2064:	701a      	strb	r2, [r3, #0]
  {
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
  }
  /* Copy the frame to be sent into memory pointed by the current ETHERNET DMA Tx descriptor */      
  for(offset=0; offset<FrameLength; offset++)
    2066:	697b      	ldr	r3, [r7, #20]
    2068:	f103 0301 	add.w	r3, r3, #1
    206c:	617b      	str	r3, [r7, #20]
    206e:	897a      	ldrh	r2, [r7, #10]
    2070:	697b      	ldr	r3, [r7, #20]
    2072:	429a      	cmp	r2, r3
    2074:	d8ed      	bhi.n	2052 <ETH_HandlePTPTxPkt+0x32>
  {
    (*(__IO uint8_t *)((DMAPTPTxDescToSet->Buffer1Addr) + offset)) = (*(ppkt + offset));
  }
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & (uint32_t)0x1FFF);
    2076:	4b60      	ldr	r3, [pc, #384]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    2078:	681a      	ldr	r2, [r3, #0]
    207a:	897b      	ldrh	r3, [r7, #10]
    207c:	ea4f 43c3 	mov.w	r3, r3, lsl #19
    2080:	ea4f 43d3 	mov.w	r3, r3, lsr #19
    2084:	6053      	str	r3, [r2, #4]
  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
    2086:	4b5c      	ldr	r3, [pc, #368]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    2088:	681b      	ldr	r3, [r3, #0]
    208a:	4a5b      	ldr	r2, [pc, #364]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    208c:	6812      	ldr	r2, [r2, #0]
    208e:	6812      	ldr	r2, [r2, #0]
    2090:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
    2094:	601a      	str	r2, [r3, #0]
  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
    2096:	4b58      	ldr	r3, [pc, #352]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    2098:	681b      	ldr	r3, [r3, #0]
    209a:	4a57      	ldr	r2, [pc, #348]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    209c:	6812      	ldr	r2, [r2, #0]
    209e:	6812      	ldr	r2, [r2, #0]
    20a0:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    20a4:	601a      	str	r2, [r3, #0]
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
    20a6:	4b56      	ldr	r3, [pc, #344]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    20a8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    20ac:	f103 0314 	add.w	r3, r3, #20
    20b0:	681b      	ldr	r3, [r3, #0]
    20b2:	f003 0304 	and.w	r3, r3, #4
    20b6:	2b00      	cmp	r3, #0
    20b8:	d00f      	beq.n	20da <ETH_HandlePTPTxPkt+0xba>
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
    20ba:	4b51      	ldr	r3, [pc, #324]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    20bc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    20c0:	f103 0314 	add.w	r3, r3, #20
    20c4:	f04f 0204 	mov.w	r2, #4
    20c8:	601a      	str	r2, [r3, #0]
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
    20ca:	4b4d      	ldr	r3, [pc, #308]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    20cc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    20d0:	f103 0304 	add.w	r3, r3, #4
    20d4:	f04f 0200 	mov.w	r2, #0
    20d8:	601a      	str	r2, [r3, #0]
  }
  /* Wait for ETH_DMATxDesc_TTSS flag to be set */
  do
  {
    timeout++;
    20da:	693b      	ldr	r3, [r7, #16]
    20dc:	f103 0301 	add.w	r3, r3, #1
    20e0:	613b      	str	r3, [r7, #16]
  } while (!(DMATxDescToSet->Status & ETH_DMATxDesc_TTSS) && (timeout < 0xFFFF));
    20e2:	4b45      	ldr	r3, [pc, #276]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    20e4:	681b      	ldr	r3, [r3, #0]
    20e6:	681b      	ldr	r3, [r3, #0]
    20e8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    20ec:	2b00      	cmp	r3, #0
    20ee:	d104      	bne.n	20fa <ETH_HandlePTPTxPkt+0xda>
    20f0:	693a      	ldr	r2, [r7, #16]
    20f2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
    20f6:	429a      	cmp	r2, r3
    20f8:	d9ef      	bls.n	20da <ETH_HandlePTPTxPkt+0xba>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
    20fa:	693a      	ldr	r2, [r7, #16]
    20fc:	4b41      	ldr	r3, [pc, #260]	; (2204 <ETH_HandlePTPTxPkt+0x1e4>)
    20fe:	429a      	cmp	r2, r3
    2100:	d102      	bne.n	2108 <ETH_HandlePTPTxPkt+0xe8>
  {
    return ETH_ERROR;
    2102:	f04f 0300 	mov.w	r3, #0
    2106:	e071      	b.n	21ec <ETH_HandlePTPTxPkt+0x1cc>
  }
  /* Clear the DMATxDescToSet status register TTSS flag */
  DMATxDescToSet->Status &= ~ETH_DMATxDesc_TTSS;
    2108:	4b3b      	ldr	r3, [pc, #236]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    210a:	681b      	ldr	r3, [r3, #0]
    210c:	4a3a      	ldr	r2, [pc, #232]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    210e:	6812      	ldr	r2, [r2, #0]
    2110:	6812      	ldr	r2, [r2, #0]
    2112:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
    2116:	601a      	str	r2, [r3, #0]
  *PTPTxTab++ = DMATxDescToSet->Buffer1Addr;
    2118:	4b37      	ldr	r3, [pc, #220]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    211a:	681b      	ldr	r3, [r3, #0]
    211c:	689a      	ldr	r2, [r3, #8]
    211e:	687b      	ldr	r3, [r7, #4]
    2120:	601a      	str	r2, [r3, #0]
    2122:	687b      	ldr	r3, [r7, #4]
    2124:	f103 0304 	add.w	r3, r3, #4
    2128:	607b      	str	r3, [r7, #4]
  *PTPTxTab = DMATxDescToSet->Buffer2NextDescAddr;
    212a:	4b33      	ldr	r3, [pc, #204]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    212c:	681b      	ldr	r3, [r3, #0]
    212e:	68da      	ldr	r2, [r3, #12]
    2130:	687b      	ldr	r3, [r7, #4]
    2132:	601a      	str	r2, [r3, #0]
  /* Update the ENET DMA current descriptor */
  /* Chained Mode */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_TCH) != (uint32_t)RESET)
    2134:	4b30      	ldr	r3, [pc, #192]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    2136:	681b      	ldr	r3, [r3, #0]
    2138:	681b      	ldr	r3, [r3, #0]
    213a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    213e:	2b00      	cmp	r3, #0
    2140:	d018      	beq.n	2174 <ETH_HandlePTPTxPkt+0x154>
  {  
    /* Selects the next DMA Tx descriptor list for next buffer read */ 
    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet->Buffer2NextDescAddr);
    2142:	4b2e      	ldr	r3, [pc, #184]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    2144:	681b      	ldr	r3, [r3, #0]
    2146:	68db      	ldr	r3, [r3, #12]
    2148:	461a      	mov	r2, r3
    214a:	4b2b      	ldr	r3, [pc, #172]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    214c:	601a      	str	r2, [r3, #0]
    if(DMAPTPTxDescToSet->Status != 0)
    214e:	4b2b      	ldr	r3, [pc, #172]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    2150:	681b      	ldr	r3, [r3, #0]
    2152:	681b      	ldr	r3, [r3, #0]
    2154:	2b00      	cmp	r3, #0
    2156:	d006      	beq.n	2166 <ETH_HandlePTPTxPkt+0x146>
    { 
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (DMAPTPTxDescToSet->Status);
    2158:	4b28      	ldr	r3, [pc, #160]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    215a:	681b      	ldr	r3, [r3, #0]
    215c:	681b      	ldr	r3, [r3, #0]
    215e:	461a      	mov	r2, r3
    2160:	4b26      	ldr	r3, [pc, #152]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    2162:	601a      	str	r2, [r3, #0]
    2164:	e040      	b.n	21e8 <ETH_HandlePTPTxPkt+0x1c8>
    }
    else
    {
      DMAPTPTxDescToSet++;
    2166:	4b25      	ldr	r3, [pc, #148]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    2168:	681b      	ldr	r3, [r3, #0]
    216a:	f103 0210 	add.w	r2, r3, #16
    216e:	4b23      	ldr	r3, [pc, #140]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    2170:	601a      	str	r2, [r3, #0]
    2172:	e039      	b.n	21e8 <ETH_HandlePTPTxPkt+0x1c8>
    }
  }
  else /* Ring Mode */
  {  
    if((DMATxDescToSet->Status & ETH_DMATxDesc_TER) != (uint32_t)RESET)
    2174:	4b20      	ldr	r3, [pc, #128]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    2176:	681b      	ldr	r3, [r3, #0]
    2178:	681b      	ldr	r3, [r3, #0]
    217a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    217e:	2b00      	cmp	r3, #0
    2180:	d012      	beq.n	21a8 <ETH_HandlePTPTxPkt+0x188>
    {
      /* Selects the next DMA Tx descriptor list for next buffer read: this will
         be the first Tx descriptor in this case */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR); 
    2182:	4b1f      	ldr	r3, [pc, #124]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    2184:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2188:	f103 0310 	add.w	r3, r3, #16
    218c:	681b      	ldr	r3, [r3, #0]
    218e:	461a      	mov	r2, r3
    2190:	4b19      	ldr	r3, [pc, #100]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    2192:	601a      	str	r2, [r3, #0]
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) (ETH->DMATDLAR);
    2194:	4b1a      	ldr	r3, [pc, #104]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    2196:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    219a:	f103 0310 	add.w	r3, r3, #16
    219e:	681b      	ldr	r3, [r3, #0]
    21a0:	461a      	mov	r2, r3
    21a2:	4b16      	ldr	r3, [pc, #88]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    21a4:	601a      	str	r2, [r3, #0]
    21a6:	e01f      	b.n	21e8 <ETH_HandlePTPTxPkt+0x1c8>
    }
    else
    {
      /* Selects the next DMA Tx descriptor list for next buffer read */
      DMATxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMATxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
    21a8:	4b15      	ldr	r3, [pc, #84]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    21aa:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    21ae:	681b      	ldr	r3, [r3, #0]
    21b0:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    21b4:	ea4f 0293 	mov.w	r2, r3, lsr #2
    21b8:	4b0f      	ldr	r3, [pc, #60]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    21ba:	681b      	ldr	r3, [r3, #0]
    21bc:	18d3      	adds	r3, r2, r3
    21be:	f103 0310 	add.w	r3, r3, #16
    21c2:	461a      	mov	r2, r3
    21c4:	4b0c      	ldr	r3, [pc, #48]	; (21f8 <ETH_HandlePTPTxPkt+0x1d8>)
    21c6:	601a      	str	r2, [r3, #0]
      DMAPTPTxDescToSet = (ETH_DMADESCTypeDef*) ((uint32_t)DMAPTPTxDescToSet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
    21c8:	4b0d      	ldr	r3, [pc, #52]	; (2200 <ETH_HandlePTPTxPkt+0x1e0>)
    21ca:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    21ce:	681b      	ldr	r3, [r3, #0]
    21d0:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    21d4:	ea4f 0293 	mov.w	r2, r3, lsr #2
    21d8:	4b08      	ldr	r3, [pc, #32]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    21da:	681b      	ldr	r3, [r3, #0]
    21dc:	18d3      	adds	r3, r2, r3
    21de:	f103 0310 	add.w	r3, r3, #16
    21e2:	461a      	mov	r2, r3
    21e4:	4b05      	ldr	r3, [pc, #20]	; (21fc <ETH_HandlePTPTxPkt+0x1dc>)
    21e6:	601a      	str	r2, [r3, #0]
    }
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;
    21e8:	f04f 0301 	mov.w	r3, #1
}
    21ec:	4618      	mov	r0, r3
    21ee:	f107 071c 	add.w	r7, r7, #28
    21f2:	46bd      	mov	sp, r7
    21f4:	bc80      	pop	{r7}
    21f6:	4770      	bx	lr
	...
			21f8: R_ARM_ABS32	DMATxDescToSet
			21fc: R_ARM_ABS32	DMAPTPTxDescToSet
    2200:	40028000 	.word	0x40028000
    2204:	0004ffff 	.word	0x0004ffff

00002208 <ETH_HandlePTPRxPkt>:
  * @param  PTPRxTab: Pointer on the first PTP Rx table to store Time stamp values.
  * @retval ETH_ERROR: if there is error in reception
  *         framelength: received packet size if packet reception is correct
  */
uint32_t ETH_HandlePTPRxPkt(uint8_t *ppkt, uint32_t *PTPRxTab)
{
    2208:	b480      	push	{r7}
    220a:	b085      	sub	sp, #20
    220c:	af00      	add	r7, sp, #0
    220e:	6078      	str	r0, [r7, #4]
    2210:	6039      	str	r1, [r7, #0]
  uint32_t offset = 0, framelength = 0;
    2212:	f04f 0300 	mov.w	r3, #0
    2216:	60fb      	str	r3, [r7, #12]
    2218:	f04f 0300 	mov.w	r3, #0
    221c:	60bb      	str	r3, [r7, #8]
  /* Check if the descriptor is owned by the ENET or CPU */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
    221e:	4b5d      	ldr	r3, [pc, #372]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2220:	681b      	ldr	r3, [r3, #0]
    2222:	681b      	ldr	r3, [r3, #0]
    2224:	2b00      	cmp	r3, #0
    2226:	da02      	bge.n	222e <ETH_HandlePTPRxPkt+0x26>
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
    2228:	f04f 0300 	mov.w	r3, #0
    222c:	e0ac      	b.n	2388 <ETH_HandlePTPRxPkt+0x180>
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
    222e:	4b59      	ldr	r3, [pc, #356]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2230:	681b      	ldr	r3, [r3, #0]
    2232:	681b      	ldr	r3, [r3, #0]
    2234:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    2238:	2b00      	cmp	r3, #0
    223a:	d130      	bne.n	229e <ETH_HandlePTPRxPkt+0x96>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
    223c:	4b55      	ldr	r3, [pc, #340]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    223e:	681b      	ldr	r3, [r3, #0]
    2240:	681b      	ldr	r3, [r3, #0]
    2242:	f403 7380 	and.w	r3, r3, #256	; 0x100
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
    2246:	2b00      	cmp	r3, #0
    2248:	d029      	beq.n	229e <ETH_HandlePTPRxPkt+0x96>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
    224a:	4b52      	ldr	r3, [pc, #328]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    224c:	681b      	ldr	r3, [r3, #0]
    224e:	681b      	ldr	r3, [r3, #0]
    2250:	f403 7300 	and.w	r3, r3, #512	; 0x200
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET) &&
    2254:	2b00      	cmp	r3, #0
    2256:	d022      	beq.n	229e <ETH_HandlePTPRxPkt+0x96>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    2258:	4b4e      	ldr	r3, [pc, #312]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    225a:	681b      	ldr	r3, [r3, #0]
    225c:	681a      	ldr	r2, [r3, #0]
    225e:	4b4e      	ldr	r3, [pc, #312]	; (2398 <ETH_HandlePTPRxPkt+0x190>)
    2260:	ea02 0303 	and.w	r3, r2, r3
    2264:	ea4f 4313 	mov.w	r3, r3, lsr #16
    2268:	f1a3 0304 	sub.w	r3, r3, #4
    226c:	60bb      	str	r3, [r7, #8]
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ 
    for(offset=0; offset<framelength; offset++)
    226e:	f04f 0300 	mov.w	r3, #0
    2272:	60fb      	str	r3, [r7, #12]
    2274:	e00e      	b.n	2294 <ETH_HandlePTPRxPkt+0x8c>
    {
      (*(ppkt + offset)) = (*(__IO uint8_t *)((DMAPTPRxDescToGet->Buffer1Addr) + offset));
    2276:	687a      	ldr	r2, [r7, #4]
    2278:	68fb      	ldr	r3, [r7, #12]
    227a:	18d3      	adds	r3, r2, r3
    227c:	4a47      	ldr	r2, [pc, #284]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    227e:	6812      	ldr	r2, [r2, #0]
    2280:	6891      	ldr	r1, [r2, #8]
    2282:	68fa      	ldr	r2, [r7, #12]
    2284:	188a      	adds	r2, r1, r2
    2286:	7812      	ldrb	r2, [r2, #0]
    2288:	b2d2      	uxtb	r2, r2
    228a:	701a      	strb	r2, [r3, #0]
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET))
  {
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT) - 4;
    /* Copy the received frame into buffer from memory pointed by the current ETHERNET DMA Rx descriptor */ 
    for(offset=0; offset<framelength; offset++)
    228c:	68fb      	ldr	r3, [r7, #12]
    228e:	f103 0301 	add.w	r3, r3, #1
    2292:	60fb      	str	r3, [r7, #12]
    2294:	68fa      	ldr	r2, [r7, #12]
    2296:	68bb      	ldr	r3, [r7, #8]
    2298:	429a      	cmp	r2, r3
    229a:	d3ec      	bcc.n	2276 <ETH_HandlePTPRxPkt+0x6e>
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (uint32_t)RESET)
  {
    /* Return error: OWN bit set */
    return ETH_ERROR;
  }
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
    229c:	e002      	b.n	22a4 <ETH_HandlePTPRxPkt+0x9c>
    }
  }
  else
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
    229e:	f04f 0300 	mov.w	r3, #0
    22a2:	60bb      	str	r3, [r7, #8]
  }
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
    22a4:	4b3e      	ldr	r3, [pc, #248]	; (23a0 <ETH_HandlePTPRxPkt+0x198>)
    22a6:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    22aa:	f103 0314 	add.w	r3, r3, #20
    22ae:	681b      	ldr	r3, [r3, #0]
    22b0:	f003 0380 	and.w	r3, r3, #128	; 0x80
    22b4:	2b00      	cmp	r3, #0
    22b6:	d00f      	beq.n	22d8 <ETH_HandlePTPRxPkt+0xd0>
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
    22b8:	4b39      	ldr	r3, [pc, #228]	; (23a0 <ETH_HandlePTPRxPkt+0x198>)
    22ba:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    22be:	f103 0314 	add.w	r3, r3, #20
    22c2:	f04f 0280 	mov.w	r2, #128	; 0x80
    22c6:	601a      	str	r2, [r3, #0]
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
    22c8:	4b35      	ldr	r3, [pc, #212]	; (23a0 <ETH_HandlePTPRxPkt+0x198>)
    22ca:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    22ce:	f103 0308 	add.w	r3, r3, #8
    22d2:	f04f 0200 	mov.w	r2, #0
    22d6:	601a      	str	r2, [r3, #0]
  }
  *PTPRxTab++ = DMARxDescToGet->Buffer1Addr;
    22d8:	4b2e      	ldr	r3, [pc, #184]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    22da:	681b      	ldr	r3, [r3, #0]
    22dc:	689a      	ldr	r2, [r3, #8]
    22de:	683b      	ldr	r3, [r7, #0]
    22e0:	601a      	str	r2, [r3, #0]
    22e2:	683b      	ldr	r3, [r7, #0]
    22e4:	f103 0304 	add.w	r3, r3, #4
    22e8:	603b      	str	r3, [r7, #0]
  *PTPRxTab = DMARxDescToGet->Buffer2NextDescAddr;
    22ea:	4b2a      	ldr	r3, [pc, #168]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    22ec:	681b      	ldr	r3, [r3, #0]
    22ee:	68da      	ldr	r2, [r3, #12]
    22f0:	683b      	ldr	r3, [r7, #0]
    22f2:	601a      	str	r2, [r3, #0]
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMARxDescToGet->Status |= ETH_DMARxDesc_OWN;
    22f4:	4b27      	ldr	r3, [pc, #156]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    22f6:	681b      	ldr	r3, [r3, #0]
    22f8:	4a26      	ldr	r2, [pc, #152]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    22fa:	6812      	ldr	r2, [r2, #0]
    22fc:	6812      	ldr	r2, [r2, #0]
    22fe:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
    2302:	601a      	str	r2, [r3, #0]
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */
  /* Chained Mode */
  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
    2304:	4b23      	ldr	r3, [pc, #140]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2306:	681b      	ldr	r3, [r3, #0]
    2308:	685b      	ldr	r3, [r3, #4]
    230a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    230e:	2b00      	cmp	r3, #0
    2310:	d018      	beq.n	2344 <ETH_HandlePTPRxPkt+0x13c>
  {
    /* Selects the next DMA Rx descriptor list for next buffer read */
    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet->Buffer2NextDescAddr);
    2312:	4b22      	ldr	r3, [pc, #136]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    2314:	681b      	ldr	r3, [r3, #0]
    2316:	68db      	ldr	r3, [r3, #12]
    2318:	461a      	mov	r2, r3
    231a:	4b1e      	ldr	r3, [pc, #120]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    231c:	601a      	str	r2, [r3, #0]
    if(DMAPTPRxDescToGet->Status != 0)
    231e:	4b1f      	ldr	r3, [pc, #124]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    2320:	681b      	ldr	r3, [r3, #0]
    2322:	681b      	ldr	r3, [r3, #0]
    2324:	2b00      	cmp	r3, #0
    2326:	d006      	beq.n	2336 <ETH_HandlePTPRxPkt+0x12e>
    {
      DMAPTPRxDescToGet = (ETH_DMADESCTypeDef*) (DMAPTPRxDescToGet->Status);
    2328:	4b1c      	ldr	r3, [pc, #112]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    232a:	681b      	ldr	r3, [r3, #0]
    232c:	681b      	ldr	r3, [r3, #0]
    232e:	461a      	mov	r2, r3
    2330:	4b1a      	ldr	r3, [pc, #104]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    2332:	601a      	str	r2, [r3, #0]
    2334:	e027      	b.n	2386 <ETH_HandlePTPRxPkt+0x17e>
    }
    else
    {
      DMAPTPRxDescToGet++;
    2336:	4b19      	ldr	r3, [pc, #100]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    2338:	681b      	ldr	r3, [r3, #0]
    233a:	f103 0210 	add.w	r2, r3, #16
    233e:	4b17      	ldr	r3, [pc, #92]	; (239c <ETH_HandlePTPRxPkt+0x194>)
    2340:	601a      	str	r2, [r3, #0]
    2342:	e020      	b.n	2386 <ETH_HandlePTPRxPkt+0x17e>
    }
  }
  else /* Ring Mode */
  {
    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
    2344:	4b13      	ldr	r3, [pc, #76]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2346:	681b      	ldr	r3, [r3, #0]
    2348:	685b      	ldr	r3, [r3, #4]
    234a:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    234e:	2b00      	cmp	r3, #0
    2350:	d009      	beq.n	2366 <ETH_HandlePTPRxPkt+0x15e>
    {
      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);
    2352:	4b13      	ldr	r3, [pc, #76]	; (23a0 <ETH_HandlePTPRxPkt+0x198>)
    2354:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    2358:	f103 030c 	add.w	r3, r3, #12
    235c:	681b      	ldr	r3, [r3, #0]
    235e:	461a      	mov	r2, r3
    2360:	4b0c      	ldr	r3, [pc, #48]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2362:	601a      	str	r2, [r3, #0]
    2364:	e00f      	b.n	2386 <ETH_HandlePTPRxPkt+0x17e>
    }
    else
    {
      /* Selects the next DMA Rx descriptor list for next buffer to read */
      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
    2366:	4b0e      	ldr	r3, [pc, #56]	; (23a0 <ETH_HandlePTPRxPkt+0x198>)
    2368:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
    236c:	681b      	ldr	r3, [r3, #0]
    236e:	f003 037c 	and.w	r3, r3, #124	; 0x7c
    2372:	ea4f 0293 	mov.w	r2, r3, lsr #2
    2376:	4b07      	ldr	r3, [pc, #28]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2378:	681b      	ldr	r3, [r3, #0]
    237a:	18d3      	adds	r3, r2, r3
    237c:	f103 0310 	add.w	r3, r3, #16
    2380:	461a      	mov	r2, r3
    2382:	4b04      	ldr	r3, [pc, #16]	; (2394 <ETH_HandlePTPRxPkt+0x18c>)
    2384:	601a      	str	r2, [r3, #0]
    }
  }
  /* Return Frame Length/ERROR */
  return (framelength);
    2386:	68bb      	ldr	r3, [r7, #8]
}
    2388:	4618      	mov	r0, r3
    238a:	f107 0714 	add.w	r7, r7, #20
    238e:	46bd      	mov	sp, r7
    2390:	bc80      	pop	{r7}
    2392:	4770      	bx	lr
    2394:	00000000 	.word	0x00000000
			2394: R_ARM_ABS32	DMARxDescToGet
    2398:	3fff0000 	.word	0x3fff0000
    239c:	00000000 	.word	0x00000000
			239c: R_ARM_ABS32	DMAPTPRxDescToGet
    23a0:	40028000 	.word	0x40028000

000023a4 <ETH_Delay>:
  * @brief  Inserts a delay time.
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
    23a4:	b480      	push	{r7}
    23a6:	b085      	sub	sp, #20
    23a8:	af00      	add	r7, sp, #0
    23aa:	6078      	str	r0, [r7, #4]
  __IO uint32_t index = 0; 
    23ac:	f04f 0300 	mov.w	r3, #0
    23b0:	60fb      	str	r3, [r7, #12]
  for(index = nCount; index != 0; index--)
    23b2:	687b      	ldr	r3, [r7, #4]
    23b4:	60fb      	str	r3, [r7, #12]
    23b6:	e003      	b.n	23c0 <ETH_Delay+0x1c>
    23b8:	68fb      	ldr	r3, [r7, #12]
    23ba:	f103 33ff 	add.w	r3, r3, #4294967295
    23be:	60fb      	str	r3, [r7, #12]
    23c0:	68fb      	ldr	r3, [r7, #12]
    23c2:	2b00      	cmp	r3, #0
    23c4:	d1f8      	bne.n	23b8 <ETH_Delay+0x14>
  {
  }
}
    23c6:	f107 0714 	add.w	r7, r7, #20
    23ca:	46bd      	mov	sp, r7
    23cc:	bc80      	pop	{r7}
    23ce:	4770      	bx	lr

ethernetif.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0 403616 Jul 30 19:07 2021 ethernetif.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000794  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  00000000  00000000  000007c8  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000010  00000000  00000000  000007cc  2**2
                  ALLOC
  3 .debug_abbrev 000002cc  00000000  00000000  000007cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000f82  00000000  00000000  00000a98  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   00000bb4  00000000  00000000  00001a1a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 0005dad1  00000000  00000000  000025ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000288  00000000  00000000  0006009f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000129  00000000  00000000  00060327  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000001d5  00000000  00000000  00060450  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00060625  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    000007b2  00000000  00000000  00060645  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  00060df7  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  00060e22  2**0
                  CONTENTS, READONLY
 14 .debug_frame  00000180  00000000  00000000  00060e54  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 ethernetif.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000004 l       .bss	00000000 s_pxNetIf
00000000 l     F .text	00000068 dequeue_packet
00000068 l     F .text	0000015c low_level_init
000001c4 l     F .text	000000d8 low_level_output
0000000c l       .bss	00000000 xTxSemaphore.7215
0000029c l     F .text	00000138 low_level_input
00000008 l       .bss	00000000 xRxSemaphore.7226
000003d4 l     F .text	000000ac ethernetif_input
0000076c l     F .text	00000028 arp_timer
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000004       O *COM*	00000004 tcp_end_time
00000004       O *COM*	00000004 arp_end_time
00000000 g     O .bss	00000004 s_xSemaphore
00000006       O *COM*	00000004 MACaddr
00000040       O *COM*	00000004 DMARxDscrTab
00000020       O *COM*	00000004 DMATxDscrTab
000017c0       O *COM*	00000004 Rx_Buff
00000be0       O *COM*	00000004 Tx_Buff
00000000 g     O .data	00000004 DMATxDesc
00000000         *UND*	00000000 sys_arch_protect
00000000         *UND*	00000000 sys_arch_unprotect
00000000         *UND*	00000000 xQueueGenericCreate
00000000         *UND*	00000000 xQueueGenericSend
00000000         *UND*	00000000 xQueueGenericReceive
00000000         *UND*	00000000 ETH_MACAddressConfig
00000000         *UND*	00000000 ETH_DMATxDescChainInit
00000000         *UND*	00000000 ETH_DMARxDescChainInit
00000000         *UND*	00000000 ETH_DMARxDescReceiveITConfig
00000000         *UND*	00000000 ETH_DMATxDescChecksumInsertionConfig
00000000         *UND*	00000000 ETH_Start
00000734 g     F .text	00000018 ETH_GetCurrentTxBuffer
00000000         *UND*	00000000 memcpy
00000690 g     F .text	000000a4 ETH_TxPkt_ChainMode
00000588 g     F .text	00000108 ETH_RxPkt_ChainMode
00000000         *UND*	00000000 pbuf_alloc
0000074c g     F .text	00000020 vEMACWaitForInput
00000000         *UND*	00000000 lwip_htons
00000000         *UND*	00000000 pbuf_free
00000000         *UND*	00000000 ethernet_input
00000480 g     F .text	00000098 stm32_ethernetif_input
00000000         *UND*	00000000 tcpip_input
00000518 g     F .text	00000070 ethernetif_init
00000000         *UND*	00000000 mem_malloc
00000000         *UND*	00000000 etharp_output
00000000         *UND*	00000000 DMARxDescToGet
00000000         *UND*	00000000 DMATxDescToSet
00000000         *UND*	00000000 etharp_tmr
00000000         *UND*	00000000 sys_timeout



Disassembly of section .text:

00000000 <dequeue_packet>:
 *
 * @return pointer to pbuf packet if available, NULL otherswise.
 */
static struct pbuf *
dequeue_packet(struct pbufq *q)
{
   0:	b580      	push	{r7, lr}
   2:	b084      	sub	sp, #16
   4:	af00      	add	r7, sp, #0
   6:	6078      	str	r0, [r7, #4]
  /**
   * This entire function must run within a "critical section" to preserve
   * the integrity of the transmit pbuf queue.
   *
   */
  SYS_ARCH_PROTECT(lev);
   8:	f7ff fffe 	bl	0 <sys_arch_protect>
			8: R_ARM_THM_CALL	sys_arch_protect
   c:	60b8      	str	r0, [r7, #8]

  if(PBUF_QUEUE_EMPTY(q)) {
   e:	687b      	ldr	r3, [r7, #4]
  10:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  12:	687b      	ldr	r3, [r7, #4]
  14:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  16:	429a      	cmp	r2, r3
  18:	d103      	bne.n	22 <dequeue_packet+0x22>
    /* Return a NULL pointer if the queue is empty. */
    pBuf = (struct pbuf *)NULL;
  1a:	f04f 0300 	mov.w	r3, #0
  1e:	60fb      	str	r3, [r7, #12]
  20:	e017      	b.n	52 <dequeue_packet+0x52>
    /**
     * The queue is not empty so return the next frame from it
     * and adjust the read pointer accordingly.
     *
     */
    pBuf = q->pbuf[q->qread];
  22:	687b      	ldr	r3, [r7, #4]
  24:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  26:	687b      	ldr	r3, [r7, #4]
  28:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  2c:	60fb      	str	r3, [r7, #12]
    q->qread = ((q->qread + 1) % STM32_NUM_PBUF_QUEUE);
  2e:	687b      	ldr	r3, [r7, #4]
  30:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  32:	f103 0101 	add.w	r1, r3, #1
  36:	4b0b      	ldr	r3, [pc, #44]	; (64 <dequeue_packet+0x64>)
  38:	fba3 2301 	umull	r2, r3, r3, r1
  3c:	ea4f 1213 	mov.w	r2, r3, lsr #4
  40:	4613      	mov	r3, r2
  42:	ea4f 0383 	mov.w	r3, r3, lsl #2
  46:	189b      	adds	r3, r3, r2
  48:	ea4f 0383 	mov.w	r3, r3, lsl #2
  4c:	1aca      	subs	r2, r1, r3
  4e:	687b      	ldr	r3, [r7, #4]
  50:	655a      	str	r2, [r3, #84]	; 0x54
  }

  /* Return to prior interrupt state and return the pbuf pointer. */
  SYS_ARCH_UNPROTECT(lev);
  52:	68b8      	ldr	r0, [r7, #8]
  54:	f7ff fffe 	bl	0 <sys_arch_unprotect>
			54: R_ARM_THM_CALL	sys_arch_unprotect
  return(pBuf);
  58:	68fb      	ldr	r3, [r7, #12]
}
  5a:	4618      	mov	r0, r3
  5c:	f107 0710 	add.w	r7, r7, #16
  60:	46bd      	mov	sp, r7
  62:	bd80      	pop	{r7, pc}
  64:	cccccccd 	.word	0xcccccccd

00000068 <low_level_init>:
 * @param netif the already initialized lwip network interface structure
 *        for this ethernetif
 */
static void
low_level_init(struct netif *netif)
{
  68:	b580      	push	{r7, lr}
  6a:	b084      	sub	sp, #16
  6c:	af00      	add	r7, sp, #0
  6e:	6078      	str	r0, [r7, #4]
	/* set MAC hardware address length */
	netif->hwaddr_len = ETHARP_HWADDR_LEN;
  70:	687b      	ldr	r3, [r7, #4]
  72:	f04f 0206 	mov.w	r2, #6
  76:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
	/* set MAC hardware address */

	// TODO: Redundant?
	netif->hwaddr[0] =  MAC_ADDR0;
  7a:	687b      	ldr	r3, [r7, #4]
  7c:	f04f 020e 	mov.w	r2, #14
  80:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  	netif->hwaddr[1] =  MAC_ADDR1;
  84:	687b      	ldr	r3, [r7, #4]
  86:	f04f 0211 	mov.w	r2, #17
  8a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  	netif->hwaddr[2] =  MAC_ADDR2;
  8e:	687b      	ldr	r3, [r7, #4]
  90:	f04f 02eb 	mov.w	r2, #235	; 0xeb
  94:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
  	netif->hwaddr[3] =  MAC_ADDR3;
  98:	687b      	ldr	r3, [r7, #4]
  9a:	f04f 0200 	mov.w	r2, #0
  9e:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  	netif->hwaddr[4] =  MAC_ADDR4;
  a2:	687b      	ldr	r3, [r7, #4]
  a4:	f04f 0200 	mov.w	r2, #0
  a8:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
  	netif->hwaddr[5] =  MAC_ADDR5;
  ac:	687b      	ldr	r3, [r7, #4]
  ae:	f04f 0259 	mov.w	r2, #89	; 0x59
  b2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
 	 /* maximum transfer unit */
  	netif->mtu = 1500;
  b6:	687b      	ldr	r3, [r7, #4]
  b8:	f240 52dc 	movw	r2, #1500	; 0x5dc
  bc:	859a      	strh	r2, [r3, #44]	; 0x2c

  	/* Accept broadcast address and ARP traffic */
    netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_IGMP | NETIF_FLAG_LINK_UP;
  be:	687b      	ldr	r3, [r7, #4]
  c0:	f04f 02b2 	mov.w	r2, #178	; 0xb2
  c4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 	
  	s_pxNetIf =netif;
  c8:	4b38      	ldr	r3, [pc, #224]	; (1ac <low_level_init+0x144>)
  ca:	687a      	ldr	r2, [r7, #4]
  cc:	601a      	str	r2, [r3, #0]
  
  	if (s_xSemaphore == NULL)
  ce:	4b38      	ldr	r3, [pc, #224]	; (1b0 <low_level_init+0x148>)
  d0:	681b      	ldr	r3, [r3, #0]
  d2:	2b00      	cmp	r3, #0
  d4:	d124      	bne.n	120 <low_level_init+0xb8>
  	{
    	vSemaphoreCreateBinary(s_xSemaphore);
  d6:	f04f 0001 	mov.w	r0, #1
  da:	f04f 0100 	mov.w	r1, #0
  de:	f04f 0203 	mov.w	r2, #3
  e2:	f7ff fffe 	bl	0 <xQueueGenericCreate>
			e2: R_ARM_THM_CALL	xQueueGenericCreate
  e6:	4602      	mov	r2, r0
  e8:	4b31      	ldr	r3, [pc, #196]	; (1b0 <low_level_init+0x148>)
  ea:	601a      	str	r2, [r3, #0]
  ec:	4b30      	ldr	r3, [pc, #192]	; (1b0 <low_level_init+0x148>)
  ee:	681b      	ldr	r3, [r3, #0]
  f0:	2b00      	cmp	r3, #0
  f2:	d00a      	beq.n	10a <low_level_init+0xa2>
  f4:	4b2e      	ldr	r3, [pc, #184]	; (1b0 <low_level_init+0x148>)
  f6:	681b      	ldr	r3, [r3, #0]
  f8:	4618      	mov	r0, r3
  fa:	f04f 0100 	mov.w	r1, #0
  fe:	f04f 0200 	mov.w	r2, #0
 102:	f04f 0300 	mov.w	r3, #0
 106:	f7ff fffe 	bl	0 <xQueueGenericSend>
			106: R_ARM_THM_CALL	xQueueGenericSend
    	xSemaphoreTake(s_xSemaphore, 0);
 10a:	4b29      	ldr	r3, [pc, #164]	; (1b0 <low_level_init+0x148>)
 10c:	681b      	ldr	r3, [r3, #0]
 10e:	4618      	mov	r0, r3
 110:	f04f 0100 	mov.w	r1, #0
 114:	f04f 0200 	mov.w	r2, #0
 118:	f04f 0300 	mov.w	r3, #0
 11c:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			11c: R_ARM_THM_CALL	xQueueGenericReceive
  	}

  	/* initialize MAC address in ETH_MAC*/ 
  	ETH_MACAddressConfig(ETH_MAC_Address0, netif->hwaddr); 
 120:	687b      	ldr	r3, [r7, #4]
 122:	f103 032f 	add.w	r3, r3, #47	; 0x2f
 126:	f04f 0000 	mov.w	r0, #0
 12a:	4619      	mov	r1, r3
 12c:	f7ff fffe 	bl	0 <ETH_MACAddressConfig>
			12c: R_ARM_THM_CALL	ETH_MACAddressConfig
  
  	/* Initialize Tx Descriptors list: Chain Mode */
  	ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 130:	4b20      	ldr	r3, [pc, #128]	; (1b4 <low_level_init+0x14c>)
 132:	4821      	ldr	r0, [pc, #132]	; (1b8 <low_level_init+0x150>)
 134:	4619      	mov	r1, r3
 136:	f04f 0202 	mov.w	r2, #2
 13a:	f7ff fffe 	bl	0 <ETH_DMATxDescChainInit>
			13a: R_ARM_THM_CALL	ETH_DMATxDescChainInit
  	/* Initialize Rx Descriptors list: Chain Mode  */
  	ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 13e:	4b1f      	ldr	r3, [pc, #124]	; (1bc <low_level_init+0x154>)
 140:	481f      	ldr	r0, [pc, #124]	; (1c0 <low_level_init+0x158>)
 142:	4619      	mov	r1, r3
 144:	f04f 0204 	mov.w	r2, #4
 148:	f7ff fffe 	bl	0 <ETH_DMARxDescChainInit>
			148: R_ARM_THM_CALL	ETH_DMARxDescChainInit

  	/* Enable Ethernet Rx interrrupt */
  	{ 
  		int i;
    	for(i=0; i<ETH_RXBUFNB; i++)
 14c:	f04f 0300 	mov.w	r3, #0
 150:	60fb      	str	r3, [r7, #12]
 152:	e00d      	b.n	170 <low_level_init+0x108>
    	{
      		ETH_DMARxDescReceiveITConfig(&DMARxDscrTab[i], ENABLE);
 154:	68fb      	ldr	r3, [r7, #12]
 156:	ea4f 1203 	mov.w	r2, r3, lsl #4
 15a:	4b19      	ldr	r3, [pc, #100]	; (1c0 <low_level_init+0x158>)
 15c:	18d3      	adds	r3, r2, r3
 15e:	4618      	mov	r0, r3
 160:	f04f 0101 	mov.w	r1, #1
 164:	f7ff fffe 	bl	0 <ETH_DMARxDescReceiveITConfig>
			164: R_ARM_THM_CALL	ETH_DMARxDescReceiveITConfig
  	ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);

  	/* Enable Ethernet Rx interrrupt */
  	{ 
  		int i;
    	for(i=0; i<ETH_RXBUFNB; i++)
 168:	68fb      	ldr	r3, [r7, #12]
 16a:	f103 0301 	add.w	r3, r3, #1
 16e:	60fb      	str	r3, [r7, #12]
 170:	68fb      	ldr	r3, [r7, #12]
 172:	2b03      	cmp	r3, #3
 174:	ddee      	ble.n	154 <low_level_init+0xec>

	#ifdef CHECKSUM_BY_HARDWARE
  	/* Enable the checksum insertion for the Tx frames */
  	{
  		int i;
    	for(i=0; i<ETH_TXBUFNB; i++)
 176:	f04f 0300 	mov.w	r3, #0
 17a:	60bb      	str	r3, [r7, #8]
 17c:	e00d      	b.n	19a <low_level_init+0x132>
    	{
      		ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
 17e:	68bb      	ldr	r3, [r7, #8]
 180:	ea4f 1203 	mov.w	r2, r3, lsl #4
 184:	4b0c      	ldr	r3, [pc, #48]	; (1b8 <low_level_init+0x150>)
 186:	18d3      	adds	r3, r2, r3
 188:	4618      	mov	r0, r3
 18a:	f44f 0140 	mov.w	r1, #12582912	; 0xc00000
 18e:	f7ff fffe 	bl	0 <ETH_DMATxDescChecksumInsertionConfig>
			18e: R_ARM_THM_CALL	ETH_DMATxDescChecksumInsertionConfig

	#ifdef CHECKSUM_BY_HARDWARE
  	/* Enable the checksum insertion for the Tx frames */
  	{
  		int i;
    	for(i=0; i<ETH_TXBUFNB; i++)
 192:	68bb      	ldr	r3, [r7, #8]
 194:	f103 0301 	add.w	r3, r3, #1
 198:	60bb      	str	r3, [r7, #8]
 19a:	68bb      	ldr	r3, [r7, #8]
 19c:	2b01      	cmp	r3, #1
 19e:	ddee      	ble.n	17e <low_level_init+0x116>
    	}
  	}
	#endif

  	/* Enable MAC and DMA transmission and reception */
  	ETH_Start();
 1a0:	f7ff fffe 	bl	0 <ETH_Start>
			1a0: R_ARM_THM_CALL	ETH_Start
  	// TODO
  	/* create the task that handles the ETH_MAC */
  	//xTaskCreate(ethernetif_input, (signed char*) "ETH_INT", netifINTERFACE_TASK_STACK_SIZE, NULL,
    //          netifINTERFACE_TASK_PRIORITY,NULL);

}
 1a4:	f107 0710 	add.w	r7, r7, #16
 1a8:	46bd      	mov	sp, r7
 1aa:	bd80      	pop	{r7, pc}
 1ac:	00000004 	.word	0x00000004
			1ac: R_ARM_ABS32	.bss
	...
			1b0: R_ARM_ABS32	s_xSemaphore
			1b4: R_ARM_ABS32	Tx_Buff
			1b8: R_ARM_ABS32	DMATxDscrTab
			1bc: R_ARM_ABS32	Rx_Buff
			1c0: R_ARM_ABS32	DMARxDscrTab

000001c4 <low_level_output>:
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
 1c4:	b580      	push	{r7, lr}
 1c6:	b086      	sub	sp, #24
 1c8:	af00      	add	r7, sp, #0
 1ca:	6078      	str	r0, [r7, #4]
 1cc:	6039      	str	r1, [r7, #0]
	static xSemaphoreHandle xTxSemaphore = NULL;
  	struct pbuf *q;
  	int l = 0;
 1ce:	f04f 0300 	mov.w	r3, #0
 1d2:	613b      	str	r3, [r7, #16]
  	u8 *buffer ;
  
  	if (xTxSemaphore == NULL)
 1d4:	4b30      	ldr	r3, [pc, #192]	; (298 <low_level_output+0xd4>)
 1d6:	681b      	ldr	r3, [r3, #0]
 1d8:	2b00      	cmp	r3, #0
 1da:	d119      	bne.n	210 <low_level_output+0x4c>
  	{
  		vSemaphoreCreateBinary (xTxSemaphore);
 1dc:	f04f 0001 	mov.w	r0, #1
 1e0:	f04f 0100 	mov.w	r1, #0
 1e4:	f04f 0203 	mov.w	r2, #3
 1e8:	f7ff fffe 	bl	0 <xQueueGenericCreate>
			1e8: R_ARM_THM_CALL	xQueueGenericCreate
 1ec:	4602      	mov	r2, r0
 1ee:	4b2a      	ldr	r3, [pc, #168]	; (298 <low_level_output+0xd4>)
 1f0:	601a      	str	r2, [r3, #0]
 1f2:	4b29      	ldr	r3, [pc, #164]	; (298 <low_level_output+0xd4>)
 1f4:	681b      	ldr	r3, [r3, #0]
 1f6:	2b00      	cmp	r3, #0
 1f8:	d00a      	beq.n	210 <low_level_output+0x4c>
 1fa:	4b27      	ldr	r3, [pc, #156]	; (298 <low_level_output+0xd4>)
 1fc:	681b      	ldr	r3, [r3, #0]
 1fe:	4618      	mov	r0, r3
 200:	f04f 0100 	mov.w	r1, #0
 204:	f04f 0200 	mov.w	r2, #0
 208:	f04f 0300 	mov.w	r3, #0
 20c:	f7ff fffe 	bl	0 <xQueueGenericSend>
			20c: R_ARM_THM_CALL	xQueueGenericSend
  	} 
    
  	if (xSemaphoreTake(xTxSemaphore, netifGUARD_BLOCK_TIME))
 210:	4b21      	ldr	r3, [pc, #132]	; (298 <low_level_output+0xd4>)
 212:	681b      	ldr	r3, [r3, #0]
 214:	4618      	mov	r0, r3
 216:	f04f 0100 	mov.w	r1, #0
 21a:	f04f 02fa 	mov.w	r2, #250	; 0xfa
 21e:	f04f 0300 	mov.w	r3, #0
 222:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			222: R_ARM_THM_CALL	xQueueGenericReceive
 226:	4603      	mov	r3, r0
 228:	2b00      	cmp	r3, #0
 22a:	d01d      	beq.n	268 <low_level_output+0xa4>
  	{
  		u8 *buffer =  (u8 *)ETH_GetCurrentTxBuffer();
 22c:	f7ff fffe 	bl	734 <ETH_GetCurrentTxBuffer>
			22c: R_ARM_THM_CALL	ETH_GetCurrentTxBuffer
 230:	4603      	mov	r3, r0
 232:	60fb      	str	r3, [r7, #12]
  		for(q = p; q != NULL; q = q->next) 
 234:	683b      	ldr	r3, [r7, #0]
 236:	617b      	str	r3, [r7, #20]
 238:	e013      	b.n	262 <low_level_output+0x9e>
  		{
  			memcpy((u8_t*)&buffer[l], q->payload, q->len);
 23a:	693b      	ldr	r3, [r7, #16]
 23c:	68fa      	ldr	r2, [r7, #12]
 23e:	18d1      	adds	r1, r2, r3
 240:	697b      	ldr	r3, [r7, #20]
 242:	685a      	ldr	r2, [r3, #4]
 244:	697b      	ldr	r3, [r7, #20]
 246:	895b      	ldrh	r3, [r3, #10]
 248:	4608      	mov	r0, r1
 24a:	4611      	mov	r1, r2
 24c:	461a      	mov	r2, r3
 24e:	f7ff fffe 	bl	0 <memcpy>
			24e: R_ARM_THM_CALL	memcpy
  			l = l + q->len;
 252:	697b      	ldr	r3, [r7, #20]
 254:	895b      	ldrh	r3, [r3, #10]
 256:	693a      	ldr	r2, [r7, #16]
 258:	18d3      	adds	r3, r2, r3
 25a:	613b      	str	r3, [r7, #16]
  	} 
    
  	if (xSemaphoreTake(xTxSemaphore, netifGUARD_BLOCK_TIME))
  	{
  		u8 *buffer =  (u8 *)ETH_GetCurrentTxBuffer();
  		for(q = p; q != NULL; q = q->next) 
 25c:	697b      	ldr	r3, [r7, #20]
 25e:	681b      	ldr	r3, [r3, #0]
 260:	617b      	str	r3, [r7, #20]
 262:	697b      	ldr	r3, [r7, #20]
 264:	2b00      	cmp	r3, #0
 266:	d1e8      	bne.n	23a <low_level_output+0x76>
  		{
  			memcpy((u8_t*)&buffer[l], q->payload, q->len);
  			l = l + q->len;
  		}
  	}
  	xSemaphoreGive(xTxSemaphore);
 268:	4b0b      	ldr	r3, [pc, #44]	; (298 <low_level_output+0xd4>)
 26a:	681b      	ldr	r3, [r3, #0]
 26c:	4618      	mov	r0, r3
 26e:	f04f 0100 	mov.w	r1, #0
 272:	f04f 0200 	mov.w	r2, #0
 276:	f04f 0300 	mov.w	r3, #0
 27a:	f7ff fffe 	bl	0 <xQueueGenericSend>
			27a: R_ARM_THM_CALL	xQueueGenericSend
  	ETH_TxPkt_ChainMode(l);
 27e:	693b      	ldr	r3, [r7, #16]
 280:	b29b      	uxth	r3, r3
 282:	4618      	mov	r0, r3
 284:	f7ff fffe 	bl	690 <ETH_TxPkt_ChainMode>
			284: R_ARM_THM_CALL	ETH_TxPkt_ChainMode

 	 return ERR_OK;
 288:	f04f 0300 	mov.w	r3, #0
 28c:	b25b      	sxtb	r3, r3
}
 28e:	4618      	mov	r0, r3
 290:	f107 0718 	add.w	r7, r7, #24
 294:	46bd      	mov	sp, r7
 296:	bd80      	pop	{r7, pc}
 298:	0000000c 	.word	0x0000000c
			298: R_ARM_ABS32	.bss

0000029c <low_level_input>:
 * @return a pbuf filled with the received packet (including MAC header)
 *         NULL on memory error
 */
static struct pbuf *
low_level_input(struct netif *netif)
{
 29c:	b580      	push	{r7, lr}
 29e:	b08a      	sub	sp, #40	; 0x28
 2a0:	af00      	add	r7, sp, #0
 2a2:	6078      	str	r0, [r7, #4]
 static xSemaphoreHandle xRxSemaphore = NULL;


  struct pbuf *p, *q;
  u16_t len;
  int l =0;
 2a4:	f04f 0300 	mov.w	r3, #0
 2a8:	61fb      	str	r3, [r7, #28]
  FrameTypeDef frame;
  u8 *buffer;
  
  p = NULL;
 2aa:	f04f 0300 	mov.w	r3, #0
 2ae:	627b      	str	r3, [r7, #36]	; 0x24

 if( xRxSemaphore ==NULL)
 2b0:	4b46      	ldr	r3, [pc, #280]	; (3cc <low_level_input+0x130>)
 2b2:	681b      	ldr	r3, [r3, #0]
 2b4:	2b00      	cmp	r3, #0
 2b6:	d119      	bne.n	2ec <low_level_input+0x50>
 	{
 	vSemaphoreCreateBinary(xRxSemaphore);
 2b8:	f04f 0001 	mov.w	r0, #1
 2bc:	f04f 0100 	mov.w	r1, #0
 2c0:	f04f 0203 	mov.w	r2, #3
 2c4:	f7ff fffe 	bl	0 <xQueueGenericCreate>
			2c4: R_ARM_THM_CALL	xQueueGenericCreate
 2c8:	4602      	mov	r2, r0
 2ca:	4b40      	ldr	r3, [pc, #256]	; (3cc <low_level_input+0x130>)
 2cc:	601a      	str	r2, [r3, #0]
 2ce:	4b3f      	ldr	r3, [pc, #252]	; (3cc <low_level_input+0x130>)
 2d0:	681b      	ldr	r3, [r3, #0]
 2d2:	2b00      	cmp	r3, #0
 2d4:	d00a      	beq.n	2ec <low_level_input+0x50>
 2d6:	4b3d      	ldr	r3, [pc, #244]	; (3cc <low_level_input+0x130>)
 2d8:	681b      	ldr	r3, [r3, #0]
 2da:	4618      	mov	r0, r3
 2dc:	f04f 0100 	mov.w	r1, #0
 2e0:	f04f 0200 	mov.w	r2, #0
 2e4:	f04f 0300 	mov.w	r3, #0
 2e8:	f7ff fffe 	bl	0 <xQueueGenericSend>
			2e8: R_ARM_THM_CALL	xQueueGenericSend
 	}
 /* access to emac is guarded using a semphore */

 if (xSemaphoreTake(xRxSemaphore, netifGUARD_BLOCK_TIME))
 2ec:	4b37      	ldr	r3, [pc, #220]	; (3cc <low_level_input+0x130>)
 2ee:	681b      	ldr	r3, [r3, #0]
 2f0:	4618      	mov	r0, r3
 2f2:	f04f 0100 	mov.w	r1, #0
 2f6:	f04f 02fa 	mov.w	r2, #250	; 0xfa
 2fa:	f04f 0300 	mov.w	r3, #0
 2fe:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			2fe: R_ARM_THM_CALL	xQueueGenericReceive
 302:	4603      	mov	r3, r0
 304:	2b00      	cmp	r3, #0
 306:	d04f      	beq.n	3a8 <low_level_input+0x10c>
 	{
          
          
          
 
  frame = ETH_RxPkt_ChainMode();
 308:	f107 0308 	add.w	r3, r7, #8
 30c:	4618      	mov	r0, r3
 30e:	f7ff fffe 	bl	588 <ETH_RxPkt_ChainMode>
			30e: R_ARM_THM_CALL	ETH_RxPkt_ChainMode
  /* Obtain the size of the packet and put it into the "len"
     variable. */
  len = frame.length;
 312:	68bb      	ldr	r3, [r7, #8]
 314:	837b      	strh	r3, [r7, #26]
  
  if (len)
 316:	8b7b      	ldrh	r3, [r7, #26]
 318:	2b00      	cmp	r3, #0
 31a:	d045      	beq.n	3a8 <low_level_input+0x10c>
  {
  buffer = (u8 *)frame.buffer;
 31c:	68fb      	ldr	r3, [r7, #12]
 31e:	617b      	str	r3, [r7, #20]

  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 320:	8b7b      	ldrh	r3, [r7, #26]
 322:	f04f 0003 	mov.w	r0, #3
 326:	4619      	mov	r1, r3
 328:	f04f 0203 	mov.w	r2, #3
 32c:	f7ff fffe 	bl	0 <pbuf_alloc>
			32c: R_ARM_THM_CALL	pbuf_alloc
 330:	6278      	str	r0, [r7, #36]	; 0x24
 
  if (p != NULL)
 332:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 334:	2b00      	cmp	r3, #0
 336:	d019      	beq.n	36c <low_level_input+0xd0>
  {
    for (q = p; q != NULL; q = q->next)
 338:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 33a:	623b      	str	r3, [r7, #32]
 33c:	e013      	b.n	366 <low_level_input+0xca>
    {
	  memcpy((u8_t*)q->payload, (u8_t*)&buffer[l], q->len);
 33e:	6a3b      	ldr	r3, [r7, #32]
 340:	6859      	ldr	r1, [r3, #4]
 342:	69fb      	ldr	r3, [r7, #28]
 344:	697a      	ldr	r2, [r7, #20]
 346:	18d2      	adds	r2, r2, r3
 348:	6a3b      	ldr	r3, [r7, #32]
 34a:	895b      	ldrh	r3, [r3, #10]
 34c:	4608      	mov	r0, r1
 34e:	4611      	mov	r1, r2
 350:	461a      	mov	r2, r3
 352:	f7ff fffe 	bl	0 <memcpy>
			352: R_ARM_THM_CALL	memcpy
      l = l + q->len;
 356:	6a3b      	ldr	r3, [r7, #32]
 358:	895b      	ldrh	r3, [r3, #10]
 35a:	69fa      	ldr	r2, [r7, #28]
 35c:	18d3      	adds	r3, r2, r3
 35e:	61fb      	str	r3, [r7, #28]
  /* We allocate a pbuf chain of pbufs from the pool. */
  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 
  if (p != NULL)
  {
    for (q = p; q != NULL; q = q->next)
 360:	6a3b      	ldr	r3, [r7, #32]
 362:	681b      	ldr	r3, [r3, #0]
 364:	623b      	str	r3, [r7, #32]
 366:	6a3b      	ldr	r3, [r7, #32]
 368:	2b00      	cmp	r3, #0
 36a:	d1e8      	bne.n	33e <low_level_input+0xa2>
      l = l + q->len;
    }    
  
  }
  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
  frame.descriptor->Status = ETH_DMARxDesc_OWN; 
 36c:	693b      	ldr	r3, [r7, #16]
 36e:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 372:	601a      	str	r2, [r3, #0]
 
  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
  if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
 374:	4b16      	ldr	r3, [pc, #88]	; (3d0 <low_level_input+0x134>)
 376:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 37a:	f103 0314 	add.w	r3, r3, #20
 37e:	681b      	ldr	r3, [r3, #0]
 380:	f003 0380 	and.w	r3, r3, #128	; 0x80
 384:	2b00      	cmp	r3, #0
 386:	d00f      	beq.n	3a8 <low_level_input+0x10c>
  {
    /* Clear RBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_RBUS;
 388:	4b11      	ldr	r3, [pc, #68]	; (3d0 <low_level_input+0x134>)
 38a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 38e:	f103 0314 	add.w	r3, r3, #20
 392:	f04f 0280 	mov.w	r2, #128	; 0x80
 396:	601a      	str	r2, [r3, #0]
    /* Resume DMA reception */
    ETH->DMARPDR = 0;
 398:	4b0d      	ldr	r3, [pc, #52]	; (3d0 <low_level_input+0x134>)
 39a:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 39e:	f103 0308 	add.w	r3, r3, #8
 3a2:	f04f 0200 	mov.w	r2, #0
 3a6:	601a      	str	r2, [r3, #0]
  }
  }
 }
 xSemaphoreGive(xRxSemaphore);
 3a8:	4b08      	ldr	r3, [pc, #32]	; (3cc <low_level_input+0x130>)
 3aa:	681b      	ldr	r3, [r3, #0]
 3ac:	4618      	mov	r0, r3
 3ae:	f04f 0100 	mov.w	r1, #0
 3b2:	f04f 0200 	mov.w	r2, #0
 3b6:	f04f 0300 	mov.w	r3, #0
 3ba:	f7ff fffe 	bl	0 <xQueueGenericSend>
			3ba: R_ARM_THM_CALL	xQueueGenericSend
  return p;
 3be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 3c0:	4618      	mov	r0, r3
 3c2:	f107 0728 	add.w	r7, r7, #40	; 0x28
 3c6:	46bd      	mov	sp, r7
 3c8:	bd80      	pop	{r7, pc}
 3ca:	bf00      	nop
 3cc:	00000008 	.word	0x00000008
			3cc: R_ARM_ABS32	.bss
 3d0:	40028000 	.word	0x40028000

000003d4 <ethernetif_input>:
 * the appropriate input function is called.
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
static void ethernetif_input( void * pvParameters )
{
 3d4:	b580      	push	{r7, lr}
 3d6:	b086      	sub	sp, #24
 3d8:	af00      	add	r7, sp, #0
 3da:	6078      	str	r0, [r7, #4]

//	for( ;; )
	{
		do
		{
			ethernetif = s_pxNetIf->state;
 3dc:	4b27      	ldr	r3, [pc, #156]	; (47c <ethernetif_input+0xa8>)
 3de:	681b      	ldr	r3, [r3, #0]
 3e0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 3e2:	617b      	str	r3, [r7, #20]
			
			/* move received packet into a new pbuf */
			p = low_level_input( s_pxNetIf );
 3e4:	4b25      	ldr	r3, [pc, #148]	; (47c <ethernetif_input+0xa8>)
 3e6:	681b      	ldr	r3, [r3, #0]
 3e8:	4618      	mov	r0, r3
 3ea:	f7ff ff57 	bl	29c <low_level_input>
 3ee:	6138      	str	r0, [r7, #16]
			
			if( p == NULL )
 3f0:	693b      	ldr	r3, [r7, #16]
 3f2:	2b00      	cmp	r3, #0
 3f4:	d101      	bne.n	3fa <ethernetif_input+0x26>
			{
				/* No packet could be read.  Wait a for an interrupt to tell us
				there is more data available. */
				vEMACWaitForInput();
 3f6:	f7ff fffe 	bl	74c <vEMACWaitForInput>
			3f6: R_ARM_THM_CALL	vEMACWaitForInput
			}
		
		} while( p == NULL );
 3fa:	693b      	ldr	r3, [r7, #16]
 3fc:	2b00      	cmp	r3, #0
 3fe:	d0ed      	beq.n	3dc <ethernetif_input+0x8>

		/* points to packet payload, which starts with an Ethernet header */
		ethhdr = p->payload;
 400:	693b      	ldr	r3, [r7, #16]
 402:	685b      	ldr	r3, [r3, #4]
 404:	60fb      	str	r3, [r7, #12]

		#if LINK_STATS
			lwip_stats.link.recv++;
		#endif /* LINK_STATS */

		ethhdr = p->payload;
 406:	693b      	ldr	r3, [r7, #16]
 408:	685b      	ldr	r3, [r3, #4]
 40a:	60fb      	str	r3, [r7, #12]

		switch (htons(ethhdr->type))
 40c:	68fb      	ldr	r3, [r7, #12]
 40e:	899b      	ldrh	r3, [r3, #12]
 410:	b29b      	uxth	r3, r3
 412:	4618      	mov	r0, r3
 414:	f7ff fffe 	bl	0 <lwip_htons>
			414: R_ARM_THM_CALL	lwip_htons
 418:	4603      	mov	r3, r0
 41a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 41e:	d006      	beq.n	42e <ethernetif_input+0x5a>
 420:	f640 0206 	movw	r2, #2054	; 0x806
 424:	4293      	cmp	r3, r2
 426:	d014      	beq.n	452 <ethernetif_input+0x7e>
 428:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 42c:	d118      	bne.n	460 <ethernetif_input+0x8c>
			/* IP packet? */
		case 256:
			case ETHTYPE_IP:
				
                          /* full packet send to tcpip_thread to process */
			if (s_pxNetIf->input(p, s_pxNetIf) != ERR_OK)
 42e:	4b13      	ldr	r3, [pc, #76]	; (47c <ethernetif_input+0xa8>)
 430:	681b      	ldr	r3, [r3, #0]
 432:	691b      	ldr	r3, [r3, #16]
 434:	4a11      	ldr	r2, [pc, #68]	; (47c <ethernetif_input+0xa8>)
 436:	6812      	ldr	r2, [r2, #0]
 438:	6938      	ldr	r0, [r7, #16]
 43a:	4611      	mov	r1, r2
 43c:	4798      	blx	r3
 43e:	4603      	mov	r3, r0
 440:	2b00      	cmp	r3, #0
 442:	d015      	beq.n	470 <ethernetif_input+0x9c>
			{
				LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
				pbuf_free(p);
 444:	6938      	ldr	r0, [r7, #16]
 446:	f7ff fffe 	bl	0 <pbuf_free>
			446: R_ARM_THM_CALL	pbuf_free
				p = NULL;
 44a:	f04f 0300 	mov.w	r3, #0
 44e:	613b      	str	r3, [r7, #16]
			}
			break;
 450:	e00f      	b.n	472 <ethernetif_input+0x9e>
      
      case ETHTYPE_ARP:                    
			  /* pass p to ARP module  */
    	  	  ethernet_input(p, s_pxNetIf);
 452:	4b0a      	ldr	r3, [pc, #40]	; (47c <ethernetif_input+0xa8>)
 454:	681b      	ldr	r3, [r3, #0]
 456:	6938      	ldr	r0, [r7, #16]
 458:	4619      	mov	r1, r3
 45a:	f7ff fffe 	bl	0 <ethernet_input>
			45a: R_ARM_THM_CALL	ethernet_input
			  break;
 45e:	e008      	b.n	472 <ethernetif_input+0x9e>
				
			default:
				  pbuf_free(p);
 460:	6938      	ldr	r0, [r7, #16]
 462:	f7ff fffe 	bl	0 <pbuf_free>
			462: R_ARM_THM_CALL	pbuf_free
				  p = NULL;
 466:	f04f 0300 	mov.w	r3, #0
 46a:	613b      	str	r3, [r7, #16]
				  break;
 46c:	bf00      	nop
 46e:	e000      	b.n	472 <ethernetif_input+0x9e>
			{
				LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
				pbuf_free(p);
				p = NULL;
			}
			break;
 470:	bf00      	nop
				  pbuf_free(p);
				  p = NULL;
				  break;
		}
	}
}
 472:	f107 0718 	add.w	r7, r7, #24
 476:	46bd      	mov	sp, r7
 478:	bd80      	pop	{r7, pc}
 47a:	bf00      	nop
 47c:	00000004 	.word	0x00000004
			47c: R_ARM_ABS32	.bss

00000480 <stm32_ethernetif_input>:

// This is implementation of an ethernetif_input similar to the one for the stellaris
void
stm32_ethernetif_input(struct netif *netif)
{
 480:	b580      	push	{r7, lr}
 482:	b084      	sub	sp, #16
 484:	af00      	add	r7, sp, #0
 486:	6078      	str	r0, [r7, #4]
  struct pbuf *p;
  int i,res;
  unsigned char *input_string;

  /* setup pointer to the if state data */
  ethernetif = netif->state;
 488:	687b      	ldr	r3, [r7, #4]
 48a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 48c:	60bb      	str	r3, [r7, #8]
  /**
   * Process the transmit and receive queues as long as there is receive
   * data available
   *
   */
  p = low_level_input(netif);
 48e:	6878      	ldr	r0, [r7, #4]
 490:	f7ff ff04 	bl	29c <low_level_input>
 494:	60f8      	str	r0, [r7, #12]
  while(p != NULL) {
 496:	e021      	b.n	4dc <stm32_ethernetif_input+0x5c>
	/* process the packet */
#if NO_SYS
	if(ethernet_input(p, netif)!=ERR_OK) {
#else
	if(tcpip_input(p, netif)!=ERR_OK) {
 498:	68f8      	ldr	r0, [r7, #12]
 49a:	6879      	ldr	r1, [r7, #4]
 49c:	f7ff fffe 	bl	0 <tcpip_input>
			49c: R_ARM_THM_CALL	tcpip_input
 4a0:	4603      	mov	r3, r0
 4a2:	2b00      	cmp	r3, #0
 4a4:	d002      	beq.n	4ac <stm32_ethernetif_input+0x2c>
#endif
	  /* drop the packet */
	  LWIP_DEBUGF(NETIF_DEBUG, ("stellarisif_input: input error\n"));
	  pbuf_free(p);
 4a6:	68f8      	ldr	r0, [r7, #12]
 4a8:	f7ff fffe 	bl	0 <pbuf_free>
			4a8: R_ARM_THM_CALL	pbuf_free
	  LINK_STATS_INC(link.memerr);
	  LINK_STATS_INC(link.drop);
}

	/* Check if TX fifo is empty and packet available */
	if((HWREG(ETH_BASE + MAC_O_TR) & MAC_TR_NEWTX) == 0) {
 4ac:	4b19      	ldr	r3, [pc, #100]	; (514 <stm32_ethernetif_input+0x94>)
 4ae:	681b      	ldr	r3, [r3, #0]
 4b0:	f003 0301 	and.w	r3, r3, #1
 4b4:	2b00      	cmp	r3, #0
 4b6:	d10d      	bne.n	4d4 <stm32_ethernetif_input+0x54>
	  p = dequeue_packet(&ethernetif->txq);
 4b8:	68bb      	ldr	r3, [r7, #8]
 4ba:	f103 0308 	add.w	r3, r3, #8
 4be:	4618      	mov	r0, r3
 4c0:	f7ff fd9e 	bl	0 <dequeue_packet>
 4c4:	60f8      	str	r0, [r7, #12]
	  if(p != NULL) {
 4c6:	68fb      	ldr	r3, [r7, #12]
 4c8:	2b00      	cmp	r3, #0
 4ca:	d003      	beq.n	4d4 <stm32_ethernetif_input+0x54>
		  low_level_output(netif, p);
 4cc:	6878      	ldr	r0, [r7, #4]
 4ce:	68f9      	ldr	r1, [r7, #12]
 4d0:	f7ff fe78 	bl	1c4 <low_level_output>
	  }
	}

	/* Read another packet from the RX fifo */
	p = low_level_input(netif);
 4d4:	6878      	ldr	r0, [r7, #4]
 4d6:	f7ff fee1 	bl	29c <low_level_input>
 4da:	60f8      	str	r0, [r7, #12]
   * Process the transmit and receive queues as long as there is receive
   * data available
   *
   */
  p = low_level_input(netif);
  while(p != NULL) {
 4dc:	68fb      	ldr	r3, [r7, #12]
 4de:	2b00      	cmp	r3, #0
 4e0:	d1da      	bne.n	498 <stm32_ethernetif_input+0x18>
	/* Read another packet from the RX fifo */
	p = low_level_input(netif);
  }

  /* One more check of the transmit queue/fifo */
  if((HWREG(ETH_BASE + MAC_O_TR) & MAC_TR_NEWTX) == 0) {
 4e2:	4b0c      	ldr	r3, [pc, #48]	; (514 <stm32_ethernetif_input+0x94>)
 4e4:	681b      	ldr	r3, [r3, #0]
 4e6:	f003 0301 	and.w	r3, r3, #1
 4ea:	2b00      	cmp	r3, #0
 4ec:	d10d      	bne.n	50a <stm32_ethernetif_input+0x8a>
	p = dequeue_packet(&ethernetif->txq);
 4ee:	68bb      	ldr	r3, [r7, #8]
 4f0:	f103 0308 	add.w	r3, r3, #8
 4f4:	4618      	mov	r0, r3
 4f6:	f7ff fd83 	bl	0 <dequeue_packet>
 4fa:	60f8      	str	r0, [r7, #12]
	if(p != NULL) {
 4fc:	68fb      	ldr	r3, [r7, #12]
 4fe:	2b00      	cmp	r3, #0
 500:	d003      	beq.n	50a <stm32_ethernetif_input+0x8a>
		low_level_output(netif, p);
 502:	6878      	ldr	r0, [r7, #4]
 504:	68f9      	ldr	r1, [r7, #12]
 506:	f7ff fe5d 	bl	1c4 <low_level_output>
	}
  }
}
 50a:	f107 0710 	add.w	r7, r7, #16
 50e:	46bd      	mov	sp, r7
 510:	bd80      	pop	{r7, pc}
 512:	bf00      	nop
 514:	40028038 	.word	0x40028038

00000518 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
 518:	b580      	push	{r7, lr}
 51a:	b084      	sub	sp, #16
 51c:	af00      	add	r7, sp, #0
 51e:	6078      	str	r0, [r7, #4]
  struct ethernetif *ethernetif;

  LWIP_ASSERT("netif != NULL", (netif != NULL));

  ethernetif = mem_malloc(sizeof(struct ethernetif));
 520:	f04f 0064 	mov.w	r0, #100	; 0x64
 524:	f7ff fffe 	bl	0 <mem_malloc>
			524: R_ARM_THM_CALL	mem_malloc
 528:	4603      	mov	r3, r0
 52a:	60fb      	str	r3, [r7, #12]
  if (ethernetif == NULL)
 52c:	68fb      	ldr	r3, [r7, #12]
 52e:	2b00      	cmp	r3, #0
 530:	d102      	bne.n	538 <ethernetif_init+0x20>
  {
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_init: out of memory\n"));
    return ERR_MEM;
 532:	f04f 03ff 	mov.w	r3, #255	; 0xff
 536:	e01d      	b.n	574 <ethernetif_init+0x5c>
   * The last argument should be replaced with your link speed, in units
   * of bits per second.
   */
  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, 100000000);

  netif->state = ethernetif;
 538:	687b      	ldr	r3, [r7, #4]
 53a:	68fa      	ldr	r2, [r7, #12]
 53c:	625a      	str	r2, [r3, #36]	; 0x24
  netif->name[0] = IFNAME0;
 53e:	687b      	ldr	r3, [r7, #4]
 540:	f04f 0273 	mov.w	r2, #115	; 0x73
 544:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
  netif->name[1] = IFNAME1;
 548:	687b      	ldr	r3, [r7, #4]
 54a:	f04f 0274 	mov.w	r2, #116	; 0x74
 54e:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
  netif->output = etharp_output;
 552:	687b      	ldr	r3, [r7, #4]
 554:	4a0a      	ldr	r2, [pc, #40]	; (580 <ethernetif_init+0x68>)
 556:	615a      	str	r2, [r3, #20]
  netif->linkoutput = low_level_output;
 558:	687b      	ldr	r3, [r7, #4]
 55a:	4a0a      	ldr	r2, [pc, #40]	; (584 <ethernetif_init+0x6c>)
 55c:	619a      	str	r2, [r3, #24]

  ethernetif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
 55e:	687b      	ldr	r3, [r7, #4]
 560:	f103 032f 	add.w	r3, r3, #47	; 0x2f
 564:	461a      	mov	r2, r3
 566:	68fb      	ldr	r3, [r7, #12]
 568:	601a      	str	r2, [r3, #0]

  /* initialize the hardware */
  low_level_init(netif);
 56a:	6878      	ldr	r0, [r7, #4]
 56c:	f7ff fd7c 	bl	68 <low_level_init>
  
  return ERR_OK;
 570:	f04f 0300 	mov.w	r3, #0
 574:	b25b      	sxtb	r3, r3
}
 576:	4618      	mov	r0, r3
 578:	f107 0710 	add.w	r7, r7, #16
 57c:	46bd      	mov	sp, r7
 57e:	bd80      	pop	{r7, pc}
	...
			580: R_ARM_ABS32	etharp_output
			584: R_ARM_ABS32	low_level_output

00000588 <ETH_RxPkt_ChainMode>:
* Input          : None
* Output         : None
* Return         : frame: farme size and location
*******************************************************************************/
FrameTypeDef ETH_RxPkt_ChainMode(void)
{ 
 588:	b490      	push	{r4, r7}
 58a:	b084      	sub	sp, #16
 58c:	af00      	add	r7, sp, #0
 58e:	4604      	mov	r4, r0
  u32 framelength = 0;
 590:	f04f 0300 	mov.w	r3, #0
 594:	60fb      	str	r3, [r7, #12]
  FrameTypeDef frame = {0,0}; 
 596:	463b      	mov	r3, r7
 598:	f04f 0200 	mov.w	r2, #0
 59c:	601a      	str	r2, [r3, #0]
 59e:	f103 0304 	add.w	r3, r3, #4
 5a2:	f04f 0200 	mov.w	r2, #0
 5a6:	601a      	str	r2, [r3, #0]
 5a8:	f103 0304 	add.w	r3, r3, #4
 5ac:	f04f 0200 	mov.w	r2, #0
 5b0:	601a      	str	r2, [r3, #0]
 5b2:	f103 0304 	add.w	r3, r3, #4

  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (u32)RESET)
 5b6:	4b33      	ldr	r3, [pc, #204]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 5b8:	681b      	ldr	r3, [r3, #0]
 5ba:	681b      	ldr	r3, [r3, #0]
 5bc:	2b00      	cmp	r3, #0
 5be:	da22      	bge.n	606 <ETH_RxPkt_ChainMode+0x7e>
  {	
	frame.length = ETH_ERROR;
 5c0:	f04f 0300 	mov.w	r3, #0
 5c4:	603b      	str	r3, [r7, #0]

    if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET)  
 5c6:	4b30      	ldr	r3, [pc, #192]	; (688 <ETH_RxPkt_ChainMode+0x100>)
 5c8:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 5cc:	f103 0314 	add.w	r3, r3, #20
 5d0:	681b      	ldr	r3, [r3, #0]
 5d2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 5d6:	2b00      	cmp	r3, #0
 5d8:	d00f      	beq.n	5fa <ETH_RxPkt_ChainMode+0x72>
    {
      /* Clear RBUS ETHERNET DMA flag */
      ETH->DMASR = ETH_DMASR_RBUS;
 5da:	4b2b      	ldr	r3, [pc, #172]	; (688 <ETH_RxPkt_ChainMode+0x100>)
 5dc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 5e0:	f103 0314 	add.w	r3, r3, #20
 5e4:	f04f 0280 	mov.w	r2, #128	; 0x80
 5e8:	601a      	str	r2, [r3, #0]
      /* Resume DMA reception */
      ETH->DMARPDR = 0;
 5ea:	4b27      	ldr	r3, [pc, #156]	; (688 <ETH_RxPkt_ChainMode+0x100>)
 5ec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 5f0:	f103 0308 	add.w	r3, r3, #8
 5f4:	f04f 0200 	mov.w	r2, #0
 5f8:	601a      	str	r2, [r3, #0]
    }

	/* Return error: OWN bit set */
    return frame; 
 5fa:	4623      	mov	r3, r4
 5fc:	463a      	mov	r2, r7
 5fe:	ca07      	ldmia	r2, {r0, r1, r2}
 600:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 604:	e037      	b.n	676 <ETH_RxPkt_ChainMode+0xee>
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (u32)RESET) && 
 606:	4b1f      	ldr	r3, [pc, #124]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 608:	681b      	ldr	r3, [r3, #0]
 60a:	681b      	ldr	r3, [r3, #0]
 60c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 610:	2b00      	cmp	r3, #0
 612:	d11d      	bne.n	650 <ETH_RxPkt_ChainMode+0xc8>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (u32)RESET) &&  
 614:	4b1b      	ldr	r3, [pc, #108]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 616:	681b      	ldr	r3, [r3, #0]
 618:	681b      	ldr	r3, [r3, #0]
 61a:	f403 7380 	and.w	r3, r3, #256	; 0x100

	/* Return error: OWN bit set */
    return frame; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (u32)RESET) && 
 61e:	2b00      	cmp	r3, #0
 620:	d016      	beq.n	650 <ETH_RxPkt_ChainMode+0xc8>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (u32)RESET) &&  
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (u32)RESET))  
 622:	4b18      	ldr	r3, [pc, #96]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 624:	681b      	ldr	r3, [r3, #0]
 626:	681b      	ldr	r3, [r3, #0]
 628:	f403 7300 	and.w	r3, r3, #512	; 0x200
	/* Return error: OWN bit set */
    return frame; 
  }
  
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (u32)RESET) && 
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (u32)RESET) &&  
 62c:	2b00      	cmp	r3, #0
 62e:	d00f      	beq.n	650 <ETH_RxPkt_ChainMode+0xc8>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (u32)RESET))  
  {      
    /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
    framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 630:	4b14      	ldr	r3, [pc, #80]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 632:	681b      	ldr	r3, [r3, #0]
 634:	681a      	ldr	r2, [r3, #0]
 636:	4b15      	ldr	r3, [pc, #84]	; (68c <ETH_RxPkt_ChainMode+0x104>)
 638:	ea02 0303 	and.w	r3, r2, r3
 63c:	ea4f 4313 	mov.w	r3, r3, lsr #16
 640:	f1a3 0304 	sub.w	r3, r3, #4
 644:	60fb      	str	r3, [r7, #12]
	
	/* Get the addrees of the actual buffer */
	frame.buffer = DMARxDescToGet->Buffer1Addr;	
 646:	4b0f      	ldr	r3, [pc, #60]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 648:	681b      	ldr	r3, [r3, #0]
 64a:	689b      	ldr	r3, [r3, #8]
 64c:	607b      	str	r3, [r7, #4]
 64e:	e002      	b.n	656 <ETH_RxPkt_ChainMode+0xce>
  }
  else
  {
    /* Return ERROR */
    framelength = ETH_ERROR;
 650:	f04f 0300 	mov.w	r3, #0
 654:	60fb      	str	r3, [r7, #12]
  }

  frame.length = framelength;
 656:	68fb      	ldr	r3, [r7, #12]
 658:	603b      	str	r3, [r7, #0]


  frame.descriptor = DMARxDescToGet;
 65a:	4b0a      	ldr	r3, [pc, #40]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 65c:	681b      	ldr	r3, [r3, #0]
 65e:	60bb      	str	r3, [r7, #8]
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */      
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
 660:	4b08      	ldr	r3, [pc, #32]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 662:	681b      	ldr	r3, [r3, #0]
 664:	68db      	ldr	r3, [r3, #12]
 666:	461a      	mov	r2, r3
 668:	4b06      	ldr	r3, [pc, #24]	; (684 <ETH_RxPkt_ChainMode+0xfc>)
 66a:	601a      	str	r2, [r3, #0]
  
  /* Return Frame */
  return (frame);  
 66c:	4623      	mov	r3, r4
 66e:	463a      	mov	r2, r7
 670:	ca07      	ldmia	r2, {r0, r1, r2}
 672:	e883 0007 	stmia.w	r3, {r0, r1, r2}
}
 676:	4620      	mov	r0, r4
 678:	f107 0710 	add.w	r7, r7, #16
 67c:	46bd      	mov	sp, r7
 67e:	bc90      	pop	{r4, r7}
 680:	4770      	bx	lr
 682:	bf00      	nop
 684:	00000000 	.word	0x00000000
			684: R_ARM_ABS32	DMARxDescToGet
 688:	40028000 	.word	0x40028000
 68c:	3fff0000 	.word	0x3fff0000

00000690 <ETH_TxPkt_ChainMode>:
* Output         : None
* Return         : ETH_ERROR: in case of Tx desc owned by DMA
*                  ETH_SUCCESS: for correct transmission
*******************************************************************************/
u32 ETH_TxPkt_ChainMode(u16 FrameLength)
{   
 690:	b480      	push	{r7}
 692:	b083      	sub	sp, #12
 694:	af00      	add	r7, sp, #0
 696:	4603      	mov	r3, r0
 698:	80fb      	strh	r3, [r7, #6]
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 69a:	4b24      	ldr	r3, [pc, #144]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 69c:	681b      	ldr	r3, [r3, #0]
 69e:	681b      	ldr	r3, [r3, #0]
 6a0:	2b00      	cmp	r3, #0
 6a2:	da02      	bge.n	6aa <ETH_TxPkt_ChainMode+0x1a>
  {  
	/* Return ERROR: OWN bit set */
    return ETH_ERROR;
 6a4:	f04f 0300 	mov.w	r3, #0
 6a8:	e039      	b.n	71e <ETH_TxPkt_ChainMode+0x8e>
  }
        
  /* Setting the Frame Length: bits[12:0] */
  DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
 6aa:	4b20      	ldr	r3, [pc, #128]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 6ac:	681a      	ldr	r2, [r3, #0]
 6ae:	88fb      	ldrh	r3, [r7, #6]
 6b0:	ea4f 43c3 	mov.w	r3, r3, lsl #19
 6b4:	ea4f 43d3 	mov.w	r3, r3, lsr #19
 6b8:	6053      	str	r3, [r2, #4]

  /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */    
  DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
 6ba:	4b1c      	ldr	r3, [pc, #112]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 6bc:	681b      	ldr	r3, [r3, #0]
 6be:	4a1b      	ldr	r2, [pc, #108]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 6c0:	6812      	ldr	r2, [r2, #0]
 6c2:	6812      	ldr	r2, [r2, #0]
 6c4:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
 6c8:	601a      	str	r2, [r3, #0]

  /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
  DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
 6ca:	4b18      	ldr	r3, [pc, #96]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 6cc:	681b      	ldr	r3, [r3, #0]
 6ce:	4a17      	ldr	r2, [pc, #92]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 6d0:	6812      	ldr	r2, [r2, #0]
 6d2:	6812      	ldr	r2, [r2, #0]
 6d4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 6d8:	601a      	str	r2, [r3, #0]

  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
 6da:	4b15      	ldr	r3, [pc, #84]	; (730 <ETH_TxPkt_ChainMode+0xa0>)
 6dc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 6e0:	f103 0314 	add.w	r3, r3, #20
 6e4:	681b      	ldr	r3, [r3, #0]
 6e6:	f003 0304 	and.w	r3, r3, #4
 6ea:	2b00      	cmp	r3, #0
 6ec:	d00f      	beq.n	70e <ETH_TxPkt_ChainMode+0x7e>
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
 6ee:	4b10      	ldr	r3, [pc, #64]	; (730 <ETH_TxPkt_ChainMode+0xa0>)
 6f0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 6f4:	f103 0314 	add.w	r3, r3, #20
 6f8:	f04f 0204 	mov.w	r2, #4
 6fc:	601a      	str	r2, [r3, #0]
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 6fe:	4b0c      	ldr	r3, [pc, #48]	; (730 <ETH_TxPkt_ChainMode+0xa0>)
 700:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 704:	f103 0304 	add.w	r3, r3, #4
 708:	f04f 0200 	mov.w	r2, #0
 70c:	601a      	str	r2, [r3, #0]
  }
  
  /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */  
  /* Chained Mode */
  /* Selects the next DMA Tx descriptor list for next buffer to send */ 
  DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet->Buffer2NextDescAddr);    
 70e:	4b07      	ldr	r3, [pc, #28]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 710:	681b      	ldr	r3, [r3, #0]
 712:	68db      	ldr	r3, [r3, #12]
 714:	461a      	mov	r2, r3
 716:	4b05      	ldr	r3, [pc, #20]	; (72c <ETH_TxPkt_ChainMode+0x9c>)
 718:	601a      	str	r2, [r3, #0]


  /* Return SUCCESS */
  return ETH_SUCCESS;   
 71a:	f04f 0301 	mov.w	r3, #1
}
 71e:	4618      	mov	r0, r3
 720:	f107 070c 	add.w	r7, r7, #12
 724:	46bd      	mov	sp, r7
 726:	bc80      	pop	{r7}
 728:	4770      	bx	lr
 72a:	bf00      	nop
 72c:	00000000 	.word	0x00000000
			72c: R_ARM_ABS32	DMATxDescToSet
 730:	40028000 	.word	0x40028000

00000734 <ETH_GetCurrentTxBuffer>:
* Input          : None
* Output         : None
* Return         : Buffer address
*******************************************************************************/
u32 ETH_GetCurrentTxBuffer(void)
{ 
 734:	b480      	push	{r7}
 736:	af00      	add	r7, sp, #0
  /* Return Buffer address */
  return (DMATxDescToSet->Buffer1Addr);   
 738:	4b03      	ldr	r3, [pc, #12]	; (748 <ETH_GetCurrentTxBuffer+0x14>)
 73a:	681b      	ldr	r3, [r3, #0]
 73c:	689b      	ldr	r3, [r3, #8]
}
 73e:	4618      	mov	r0, r3
 740:	46bd      	mov	sp, r7
 742:	bc80      	pop	{r7}
 744:	4770      	bx	lr
 746:	bf00      	nop
 748:	00000000 	.word	0x00000000
			748: R_ARM_ABS32	DMATxDescToSet

0000074c <vEMACWaitForInput>:


void vEMACWaitForInput( void )
{
 74c:	b580      	push	{r7, lr}
 74e:	af00      	add	r7, sp, #0
	/* Just wait until we are signled from an ISR that data is available, or
	we simply time out. */
	xSemaphoreTake( s_xSemaphore, emacBLOCK_TIME_WAITING_FOR_INPUT );
 750:	4b05      	ldr	r3, [pc, #20]	; (768 <vEMACWaitForInput+0x1c>)
 752:	681b      	ldr	r3, [r3, #0]
 754:	4618      	mov	r0, r3
 756:	f04f 0100 	mov.w	r1, #0
 75a:	f04f 0264 	mov.w	r2, #100	; 0x64
 75e:	f04f 0300 	mov.w	r3, #0
 762:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			762: R_ARM_THM_CALL	xQueueGenericReceive
}
 766:	bd80      	pop	{r7, pc}
 768:	00000000 	.word	0x00000000
			768: R_ARM_ABS32	s_xSemaphore

0000076c <arp_timer>:

static void
arp_timer(void *arg)
{
 76c:	b580      	push	{r7, lr}
 76e:	b082      	sub	sp, #8
 770:	af00      	add	r7, sp, #0
 772:	6078      	str	r0, [r7, #4]
  etharp_tmr();
 774:	f7ff fffe 	bl	0 <etharp_tmr>
			774: R_ARM_THM_CALL	etharp_tmr
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 778:	f241 3088 	movw	r0, #5000	; 0x1388
 77c:	4904      	ldr	r1, [pc, #16]	; (790 <arp_timer+0x24>)
 77e:	f04f 0200 	mov.w	r2, #0
 782:	f7ff fffe 	bl	0 <sys_timeout>
			782: R_ARM_THM_CALL	sys_timeout
}
 786:	f107 0708 	add.w	r7, r7, #8
 78a:	46bd      	mov	sp, r7
 78c:	bd80      	pop	{r7, pc}
 78e:	bf00      	nop
 790:	00000000 	.word	0x00000000
			790: R_ARM_ABS32	arp_timer

sys_arch.c.obj:     file format elf32-littlearm
rw-rw-rw- 0/0  46196 Jul 30 19:07 2021 sys_arch.c.obj
architecture: arm, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000
private flags = 5000000: [Version5 EABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000490  00000000  00000000  00000034  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000004  00000000  00000000  000004c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  000004c8  2**1
                  ALLOC
  3 .debug_abbrev 00000160  00000000  00000000  000004c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000632  00000000  00000000  00000628  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_line   000004a6  00000000  00000000  00000c5a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_macinfo 00008519  00000000  00000000  00001100  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000043c  00000000  00000000  00009619  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000019d  00000000  00000000  00009a55  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_pubtypes 000000d9  00000000  00000000  00009bf2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_aranges 00000020  00000000  00000000  00009ccb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000337  00000000  00000000  00009ceb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002b  00000000  00000000  0000a022  2**0
                  CONTENTS, READONLY
 13 .ARM.attributes 00000031  00000000  00000000  0000a04d  2**0
                  CONTENTS, READONLY
 14 .debug_frame  0000026c  00000000  00000000  0000a080  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    df *ABS*	00000000 sys_arch.c
00000000 l    d  .text	00000000 .text
00000000 l    d  .data	00000000 .data
00000000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_macinfo	00000000 .debug_macinfo
00000000 l       .bss	00000000 s_nextthread
00000000 l     O .data	00000004 next.4304
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_pubtypes	00000000 .debug_pubtypes
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 g     F .text	00000030 lwip_rand_arch
00000030 g     F .text	00000056 sys_mbox_new
00000000         *UND*	00000000 xQueueGenericCreate
00000088 g     F .text	0000002c sys_mbox_free
00000000         *UND*	00000000 uxQueueMessagesWaiting
00000000         *UND*	00000000 vQueueDelete
000000b4 g     F .text	00000030 sys_mbox_post
00000000         *UND*	00000000 xQueueGenericSend
000000e4 g     F .text	00000042 sys_mbox_trypost
00000128 g     F .text	00000092 sys_arch_mbox_fetch
00000000         *UND*	00000000 xTaskGetTickCount
00000000         *UND*	00000000 xQueueGenericReceive
000001bc g     F .text	00000044 sys_arch_mbox_tryfetch
00000200 g     F .text	00000088 sys_sem_new
00000288 g     F .text	00000080 sys_arch_sem_wait
00000308 g     F .text	00000026 sys_sem_signal
00000330 g     F .text	00000022 sys_sem_free
00000354 g     F .text	00000018 sys_init
0000036c g     F .text	00000070 sys_thread_new
00000000         *UND*	00000000 xTaskGenericCreate
000003dc g     F .text	00000010 sys_arch_protect
00000000         *UND*	00000000 vPortEnterCritical
000003ec g     F .text	00000014 sys_arch_unprotect
00000000         *UND*	00000000 vPortExitCritical
00000400 g     F .text	0000000e sys_assert
00000410 g     F .text	00000024 sys_mbox_valid
00000434 g     F .text	0000001a sys_mbox_set_invalid
00000450 g     F .text	00000024 sys_sem_valid
00000474 g     F .text	0000001a sys_sem_set_invalid



Disassembly of section .text:

00000000 <lwip_rand_arch>:
/* This is the number of threads that can be started with sys_thread_new() */
#define SYS_THREAD_MAX 4
static u16_t s_nextthread = 0;

u32_t lwip_rand_arch(void)
{
   0:	b480      	push	{r7}
   2:	af00      	add	r7, sp, #0
	static u32_t next = 1;
	next = next * 1103515245 + 12345;
   4:	4b08      	ldr	r3, [pc, #32]	; (28 <lwip_rand_arch+0x28>)
   6:	681b      	ldr	r3, [r3, #0]
   8:	4a08      	ldr	r2, [pc, #32]	; (2c <lwip_rand_arch+0x2c>)
   a:	fb02 f303 	mul.w	r3, r2, r3
   e:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
  12:	f103 0339 	add.w	r3, r3, #57	; 0x39
  16:	4a04      	ldr	r2, [pc, #16]	; (28 <lwip_rand_arch+0x28>)
  18:	6013      	str	r3, [r2, #0]
	return next;
  1a:	4b03      	ldr	r3, [pc, #12]	; (28 <lwip_rand_arch+0x28>)
  1c:	681b      	ldr	r3, [r3, #0]
}
  1e:	4618      	mov	r0, r3
  20:	46bd      	mov	sp, r7
  22:	bc80      	pop	{r7}
  24:	4770      	bx	lr
  26:	bf00      	nop
  28:	00000000 	.word	0x00000000
			28: R_ARM_ABS32	.data
  2c:	41c64e6d 	.word	0x41c64e6d

00000030 <sys_mbox_new>:

/*-----------------------------------------------------------------------------------*/
//  Creates an empty mailbox.
err_t sys_mbox_new(sys_mbox_t *mbox, int size)
{
  30:	b580      	push	{r7, lr}
  32:	b084      	sub	sp, #16
  34:	af00      	add	r7, sp, #0
  36:	6078      	str	r0, [r7, #4]
  38:	6039      	str	r1, [r7, #0]
	xQueueHandle lmbox;

	( void ) size;

	lmbox = xQueueCreate( archMESG_QUEUE_LENGTH, sizeof( void * ) );
  3a:	f04f 0006 	mov.w	r0, #6
  3e:	f04f 0104 	mov.w	r1, #4
  42:	f04f 0200 	mov.w	r2, #0
  46:	f7ff fffe 	bl	0 <xQueueGenericCreate>
			46: R_ARM_THM_CALL	xQueueGenericCreate
  4a:	60f8      	str	r0, [r7, #12]

	if ( lmbox == NULL )
  4c:	68fb      	ldr	r3, [r7, #12]
  4e:	2b00      	cmp	r3, #0
  50:	d10a      	bne.n	68 <sys_mbox_new+0x38>
	{
		mbox->handle = NULL;
  52:	687b      	ldr	r3, [r7, #4]
  54:	f04f 0200 	mov.w	r2, #0
  58:	601a      	str	r2, [r3, #0]
		mbox->valid = 0;
  5a:	687b      	ldr	r3, [r7, #4]
  5c:	f04f 0200 	mov.w	r2, #0
  60:	711a      	strb	r2, [r3, #4]
		return ERR_MEM;
  62:	f04f 03ff 	mov.w	r3, #255	; 0xff
  66:	e008      	b.n	7a <sys_mbox_new+0x4a>
	}

	mbox->handle = lmbox;
  68:	687b      	ldr	r3, [r7, #4]
  6a:	68fa      	ldr	r2, [r7, #12]
  6c:	601a      	str	r2, [r3, #0]
	mbox->valid = 1;
  6e:	687b      	ldr	r3, [r7, #4]
  70:	f04f 0201 	mov.w	r2, #1
  74:	711a      	strb	r2, [r3, #4]
      if (lwip_stats.sys.mbox.max < lwip_stats.sys.mbox.used) {
         lwip_stats.sys.mbox.max = lwip_stats.sys.mbox.used;
	  }
#endif /* SYS_STATS */

	return ERR_OK;
  76:	f04f 0300 	mov.w	r3, #0
  7a:	b25b      	sxtb	r3, r3
}
  7c:	4618      	mov	r0, r3
  7e:	f107 0710 	add.w	r7, r7, #16
  82:	46bd      	mov	sp, r7
  84:	bd80      	pop	{r7, pc}
  86:	bf00      	nop

00000088 <sys_mbox_free>:
  Deallocates a mailbox. If there are messages still present in the
  mailbox when the mailbox is deallocated, it is an indication of a
  programming error in lwIP and the developer should be notified.
*/
void sys_mbox_free(sys_mbox_t *mbox)
{
  88:	b580      	push	{r7, lr}
  8a:	b082      	sub	sp, #8
  8c:	af00      	add	r7, sp, #0
  8e:	6078      	str	r0, [r7, #4]
	if( uxQueueMessagesWaiting( mbox->handle ) )
  90:	687b      	ldr	r3, [r7, #4]
  92:	681b      	ldr	r3, [r3, #0]
  94:	4618      	mov	r0, r3
  96:	f7ff fffe 	bl	0 <uxQueueMessagesWaiting>
			96: R_ARM_THM_CALL	uxQueueMessagesWaiting
#endif /* SYS_STATS */

		// TODO notify the user of failure.
	}

	vQueueDelete( mbox->handle );
  9a:	687b      	ldr	r3, [r7, #4]
  9c:	681b      	ldr	r3, [r3, #0]
  9e:	4618      	mov	r0, r3
  a0:	f7ff fffe 	bl	0 <vQueueDelete>
			a0: R_ARM_THM_CALL	vQueueDelete
	mbox->valid = 0;
  a4:	687b      	ldr	r3, [r7, #4]
  a6:	f04f 0200 	mov.w	r2, #0
  aa:	711a      	strb	r2, [r3, #4]

#if SYS_STATS
     --lwip_stats.sys.mbox.used;
#endif /* SYS_STATS */
}
  ac:	f107 0708 	add.w	r7, r7, #8
  b0:	46bd      	mov	sp, r7
  b2:	bd80      	pop	{r7, pc}

000000b4 <sys_mbox_post>:

/*-----------------------------------------------------------------------------------*/
//   Posts the "msg" to the mailbox.
void sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
  b4:	b580      	push	{r7, lr}
  b6:	b082      	sub	sp, #8
  b8:	af00      	add	r7, sp, #0
  ba:	6078      	str	r0, [r7, #4]
  bc:	6039      	str	r1, [r7, #0]
	while ( xQueueSendToBack(mbox->handle, &msg, portMAX_DELAY ) != pdTRUE ){}
  be:	bf00      	nop
  c0:	687b      	ldr	r3, [r7, #4]
  c2:	681a      	ldr	r2, [r3, #0]
  c4:	463b      	mov	r3, r7
  c6:	4610      	mov	r0, r2
  c8:	4619      	mov	r1, r3
  ca:	f04f 32ff 	mov.w	r2, #4294967295
  ce:	f04f 0300 	mov.w	r3, #0
  d2:	f7ff fffe 	bl	0 <xQueueGenericSend>
			d2: R_ARM_THM_CALL	xQueueGenericSend
  d6:	4603      	mov	r3, r0
  d8:	2b01      	cmp	r3, #1
  da:	d1f1      	bne.n	c0 <sys_mbox_post+0xc>
}
  dc:	f107 0708 	add.w	r7, r7, #8
  e0:	46bd      	mov	sp, r7
  e2:	bd80      	pop	{r7, pc}

000000e4 <sys_mbox_trypost>:

/*-----------------------------------------------------------------------------------*/
//   Try to post the "msg" to the mailbox.
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
  e4:	b580      	push	{r7, lr}
  e6:	b084      	sub	sp, #16
  e8:	af00      	add	r7, sp, #0
  ea:	6078      	str	r0, [r7, #4]
  ec:	6039      	str	r1, [r7, #0]
	err_t result;

   if ( xQueueSend( mbox->handle, &msg, 0 ) == pdPASS )
  ee:	687b      	ldr	r3, [r7, #4]
  f0:	681a      	ldr	r2, [r3, #0]
  f2:	463b      	mov	r3, r7
  f4:	4610      	mov	r0, r2
  f6:	4619      	mov	r1, r3
  f8:	f04f 0200 	mov.w	r2, #0
  fc:	f04f 0300 	mov.w	r3, #0
 100:	f7ff fffe 	bl	0 <xQueueGenericSend>
			100: R_ARM_THM_CALL	xQueueGenericSend
 104:	4603      	mov	r3, r0
 106:	2b01      	cmp	r3, #1
 108:	d103      	bne.n	112 <sys_mbox_trypost+0x2e>
   {
      result = ERR_OK;
 10a:	f04f 0300 	mov.w	r3, #0
 10e:	73fb      	strb	r3, [r7, #15]
 110:	e002      	b.n	118 <sys_mbox_trypost+0x34>
   }
   else {
      // could not post, queue must be full
      result = ERR_MEM;
 112:	f04f 03ff 	mov.w	r3, #255	; 0xff
 116:	73fb      	strb	r3, [r7, #15]
      lwip_stats.sys.mbox.err++;
#endif /* SYS_STATS */

   }

   return result;
 118:	7bfb      	ldrb	r3, [r7, #15]
 11a:	b25b      	sxtb	r3, r3
}
 11c:	4618      	mov	r0, r3
 11e:	f107 0710 	add.w	r7, r7, #16
 122:	46bd      	mov	sp, r7
 124:	bd80      	pop	{r7, pc}
 126:	bf00      	nop

00000128 <sys_arch_mbox_fetch>:

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP.
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{
 128:	b580      	push	{r7, lr}
 12a:	b088      	sub	sp, #32
 12c:	af00      	add	r7, sp, #0
 12e:	60f8      	str	r0, [r7, #12]
 130:	60b9      	str	r1, [r7, #8]
 132:	607a      	str	r2, [r7, #4]
	void *dummyptr;
	portTickType StartTime, EndTime, Elapsed;

	StartTime = xTaskGetTickCount();
 134:	f7ff fffe 	bl	0 <xTaskGetTickCount>
			134: R_ARM_THM_CALL	xTaskGetTickCount
 138:	61f8      	str	r0, [r7, #28]

	if ( msg == NULL )
 13a:	68bb      	ldr	r3, [r7, #8]
 13c:	2b00      	cmp	r3, #0
 13e:	d102      	bne.n	146 <sys_arch_mbox_fetch+0x1e>
	{
		msg = &dummyptr;
 140:	f107 0310 	add.w	r3, r7, #16
 144:	60bb      	str	r3, [r7, #8]
	}

	if ( timeout != 0 )
 146:	687b      	ldr	r3, [r7, #4]
 148:	2b00      	cmp	r3, #0
 14a:	d01b      	beq.n	184 <sys_arch_mbox_fetch+0x5c>
	{
		if ( pdTRUE == xQueueReceive( mbox->handle, &(*msg), timeout / portTICK_RATE_MS ) )
 14c:	68fb      	ldr	r3, [r7, #12]
 14e:	681b      	ldr	r3, [r3, #0]
 150:	4618      	mov	r0, r3
 152:	68b9      	ldr	r1, [r7, #8]
 154:	687a      	ldr	r2, [r7, #4]
 156:	f04f 0300 	mov.w	r3, #0
 15a:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			15a: R_ARM_THM_CALL	xQueueGenericReceive
 15e:	4603      	mov	r3, r0
 160:	2b01      	cmp	r3, #1
 162:	d108      	bne.n	176 <sys_arch_mbox_fetch+0x4e>
		{
			EndTime = xTaskGetTickCount();
 164:	f7ff fffe 	bl	0 <xTaskGetTickCount>
			164: R_ARM_THM_CALL	xTaskGetTickCount
 168:	61b8      	str	r0, [r7, #24]
			Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
 16a:	69ba      	ldr	r2, [r7, #24]
 16c:	69fb      	ldr	r3, [r7, #28]
 16e:	1ad3      	subs	r3, r2, r3
 170:	617b      	str	r3, [r7, #20]

			return ( Elapsed );
 172:	697b      	ldr	r3, [r7, #20]
 174:	e01c      	b.n	1b0 <sys_arch_mbox_fetch+0x88>
		}
		else // timed out blocking for message
		{
			*msg = NULL;
 176:	68bb      	ldr	r3, [r7, #8]
 178:	f04f 0200 	mov.w	r2, #0
 17c:	601a      	str	r2, [r3, #0]

			return SYS_ARCH_TIMEOUT;
 17e:	f04f 33ff 	mov.w	r3, #4294967295
 182:	e015      	b.n	1b0 <sys_arch_mbox_fetch+0x88>
		}
	}
	else // block forever for a message.
	{
		while( pdTRUE != xQueueReceive( mbox->handle, &(*msg), portMAX_DELAY ) ){} // time is arbitrary
 184:	bf00      	nop
 186:	68fb      	ldr	r3, [r7, #12]
 188:	681b      	ldr	r3, [r3, #0]
 18a:	4618      	mov	r0, r3
 18c:	68b9      	ldr	r1, [r7, #8]
 18e:	f04f 32ff 	mov.w	r2, #4294967295
 192:	f04f 0300 	mov.w	r3, #0
 196:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			196: R_ARM_THM_CALL	xQueueGenericReceive
 19a:	4603      	mov	r3, r0
 19c:	2b01      	cmp	r3, #1
 19e:	d1f2      	bne.n	186 <sys_arch_mbox_fetch+0x5e>
		EndTime = xTaskGetTickCount();
 1a0:	f7ff fffe 	bl	0 <xTaskGetTickCount>
			1a0: R_ARM_THM_CALL	xTaskGetTickCount
 1a4:	61b8      	str	r0, [r7, #24]
		Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
 1a6:	69ba      	ldr	r2, [r7, #24]
 1a8:	69fb      	ldr	r3, [r7, #28]
 1aa:	1ad3      	subs	r3, r2, r3
 1ac:	617b      	str	r3, [r7, #20]

		return ( Elapsed ); // return time blocked TODO test
 1ae:	697b      	ldr	r3, [r7, #20]
	}
}
 1b0:	4618      	mov	r0, r3
 1b2:	f107 0720 	add.w	r7, r7, #32
 1b6:	46bd      	mov	sp, r7
 1b8:	bd80      	pop	{r7, pc}
 1ba:	bf00      	nop

000001bc <sys_arch_mbox_tryfetch>:
/*
  Similar to sys_arch_mbox_fetch, but if message is not ready immediately, we'll
  return with SYS_MBOX_EMPTY.  On success, 0 is returned.
*/
u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg)
{
 1bc:	b580      	push	{r7, lr}
 1be:	b084      	sub	sp, #16
 1c0:	af00      	add	r7, sp, #0
 1c2:	6078      	str	r0, [r7, #4]
 1c4:	6039      	str	r1, [r7, #0]
	void *dummyptr;

	if ( msg == NULL )
 1c6:	683b      	ldr	r3, [r7, #0]
 1c8:	2b00      	cmp	r3, #0
 1ca:	d102      	bne.n	1d2 <sys_arch_mbox_tryfetch+0x16>
	{
		msg = &dummyptr;
 1cc:	f107 030c 	add.w	r3, r7, #12
 1d0:	603b      	str	r3, [r7, #0]
	}

   if ( pdTRUE == xQueueReceive( mbox->handle, &(*msg), 0 ) )
 1d2:	687b      	ldr	r3, [r7, #4]
 1d4:	681b      	ldr	r3, [r3, #0]
 1d6:	4618      	mov	r0, r3
 1d8:	6839      	ldr	r1, [r7, #0]
 1da:	f04f 0200 	mov.w	r2, #0
 1de:	f04f 0300 	mov.w	r3, #0
 1e2:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			1e2: R_ARM_THM_CALL	xQueueGenericReceive
 1e6:	4603      	mov	r3, r0
 1e8:	2b01      	cmp	r3, #1
 1ea:	d102      	bne.n	1f2 <sys_arch_mbox_tryfetch+0x36>
   {
      return ERR_OK;
 1ec:	f04f 0300 	mov.w	r3, #0
 1f0:	e001      	b.n	1f6 <sys_arch_mbox_tryfetch+0x3a>
   }
   else
   {
      return SYS_MBOX_EMPTY;
 1f2:	f04f 33ff 	mov.w	r3, #4294967295
   }
}
 1f6:	4618      	mov	r0, r3
 1f8:	f107 0710 	add.w	r7, r7, #16
 1fc:	46bd      	mov	sp, r7
 1fe:	bd80      	pop	{r7, pc}

00000200 <sys_sem_new>:

/*-----------------------------------------------------------------------------------*/
//  Creates and returns a new semaphore. The "count" argument specifies
//  the initial state of the semaphore.
err_t sys_sem_new(sys_sem_t *sem, u8_t count)
{
 200:	b580      	push	{r7, lr}
 202:	b084      	sub	sp, #16
 204:	af00      	add	r7, sp, #0
 206:	6078      	str	r0, [r7, #4]
 208:	460b      	mov	r3, r1
 20a:	70fb      	strb	r3, [r7, #3]
	xSemaphoreHandle  lxSemaphore;

	vSemaphoreCreateBinary( lxSemaphore );
 20c:	f04f 0001 	mov.w	r0, #1
 210:	f04f 0100 	mov.w	r1, #0
 214:	f04f 0203 	mov.w	r2, #3
 218:	f7ff fffe 	bl	0 <xQueueGenericCreate>
			218: R_ARM_THM_CALL	xQueueGenericCreate
 21c:	60f8      	str	r0, [r7, #12]
 21e:	68fb      	ldr	r3, [r7, #12]
 220:	2b00      	cmp	r3, #0
 222:	d008      	beq.n	236 <sys_sem_new+0x36>
 224:	68f8      	ldr	r0, [r7, #12]
 226:	f04f 0100 	mov.w	r1, #0
 22a:	f04f 0200 	mov.w	r2, #0
 22e:	f04f 0300 	mov.w	r3, #0
 232:	f7ff fffe 	bl	0 <xQueueGenericSend>
			232: R_ARM_THM_CALL	xQueueGenericSend

	if( lxSemaphore == NULL )
 236:	68fb      	ldr	r3, [r7, #12]
 238:	2b00      	cmp	r3, #0
 23a:	d10a      	bne.n	252 <sys_sem_new+0x52>
	{

#if SYS_STATS
      ++lwip_stats.sys.sem.err;
#endif /* SYS_STATS */
      	sem->handle = NULL;
 23c:	687b      	ldr	r3, [r7, #4]
 23e:	f04f 0200 	mov.w	r2, #0
 242:	601a      	str	r2, [r3, #0]
      	sem->valid = 0;
 244:	687b      	ldr	r3, [r7, #4]
 246:	f04f 0200 	mov.w	r2, #0
 24a:	711a      	strb	r2, [r3, #4]
		return ERR_MEM;
 24c:	f04f 03ff 	mov.w	r3, #255	; 0xff
 250:	e014      	b.n	27c <sys_sem_new+0x7c>
	}

	if(count == 0)	// Means it can't be taken
 252:	78fb      	ldrb	r3, [r7, #3]
 254:	2b00      	cmp	r3, #0
 256:	d108      	bne.n	26a <sys_sem_new+0x6a>
	{
		xSemaphoreTake(lxSemaphore,1);
 258:	68f8      	ldr	r0, [r7, #12]
 25a:	f04f 0100 	mov.w	r1, #0
 25e:	f04f 0201 	mov.w	r2, #1
 262:	f04f 0300 	mov.w	r3, #0
 266:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			266: R_ARM_THM_CALL	xQueueGenericReceive
 	if (lwip_stats.sys.sem.max < lwip_stats.sys.sem.used) {
		lwip_stats.sys.sem.max = lwip_stats.sys.sem.used;
	}
#endif /* SYS_STATS */

	sem->handle = lxSemaphore;
 26a:	687b      	ldr	r3, [r7, #4]
 26c:	68fa      	ldr	r2, [r7, #12]
 26e:	601a      	str	r2, [r3, #0]
	sem->valid = 1;
 270:	687b      	ldr	r3, [r7, #4]
 272:	f04f 0201 	mov.w	r2, #1
 276:	711a      	strb	r2, [r3, #4]

	return ERR_OK;
 278:	f04f 0300 	mov.w	r3, #0
 27c:	b25b      	sxtb	r3, r3
}
 27e:	4618      	mov	r0, r3
 280:	f107 0710 	add.w	r7, r7, #16
 284:	46bd      	mov	sp, r7
 286:	bd80      	pop	{r7, pc}

00000288 <sys_arch_sem_wait>:

  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{
 288:	b580      	push	{r7, lr}
 28a:	b086      	sub	sp, #24
 28c:	af00      	add	r7, sp, #0
 28e:	6078      	str	r0, [r7, #4]
 290:	6039      	str	r1, [r7, #0]
portTickType StartTime, EndTime, Elapsed;

	StartTime = xTaskGetTickCount();
 292:	f7ff fffe 	bl	0 <xTaskGetTickCount>
			292: R_ARM_THM_CALL	xTaskGetTickCount
 296:	6178      	str	r0, [r7, #20]

	if(	timeout != 0)
 298:	683b      	ldr	r3, [r7, #0]
 29a:	2b00      	cmp	r3, #0
 29c:	d018      	beq.n	2d0 <sys_arch_sem_wait+0x48>
	{
		if( xSemaphoreTake( sem->handle, timeout / portTICK_RATE_MS ) == pdTRUE )
 29e:	687b      	ldr	r3, [r7, #4]
 2a0:	681b      	ldr	r3, [r3, #0]
 2a2:	4618      	mov	r0, r3
 2a4:	f04f 0100 	mov.w	r1, #0
 2a8:	683a      	ldr	r2, [r7, #0]
 2aa:	f04f 0300 	mov.w	r3, #0
 2ae:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			2ae: R_ARM_THM_CALL	xQueueGenericReceive
 2b2:	4603      	mov	r3, r0
 2b4:	2b01      	cmp	r3, #1
 2b6:	d108      	bne.n	2ca <sys_arch_sem_wait+0x42>
		{
			EndTime = xTaskGetTickCount();
 2b8:	f7ff fffe 	bl	0 <xTaskGetTickCount>
			2b8: R_ARM_THM_CALL	xTaskGetTickCount
 2bc:	6138      	str	r0, [r7, #16]
			Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
 2be:	693a      	ldr	r2, [r7, #16]
 2c0:	697b      	ldr	r3, [r7, #20]
 2c2:	1ad3      	subs	r3, r2, r3
 2c4:	60fb      	str	r3, [r7, #12]

			return (Elapsed); // return time blocked TODO test
 2c6:	68fb      	ldr	r3, [r7, #12]
 2c8:	e019      	b.n	2fe <sys_arch_sem_wait+0x76>
		}
		else
		{
			return SYS_ARCH_TIMEOUT;
 2ca:	f04f 33ff 	mov.w	r3, #4294967295
 2ce:	e016      	b.n	2fe <sys_arch_sem_wait+0x76>
		}
	}
	else // must block without a timeout
	{
		while( xSemaphoreTake( sem->handle, portMAX_DELAY ) != pdTRUE ){}
 2d0:	bf00      	nop
 2d2:	687b      	ldr	r3, [r7, #4]
 2d4:	681b      	ldr	r3, [r3, #0]
 2d6:	4618      	mov	r0, r3
 2d8:	f04f 0100 	mov.w	r1, #0
 2dc:	f04f 32ff 	mov.w	r2, #4294967295
 2e0:	f04f 0300 	mov.w	r3, #0
 2e4:	f7ff fffe 	bl	0 <xQueueGenericReceive>
			2e4: R_ARM_THM_CALL	xQueueGenericReceive
 2e8:	4603      	mov	r3, r0
 2ea:	2b01      	cmp	r3, #1
 2ec:	d1f1      	bne.n	2d2 <sys_arch_sem_wait+0x4a>
		EndTime = xTaskGetTickCount();
 2ee:	f7ff fffe 	bl	0 <xTaskGetTickCount>
			2ee: R_ARM_THM_CALL	xTaskGetTickCount
 2f2:	6138      	str	r0, [r7, #16]
		Elapsed = (EndTime - StartTime) * portTICK_RATE_MS;
 2f4:	693a      	ldr	r2, [r7, #16]
 2f6:	697b      	ldr	r3, [r7, #20]
 2f8:	1ad3      	subs	r3, r2, r3
 2fa:	60fb      	str	r3, [r7, #12]

		return ( Elapsed ); // return time blocked
 2fc:	68fb      	ldr	r3, [r7, #12]
	}
}
 2fe:	4618      	mov	r0, r3
 300:	f107 0718 	add.w	r7, r7, #24
 304:	46bd      	mov	sp, r7
 306:	bd80      	pop	{r7, pc}

00000308 <sys_sem_signal>:

/*-----------------------------------------------------------------------------------*/
// Signals a semaphore
void sys_sem_signal(sys_sem_t *sem)
{
 308:	b580      	push	{r7, lr}
 30a:	b082      	sub	sp, #8
 30c:	af00      	add	r7, sp, #0
 30e:	6078      	str	r0, [r7, #4]
	xSemaphoreGive( sem->handle );
 310:	687b      	ldr	r3, [r7, #4]
 312:	681b      	ldr	r3, [r3, #0]
 314:	4618      	mov	r0, r3
 316:	f04f 0100 	mov.w	r1, #0
 31a:	f04f 0200 	mov.w	r2, #0
 31e:	f04f 0300 	mov.w	r3, #0
 322:	f7ff fffe 	bl	0 <xQueueGenericSend>
			322: R_ARM_THM_CALL	xQueueGenericSend
}
 326:	f107 0708 	add.w	r7, r7, #8
 32a:	46bd      	mov	sp, r7
 32c:	bd80      	pop	{r7, pc}
 32e:	bf00      	nop

00000330 <sys_sem_free>:

/*-----------------------------------------------------------------------------------*/
// Deallocates a semaphore
void sys_sem_free(sys_sem_t *sem)
{
 330:	b580      	push	{r7, lr}
 332:	b082      	sub	sp, #8
 334:	af00      	add	r7, sp, #0
 336:	6078      	str	r0, [r7, #4]
#if SYS_STATS
      --lwip_stats.sys.sem.used;
#endif /* SYS_STATS */

	vQueueDelete( sem->handle );
 338:	687b      	ldr	r3, [r7, #4]
 33a:	681b      	ldr	r3, [r3, #0]
 33c:	4618      	mov	r0, r3
 33e:	f7ff fffe 	bl	0 <vQueueDelete>
			33e: R_ARM_THM_CALL	vQueueDelete
	sem->valid = 0;
 342:	687b      	ldr	r3, [r7, #4]
 344:	f04f 0200 	mov.w	r2, #0
 348:	711a      	strb	r2, [r3, #4]
}
 34a:	f107 0708 	add.w	r7, r7, #8
 34e:	46bd      	mov	sp, r7
 350:	bd80      	pop	{r7, pc}
 352:	bf00      	nop

00000354 <sys_init>:

/*-----------------------------------------------------------------------------------*/
// Initialize sys arch
void sys_init(void)
{
 354:	b480      	push	{r7}
 356:	af00      	add	r7, sp, #0
	// keep track of how many threads have been created
	s_nextthread = 0;
 358:	4b03      	ldr	r3, [pc, #12]	; (368 <sys_init+0x14>)
 35a:	f04f 0200 	mov.w	r2, #0
 35e:	801a      	strh	r2, [r3, #0]
}
 360:	46bd      	mov	sp, r7
 362:	bc80      	pop	{r7}
 364:	4770      	bx	lr
 366:	bf00      	nop
 368:	00000000 	.word	0x00000000
			368: R_ARM_ABS32	.bss

0000036c <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
 36c:	b580      	push	{r7, lr}
 36e:	b08a      	sub	sp, #40	; 0x28
 370:	af04      	add	r7, sp, #16
 372:	60f8      	str	r0, [r7, #12]
 374:	60b9      	str	r1, [r7, #8]
 376:	607a      	str	r2, [r7, #4]
 378:	603b      	str	r3, [r7, #0]
	xTaskHandle CreatedTask;
	int result;

   if ( s_nextthread < SYS_THREAD_MAX )
 37a:	4b17      	ldr	r3, [pc, #92]	; (3d8 <sys_thread_new+0x6c>)
 37c:	881b      	ldrh	r3, [r3, #0]
 37e:	2b03      	cmp	r3, #3
 380:	d823      	bhi.n	3ca <sys_thread_new+0x5e>
   {
      result = xTaskCreate( thread, ( signed portCHAR * ) name, stacksize, arg, prio, &CreatedTask );
 382:	68fa      	ldr	r2, [r7, #12]
 384:	683b      	ldr	r3, [r7, #0]
 386:	b29b      	uxth	r3, r3
 388:	6a39      	ldr	r1, [r7, #32]
 38a:	9100      	str	r1, [sp, #0]
 38c:	f107 0110 	add.w	r1, r7, #16
 390:	9101      	str	r1, [sp, #4]
 392:	f04f 0100 	mov.w	r1, #0
 396:	9102      	str	r1, [sp, #8]
 398:	f04f 0100 	mov.w	r1, #0
 39c:	9103      	str	r1, [sp, #12]
 39e:	68b8      	ldr	r0, [r7, #8]
 3a0:	4611      	mov	r1, r2
 3a2:	461a      	mov	r2, r3
 3a4:	687b      	ldr	r3, [r7, #4]
 3a6:	f7ff fffe 	bl	0 <xTaskGenericCreate>
			3a6: R_ARM_THM_CALL	xTaskGenericCreate
 3aa:	6178      	str	r0, [r7, #20]

       s_nextthread++;
 3ac:	4b0a      	ldr	r3, [pc, #40]	; (3d8 <sys_thread_new+0x6c>)
 3ae:	881b      	ldrh	r3, [r3, #0]
 3b0:	f103 0301 	add.w	r3, r3, #1
 3b4:	b29a      	uxth	r2, r3
 3b6:	4b08      	ldr	r3, [pc, #32]	; (3d8 <sys_thread_new+0x6c>)
 3b8:	801a      	strh	r2, [r3, #0]

	   if(result == pdPASS)
 3ba:	697b      	ldr	r3, [r7, #20]
 3bc:	2b01      	cmp	r3, #1
 3be:	d101      	bne.n	3c4 <sys_thread_new+0x58>
	   {
		   return CreatedTask;
 3c0:	693b      	ldr	r3, [r7, #16]
 3c2:	e004      	b.n	3ce <sys_thread_new+0x62>
	   }
	   else
	   {
		   return NULL;
 3c4:	f04f 0300 	mov.w	r3, #0
 3c8:	e001      	b.n	3ce <sys_thread_new+0x62>
	   }
   }
   else
   {
      return NULL;
 3ca:	f04f 0300 	mov.w	r3, #0
   }
}
 3ce:	4618      	mov	r0, r3
 3d0:	f107 0718 	add.w	r7, r7, #24
 3d4:	46bd      	mov	sp, r7
 3d6:	bd80      	pop	{r7, pc}
 3d8:	00000000 	.word	0x00000000
			3d8: R_ARM_ABS32	.bss

000003dc <sys_arch_protect>:

  sys_arch_protect() is only required if your port is supporting an operating
  system.
*/
sys_prot_t sys_arch_protect(void)
{
 3dc:	b580      	push	{r7, lr}
 3de:	af00      	add	r7, sp, #0
	vPortEnterCritical();
 3e0:	f7ff fffe 	bl	0 <vPortEnterCritical>
			3e0: R_ARM_THM_CALL	vPortEnterCritical
	return 1;
 3e4:	f04f 0301 	mov.w	r3, #1
}
 3e8:	4618      	mov	r0, r3
 3ea:	bd80      	pop	{r7, pc}

000003ec <sys_arch_unprotect>:
  value specified by pval. See the documentation for sys_arch_protect() for
  more information. This function is only required if your port is supporting
  an operating system.
*/
void sys_arch_unprotect(sys_prot_t pval)
{
 3ec:	b580      	push	{r7, lr}
 3ee:	b082      	sub	sp, #8
 3f0:	af00      	add	r7, sp, #0
 3f2:	6078      	str	r0, [r7, #4]
	( void ) pval;
	vPortExitCritical();
 3f4:	f7ff fffe 	bl	0 <vPortExitCritical>
			3f4: R_ARM_THM_CALL	vPortExitCritical
}
 3f8:	f107 0708 	add.w	r7, r7, #8
 3fc:	46bd      	mov	sp, r7
 3fe:	bd80      	pop	{r7, pc}

00000400 <sys_assert>:

/*
 * Prints an assertion messages and aborts execution.
 */
void sys_assert( const char *msg )
{
 400:	b580      	push	{r7, lr}
 402:	b082      	sub	sp, #8
 404:	af00      	add	r7, sp, #0
 406:	6078      	str	r0, [r7, #4]
	( void ) msg;
    vPortEnterCritical(  );
 408:	f7ff fffe 	bl	0 <vPortEnterCritical>
			408: R_ARM_THM_CALL	vPortEnterCritical
    for(;;)
    ;
 40c:	e7fe      	b.n	40c <sys_assert+0xc>
 40e:	bf00      	nop

00000410 <sys_mbox_valid>:
}

int sys_mbox_valid(sys_mbox_t *mbox)
{
 410:	b480      	push	{r7}
 412:	b083      	sub	sp, #12
 414:	af00      	add	r7, sp, #0
 416:	6078      	str	r0, [r7, #4]
	if ( mbox == NULL ) return 0;
 418:	687b      	ldr	r3, [r7, #4]
 41a:	2b00      	cmp	r3, #0
 41c:	d102      	bne.n	424 <sys_mbox_valid+0x14>
 41e:	f04f 0300 	mov.w	r3, #0
 422:	e001      	b.n	428 <sys_mbox_valid+0x18>
	return mbox->valid;
 424:	687b      	ldr	r3, [r7, #4]
 426:	791b      	ldrb	r3, [r3, #4]
}
 428:	4618      	mov	r0, r3
 42a:	f107 070c 	add.w	r7, r7, #12
 42e:	46bd      	mov	sp, r7
 430:	bc80      	pop	{r7}
 432:	4770      	bx	lr

00000434 <sys_mbox_set_invalid>:

void sys_mbox_set_invalid(sys_mbox_t *mbox)
{
 434:	b480      	push	{r7}
 436:	b083      	sub	sp, #12
 438:	af00      	add	r7, sp, #0
 43a:	6078      	str	r0, [r7, #4]
	mbox->valid = 0;
 43c:	687b      	ldr	r3, [r7, #4]
 43e:	f04f 0200 	mov.w	r2, #0
 442:	711a      	strb	r2, [r3, #4]
	return;
}
 444:	f107 070c 	add.w	r7, r7, #12
 448:	46bd      	mov	sp, r7
 44a:	bc80      	pop	{r7}
 44c:	4770      	bx	lr
 44e:	bf00      	nop

00000450 <sys_sem_valid>:

int sys_sem_valid(sys_sem_t *sem)
{
 450:	b480      	push	{r7}
 452:	b083      	sub	sp, #12
 454:	af00      	add	r7, sp, #0
 456:	6078      	str	r0, [r7, #4]
	if ( sem == NULL ) return 0;
 458:	687b      	ldr	r3, [r7, #4]
 45a:	2b00      	cmp	r3, #0
 45c:	d102      	bne.n	464 <sys_sem_valid+0x14>
 45e:	f04f 0300 	mov.w	r3, #0
 462:	e001      	b.n	468 <sys_sem_valid+0x18>
	return sem->valid;
 464:	687b      	ldr	r3, [r7, #4]
 466:	791b      	ldrb	r3, [r3, #4]
}
 468:	4618      	mov	r0, r3
 46a:	f107 070c 	add.w	r7, r7, #12
 46e:	46bd      	mov	sp, r7
 470:	bc80      	pop	{r7}
 472:	4770      	bx	lr

00000474 <sys_sem_set_invalid>:

void sys_sem_set_invalid(sys_sem_t *sem)
{
 474:	b480      	push	{r7}
 476:	b083      	sub	sp, #12
 478:	af00      	add	r7, sp, #0
 47a:	6078      	str	r0, [r7, #4]
	sem->valid = 0;
 47c:	687b      	ldr	r3, [r7, #4]
 47e:	f04f 0200 	mov.w	r2, #0
 482:	711a      	strb	r2, [r3, #4]
	return;
}
 484:	f107 070c 	add.w	r7, r7, #12
 488:	46bd      	mov	sp, r7
 48a:	bc80      	pop	{r7}
 48c:	4770      	bx	lr
 48e:	bf00      	nop
